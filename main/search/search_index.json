{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Execution Spec Tests","text":"<p>ethereum/execution-spec-tests is both a collection of test cases and a framework in Python to generate tests for Ethereum execution clients implemented.</p> <p>The framework collects and executes the test cases in order to generate test fixtures (JSON) which can be consumed by any execution client to verify their implementation of ethereum/execution-specs. The fixtures, which define state transition and block tests, are generated by the framework using one of the <code>t8n</code> command-line tools that are provided by most execution clients, see below for an overview of the supported <code>t8n</code> tools.</p> <pre><code>---\ntitle: Test Fixture Generation with execution-spec-tests\n---\nflowchart LR\n  style C stroke:#333,stroke-width:2px\n  style D stroke:#333,stroke-width:2px\n  style G stroke:#F9A825,stroke-width:2px\n  style H stroke:#F9A825,stroke-width:2px\n\n  subgraph ethereum/go-ethereum\n    C[&lt;code&gt;evm t8n&lt;/code&gt;\\nexternal executable]\n  end\n\n  subgraph ethereum/solidity\n    D[&lt;code&gt;solc&lt;/code&gt;\\nexternal executable]\n  end\n\n  subgraph ethereum/EIPs\n    E(&lt;code&gt;EIPS/EIP-*.md&lt;/code&gt;\\nSHA digest via Github API)\n  end\n\n  subgraph \"ethereum/execution-spec-tests\"\n    A(&lt;code&gt;./tests/**/*.py&lt;/code&gt;\\nPython Test Cases)\n    B([&lt;code&gt;$ fill ./tests/&lt;/code&gt;\\nPython Framework])\n  end\n\n  subgraph Test Fixture Consumers\n    subgraph ethereum/hive\n      G([&lt;code&gt;$ hive ...&lt;/code&gt;\\nGo Test Framework])\n    end\n    H([Client executables])\n  end\n\n  C &lt;-.-&gt; B  \n  D &lt;-.-&gt; B\n  A --&gt; B\n  E &lt;-.-&gt; |retrieve latest spec version\\ncheck tested spec version| B\n  B --&gt;|output| F(&lt;code&gt;./fixtures/**/*.json&lt;/code&gt;\\nJSON Test Fixtures)\n  F --&gt;|input| G\n  F --&gt;|input| H</code></pre> <p>The generated test fixtures can be used:</p> <ol> <li>Directly by client teams' test frameworks, and,</li> <li>In the integration tests executed in the ethereum/hive framework.</li> </ol> <p>More information on how to use and download the released test fixtures can be found here.</p>"},{"location":"#relationship-to-ethereumtests","title":"Relationship to ethereum/tests","text":"<p>This collection of tests is relatively new (test case development started Q4, 2022) and mainly targets recent and upcoming Ethereum specification changes. It does not replace, but rather complements the existing tests in ethereum/tests.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>The motivation to implement test cases in ethereum/execution-spec-tests is:</p> <ol> <li>To implement test cases as code and ensure that changes, due to spec changes, for example, can be easily made. Moreover, changes are easily understandable and available in version control.</li> <li>To avoid the 2-step approach often used in ethereum/tests:<ol> <li>Code (often unavailable) -&gt; Test case (YAML).</li> <li>Test case (YAML) -&gt; Fixtures (JSON).</li> </ol> </li> </ol> <p>Contributing</p> <p>Contributions via PR are welcome!</p> <p>Reporting a Vulnerability</p> <p>Care is required when adding PRs or issues for functionality that is live on Ethereum mainnet. Please report vulnerabilities and verify bounty eligibility via the bug bounty program.</p> <ul> <li>Please do not create a PR with a vulnerability visible.</li> <li>Please do not file a public ticket mentioning the vulnerability.</li> </ul>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>Test fixtures for use by clients are available for each release on the Github releases page.</p> <p>Key: \u2728 = New, \ud83d\udc1e = Fixed, \ud83d\udd00 = Changed. \ud83d\udca5 = Breaking</p>"},{"location":"CHANGELOG/#unreleased","title":"\ud83d\udd1c [Unreleased]","text":"<p>Note: Although not a breaking change, <code>consume</code> users should delete the cache directory (typically located at <code>~/.cache/ethereum-execution-spec-tests</code>) used to store downloaded fixture release tarballs. This release adds support for ethereum/tests and ethereum/legacytests fixture release downloads and the structure of the cache directory has been updated to accommodate this change.</p> <p>To try this feature:</p> <pre><code>consume direct --input=https://github.com/ethereum/tests/releases/download/v17.0/fixtures_blockchain_tests.tgz\n</code></pre> <p>To determine the cache directory location, see the <code>--cache-folder</code> entry from the command:</p> <pre><code>consume cache --help\n</code></pre>"},{"location":"CHANGELOG/#breaking-change","title":"\ud83d\udca5 Breaking Change","text":""},{"location":"CHANGELOG/#framework","title":"\ud83d\udee0\ufe0f Framework","text":""},{"location":"CHANGELOG/#consume","title":"<code>consume</code>","text":"<ul> <li>\u2728 Add support for ethereum/tests and ethereum/legacytests release tarball download via URL to the <code>--input</code> flag of <code>consume</code> commands (#1306).</li> <li>\u2728 Add support for Nethermind's <code>nethtest</code> command to <code>consume direct</code> (#1250).</li> <li>\u2728 Allow filtering of test cases by fork via pytest marks (e.g., <code>-m \"Cancun or Prague\"</code>) (#1304, #1318).</li> <li>\u2728 Allow filtering of test cases by fixture format via pytest marks (e.g., <code>-m blockchain_test</code>) (#1314).</li> <li>\u2728 Add top-level entries <code>forks</code> and <code>fixture_formats</code> to the index file that list all the forks and fixture formats used in the indexed fixtures (#1318).</li> <li>\ud83d\udc1e Don't parametrize tests for unsupported fixture formats; improve <code>consume</code> test collection (#1315).</li> <li>\ud83d\udc1e Fix the the hive command printed in test reports to reproduce tests in isolation by prefixing the <code>--sim.limit</code> flag value with <code>id:</code> (#1333).</li> <li>\ud83d\udc1e Improve index generation of ethereum/tests fixtures: Allow generation at any directory level and include <code>generatedTestHash</code> in the index file for the <code>fixture_hash</code> (#1303).</li> <li>\ud83d\udc1e Fix loading of ethereum/tests and ethereum/legacytests fixtures for the case of mixed <code>0x0</code> and <code>0x1</code> transaction types in multi-index (<code>data</code>, <code>gas</code>, <code>value</code>) state test fixtures (#1330).</li> </ul>"},{"location":"CHANGELOG/#fill","title":"<code>fill</code>","text":"<ul> <li>\ud83d\udc1e Fix <code>--fork/from/until</code> for transition forks when using <code>fill</code> #1311.</li> <li>\ud83d\udc1e Fix the node id for state tests marked by transition forks (#1313).</li> </ul>"},{"location":"CHANGELOG/#misc","title":"\ud83d\udccb Misc","text":"<ul> <li>\ud83d\udd00 Bump the version of <code>execution-specs</code> used by the framework to the package <code>ethereum-execution==1.17.0rc6.dev1</code>; bump the version used for test fixture generation for forks &lt; Prague to current <code>execution-specs</code> master, fa847a0 (#1310).</li> <li>\ud83d\udc1e Init <code>TransitionTool</code> in <code>GethTransitionTool</code> (#1276).</li> <li>\ud83d\udc1e Fix <code>eest make test</code> when <code>ethereum-execution-spec-tests</code> is installed as a package (#1342).</li> <li>\ud83d\udc1e Add and restrict <code>pycryptodome</code> version to the project, fixes CI issues on macOS (#1343).</li> </ul>"},{"location":"CHANGELOG/#test-cases","title":"\ud83e\uddea Test Cases","text":""},{"location":"CHANGELOG/#v410-2025-03-11","title":"v4.1.0 - 2025-03-11","text":""},{"location":"CHANGELOG/#breaking-changes","title":"\ud83d\udca5 Breaking Changes","text":"<p>The following changes may be potentially breaking (all clients were tested with these changes with the state test format, but not the blockchain test format):</p> <ul> <li>\ud83d\udca5 Add a <code>yParity</code> field (that duplicates <code>v</code>) to transaction authorization tuples in fixture formats to have fields that conform to EIP-7702 spec, resolves erigontech/erigon#14073 (#1286).</li> <li>\ud83d\udca5 Rename the recently introduced <code>_info</code> field <code>fixture_format</code> to <code>fixture-format</code> for consistency #1295.</li> </ul>"},{"location":"CHANGELOG/#framework_1","title":"\ud83d\udee0\ufe0f Framework","text":"<ul> <li>\ud83d\udd00 Make <code>BaseFixture</code> able to parse any fixture format such as <code>BlockchainFixture</code> (#1210).</li> <li>\u2728 Blockchain and Blockchain-Engine tests now have a marker to specify that they were generated from a state test, which can be used with <code>-m blockchain_test_from_state_test</code> and <code>-m blockchain_test_engine_from_state_test</code> respectively (#1220).</li> <li>\u2728 Blockchain and Blockchain-Engine tests that were generated from a state test now have <code>blockchain_test_from_state_test</code> or <code>blockchain_test_engine_from_state_test</code> as part of their test IDs (#1220).</li> <li>\ud83d\udd00 Refactor <code>ethereum_test_fixtures</code> and <code>ethereum_clis</code> to create <code>FixtureConsumer</code> and <code>FixtureConsumerTool</code> classes which abstract away the consumption process used by <code>consume direct</code> (#935).</li> <li>\u2728 Allow <code>consume direct --collect-only</code> without specifying a fixture consumer binary on the command-line (#1237).</li> <li>\u2728 Allow <code>fill --collect-only</code> without the need for existence of the folder `./fixtures'</li> <li>\u2728 Report the (resolved) fixture tarball URL and local fixture cache directory when <code>consume</code>'s <code>--input</code> flag is a release spec or URL (#1239).</li> <li>\u2728 EOF Container validation tests (<code>eof_test</code>) now generate container deployment state tests, by wrapping the EOF container in an init-container and sending a deploy transaction (#783, #1233).</li> <li>\u2728 Use regexes for Hive's <code>--sim.limit</code> argument and don't use xdist if <code>--sim.parallelism==1</code> in the <code>eest/consume-rlp</code> and <code>eest/consume-rlp</code> simulators (#1220).</li> <li>\ud83d\udc1e Register generated test markers, e.g., <code>blockchain_test_from_state_test</code>, to prevent test session warnings (#1238, #1245).</li> <li>\ud83d\udc1e Zero-pad <code>Environment</code> fields passed to <code>t8n</code> tools as required by <code>evmone-t8n</code> (#1268).</li> </ul>"},{"location":"CHANGELOG/#misc_1","title":"\ud83d\udccb Misc","text":"<ul> <li>\u2728 Add a guide to the docs for porting tests from <code>ethereum/tests</code> to EEST (#1165).</li> <li>\u2728 Improve the <code>uv run eest make test</code> interactive CLI to enable creation of new test modules within existing test sub-folders (#1241).</li> <li>\u2728 Update <code>mypy</code> to latest release <code>&gt;=1.15.0,&lt;1.16</code> (#1209).</li> <li>\ud83d\udc1e Bug fix for filling with EELS for certain Python versions due to an issue with CPython (#1231).</li> <li>\ud83d\udc1e Fix HTML site deployment due to the site's index file exceeding Github's max file size limit (#1292).</li> <li>\u2728 Update the build fixtures workflow to use multiple self-hosted runners, remove <code>pectra-devnet-6</code> feature build (#1296).</li> </ul>"},{"location":"CHANGELOG/#test-cases_1","title":"\ud83e\uddea Test Cases","text":"<ul> <li>\u2728 Add gas cost of delegation access in CALL opcode (#1208).</li> <li>\u2728 Add EIP-7698 failed nonce and short data tests (#1211).</li> <li>\u2728 Add EIP-2537 additional pairing precompile tests cases, and then update all BLS12 test vectors (#1275, #1289).</li> </ul>"},{"location":"CHANGELOG/#v400-2025-02-14-","title":"v4.0.0 - 2025-02-14 - \ud83d\udc95","text":""},{"location":"CHANGELOG/#fixture-releases","title":"\ud83d\udcc1 Fixture Releases","text":"<ul> <li>\ud83d\udd00 Initially we moved old fork configured tests within stable and develop fixture releases to a separate legacy release (#788).</li> <li>\ud83d\udd00 This was later reverted after some client teams preferred to keep them in all in the same releases (#1053).</li> </ul>"},{"location":"CHANGELOG/#breaking-change_1","title":"\ud83d\udca5 Breaking Change","text":"<ul> <li>\u2728 Use uv for package management replacing pip (#777).</li> <li>\u2728 Ruff now replaces Flake8, Isort and Black resulting in significant changes to the entire code base including its usage (#922).</li> <li>\ud83d\udd00 Fill test fixtures using EELS by default. EEST now uses the <code>ethereum-specs-evm-resolver</code> with the EELS daemon (#792).</li> <li>\ud83d\udd00 The EOF fixture format contained in <code>eof_tests</code> may now contain multiple exceptions in the <code>\"exception\"</code> field in the form of a pipe (<code>|</code>) separated string (#759).</li> <li>\ud83d\udd00 <code>state_test</code>, <code>blockchain_test</code> and <code>blockchain_test_engine</code> fixtures now contain a <code>config</code> field, which contains an object that contains a <code>blobSchedule</code> field. On the <code>blockchain_test</code> and <code>blockchain_test_engine</code> fixtures, the object also contains a duplicate of the <code>network</code> root field. The root's <code>network</code> field will be eventually deprecated (#1040).</li> <li>\ud83d\udd00 <code>latest-stable-release</code> and <code>latest-develop-release</code> keywords for the <code>--input</code> flag in consume commands have been replaced with <code>stable@latest</code> and <code>develop@latest</code> respectively (#1044).</li> </ul>"},{"location":"CHANGELOG/#framework_2","title":"\ud83d\udee0\ufe0f Framework","text":"<ul> <li>\u2728 Execute command added to run existing tests in live networks (#).</li> <li>\ud83d\udc1e Fixed consume hive commands from spawning different hive test suites during the same test execution when using xdist (#712).</li> <li>\u2728 <code>consume hive</code> command is now available to run all types of hive tests (#712).</li> <li>\u2728 Generated fixtures now contain the test index <code>index.json</code> by default (#716).</li> <li>\u2728 A metadata folder <code>.meta/</code> now stores all fixture metadata files by default (#721).</li> <li>\ud83d\udc1e Fixed <code>fill</code> command index generation issue due to concurrency (#725).</li> <li>\u2728 Added <code>with_all_evm_code_types</code>, <code>with_all_call_opcodes</code> and <code>with_all_create_opcodes</code> markers, which allow automatic parametrization of tests to EOF (#610, #739).</li> <li>\u2728 Added <code>with_all_system_contracts</code> marker, which helps parametrize tests with all contracts that affect the chain on a system level (#739).</li> <li>\u2728 Code generators <code>Conditional</code> and <code>Switch</code> now support EOF by adding parameter <code>evm_code_type</code> (#610).</li> <li>\u2728 <code>fill</code> command now supports parameter <code>--evm-code-type</code> that can be (currently) set to <code>legacy</code> or <code>eof_v1</code> to force all test smart contracts to deployed in normal or in EOF containers (#610).</li> <li>\ud83d\udc1e Fixed fixture index generation on EOF tests (#728).</li> <li>\ud83d\udc1e Fixes consume genesis mismatch exception for hive based simulators (#734).</li> <li>\u2728 Adds reproducible consume commands to hiveview (#717).</li> <li>\ud83d\udca5 Added multiple exceptions to the EOF fixture format (#759).</li> <li>\u2728 Added optional parameter to all <code>with_all_*</code> markers to specify a lambda function that filters the parametrized values (#739).</li> <li>\u2728 Added <code>extend_with_defaults</code> utility function, which helps extend test case parameter sets with default values. <code>@pytest.mark.parametrize</code> (#739).</li> <li>\u2728 Added <code>Container.Init</code> to <code>ethereum_test_types.EOF.V1</code> package, which allows generation of an EOF init container more easily (#739).</li> <li>\u2728 Introduce method valid_opcodes() to the fork class (#748).</li> <li>\ud83d\udc1e Fixed <code>consume</code> exit code return values, ensuring that pytest's return value is correctly propagated to the shell. This allows the shell to accurately reflect the test results (e.g., failures) based on the pytest exit code (#765).</li> <li>\u2728 Added a new flag <code>--solc-version</code> to the <code>fill</code> command, which allows the user to specify the version of the Solidity compiler to use when compiling Yul source code; this version will now be automatically downloaded by <code>fill</code> via <code>solc-select</code> (#772).</li> <li>\ud83d\udc1e Fix usage of multiple <code>@pytest.mark.with_all*</code> markers which shared parameters, such as <code>with_all_call_opcodes</code> and <code>with_all_create_opcodes</code> which shared <code>evm_code_type</code>, and now only parametrize compatible values (#762).</li> <li>\u2728 Added <code>selector</code> and <code>marks</code> fields to all <code>@pytest.mark.with_all*</code> markers, which allows passing lambda functions to select or mark specific parametrized values (see documentation for more information) (#762).</li> <li>\u2728 Improves consume input flags for develop and stable fixture releases, fixes <code>--help</code> flag for consume (#745).</li> <li>\ud83d\udd00 Return exit-code from <code>consume</code> commands (#766).</li> <li>\ud83d\udd00 Remove duplicate EOF container tests, automatically check for duplicates (#800).</li> <li>\ud83d\udd00 Fix DATALOAD <code>pushed_stack_items</code> calculation (#784).</li> <li>\u2728 Add <code>evm_bytes</code> rename and print asm (#844).</li> <li>\ud83d\udd00 Use the <code>session_temp_folder</code> introduced in #824 (#845).</li> <li>\ud83d\udc1e Don't treat eels resolutions as a fixture (#878).</li> <li>\u2728 Emphasize that no tests were executed during a fill pytest session (#887).</li> <li>\ud83d\udd00 Move generic code from TransitionTool to a new generic base class EthereumCLI (#894).</li> <li>\ud83d\udc1e Fix erroneous fork mes- \ud83d\udd00 Fix max stack height calculation (#810).</li> <li>\u2728 Add storage key hint in Storage class (#917).</li> <li>\u2728 Add system to verify exception strings (#795).</li> <li>\ud83d\udd00 Fix <code>FixedBytes</code> assignment rules (#1010).</li> <li>\ud83d\udd00 Fix <code>Address</code> padding options (#1113).</li> <li>\ud83d\udd00 Add <code>Container.expected_bytecode</code> optional parameter (#737).</li> <li>\u2728 Add support for <code>initcode_prefix</code> on EOF <code>Container.Init</code> (#819).sage in pytest session header with development forks (#806).</li> <li>\ud83d\udc1e Fix <code>Conditional</code> code generator in EOF mode (#821).</li> <li>\ud83d\udd00 Ensure that <code>Block</code> objects keep track of their <code>fork</code>, for example, when the block's <code>rlp_modifier</code> is not <code>None</code> (#854).</li> <li>\ud83d\udd00 <code>ethereum_test_rpc</code> library has been created with what was previously <code>ethereum_test_tools.rpc</code> (#822).</li> <li>\u2728 Add <code>Wei</code> type to <code>ethereum_test_base_types</code> which allows parsing wei amounts from strings like \"1 ether\", \"1000 wei\", \"10**2 gwei\", etc (#825).</li> <li>\u2728 Pin EELS versions in <code>eels_resolutions.json</code> and include this file in fixture releases (#872).</li> <li>\ud83d\udd00 Replace <code>ethereum.base_types</code> with <code>ethereum-types</code> (#850).</li> <li>\ud83d\udca5 Rename the <code>PragueEIP7692</code> fork to <code>Osaka</code> (#869).</li> <li>\u2728 Improve <code>fill</code> terminal output to emphasize that filling tests is not actually testing a client (#807).</li> <li>\u2728 Add the <code>BlockchainTestEngine</code> test spec type that only generates a fixture in the <code>EngineFixture</code> (<code>blockchain_test_engine</code>) format (#888).</li> <li>\ud83d\udd00 Move the <code>evm_transition_tool</code> package to <code>ethereum_clis</code> and derive the transition tool CL interfaces from a shared <code>EthereumCLI</code> class that can be reused for other sub-commands (#894).</li> <li>\u2728 Pass <code>state_test</code> property to T8N tools that support it (Only EELS at the time of merge) (#943).</li> <li>\u2728 Add the <code>eofwrap</code> cli used to wrap tests from <code>ethereum/tests</code> in an EOF container (#896).</li> <li>\ud83d\udd00 Improve gentest architecture with <code>EthereumTestBaseModel</code> and <code>EthereumTestRootModel</code> (#901).</li> <li>\ud83d\udd00 Migrate transaction test to <code>state_test</code> for <code>gentest</code> (#903).</li> <li>\ud83d\udd00 <code>ethereum_test_forks</code> forks now contain gas-calculating functions, which return the appropriate function to calculate the gas used by a transaction or memory function for the given fork (#779).</li> <li>\ud83d\udc1e Fix <code>Bytecode</code> class <code>__eq__</code> method (#939).</li> <li>\ud83d\udd00 Update <code>pydantic</code> from 2.8.2 to 2.9.2 (#960).</li> <li>\u2728 Add the <code>eest make test</code> command, an interactive CLI that helps users create a new test module and function (#950).</li> <li>\u2728 Add the <code>eest clean</code> command that helps delete generated files and directories from the repository (#980).</li> <li>\u2728 Add framework changes for EIP-7742, required for Prague devnet-5 (#931).</li> <li>\u2728 Add the <code>eest make env</code> command that generates a default env file (<code>env.yaml</code>)(#996).</li> <li>\u2728 Generate Transaction Test type (#933).</li> <li>\u2728 Add a default location for evm logs (<code>--evm-dump-dir</code>) when filling tests (#999).</li> <li>\u2728 Slow tests now have greater timeout when making a request to the T8N server (#1037).</li> <li>\u2728 Introduce <code>pytest.mark.parametrize_by_fork</code> helper marker (#1019, #1057).</li> <li>\ud83d\udc1e fix(consume): allow absolute paths with <code>--evm-bin</code> (#1052).</li> <li>\u2728 Disable EIP-7742 framework changes for Prague (#1023).</li> <li>\u2728 Allow verification of the transaction receipt on executed test transactions (#1068).</li> <li>\u2728 Modify <code>valid_at_transition_to</code> marker to add keyword arguments <code>subsequent_transitions</code> and <code>until</code> to fill a test using multiple transition forks (#1081).</li> <li>\ud83d\udc1e fix(consume): use <code>\"HIVE_CHECK_LIVE_PORT\"</code> to signal hive to wait for port 8551 (Engine API port) instead of the 8545 port when running <code>consume engine</code> (#1095).</li> <li>\u2728 <code>state_test</code>, <code>blockchain_test</code> and <code>blockchain_test_engine</code> fixtures now contain the <code>blobSchedule</code> from EIP-7840, only for tests filled for Cancun and Prague forks (#1040).</li> <li>\ud83d\udd00 Change <code>--dist</code> flag to the default value, <code>load</code>, for better parallelism handling during test filling (#1118).</li> <li>\ud83d\udd00 Refactor framework code to use the <code>ethereum-rlp</code> package instead of <code>ethereum.rlp</code>, previously available in ethereum/execution-specs (#1180).</li> <li>\ud83d\udd00 Update EELS / execution-specs EEST dependency to 99238233 for EEST framework libraries and test case generation (#1181).</li> <li>\u2728 Add the <code>consume cache</code> command to cache fixtures before running consume commands (#1044).</li> <li>\u2728 The <code>--input</code> flag of the consume commands now supports parsing of tagged release names in the format <code>&lt;RELEASE_NAME&gt;@&lt;RELEASE_VERSION&gt;</code> (#1044).</li> <li>\ud83d\udc1e Fix stdout output when using the <code>fill</code> command (#1188).</li> <li>\u2728 Add tests for blockchain intermediate state verification (#1075).</li> <li>\u2728 Add Interactive CLI input functionality (#947).</li> <li>\ud83d\udd00 Rename <code>EOFTest.data</code> to <code>EOFTest.container</code> with rebase of <code>EOFStateTest</code> (#1145).</li> <li>\u2728 Turn on <code>--traces</code> for EELS + <code>ethereum-specs-evm-resolver</code> (#1174).</li> </ul>"},{"location":"CHANGELOG/#misc_2","title":"\ud83d\udccb Misc","text":"<ul> <li>\u2728 Feature releases can now include multiple types of fixture tarball files from different releases that start with the same prefix (#736).</li> <li>\u2728 Releases for feature eip7692 now include both Cancun and Prague based tests in the same release, in files <code>fixtures_eip7692.tar.gz</code> and <code>fixtures_eip7692-prague.tar.gz</code> respectively (#743). \u2728 Re-write the test case reference doc flow as a pytest plugin and add pages for test functions with a table providing an overview of their parametrized test cases (#801, #842).</li> <li>\ud83d\udd00 Simplify Python project configuration and consolidate it into <code>pyproject.toml</code> (#764).</li> <li>\u2728 Add dev docs to help using nectos/act (#776).</li> <li>\ud83d\udd00 Update <code>uv.lock</code> for updated solc deps (#782).</li> <li>\u2728 Enable coverage on any test change (#790).</li> <li>\ud83d\udd00 Created <code>pytest_plugins.concurrency</code> plugin to sync multiple <code>xdist</code> processes without using a command flag to specify the temporary working folder (#824)</li> <li>\ud83d\udd00 Move pytest plugin <code>pytest_plugins.filler.solc</code> to <code>pytest_plugins.solc.solc</code> (#823).</li> <li>\ud83d\udd00 Remove <code>formats.py</code>, embed properties as class vars (#826).</li> <li>\u2728 Add <code>build-evm-base</code> to docs deploy workflows (#829).</li> <li>\ud83d\udd00 Add links to the online test case docs in the EOF tracker (#838).</li> <li>\ud83d\udd00 Fix miscellaneous improvements to troubleshooting, navigation, styling (#840).</li> <li>\u2728 Include all parameters in test parameter datatables (#842).</li> <li>\u2728 Add info about ripemd160 &amp; update running actions locally (#847).</li> <li>\u2728 Add <code>SECURITY.md</code> describing how to report vulnerabilities (#848).</li> <li>\ud83d\udd00 Change image from ubuntu-24.04 to ubuntu-latest in CI (#855).</li> <li>\ud83d\udc1e Asserts that the deploy docs tags workflow is only triggered for full releases (#857).</li> <li>\ud83d\udc1e Fix deploy docs tags workflow trigger (#858).</li> <li>\u2728 A new application-wide configuration manager provides access to environment and application configurations. (#892).</li> <li>\ud83d\udd00 Update the developer docs navigation (#898).</li> <li>\ud83d\udd00 Use jinja2 templating in <code>gentest</code> (#900).</li> <li>\u2728 Fix/add test github actions locally page (#909).</li> <li>\ud83d\udc1e Fix print fill output in coverage workflow on errors (#919).</li> <li>\ud83d\udc1e Use a local version of ethereum/execution-specs (EELS) when running the framework tests in CI (#997).</li> <li>\u2728 Use self-hosted runners for fixture building in CI (#1051).</li> <li>\u2728 Release tarballs now contain fixtures filled for all forks, not only the fork under active development and the fork currently deployed on mainnet (#1053).</li> <li>\u2728 <code>StateTest</code> fixture format now contains <code>state</code> field in each network post result, containing the decoded post allocation that results from the transaction execution (#1064).</li> <li>\u2728 Include EELS fork resolution information in filled json test fixtures (#1123).</li> <li>\ud83d\udd00 Updates ruff from version 0.8.2 to 0.9.4 (#1168).</li> <li>\ud83d\udd00 Update <code>uv.lock</code> to be compatible with <code>uv&gt;=0.5.22</code> (#1178).</li> <li>\ud83d\udd00 Update <code>mypy</code> from version <code>0.991</code> to <code>1.15</code> (#1209).</li> </ul>"},{"location":"CHANGELOG/#test-cases_2","title":"\ud83e\uddea Test Cases","text":"<ul> <li>\u2728 Migrate validation tests <code>EIP3540/validInvalidFiller.yml</code> (#598).</li> <li>\u2728 EIP-4844 test <code>tests/cancun/eip4844_blobs/test_point_evaluation_precompile.py</code> includes an EOF test case (#610).</li> <li>\u2728 Example test <code>tests/frontier/opcodes/test_dup.py</code> now includes EOF parametrization (#610).</li> <li>\u2728 Add EOFv1 function test - Call simple contract test (#695).</li> <li>\u2728 Add section size validation tests (#705).</li> <li>\u2728 Add deep and wide EOF subcontainers tests (#718).</li> <li>\u2728 Update EIP-7702 tests for Devnet-3 (#733)</li> <li>\u2728 Migrate \"valid\" EOFCREATE validation (#738).</li> <li>\u2728 Migrate tests for truncated sections (#740).</li> <li>\u2728 Add out of order container section test (#741).</li> <li>\u2728 Convert all opcodes validation test <code>tests/frontier/opcodes/test_all_opcodes.py</code> (#748).</li> <li>\ud83d\udd00 Add Test types with 128 inputs (#749).</li> <li>\ud83d\udd00 Use new marker to EOF-ize MCOPY test (#754).</li> <li>\u2728 Add EOF Tests from Fuzzing (#756).</li> <li>\u2728 Add embedded container tests (#763).</li> <li>\u2728 Validate EOF only opcodes are invalid in legacy (#768).</li> <li>\u2728 Update EOF tracker, add unimplemented tests (#773).</li> <li>\u2728 Add EIP-7620 EOFCREATE gas tests (#785).</li> <li>\u2728 Add more fuzzing discovered EOF tests (#789).</li> <li>\u2728 Add EOF tests for invalid non-returning sections (#794).</li> <li>\u2728 Test to ensure transient storage is cleared after transactions (#798).</li> <li>\u2728 Test that transient storage stays at correct address (#799).</li> <li>\u2728 Add EOFCREATE referencing the same subcontainer twice test (#809).</li> <li>\u2728 Add dangling data in subcontainer test (#812).</li> <li>\ud83d\udc1e Fix EIP-7702+EOF tests due to incorrect test expectations and faulty <code>Conditional</code> test generator in EOF mode (#821)</li> <li>\ud83d\udc1e Fix TSTORE EOF variant test (#831).</li> <li>\ud83d\udd00 Unify EOF return code constants (#834).</li> <li>\u2728 Add RJUMP* vs CALLF tests (#833).</li> <li>\u2728 Add tests to clarify \"non-returning instruction\" (#837).</li> <li>\u2728 Add double RJUMPI stack validation tests (#851).</li> <li>\u2728 Add unreachable code sections tests (#856).</li> <li>\ud83d\udca5 <code>PragueEIP7692</code> fork in tests has been updated to <code>Osaka</code> (#869)</li> <li>\u2728 Update EIP-6110, EIP-7002, EIP-7251, EIP-7685, and EIP-7702 tests for Devnet-4 (#832)</li> <li>\u2728 Add EIP-7069 and EIP-7620 failures and context vars tests (#836).</li> <li>\u2728 Add EOF EIP-4750 Stack validation in CALLF test (#889).</li> <li>\u2728 Add stack overflow by rule check to JUMPF tests (#902).</li> <li>\ud83d\udc1e Fix erroneous test with<code>CALLF</code> rule bug (#907).</li> <li>\u2728 Add test for EXTDELEGATECALL value cost (#911).</li> <li>\u2728 Add basic EOF execution tests (#912).</li> <li>\u2728 Add parametrized CALLF execution tests (#913).</li> <li>\u2728 Add CALLF execution tests (#914).</li> <li>\u2728 Add fibonacci and factorial CALLF tests (#915).</li> <li>\u2728 Add RJUMP* execution tests (#916).</li> <li>\u2728 EIP-7702 many delegations test (#923)</li> <li>\u2728 Add opcode validation tests (#932).</li> <li>\u2728 Add RJUMPI with JUMPF tests (#928).</li> <li>\u2728 EIP-7702 set code of non-empty-storage account test (#948)</li> <li>\u2728 Add PUSH* opcode tests (#975).</li> <li>\u2728 EIP-7702 implement 7702 test ideas (#981)</li> <li>\u2728 EIP-7702 Remove delegation behavior of EXTCODE* (#984)</li> <li>\u2728 Add EIP-7620 RETURNCONTRACT behavior verification test (#1109).</li> <li>\u2728 Add EIP-7069 p256verify EOF calls tests (#1021).</li> <li>\u2728 Add EIP-7480 DATACOPY edge cases tests (#1020).</li> <li>\u2728 Add EIP-7069 EXTCALL creation gas charge tests (#1025).</li> <li>\u2728 Add generic precompile-absence test (#1036)</li> <li>\u2728 Add test for EIP-2537 which uses the full discount table of G2 MSM (#1038)</li> <li>\u2728 EIP-7691 Blob throughput increase tests by parametrization of existing EIP-4844 tests (#1023, #1082)</li> <li>\u2728 Port calldatacopy test (#1056).</li> <li>\u2728 EIP-7623 Increase calldata cost (#1004, #1071)</li> <li>\u2728 Add CALLF invalid section index tests (#1111).</li> <li>\u2728 Add JUMPF invalid section index tests (#1112).</li> <li>\u2728 Add CALLF truncated immediate bytes tests (#1114).</li> <li>\u2728 EIP-152 Add tests for Blake2 compression function <code>F</code> precompile (#1067)</li> <li>\u2728 Add CALLF non-returning section tests (#1126).</li> <li>\u2728 Add DATALOADN truncated immediate bytes tests (#1127).</li> <li>\ud83d\udd00 Update EIP-7702 test expectations according to spec updates (#1129)</li> <li>\u2728 Add tests for CALLF and non-returning (#1140).</li> <li>\ud83d\udd00 Update EIP-7251 according to spec updates #9127, #9289 (#1024, #1155).</li> <li>\ud83d\udd00 Update EIP-7002 according to spec updates #9119, #9288 (#1024, #1155).</li> <li>\ud83d\udd00 Update EIP-2935 according to spec updates #9144, #9287 (#1046, #1155)</li> <li>\u2728 Add DATALOADN validation and execution tests (#1162).</li> <li>\u2728 Add EOF prefix tests (#1187).</li> <li>\u2728 Add tests for EOF code header missing (#1193).</li> <li>\u2728 Add tests for empty EOF type section (#1194).</li> <li>\u2728 Add tests for multiple EOF type sections (#1195).</li> <li>\u2728 Add EIP-7698 legacy EOF creation prevention tests (#1206).</li> </ul>"},{"location":"CHANGELOG/#v300-2024-07-22","title":"v3.0.0 - 2024-07-22","text":""},{"location":"CHANGELOG/#test-cases_3","title":"\ud83e\uddea Test Cases","text":"<ul> <li>\u2728 Port create2 return data test (#497).</li> <li>\u2728 Add tests for eof container's section bytes position smart fuzzing (#592).</li> <li>\u2728 Add <code>test_create_selfdestruct_same_tx_increased_nonce</code> which tests self-destructing a contract with a nonce &gt; 1 (#478).</li> <li>\u2728 Add <code>test_double_kill</code> and <code>test_recreate</code> which test resurrection of accounts killed with <code>SELFDESTRUCT</code> (#488).</li> <li>\u2728 Add eof example valid invalid tests from ori, fetch EOF Container implementation (#535).</li> <li>\u2728 Add tests for EIP-2537: Precompile for BLS12-381 curve operations (#499).</li> <li>\u2728 EIP-663: Add <code>test_dupn.py</code> and <code>test_swapn.py</code> (#502).</li> <li>\u2728 Add tests for EIP-6110: Supply validator deposits on chain (#530).</li> <li>\u2728 Add tests for EIP-7002: Execution layer triggerable withdrawals (#530).</li> <li>\u2728 Add tests for EIP-7685: General purpose execution layer requests (#530).</li> <li>\u2728 Add tests for EIP-2935: Serve historical block hashes from state (#564, #585).</li> <li>\u2728 Add tests for EIP-4200: EOF - Static relative jumps (#581, #666).</li> <li>\u2728 Add tests for EIP-7069: EOF - Revamped CALL instructions (#595).</li> <li>\ud83d\udc1e Fix typos in self-destruct collision test from erroneous pytest parametrization (#608).</li> <li>\u2728 Add tests for EIP-3540: EOF - EVM Object Format v1 (#634, #668).</li> <li>\ud83d\udd00 Update EIP-7002 tests to match spec changes in ethereum/execution-apis#549 (#600)</li> <li>\u2728 Convert a few eip1153 tests from ethereum/tests repo into .py (#440).</li> <li>\u2728 Add tests for EIP-7480: EOF - Data section access instructions (#518, #664).</li> <li>\u2728 Add tests for subcontainer kind validation from EIP-7620: EOF Contract Creation for the cases with deeply nested containers and non-first code sections (#676).</li> <li>\u2728 Add tests for runtime stack overflow at CALLF instruction from EIP-4750: EOF - Functions (#678).</li> <li>\u2728 Add tests for runtime stack overflow at JUMPF instruction from EIP-6206: EOF - JUMPF and non-returning functions (#690).</li> <li>\u2728 Add tests for Devnet-1 version of EIP-7702: Set EOA account code (#621)</li> </ul>"},{"location":"CHANGELOG/#framework_3","title":"\ud83d\udee0\ufe0f Framework","text":"<ul> <li>\ud83d\udc1e Fix incorrect <code>!=</code> operator for <code>FixedSizeBytes</code> (#477).</li> <li>\u2728 Add Macro enum that represents byte sequence of Op instructions (#457)</li> <li>\u2728 Number of parameters used to call opcodes (to generate bytecode) is now checked (#492).</li> <li>\u2728 Libraries have been refactored to use <code>pydantic</code> for type checking in most test types (#486, #501, #508).</li> <li>\u2728 Opcodes are now subscriptable and it's used to define the data portion of the opcode: <code>Op.PUSH1(1) == Op.PUSH1[1]  == b\"\\x60\\x01\"</code> (#513)</li> <li>\u2728 Added EOF fixture format (#512).</li> <li>\u2728 Verify filled EOF fixtures using <code>evmone-eofparse</code> during <code>fill</code> execution (#519).</li> <li>\u2728 Added <code>--traces</code> support when running with Hyperledger Besu (#511).</li> <li>\u2728 Use pytest's \"short\" traceback style (<code>--tb=short</code>) for failure summaries in the test report for more compact terminal output (#542).</li> <li>\u2728 The <code>fill</code> command now generates HTML test reports with links to the JSON fixtures and debug information (#537).</li> <li>\u2728 Add an Ethereum RPC client class for use with consume commands (#556).</li> <li>\u2728 Add a \"slow\" pytest marker, in order to be able to limit the filled tests until release (#562).</li> <li>\u2728 Add a CLI tool that generates blockchain tests as Python from a transaction hash (#470, #576).</li> <li>\u2728 Add more Transaction and Block exceptions from existing ethereum/tests repo (#572).</li> <li>\u2728 Add \"description\" and \"url\" fields containing test case documentation and a source code permalink to fixtures during <code>fill</code> and use them in <code>consume</code>-generated Hive test reports (#579).</li> <li>\u2728 Add git workflow evmone coverage script for any new lines mentioned in converted_ethereum_tests.txt (#503).</li> <li>\u2728 Add a new covariant marker <code>with_all_contract_creating_tx_types</code> that allows automatic parametrization of a test with all contract-creating transaction types at the current executing fork (#602).</li> <li>\u2728 Tests are now encouraged to declare a <code>pre: Alloc</code> parameter to get the pre-allocation object for the test, and use <code>pre.deploy_contract</code> and <code>pre.fund_eoa</code> to deploy contracts and fund accounts respectively, instead of declaring the <code>pre</code> as a dictionary or modifying its contents directly (see the state test tutorial for an updated example) (#584).</li> <li>\u2728 Enable loading of ethereum/tests/BlockchainTests (#596).</li> <li>\ud83d\udd00 Refactor <code>gentest</code> to use <code>ethereum_test_tools.rpc.rpc</code> by adding to <code>get_transaction_by_hash</code>, <code>debug_trace_call</code> to <code>EthRPC</code> (#568).</li> <li>\u2728 Write a properties file to the output directory and enable direct generation of a fixture tarball from <code>fill</code> via <code>--output=fixtures.tgz</code>(#627).</li> <li>\ud83d\udd00 <code>ethereum_test_tools</code> library has been split into multiple libraries (#645).</li> <li>\u2728 Add the consume engine simulator and refactor the consume simulator suite (#691).</li> <li>\ud83d\udc1e Prevents forcing consume to use stdin as an input when running from hive (#701).</li> </ul>"},{"location":"CHANGELOG/#misc_3","title":"\ud83d\udccb Misc","text":"<ul> <li>\ud83d\udc1e Fix CI by using Golang 1.21 in Github Actions to build geth (#484).</li> <li>\ud83d\udca5 \"Merge\" has been renamed to \"Paris\" in the \"network\" field of the Blockchain tests, and in the \"post\" field of the State tests (#480).</li> <li>\u2728 Port entry point scripts to use click and add tests (#483).</li> <li>\ud83d\udca5 As part of the pydantic conversion, the fixtures have the following (possibly breaking) changes (#486):</li> <li>State test field <code>transaction</code> now uses the proper zero-padded hex number format for fields <code>maxPriorityFeePerGas</code>, <code>maxFeePerGas</code>, and <code>maxFeePerBlobGas</code></li> <li>Fixtures' hashes (in the <code>_info</code> field) are now calculated by removing the \"_info\" field entirely instead of it being set to an empty dict.</li> <li>\ud83d\udc1e Relax minor and patch dependency requirements to avoid conflicting package dependencies (#510).</li> <li>\ud83d\udd00 Update all CI actions to use their respective Node.js 20 versions, ahead of their Node.js 16 version deprecations (#527).</li> <li>\u2728 Releases now contain a <code>fixtures_eip7692.tar.gz</code> which contains all EOF fixtures (#573).</li> <li>\u2728 Use <code>solc-select</code> for tox when running locally and within CI (#604).</li> </ul>"},{"location":"CHANGELOG/#breaking-change_2","title":"\ud83d\udca5 Breaking Change","text":"<ul> <li>Cancun is now the latest deployed fork, and the development fork is now Prague (#489).</li> <li>Stable fixtures artifact <code>fixtures.tar.gz</code> has been renamed to <code>fixtures_stable.tar.gz</code> (#573)</li> <li>The \"Blockchain Test Hive\" fixture format has been renamed to \"Blockchain Test Engine\" and updated to more closely resemble the <code>engine_newPayload</code> format in the <code>execution-apis</code> specification (https://github.com/ethereum/execution-apis/blob/main/src/engine/prague.md#request) and now contains a single <code>\"params\"</code> field instead of multiple fields for each parameter (#687).</li> <li>Output folder for fixtures has been renamed from \"blockchain_tests_hive\" to \"blockchain_tests_engine\" (#687).</li> </ul>"},{"location":"CHANGELOG/#v211-2024-03-09","title":"v2.1.1 - 2024-03-09","text":""},{"location":"CHANGELOG/#test-cases_4","title":"\ud83e\uddea Test Cases","text":"<ul> <li>\ud83d\udc1e Dynamic create2 collision from different transactions same block (#430).</li> <li>\ud83d\udc1e Fix beacon root contract deployment tests so the account in the pre-alloc is not empty (#425).</li> <li>\ud83d\udd00 All beacon root contract tests are now contained in tests/cancun/eip4788_beacon_root/test_beacon_root_contract.py, and all state tests have been converted back to blockchain tests format (#449)</li> </ul>"},{"location":"CHANGELOG/#framework_4","title":"\ud83d\udee0\ufe0f Framework","text":"<ul> <li> <p>\u2728 Adds two <code>consume</code> commands #339:</p> </li> <li> <p><code>consume direct</code> - Execute a test fixture directly against a client using a <code>blocktest</code>-like command (currently only geth supported).</p> </li> <li> <p><code>consume rlp</code> - Execute a test fixture in a hive simulator against a client that imports the test's genesis config and blocks as RLP upon startup. This is a re-write of the ethereum/consensus Golang simulator.</p> </li> <li> <p>\u2728 Add Prague to forks (#419).</p> </li> <li>\u2728 Improve handling of the argument passed to <code>solc --evm-version</code> when compiling Yul code (#418).</li> <li>\ud83d\udc1e Fix <code>fill -m yul_test</code> which failed to filter tests that are (dynamically) marked as a yul test (#418).</li> <li>\ud83d\udd00 Helper methods <code>to_address</code>, <code>to_hash</code> and <code>to_hash_bytes</code> have been deprecated in favor of <code>Address</code> and <code>Hash</code>, which are automatically detected as opcode parameters and pushed to the stack in the resulting bytecode (#422).</li> <li>\u2728 <code>Opcodes</code> enum now contains docstrings with each opcode description, including parameters and return values, which show up in many development environments (#424) @ThreeHrSleep.</li> <li>\ud83d\udd00 Locally calculate state root for the genesis blocks in the blockchain tests instead of calling t8n (#450).</li> <li>\ud83d\udc1e Fix bug that causes an exception during test collection because the fork parameter contains <code>None</code> (#452).</li> <li>\u2728 The <code>_info</code> field in the test fixtures now contains a <code>hash</code> field, which is the hash of the test fixture, and a <code>hasher</code> script has been added which prints and performs calculations on top of the hashes of all fixtures (see <code>hasher -h</code>) (#454).</li> <li>\u2728 Adds an optional <code>verify_sync</code> field to hive blockchain tests (EngineAPI). When set to true a second client attempts to sync to the first client that executed the tests (#431).</li> <li>\ud83d\udc1e Fix manually setting the gas limit in the genesis test env for post genesis blocks in blockchain tests (#472).</li> </ul>"},{"location":"CHANGELOG/#misc_4","title":"\ud83d\udccb Misc","text":"<ul> <li>\ud83d\udc1e Fix deprecation warnings due to outdated config in recommended VS Code project settings (#420).</li> <li>\ud83d\udc1e Fix typo in the selfdestruct revert tests module (#421).</li> </ul>"},{"location":"CHANGELOG/#v210-2024-01-29-cancun","title":"v2.1.0 - 2024-01-29: \ud83d\udc0d\ud83c\udfd6\ufe0f Cancun","text":"<p>Release v2.1.0 primarily fixes a small bug introduced within the previous release where transition forks are used within the new <code>StateTest</code> format. This was highlighted by @chfast within #405 (#405), where the fork name <code>ShanghaiToCancunAtTime15k</code> was found within state tests.</p>"},{"location":"CHANGELOG/#test-cases_5","title":"\ud83e\uddea Test Cases","text":"<ul> <li>\u2728 EIP-4844: Adds <code>test_blob_gas_subtraction_tx()</code> verifying the blob gas fee is subtracted from the sender before executing the blob tx (#407).</li> </ul>"},{"location":"CHANGELOG/#framework_5","title":"\ud83d\udee0\ufe0f Framework","text":"<ul> <li>\ud83d\udc1e State tests generated with transition forks no longer use the transition fork name in the fixture output, instead they use the actual enabled fork according to the state test's block number and timestamp (#406).</li> </ul>"},{"location":"CHANGELOG/#misc_5","title":"\ud83d\udccb Misc","text":"<ul> <li>\u2728 Use <code>run-parallel</code> and shared wheel packages for <code>tox</code> (#408).</li> </ul>"},{"location":"CHANGELOG/#v200-2024-01-25-cancun","title":"v2.0.0 - 2024-01-25: \ud83d\udc0d\ud83c\udfd6\ufe0f Cancun","text":"<p>Release v2.0.0 contains many important framework changes, including introduction of the <code>StateTest</code> format, and some additional Cancun and other test coverage.</p> <p>Due to changes in the framework, there is a breaking change in the directory structure in the release tarball, please see the dedicated \"\ud83d\udca5 Breaking Changes\" section below for more information.</p>"},{"location":"CHANGELOG/#test-cases_6","title":"\ud83e\uddea Test Cases","text":"<ul> <li>\u2728 EIP-4844: Add <code>test_sufficient_balance_blob_tx()</code> and <code>test_sufficient_balance_blob_tx_pre_fund_tx()</code> (#379).</li> <li>\u2728 EIP-6780: Add a reentrancy suicide revert test (#372).</li> <li>\u2728 EIP-1153: Add <code>test_run_until_out_of_gas()</code> for transient storage opcodes (#401).</li> <li>\u2728 EIP-198: Add tests for the MODEXP precompile (#364).</li> <li>\u2728 Tests for nested <code>CALL</code> and <code>CALLCODE</code> gas consumption with a positive value transfer (previously lacking coverage) (#371).</li> <li>\ud83d\udc1e EIP-4844: Fixed <code>test_invalid_tx_max_fee_per_blob_gas()</code> to account for extra gas required in the case where the account is incorrectly deduced the balance as if it had the correct block blob gas fee (#370).</li> <li>\ud83d\udc1e EIP-4844: Fixed <code>test_insufficient_balance_blob_tx()</code> to correctly calculate the minimum balance required for the accounts (#379).</li> <li>\ud83d\udc1e EIP-4844: Fix and enable <code>test_invalid_blob_tx_contract_creation</code> (#379).</li> <li>\ud83d\udd00 Convert all eligible <code>BlockchainTest</code>s to <code>StateTest</code>s (and additionally generate corresponding <code>BlockchainTest</code>s) (#368, #370).</li> </ul>"},{"location":"CHANGELOG/#framework_6","title":"\ud83d\udee0\ufe0f Framework","text":"<ul> <li>\u2728 Add <code>StateTest</code> fixture format generation; <code>StateTests</code> now generate a <code>StateTest</code> and a corresponding <code>BlockchainTest</code> test fixture, previously only <code>BlockchainTest</code> fixtures were generated (#368).</li> <li>\u2728 Add <code>StateTestOnly</code> fixture format is now available and its only difference with <code>StateTest</code> is that it does not produce a <code>BlockchainTest</code> (#368).</li> <li>\u2728 Add <code>evm_bytes_to_python</code> command-line utility which converts EVM bytecode to Python Opcodes (#357).</li> <li>\u2728 Fork objects used to write tests can now be compared using the <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code> operators, to check for a fork being newer than, newer than or equal, older than, older than or equal, respectively when compared against other fork (#367).</li> <li>\u2728 Add solc 0.8.23 support (#373).</li> <li>\u2728 Add framework unit tests for post state exception verification (#350).</li> <li>\u2728 Add a helper class <code>ethereum_test_tools.TestParameterGroup</code> to define test parameters as dataclasses and auto-generate test IDs (#364).</li> <li>\u2728 Add a <code>--single-fixture-per-file</code> flag to generate one fixture JSON file per test case (#331).</li> <li>\ud83d\udc1e Storage type iterator is now fixed (#369).</li> <li>\ud83d\udc1e Fix type coercion in <code>FixtureHeader.join()</code> (#398).</li> <li>\ud83d\udd00 Locally calculate the transactions list's root instead of using the one returned by t8n when producing BlockchainTests (#353).</li> <li>\ud83d\udd00 Change custom exception classes to dataclasses to improve testability (#386).</li> <li>\ud83d\udd00 Update fork name from \"Merge\" to \"Paris\" used within the framework and tests (#363).</li> <li>\ud83d\udca5 Replace <code>=</code> with <code>_</code> in pytest node ids and test fixture names (#342).</li> <li>\ud83d\udca5 The <code>StateTest</code>, spec format used to write tests, is now limited to a single transaction per test (#361).</li> <li>\ud83d\udca5 Tests must now use <code>BlockException</code> and <code>TransactionException</code> to define the expected exception of a given test, which can be used to test whether the client is hitting the proper exception when processing the block or transaction (#384).</li> <li>\ud83d\udca5 <code>fill</code>: Remove the <code>--enable-hive</code> flag; now all test types are generated by default (#358).</li> <li>\ud83d\udca5 Rename test fixtures names to match the corresponding pytest node ID as generated using <code>fill</code> (#342).</li> </ul>"},{"location":"CHANGELOG/#misc_6","title":"\ud83d\udccb Misc","text":"<ul> <li>\u2728 Docs: Add a \"Consuming Tests\" section to the docs, where each test fixture format is described, along with the steps to consume them, and the description of the structures used in each format (#375).</li> <li>\ud83d\udd00 Docs: Update <code>t8n</code> tool branch to fill tests for development features in the readme (#338).</li> <li>\ud83d\udd00 Filling tool: Updated the default filling tool (<code>t8n</code>) to go-ethereum@master (#368).</li> <li>\ud83d\udc1e Docs: Fix error banner in online docs due to mermaid syntax error (#398).</li> <li>\ud83d\udc1e Docs: Fix incorrectly formatted nested lists in online doc (#403).</li> <li>\ud83d\udd00 CLI: <code>evm_bytes_to_python</code> is renamed to <code>evm_bytes</code> and now accepts flag <code>--assembly</code> to output the code in assembly format (#844)</li> </ul>"},{"location":"CHANGELOG/#breaking-changes_1","title":"\ud83d\udca5 Breaking Changes","text":"<p>A concrete example of the test name renaming and change in directory structure is provided below.</p> <ol> <li> <p>Fixture output, including release tarballs, now contain subdirectories for different test types:</p> </li> <li> <p><code>blockchain_tests</code>: Contains <code>BlockchainTest</code> formatted tests</p> </li> <li><code>blockchain_tests_hive</code>: Contains <code>BlockchainTest</code> with Engine API call directives for use in hive</li> <li> <p><code>state_tests</code>: Contains <code>StateTest</code> formatted tests</p> </li> <li> <p><code>StateTest</code>, spec format used to write tests, is now limited to a single transaction per test.</p> </li> <li>In this release the pytest node ID is now used for fixture names (previously only the test parameters were used), this should not be breaking. However, <code>=</code> in both node IDs (and therefore fixture names) have been replaced with <code>_</code>, which may break tooling that depends on the <code>=</code> character.</li> <li>Produced <code>blockchain_tests</code> fixtures and their corresponding <code>blockchain_tests_hive</code> fixtures now contain the named exceptions <code>BlockException</code> and <code>TransactionException</code> as strings in the <code>expectException</code> and <code>validationError</code> fields, respectively. These exceptions can be used to test whether the client is hitting the proper exception when processing an invalid block.</li> </ol> <p>Blockchain test:</p> <pre><code>\"blocks\": [\n      {\n         ...\n         \"expectException\": \"TransactionException.INSUFFICIENT_ACCOUNT_FUNDS\",\n         ...\n      }\n      ...\n]\n</code></pre> <p>Blockchain hive test:</p> <pre><code>\"engineNewPayloads\": [\n      {\n         ...\n         \"validationError\": \"TransactionException.INSUFFICIENT_ACCOUNT_FUNDS\",\n         ...\n      }\n      ...\n]\n</code></pre>"},{"location":"CHANGELOG/#renaming-and-release-tarball-directory-structure-change-example","title":"Renaming and Release Tarball Directory Structure Change Example","text":"<p>The fixture renaming provides a more consistent naming scheme between the pytest node ID and fixture name and allows the fixture name to be provided directly to pytest 5on the command line to execute individual tests in isolation, e.g. <code>pytest tests/frontier/opcodes/test_dup.py::test_dup[fork_Frontier]</code>.</p> <ol> <li> <p>Pytest node ID example:</p> </li> <li> <p>Previous node ID: <code>tests/frontier/opcodes/test_dup.py::test_dup[fork=Frontier]</code>.</p> </li> <li> <p>New node ID: <code>tests/frontier/opcodes/test_dup.py::test_dup[fork_Frontier]</code>.</p> </li> <li> <p>Fixture name example:</p> </li> <li> <p>Previous fixture name: <code>000-fork=Frontier</code></p> </li> <li> <p>New fixture name: <code>tests/frontier/opcodes/test_dup.py::test_dup[fork_Frontier]</code> (now the same as the pytest node ID).</p> </li> <li> <p>Fixture JSON file name example (within the release tarball):</p> </li> <li> <p>Previous fixture file name: <code>fixtures/frontier/opcodes/dup/dup.json</code> (<code>BlockChainTest</code> format).</p> </li> <li> <p>New fixture file names (all present within the release tarball):</p> <ul> <li><code>fixtures/state_tests/frontier/opcodes/dup/dup.json</code> (<code>StateTest</code> format).</li> <li><code>fixtures/blockchain_tests/frontier/opcodes/dup/dup.json</code> (<code>BlockChainTest</code> format).</li> <li><code>fixtures/blockchain_tests_hive/frontier/opcodes/dup/dup.json</code> (a blockchain test in <code>HiveFixture</code> format).</li> </ul> </li> </ol>"},{"location":"CHANGELOG/#v106-2023-10-19-cancun-devnet-10","title":"v1.0.6 - 2023-10-19: \ud83d\udc0d\ud83c\udfd6\ufe0f Cancun Devnet 10","text":""},{"location":"CHANGELOG/#test-cases_7","title":"\ud83e\uddea Test Cases","text":"<ul> <li>\ud83d\udd00 EIP-4844: Update KZG point evaluation test vectors to use data from the official KZG setup and Mainnet Trusted Setup (#336).</li> </ul>"},{"location":"CHANGELOG/#framework_7","title":"\ud83d\udee0\ufe0f Framework","text":"<ul> <li>\ud83d\udd00 Fixtures: Add a non-RLP format field (<code>rlp_decoded</code>) to invalid blocks (#322).</li> <li>\ud83d\udd00 Spec: Refactor state and blockchain spec (#307).</li> </ul>"},{"location":"CHANGELOG/#evm-tools","title":"\ud83d\udd27 EVM Tools","text":"<ul> <li>\u2728 Run geth's <code>evm blocktest</code> command to verify JSON fixtures after test case execution (<code>--verify-fixtures</code>) (#325).</li> <li>\u2728 Enable tracing support for <code>ethereum-spec-evm</code> (#289).</li> </ul>"},{"location":"CHANGELOG/#misc_7","title":"\ud83d\udccb Misc","text":"<ul> <li>\u2728 Tooling: Add Python 3.12 support (#309).</li> <li>\u2728 Process: Added a Github pull request template (#308).</li> <li>\u2728 Docs: Changelog updated post release (#321).</li> <li>\u2728 Docs: Add a section explaining execution-spec-tests release artifacts (#334).</li> <li>\ud83d\udd00 T8N Tool: Branch used to generate the tests for Cancun is now lightclient/go-ethereum@devnet-10 (#336)</li> </ul>"},{"location":"CHANGELOG/#breaking-change_3","title":"\ud83d\udca5 Breaking Change","text":"<ul> <li>Fixtures now use the Mainnet Trusted Setup merged on consensus-specs#3521 (#336)</li> </ul>"},{"location":"CHANGELOG/#v105-2023-09-26-cancun-devnet-9-release-3","title":"v1.0.5 - 2023-09-26: \ud83d\udc0d\ud83c\udfd6\ufe0f Cancun Devnet 9 Release 3","text":"<p>This release mainly serves to update the EIP-4788 beacon roots address to <code>0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02</code>, as updated in ethereum/EIPs/pull/7672.</p>"},{"location":"CHANGELOG/#test-cases_8","title":"\ud83e\uddea Test Cases","text":"<ul> <li>\ud83d\udc1e EIP-4844: Fix invalid blob txs pre-Cancun engine response (#306).</li> <li>\u2728 EIP-4788: Final update to the beacon root address (#312).</li> </ul>"},{"location":"CHANGELOG/#misc_8","title":"\ud83d\udccb Misc","text":"<ul> <li>\u2728 Docs: Changelog added (#305).</li> <li>\u2728 CI/CD: Run development fork tests in Github Actions (#302).</li> <li>\u2728 CI/CD: Generate test JSON fixtures on push (#303).</li> </ul>"},{"location":"CHANGELOG/#breaking-change_4","title":"\ud83d\udca5 Breaking Change","text":"<p>Please use development fixtures from now on when testing Cancun. These refer to changes that are currently under development within clients:</p> <ul> <li>fixtures: All tests until the last stable fork (Shanghai)</li> <li>fixtures_develop: All tests until the last development fork (Cancun)</li> <li>fixtures_hive: All tests until the last stable fork (Shanghai) in hive format (Engine API directives instead of the usual BlockchainTest format)</li> <li>fixtures_develop_hive: All tests until the last development fork (Cancun) in hive format</li> </ul>"},{"location":"CHANGELOG/#v104-2023-09-21-cancun-devnet-9-release-2","title":"v1.0.4 - 2023-09-21: \ud83d\udc0d Cancun Devnet 9 Release 2","text":"<p>This release adds additional coverage to the current set of Cancun tests, up to the Devnet-9 Cancun specification.</p> <p>Note: Additional EIP-4788 updates from ethereum/EIPs/pull/7672 will be included in the next release.</p>"},{"location":"CHANGELOG/#test-cases_9","title":"\ud83e\uddea Test Cases","text":"<ul> <li>\u2728 EIP-7516: BLOBBASEFEE opcode: Add first and comprehensive tests (@marioevz in #294).</li> <li>\u2728 EIP-4788: Beacon block root in the EVM: Increase coverage (@spencer-tb in #297).</li> <li>\ud83d\udc1e EIP-1153: Transient storage opcodes: Remove conftest '+1153' in network field (@spencer-tb in #299).</li> </ul>"},{"location":"CHANGELOG/#framework_8","title":"\ud83d\udee0\ufe0f Framework","text":"<ul> <li>\ud83d\udd00 EIP-4788: Beacon root contract is pre-deployed at <code>0xbEAC020008aFF7331c0A389CB2AAb67597567d7a</code> (@spencer-tb in #297).</li> <li>\u2728 Deprecate empty accounts within framework (@spencer-tb in #300).</li> <li>\u2728 Fixture generation split based on hive specificity (@spencer-tb in #301).</li> <li>\ud83d\udca5 <code>fill</code>: <code>--disable-hive</code> flag removed; replaced by <code>--enable-hive</code> (@spencer-tb in #301).</li> <li>\u2728 Add engine API forkchoice updated information in fixtures (@spencer-tb in #256).</li> </ul>"},{"location":"CHANGELOG/#v103-2023-09-14-cancun-devnet-9-release","title":"v1.0.3 - 2023-09-14: \ud83d\udc0d Cancun Devnet 9 Release","text":"<p>See v1.0.3.</p>"},{"location":"CHANGELOG/#v102-2023-08-11-cancun-devnet-8-4788-v2-pre-release","title":"v1.0.2 - 2023-08-11: \ud83d\udc0d Cancun Devnet 8 + 4788 v2 Pre-Release","text":"<p>See v1.0.2.</p>"},{"location":"CHANGELOG/#v101-2023-08-03-cancun-devnet-8-pre-release","title":"v1.0.1 - 2023-08-03: \ud83d\udc0d Cancun Devnet-8 Pre-Release","text":"<p>See v1.0.1.</p>"},{"location":"CHANGELOG/#v100-2023-06-27-welcome-to-the-pytest-era","title":"v1.0.0 - 2023-06-27: \ud83e\uddea Welcome to the Pytest Era","text":"<p>See v1.0.0.</p> <p>Older releases can be found on the releases page.</p>"},{"location":"changelog_section_template/","title":"Changelog Section Template","text":"<p>The following can be copy-pasted into the <code>CHANGELOG.md</code> file for a new release.</p>"},{"location":"changelog_section_template/#unreleased","title":"\ud83d\udd1c [Unreleased]","text":""},{"location":"changelog_section_template/#breaking-change","title":"\ud83d\udca5 Breaking Change","text":""},{"location":"changelog_section_template/#framework","title":"\ud83d\udee0\ufe0f Framework","text":""},{"location":"changelog_section_template/#misc","title":"\ud83d\udccb Misc","text":""},{"location":"changelog_section_template/#test-cases","title":"\ud83e\uddea Test Cases","text":""},{"location":"navigation/","title":"Navigation","text":"<ul> <li>Home</li> <li>Getting Started<ul> <li>Installation</li> <li>Installation Troubleshooting</li> <li>VS Code Setup</li> <li>Repository Overview</li> <li>Getting Help</li> </ul> </li> <li>Writing Tests<ul> <li>Adding a New Test</li> <li>Types of Test</li> <li>Writing a New Test</li> <li>Test Markers</li> <li>Referencing an EIP Spec Version</li> <li>Verifying Changes Locally</li> <li>Code Standards</li> <li>Exception Tests</li> <li>Tutorial: Adding a State Test</li> </ul> </li> <li>Filling Tests<ul> <li>Getting Started</li> <li>Filling Tests at a Prompt</li> <li>Filling Tests in VS Code</li> <li>Filling Tests for Features Under Development</li> <li>Transition Tool Support</li> <li>Debugging Transition Tools</li> </ul> </li> <li>Consuming Tests<ul> <li>State Tests</li> <li>Blockchain Tests</li> <li>Blockchain Engine Tests</li> <li>EOF Tests</li> <li>Transaction Tests</li> <li>Common Types</li> <li>Exceptions</li> </ul> </li> <li>Executing Tests</li> <li>Developer Doc<ul> <li>Managing Configurations</li> <li>Interactive Library Usage</li> <li>Generating Documentation</li> <li>Documenting CLI Commands</li> <li>Coding Style</li> <li>Enabling Precommit Checks</li> <li>Running Github Actions Locally</li> <li>Porting Legacy Tests</li> </ul> </li> <li>Changelog</li> <li>Library Reference<ul> <li>EEST CLI Tools</li> <li>Ethereum Test Base Types Package</li> <li>Ethereum Test Exceptions Package</li> <li>Ethereum Test Fixtures Package</li> <li>Ethereum Test Forks Package</li> <li>Ethereum Test Specs Package</li> <li>Ethereum Test Tools Package</li> <li>Ethereum Test Types Package</li> <li>Ethereum Test VM Package</li> <li>Ethereum CLIs Package</li> <li>Pytest Plugins</li> </ul> </li> <li>Test Case Reference<ul> <li>Osaka<ul> <li>EIP-7692 EOF V1<ul> <li>EOF Tracker</li> <li>EIP-3540 EOF V1<ul> <li>Spec</li> <li>Test All Opcodes In Container<ul> <li><code>test_all_opcodes_in_container</code></li> <li><code>test_invalid_opcodes_after_stop</code></li> <li><code>test_all_invalid_terminating_opcodes</code></li> <li><code>test_all_unreachable_terminating_opcodes_after_stop</code></li> <li><code>test_all_unreachable_terminating_opcodes_before_stop</code></li> <li><code>test_all_opcodes_stack_underflow</code></li> <li><code>test_all_opcodes_stack_overflow</code></li> <li><code>test_truncated_data_portion_opcodes</code></li> </ul> </li> <li>Test Container Size<ul> <li><code>test_max_size</code></li> <li><code>test_above_max_size_raw</code></li> <li><code>test_section_after_end_of_container</code></li> </ul> </li> <li>Test Container Validation<ul> <li><code>test_valid_containers</code></li> <li><code>test_invalid_containers</code></li> <li><code>test_magic_validation</code></li> <li><code>test_version_validation</code></li> <li><code>test_single_code_section</code></li> <li><code>test_max_code_sections</code></li> </ul> </li> <li>Test EOF Example<ul> <li><code>test_eof_example</code></li> <li><code>test_eof_example_custom_fields</code></li> <li><code>test_eof_example_parameters</code></li> </ul> </li> <li>Test Execution<ul> <li><code>test_eof_execution</code></li> </ul> </li> <li>Test Execution Function<ul> <li><code>test_eof_functions_contract_call_succeed</code></li> <li><code>test_eof_functions_contract_call_fail</code></li> <li><code>test_eof_functions_contract_call_within_deep_nested</code></li> </ul> </li> <li>Test Extcode<ul> <li><code>test_legacy_calls_eof_sstore</code></li> </ul> </li> <li>Test Migrated Valid INVALID<ul> <li><code>test_migrated_valid_invalid</code></li> </ul> </li> <li>Test Opcodes In Legacy<ul> <li><code>test_opcodes_in_legacy</code></li> <li><code>test_opcodes_in_create_tx</code></li> <li><code>test_opcodes_in_create_operation</code></li> <li><code>test_opcodes_in_eof_calling_legacy</code></li> </ul> </li> <li>Test Section Header Body Mismatch<ul> <li><code>test_code_section_header_body_mismatch</code></li> </ul> </li> <li>Test Section Order<ul> <li><code>test_section_order</code></li> <li><code>test_container_section_order</code></li> </ul> </li> <li>Test Section Size<ul> <li><code>test_section_size</code></li> <li><code>test_truncated_container_without_data</code></li> <li><code>test_truncated_container_with_data</code></li> </ul> </li> </ul> </li> <li>EIP-4200 Relative Jumps<ul> <li>Test RJUMP<ul> <li><code>test_rjump_negative</code></li> <li><code>test_rjump_positive_negative</code></li> <li><code>test_rjump_zero</code></li> <li><code>test_rjump_maxes</code></li> <li><code>test_rjump_max_bytecode_size</code></li> <li><code>test_rjump_truncated_rjump</code></li> <li><code>test_rjump_truncated_rjump_2</code></li> <li><code>test_rjump_into_header</code></li> <li><code>test_rjump_before_header</code></li> <li><code>test_rjump_into_data</code></li> <li><code>test_rjump_outside_other_section_before</code></li> <li><code>test_rjump_outside_other_section_after</code></li> <li><code>test_rjump_after_container</code></li> <li><code>test_rjump_to_code_end</code></li> <li><code>test_rjump_into_self_data_portion</code></li> <li><code>test_rjump_into_self_remaining_code</code></li> <li><code>test_rjump_into_self</code></li> <li><code>test_rjump_into_self_pre_code</code></li> <li><code>test_rjump_valid_forward</code></li> <li><code>test_rjump_valid_backward</code></li> <li><code>test_rjump_into_stack_height_diff</code></li> <li><code>test_rjump_into_stack_height_diff_2</code></li> <li><code>test_rjump_backward_invalid_max_stack_height</code></li> <li><code>test_rjump_into_stack_underflow</code></li> <li><code>test_rjump_into_rjump</code></li> <li><code>test_rjump_into_rjumpi</code></li> <li><code>test_rjump_into_push_1</code></li> <li><code>test_rjump_into_push_n</code></li> <li><code>test_rjump_into_rjumpv</code></li> <li><code>test_rjump_into_callf</code></li> <li><code>test_rjump_into_dupn</code></li> <li><code>test_rjump_into_swapn</code></li> <li><code>test_rjump_into_exchange</code></li> <li><code>test_rjump_into_eofcreate</code></li> <li><code>test_rjump_into_returncode</code></li> <li><code>test_rjump_unreachable_code</code></li> <li><code>test_rjump_backwards_reference_only</code></li> <li><code>test_rjump_backwards_illegal_stack_height</code></li> <li><code>test_rjump_backwards_infinite_loop</code></li> </ul> </li> <li>Test RJUMPI<ul> <li><code>test_rjumpi_condition_forwards</code></li> <li><code>test_rjumpi_condition_backwards</code></li> <li><code>test_rjumpi_condition_zero</code></li> <li><code>test_rjumpi_forwards</code></li> <li><code>test_rjumpi_backwards</code></li> <li><code>test_rjumpi_zero</code></li> <li><code>test_rjumpi_max_forward</code></li> <li><code>test_rjumpi_max_backward</code></li> <li><code>test_rjumpi_valid_forward</code></li> <li><code>test_rjumpi_valid_backward</code></li> <li><code>test_rjumpi_max_bytecode_size</code></li> <li><code>test_rjumpi_truncated</code></li> <li><code>test_rjumpi_truncated_2</code></li> <li><code>test_rjumpi_into_header</code></li> <li><code>test_rjumpi_jump_before_header</code></li> <li><code>test_rjumpi_into_data</code></li> <li><code>test_rjumpi_after_container</code></li> <li><code>test_rjumpi_to_code_end</code></li> <li><code>test_rjumpi_into_self_data_portion</code></li> <li><code>test_rjumpi_into_self</code></li> <li><code>test_rjumpi_into_stack_height_diff</code></li> <li><code>test_rjumpi_into_stack_underflow</code></li> <li><code>test_rjumpi_skips_stack_underflow</code></li> <li><code>test_rjumpi_into_rjump</code></li> <li><code>test_rjumpi_into_rjumpi</code></li> <li><code>test_rjumpi_into_push_1</code></li> <li><code>test_rjumpi_into_push_n</code></li> <li><code>test_rjumpi_into_rjumpv</code></li> <li><code>test_rjumpi_into_callf</code></li> <li><code>test_rjumpi_into_dupn</code></li> <li><code>test_rjumpi_into_swapn</code></li> <li><code>test_rjumpi_into_exchange</code></li> <li><code>test_rjumpi_into_eofcreate</code></li> <li><code>test_rjumpi_into_returncode</code></li> <li><code>test_rjumpi_backwards_reference_only</code></li> <li><code>test_rjumpi_stack_validation</code></li> <li><code>test_rjumpi_at_the_end</code></li> <li><code>test_tangled_rjumpi</code></li> <li><code>test_rjumpi_backwards_onto_dup</code></li> <li><code>test_rjumpi_backwards_min_stack_wrong</code></li> <li><code>test_rjumpi_rjumpv_backwards_min_stack_wrong</code></li> <li><code>test_double_rjumpi_stack_underflow</code></li> <li><code>test_double_rjumpi_stack_height_mismatch</code></li> <li><code>test_double_rjumpi_invalid_max_stack_height</code></li> <li><code>test_rjumpi_backward_invalid_max_stack_height</code></li> </ul> </li> <li>Test RJUMPV<ul> <li><code>test_rjumpv_condition</code></li> <li><code>test_rjumpv_forwards</code></li> <li><code>test_rjumpv_backwards</code></li> <li><code>test_rjumpv_backwards_onto_dup</code></li> <li><code>test_rjumpv_backwards_large_table</code></li> <li><code>test_rjumpv_zero</code></li> <li><code>test_rjumpv_size_3</code></li> <li><code>test_rjumpv_full_table</code></li> <li><code>test_rjumpv_max_forwards</code></li> <li><code>test_rjumpv_truncated_empty</code></li> <li><code>test_rjumpv_truncated</code></li> <li><code>test_rjumpv_into_header</code></li> <li><code>test_rjumpv_before_container</code></li> <li><code>test_rjumpv_into_data</code></li> <li><code>test_rjumpv_after_container</code></li> <li><code>test_rjumpv_at_end</code></li> <li><code>test_rjumpv_into_self_data_portion</code></li> <li><code>test_rjumpv_into_self</code></li> <li><code>test_rjumpv_into_stack_height_diff</code></li> <li><code>test_rjumpv_into_stack_underflow</code></li> <li><code>test_rjumpv_skips_stack_underflow</code></li> <li><code>test_rjumpv_into_rjump</code></li> <li><code>test_rjumpv_into_rjumpi</code></li> <li><code>test_rjumpv_into_push_1</code></li> <li><code>test_rjumpv_into_push_n</code></li> <li><code>test_rjumpv_into_rjumpv</code></li> <li><code>test_rjumpv_into_callf</code></li> <li><code>test_rjumpv_into_dupn</code></li> <li><code>test_rjumpv_into_swapn</code></li> <li><code>test_rjumpv_into_exchange</code></li> <li><code>test_rjumpv_into_eofcreate</code></li> <li><code>test_rjumpv_into_returncode</code></li> <li><code>test_rjumpv_backwards_reference_only</code></li> <li><code>test_rjumpv_at_the_end</code></li> <li><code>test_rjumpv_backwards_min_stack_wrong</code></li> <li><code>test_rjumpv_rjumpi_backwards_min_stack_wrong</code></li> <li><code>test_double_rjumpv</code></li> <li><code>test_rjumpv_valid_forward</code></li> <li><code>test_rjumpv_valid_backward</code></li> <li><code>test_rjumpv_backward_invalid_max_stack_height</code></li> </ul> </li> </ul> </li> <li>EIP-4750 Functions<ul> <li>Test CALLF Execution<ul> <li><code>test_callf_factorial</code></li> <li><code>test_callf_fibonacci</code></li> <li><code>test_callf</code></li> <li><code>test_callf_operand_stack_size_max</code></li> <li><code>test_callf_operand_stack_overflow</code></li> <li><code>test_callf_sneaky_stack_overflow</code></li> <li><code>test_callf_max_stack</code></li> <li><code>test_callf_retf_memory_context</code></li> </ul> </li> <li>Test Code Validation<ul> <li><code>test_eof_validity</code></li> <li><code>test_callf_truncated_immediate</code></li> <li><code>test_invalid_code_section_index</code></li> <li><code>test_unreachable_code_sections</code></li> <li><code>test_callf_stack_height_limit_exceeded</code></li> <li><code>test_callf_stack_overflow_by_outputs</code></li> <li><code>test_callf_stack_overflow_by_height</code></li> <li><code>test_returning_section_aborts</code></li> </ul> </li> </ul> </li> <li>EIP-5450 Stack<ul> <li>Test Code Validation<ul> <li><code>test_rjumps_callf_retf</code></li> <li><code>test_rjumps_jumpf_nonreturning</code></li> </ul> </li> </ul> </li> <li>EIP-6206 JUMPF<ul> <li>Spec</li> <li>Test JUMPF Execution<ul> <li><code>test_jumpf_forward</code></li> <li><code>test_jumpf_to_retf</code></li> <li><code>test_jumpf_to_self</code></li> <li><code>test_jumpf_and_retf</code></li> <li><code>test_jumpf_too_large</code></li> <li><code>test_jumpf_way_too_large</code></li> <li><code>test_jumpf_to_nonexistent_section</code></li> <li><code>test_callf_to_non_returning_section</code></li> <li><code>test_jumpf_stack_size_1024</code></li> <li><code>test_jumpf_with_inputs_stack_size_1024</code></li> <li><code>test_jumpf_stack_size_1024_at_push</code></li> <li><code>test_jumpf_stack_overflow</code></li> <li><code>test_jumpf_with_inputs_stack_size_1024_at_push</code></li> <li><code>test_jumpf_with_inputs_stack_overflow</code></li> <li><code>test_jumpf_infinite_loop</code></li> <li><code>test_jumpf_memory_context</code></li> <li><code>test_callf_jumpf_retf_memory_context</code></li> </ul> </li> <li>Test JUMPF Stack<ul> <li><code>test_jumpf_stack_non_returning_rules</code></li> <li><code>test_jumpf_stack_returning_rules</code></li> <li><code>test_jumpf_incompatible_outputs</code></li> <li><code>test_jumpf_diff_max_stack_height</code></li> <li><code>test_jumpf_diff_min_stack_height</code></li> </ul> </li> <li>Test JUMPF Target<ul> <li><code>test_jumpf_target_rules</code></li> <li><code>test_jumpf_multi_target_rules</code></li> </ul> </li> <li>Test JUMPF Validation<ul> <li><code>test_returning_jumpf</code></li> <li><code>test_invalid_code_section_index</code></li> <li><code>test_returning_section_aborts_jumpf</code></li> <li><code>test_jumpf_self_stack_overflow</code></li> <li><code>test_jumpf_other_stack_overflow</code></li> </ul> </li> <li>Test Nonreturning Validation<ul> <li><code>test_first_section_returning</code></li> <li><code>test_returning_section_not_returning</code></li> <li><code>test_returning_section_returncode</code></li> <li><code>test_retf_in_nonreturning</code></li> <li><code>test_jumpf_in_nonreturning</code></li> <li><code>test_callf_to_nonreturning</code></li> </ul> </li> </ul> </li> <li>EIP-663 DUPN SWAPN EXCHANGE<ul> <li>Test DUPN<ul> <li><code>test_dupn_all_valid_immediates</code></li> <li><code>test_dupn_stack_underflow</code></li> <li><code>test_dupn_stack_overflow</code></li> </ul> </li> <li>Test EXCHANGE<ul> <li><code>test_exchange_all_valid_immediates</code></li> <li><code>test_exchange_all_invalid_immediates</code></li> </ul> </li> <li>Test SWAPN<ul> <li><code>test_swapn_all_valid_immediates</code></li> <li><code>test_swapn_on_max_stack</code></li> <li><code>test_swapn_stack_underflow</code></li> </ul> </li> </ul> </li> <li>EIP-7069 EXTCALL<ul> <li>Spec</li> <li>Test ADDRESS Space Extension<ul> <li><code>test_address_space_extension</code></li> </ul> </li> <li>Test Calldata<ul> <li><code>test_extcalls_inputdata</code></li> <li><code>test_extdelegatecall_inputdata</code></li> <li><code>test_extstaticcall_inputdata</code></li> <li><code>test_calldata_remains_after_subcall</code></li> <li><code>test_extcalls_input_offset</code></li> </ul> </li> <li>Test Calls<ul> <li><code>test_legacy_calls_eof_sstore</code></li> <li><code>test_legacy_calls_eof_mstore</code></li> <li><code>test_eof_calls_eof_sstore</code></li> <li><code>test_eof_calls_eof_mstore</code></li> <li><code>test_eof_calls_precompile</code></li> <li><code>test_eof_calls_legacy_sstore</code></li> <li><code>test_eof_calls_legacy_mstore</code></li> <li><code>test_callee_fails</code></li> <li><code>test_callee_context</code></li> <li><code>test_eof_calls_eof_then_fails</code></li> <li><code>test_eof_calls_clear_return_buffer</code></li> <li><code>test_eof_calls_static_flag_with_value</code></li> <li><code>test_eof_calls_min_callee_gas</code></li> <li><code>test_eof_calls_with_value</code></li> <li><code>test_eof_calls_msg_depth</code></li> </ul> </li> <li>Test Gas<ul> <li><code>test_ext_calls_gas</code></li> <li><code>test_transfer_gas_is_cleared</code></li> <li><code>test_late_account_create</code></li> </ul> </li> <li>Test RETURNDATACOPY Memory Expansion<ul> <li><code>test_returndatacopy_memory_expansion</code></li> <li><code>test_returndatacopy_huge_memory_expansion</code></li> </ul> </li> <li>Test RETURNDATALOAD<ul> <li><code>test_returndatacopy_handling</code></li> <li><code>test_returndataload_handling</code></li> <li><code>test_returndatacopy_oob</code></li> </ul> </li> </ul> </li> <li>EIP-7480 Data Section<ul> <li>Spec</li> <li>Test Code Validation<ul> <li><code>test_valid_containers_with_data_section</code></li> <li><code>test_invalid_containers_with_data_section</code></li> <li><code>test_dataloadn_truncated_immediate</code></li> </ul> </li> <li>Test Data Opcodes<ul> <li><code>test_dataloadn</code></li> <li><code>test_data_section_succeed</code></li> </ul> </li> <li>Test DATACOPY Memory Expansion<ul> <li><code>test_datacopy_memory_expansion</code></li> <li><code>test_datacopy_huge_memory_expansion</code></li> </ul> </li> </ul> </li> <li>EIP-7620 EOF CREATE<ul> <li>Spec</li> <li>Test EOFCREATE<ul> <li><code>test_simple_eofcreate</code></li> <li><code>test_eofcreate_then_dataload</code></li> <li><code>test_eofcreate_then_call</code></li> <li><code>test_auxdata_variations</code></li> <li><code>test_calldata</code></li> <li><code>test_eofcreate_in_initcode</code></li> <li><code>test_eofcreate_in_initcode_reverts</code></li> <li><code>test_return_data_cleared</code></li> <li><code>test_address_collision</code></li> <li><code>test_eofcreate_revert_eof_returndata</code></li> <li><code>test_eofcreate_invalid_index</code></li> <li><code>test_eofcreate_invalid_truncated_immediate</code></li> <li><code>test_eofcreate_truncated_container</code></li> <li><code>test_eofcreate_context</code></li> <li><code>test_eofcreate_memory_context</code></li> </ul> </li> <li>Test EOFCREATE Failures<ul> <li><code>test_initcode_revert</code></li> <li><code>test_initcode_aborts</code></li> <li><code>test_eofcreate_deploy_sizes</code></li> <li><code>test_eofcreate_deploy_sizes_tx</code></li> <li><code>test_auxdata_size_failures</code></li> <li><code>test_eofcreate_insufficient_stipend</code></li> <li><code>test_insufficient_initcode_gas</code></li> <li><code>test_insufficient_gas_memory_expansion</code></li> <li><code>test_insufficient_returncode_auxdata_gas</code></li> <li><code>test_static_flag_eofcreate</code></li> <li><code>test_eof_eofcreate_msg_depth</code></li> <li><code>test_reentrant_eofcreate</code></li> </ul> </li> <li>Test Gas<ul> <li><code>test_eofcreate_gas</code></li> </ul> </li> <li>Test Legacy EOF Creates<ul> <li><code>test_cross_version_creates_fail</code></li> <li><code>test_legacy_initcode_eof_contract_fails</code></li> </ul> </li> <li>Test Memory<ul> <li><code>test_eofcreate_memory</code></li> </ul> </li> <li>Test RETURNCODE<ul> <li><code>test_returncode_valid_index_0</code></li> <li><code>test_returncode_valid_index_1</code></li> <li><code>test_returncode_valid_index_255</code></li> <li><code>test_returncode_invalid_truncated_immediate</code></li> <li><code>test_returncode_invalid_index_0</code></li> <li><code>test_returncode_invalid_index_1</code></li> <li><code>test_returncode_invalid_index_255</code></li> <li><code>test_returncode_terminating</code></li> <li><code>test_returncode_memory_expansion</code></li> </ul> </li> <li>Test Subcontainer Validation<ul> <li><code>test_simple_create_from_deployed</code></li> <li><code>test_simple_create_from_creation</code></li> <li><code>test_reverting_container</code></li> <li><code>test_orphan_container</code></li> <li><code>test_container_combos_valid</code></li> <li><code>test_container_combos_invalid</code></li> <li><code>test_container_combos_deeply_nested_valid</code></li> <li><code>test_container_combos_deeply_nested_invalid</code></li> <li><code>test_container_combos_non_first_code_sections_valid</code></li> <li><code>test_container_combos_non_first_code_sections_invalid</code></li> <li><code>test_container_both_kinds_same_sub</code></li> <li><code>test_container_ambiguous_kind</code></li> <li><code>test_container_both_kinds_different_sub</code></li> <li><code>test_container_multiple_eofcreate_references</code></li> <li><code>test_container_multiple_returncode_references</code></li> <li><code>test_subcontainer_wrong_eof_version</code></li> <li><code>test_subcontainer_wrong_size</code></li> <li><code>test_deep_container</code></li> <li><code>test_deep_container_initcode</code></li> <li><code>test_wide_container</code></li> <li><code>test_migrated_eofcreate</code></li> <li><code>test_dangling_initcode_subcontainer_bytes</code></li> <li><code>test_dangling_runtime_subcontainer_bytes</code></li> </ul> </li> </ul> </li> <li>EIP-7698 EOF Creation Tx<ul> <li>Test EOF Creation Tx<ul> <li><code>test_eof_creation_tx_context</code></li> <li><code>test_lecacy_cannot_create_eof</code></li> <li><code>test_invalid_container_deployment</code></li> <li><code>test_short_data_subcontainer</code></li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>Prague<ul> <li>EIP-2537 BLS12 381 Precompiles<ul> <li>Spec</li> <li>Test BLS12_G1ADD<ul> <li><code>test_valid</code></li> <li><code>test_invalid</code></li> <li><code>test_gas</code></li> <li><code>test_call_types</code></li> </ul> </li> <li>Test BLS12_G1MSM<ul> <li><code>test_valid</code></li> <li><code>test_invalid</code></li> <li><code>test_call_types</code></li> </ul> </li> <li>Test BLS12_G1MUL<ul> <li><code>test_valid</code></li> <li><code>test_invalid</code></li> <li><code>test_gas</code></li> <li><code>test_call_types</code></li> </ul> </li> <li>Test BLS12_G2ADD<ul> <li><code>test_valid</code></li> <li><code>test_invalid</code></li> <li><code>test_gas</code></li> <li><code>test_call_types</code></li> </ul> </li> <li>Test BLS12_G2MSM<ul> <li><code>test_valid</code></li> <li><code>test_invalid</code></li> <li><code>test_call_types</code></li> </ul> </li> <li>Test BLS12_G2MUL<ul> <li><code>test_valid</code></li> <li><code>test_invalid</code></li> <li><code>test_gas</code></li> <li><code>test_call_types</code></li> </ul> </li> <li>Test BLS12_MAP_FP2_TO_G2<ul> <li><code>test_valid</code></li> <li><code>test_invalid</code></li> <li><code>test_gas</code></li> <li><code>test_call_types</code></li> </ul> </li> <li>Test BLS12_MAP_FP_TO_G1<ul> <li><code>test_valid</code></li> <li><code>test_invalid</code></li> <li><code>test_gas</code></li> <li><code>test_call_types</code></li> </ul> </li> <li>Test BLS12_PAIRING_CHECK<ul> <li><code>test_valid</code></li> <li><code>test_multi_pair_invalid_inf</code></li> <li><code>test_invalid</code></li> <li><code>test_call_types</code></li> </ul> </li> <li>Test Bls12 Precompiles Before Fork<ul> <li><code>test_precompile_before_fork</code></li> </ul> </li> <li>Test Bls12 Variable Length Input Contracts<ul> <li><code>test_valid_gas_g1msm</code></li> <li><code>test_invalid_gas_g1msm</code></li> <li><code>test_invalid_length_g1msm</code></li> <li><code>test_valid_gas_g2msm</code></li> <li><code>test_invalid_gas_g2msm</code></li> <li><code>test_invalid_length_g2msm</code></li> <li><code>test_valid_gas_pairing</code></li> <li><code>test_invalid_gas_pairing</code></li> <li><code>test_invalid_length_pairing</code></li> </ul> </li> <li>Vectors<ul> <li>test-vectors</li> </ul> </li> </ul> </li> <li>EIP-2935 Historical Block Hashes From State<ul> <li>Spec</li> <li>Test Block Hashes<ul> <li><code>test_block_hashes_history_at_transition</code></li> <li><code>test_block_hashes_history</code></li> <li><code>test_invalid_history_contract_calls</code></li> <li><code>test_invalid_history_contract_calls_input_size</code></li> </ul> </li> <li>Test Contract Deployment<ul> <li><code>test_system_contract_deployment</code></li> </ul> </li> </ul> </li> <li>EIP-6110 Deposits<ul> <li>Spec</li> <li>Test Deposits<ul> <li><code>test_deposit</code></li> <li><code>test_deposit_negative</code></li> </ul> </li> </ul> </li> <li>EIP-7002 El Triggerable Withdrawals<ul> <li>Spec</li> <li>Test Contract Deployment<ul> <li><code>test_system_contract_deployment</code></li> </ul> </li> <li>Test Withdrawal Requests<ul> <li><code>test_withdrawal_requests</code></li> <li><code>test_withdrawal_requests_negative</code></li> </ul> </li> <li>Test Withdrawal Requests During Fork<ul> <li><code>test_withdrawal_requests_during_fork</code></li> </ul> </li> </ul> </li> <li>EIP-7251 Consolidations<ul> <li>Spec</li> <li>Test Consolidations<ul> <li><code>test_consolidation_requests</code></li> <li><code>test_consolidation_requests_negative</code></li> </ul> </li> <li>Test Consolidations During Fork<ul> <li><code>test_consolidation_requests_during_fork</code></li> </ul> </li> <li>Test Contract Deployment<ul> <li><code>test_system_contract_deployment</code></li> </ul> </li> </ul> </li> <li>EIP-7623 Increase Calldata Cost<ul> <li>Spec</li> <li>Test Execution Gas<ul> <li><code>test_full_gas_consumption</code></li> <li><code>test_gas_consumption_below_data_floor</code></li> </ul> </li> <li>Test Refunds<ul> <li><code>test_gas_refunds_from_data_floor</code></li> </ul> </li> <li>Test Transaction Validity<ul> <li><code>test_transaction_validity_type_0</code></li> <li><code>test_transaction_validity_type_1_type_2</code></li> <li><code>test_transaction_validity_type_3</code></li> <li><code>test_transaction_validity_type_4</code></li> </ul> </li> </ul> </li> <li>EIP-7685 General Purpose El Requests<ul> <li>Spec</li> <li>Test Deposits Withdrawals Consolidations<ul> <li><code>test_valid_deposit_withdrawal_consolidation_requests</code></li> <li><code>test_valid_deposit_withdrawal_consolidation_request_from_same_tx</code></li> <li><code>test_invalid_deposit_withdrawal_consolidation_requests</code></li> </ul> </li> </ul> </li> <li>EIP-7702 Set Code Tx<ul> <li>Spec</li> <li>Test Gas<ul> <li><code>test_gas_cost</code></li> <li><code>test_account_warming</code></li> <li><code>test_intrinsic_gas_cost</code></li> <li><code>test_self_set_code_cost</code></li> <li><code>test_call_to_pre_authorized_oog</code></li> </ul> </li> <li>Test INVALID Tx<ul> <li><code>test_empty_authorization_list</code></li> <li><code>test_invalid_auth_signature</code></li> <li><code>test_invalid_tx_invalid_auth_chain_id</code></li> <li><code>test_invalid_tx_invalid_nonce</code></li> </ul> </li> <li>Test Set Code Txs<ul> <li><code>test_self_sponsored_set_code</code></li> <li><code>test_set_code_to_sstore</code></li> <li><code>test_set_code_to_non_empty_storage_non_zero_nonce</code></li> <li><code>test_set_code_to_sstore_then_sload</code></li> <li><code>test_set_code_to_tstore_reentry</code></li> <li><code>test_set_code_to_tstore_available_at_correct_address</code></li> <li><code>test_set_code_to_self_destruct</code></li> <li><code>test_set_code_to_contract_creator</code></li> <li><code>test_set_code_to_self_caller</code></li> <li><code>test_set_code_max_depth_call_stack</code></li> <li><code>test_set_code_call_set_code</code></li> <li><code>test_address_from_set_code</code></li> <li><code>test_tx_into_self_delegating_set_code</code></li> <li><code>test_tx_into_chain_delegating_set_code</code></li> <li><code>test_call_into_self_delegating_set_code</code></li> <li><code>test_call_into_chain_delegating_set_code</code></li> <li><code>test_ext_code_on_set_code</code></li> <li><code>test_ext_code_on_self_set_code</code></li> <li><code>test_set_code_address_and_authority_warm_state</code></li> <li><code>test_set_code_address_and_authority_warm_state_call_types</code></li> <li><code>test_ext_code_on_self_delegating_set_code</code></li> <li><code>test_ext_code_on_chain_delegating_set_code</code></li> <li><code>test_self_code_on_set_code</code></li> <li><code>test_set_code_to_account_deployed_in_same_tx</code></li> <li><code>test_set_code_to_self_destructing_account_deployed_in_same_tx</code></li> <li><code>test_set_code_multiple_first_valid_authorization_tuples_same_signer</code></li> <li><code>test_set_code_multiple_valid_authorization_tuples_same_signer_increasing_nonce</code></li> <li><code>test_set_code_multiple_valid_authorization_tuples_same_signer_increasing_nonce_self_sponsored</code></li> <li><code>test_set_code_multiple_valid_authorization_tuples_first_invalid_same_signer</code></li> <li><code>test_set_code_all_invalid_authorization_tuples</code></li> <li><code>test_set_code_using_chain_specific_id</code></li> <li><code>test_set_code_using_valid_synthetic_signatures</code></li> <li><code>test_valid_tx_invalid_auth_signature</code></li> <li><code>test_signature_s_out_of_range</code></li> <li><code>test_valid_tx_invalid_chain_id</code></li> <li><code>test_nonce_validity</code></li> <li><code>test_nonce_overflow_after_first_authorization</code></li> <li><code>test_set_code_to_log</code></li> <li><code>test_set_code_to_precompile</code></li> <li><code>test_set_code_to_system_contract</code></li> <li><code>test_eoa_tx_after_set_code</code></li> <li><code>test_reset_code</code></li> <li><code>test_contract_create</code></li> <li><code>test_empty_authorization_list</code></li> <li><code>test_delegation_clearing</code></li> <li><code>test_delegation_clearing_tx_to</code></li> <li><code>test_delegation_clearing_and_set</code></li> <li><code>test_delegation_clearing_failing_tx</code></li> <li><code>test_deploying_delegation_designation_contract</code></li> <li><code>test_creating_delegation_designation_contract</code></li> <li><code>test_many_delegations</code></li> <li><code>test_invalid_transaction_after_authorization</code></li> <li><code>test_authorization_reusing_nonce</code></li> <li><code>test_set_code_from_account_with_non_delegating_code</code></li> </ul> </li> <li>Test Set Code Txs 2<ul> <li><code>test_pointer_contract_pointer_loop</code></li> <li><code>test_pointer_to_pointer</code></li> <li><code>test_pointer_normal</code></li> <li><code>test_pointer_measurements</code></li> <li><code>test_call_to_precompile_in_pointer_context</code></li> <li><code>test_pointer_to_precompile</code></li> <li><code>test_gas_diff_pointer_vs_direct_call</code></li> <li><code>test_pointer_call_followed_by_direct_call</code></li> <li><code>test_pointer_to_static</code></li> <li><code>test_static_to_pointer</code></li> <li><code>test_pointer_to_eof</code></li> <li><code>test_pointer_to_static_reentry</code></li> <li><code>test_contract_storage_to_pointer_with_storage</code></li> <li><code>test_pointer_reentry</code></li> <li><code>test_eoa_init_as_pointer</code></li> <li><code>test_call_pointer_to_created_from_create_after_oog_call_again</code></li> <li><code>test_pointer_reverts</code></li> <li><code>test_double_auth</code></li> <li><code>test_pointer_resets_an_empty_code_account_with_storage</code></li> </ul> </li> </ul> </li> </ul> </li> <li>Cancun<ul> <li>EIP-1153 TSTORE<ul> <li>Spec</li> <li>Test Basic TLOAD<ul> <li><code>test_basic_tload_transaction_begin</code></li> <li><code>test_basic_tload_works</code></li> <li><code>test_basic_tload_other_after_tstore</code></li> <li><code>test_basic_tload_gasprice</code></li> <li><code>test_basic_tload_after_store</code></li> </ul> </li> <li>Test TLOAD Calls<ul> <li><code>test_tload_calls</code></li> </ul> </li> <li>Test TLOAD Reentrancy<ul> <li><code>test_tload_reentrancy</code></li> </ul> </li> <li>Test Tstorage<ul> <li><code>test_transient_storage_unset_values</code></li> <li><code>test_tload_after_tstore</code></li> <li><code>test_tload_after_sstore</code></li> <li><code>test_tload_after_tstore_is_zero</code></li> <li><code>test_gas_usage</code></li> <li><code>test_run_until_out_of_gas</code></li> </ul> </li> <li>Test Tstorage Clear After Tx<ul> <li><code>test_tstore_clear_after_deployment_tx</code></li> <li><code>test_tstore_clear_after_tx</code></li> </ul> </li> <li>Test Tstorage CREATE Contexts<ul> <li><code>test_contract_creation</code></li> </ul> </li> <li>Test Tstorage Execution Contexts<ul> <li><code>test_subcall</code></li> </ul> </li> <li>Test Tstorage Reentrancy Contexts<ul> <li><code>test_reentrant_call</code></li> </ul> </li> <li>Test Tstorage SELFDESTRUCT<ul> <li><code>test_reentrant_selfdestructing_call</code></li> </ul> </li> <li>Test TSTORE Reentrancy<ul> <li><code>test_tstore_reentrancy</code></li> </ul> </li> </ul> </li> <li>EIP-4788 Beacon Root<ul> <li>Spec</li> <li>Test Beacon Root Contract<ul> <li><code>test_beacon_root_contract_calls</code></li> <li><code>test_beacon_root_contract_timestamps</code></li> <li><code>test_calldata_lengths</code></li> <li><code>test_beacon_root_equal_to_timestamp</code></li> <li><code>test_tx_to_beacon_root_contract</code></li> <li><code>test_invalid_beacon_root_calldata_value</code></li> <li><code>test_beacon_root_selfdestruct</code></li> <li><code>test_multi_block_beacon_root_timestamp_calls</code></li> <li><code>test_beacon_root_transition</code></li> <li><code>test_no_beacon_root_contract_at_transition</code></li> <li><code>test_beacon_root_contract_deploy</code></li> </ul> </li> </ul> </li> <li>EIP-4844 Blobs<ul> <li>Spec</li> <li>Test Blob Txs<ul> <li><code>test_valid_blob_tx_combinations</code></li> <li><code>test_invalid_tx_max_fee_per_blob_gas</code></li> <li><code>test_invalid_tx_max_fee_per_blob_gas_state</code></li> <li><code>test_invalid_normal_gas</code></li> <li><code>test_invalid_block_blob_count</code></li> <li><code>test_insufficient_balance_blob_tx</code></li> <li><code>test_sufficient_balance_blob_tx</code></li> <li><code>test_sufficient_balance_blob_tx_pre_fund_tx</code></li> <li><code>test_blob_gas_subtraction_tx</code></li> <li><code>test_insufficient_balance_blob_tx_combinations</code></li> <li><code>test_invalid_tx_blob_count</code></li> <li><code>test_invalid_blob_hash_versioning_single_tx</code></li> <li><code>test_invalid_blob_hash_versioning_multiple_txs</code></li> <li><code>test_invalid_blob_tx_contract_creation</code></li> <li><code>test_blob_tx_attribute_opcodes</code></li> <li><code>test_blob_tx_attribute_value_opcode</code></li> <li><code>test_blob_tx_attribute_calldata_opcodes</code></li> <li><code>test_blob_tx_attribute_gasprice_opcode</code></li> <li><code>test_blob_type_tx_pre_fork</code></li> </ul> </li> <li>Test Blob Txs Full<ul> <li><code>test_reject_valid_full_blob_in_block_rlp</code></li> </ul> </li> <li>Test BLOBHASH Opcode<ul> <li><code>test_blobhash_gas_cost</code></li> <li><code>test_blobhash_scenarios</code></li> <li><code>test_blobhash_invalid_blob_index</code></li> <li><code>test_blobhash_multiple_txs_in_block</code></li> </ul> </li> <li>Test BLOBHASH Opcode Contexts<ul> <li><code>test_blobhash_opcode_contexts</code></li> </ul> </li> <li>Test Excess Blob Gas<ul> <li><code>test_correct_excess_blob_gas_calculation</code></li> <li><code>test_correct_increasing_blob_gas_costs</code></li> <li><code>test_correct_decreasing_blob_gas_costs</code></li> <li><code>test_invalid_zero_excess_blob_gas_in_header</code></li> <li><code>test_invalid_blob_gas_used_in_header</code></li> <li><code>test_invalid_excess_blob_gas_above_target_change</code></li> <li><code>test_invalid_static_excess_blob_gas</code></li> <li><code>test_invalid_excess_blob_gas_target_blobs_increase_from_zero</code></li> <li><code>test_invalid_static_excess_blob_gas_from_zero_on_blobs_above_target</code></li> <li><code>test_invalid_excess_blob_gas_change</code></li> <li><code>test_invalid_negative_excess_blob_gas</code></li> <li><code>test_invalid_non_multiple_excess_blob_gas</code></li> </ul> </li> <li>Test Excess Blob Gas Fork Transition<ul> <li><code>test_invalid_pre_fork_block_with_blob_fields</code></li> <li><code>test_invalid_post_fork_block_without_blob_fields</code></li> <li><code>test_fork_transition_excess_blob_gas_at_blob_genesis</code></li> <li><code>test_fork_transition_excess_blob_gas_post_blob_genesis</code></li> </ul> </li> <li>Test Point Evaluation Precompile<ul> <li><code>test_valid_inputs</code></li> <li><code>test_invalid_inputs</code></li> <li><code>test_external_vectors</code></li> <li><code>test_call_opcode_types</code></li> <li><code>test_tx_entry_point</code></li> <li><code>test_precompile_before_fork</code></li> <li><code>test_precompile_during_fork</code></li> </ul> </li> <li>Test Point Evaluation Precompile Gas<ul> <li><code>test_point_evaluation_precompile_gas_usage</code></li> </ul> </li> <li>Point Evaluation Vectors<ul> <li>Readme</li> </ul> </li> </ul> </li> <li>EIP-5656 MCOPY<ul> <li>Test MCOPY<ul> <li><code>test_valid_mcopy_operations</code></li> <li><code>test_mcopy_on_empty_memory</code></li> </ul> </li> <li>Test MCOPY Contexts<ul> <li><code>test_no_memory_corruption_on_upper_call_stack_levels</code></li> <li><code>test_no_memory_corruption_on_upper_create_stack_levels</code></li> </ul> </li> <li>Test MCOPY Memory Expansion<ul> <li><code>test_mcopy_memory_expansion</code></li> <li><code>test_mcopy_huge_memory_expansion</code></li> </ul> </li> </ul> </li> <li>EIP-6780 SELFDESTRUCT<ul> <li>Test Dynamic CREATE2 SELFDESTRUCT Collision<ul> <li><code>test_dynamic_create2_selfdestruct_collision</code></li> <li><code>test_dynamic_create2_selfdestruct_collision_two_different_transactions</code></li> <li><code>test_dynamic_create2_selfdestruct_collision_multi_tx</code></li> </ul> </li> <li>Test Reentrancy SELFDESTRUCT REVERT<ul> <li><code>test_reentrancy_selfdestruct_revert</code></li> </ul> </li> <li>Test SELFDESTRUCT<ul> <li><code>test_create_selfdestruct_same_tx</code></li> <li><code>test_self_destructing_initcode</code></li> <li><code>test_self_destructing_initcode_create_tx</code></li> <li><code>test_recreate_self_destructed_contract_different_txs</code></li> <li><code>test_selfdestruct_pre_existing</code></li> <li><code>test_selfdestruct_created_same_block_different_tx</code></li> <li><code>test_calling_from_new_contract_to_pre_existing_contract</code></li> <li><code>test_calling_from_pre_existing_contract_to_new_contract</code></li> <li><code>test_create_selfdestruct_same_tx_increased_nonce</code></li> </ul> </li> <li>Test SELFDESTRUCT REVERT<ul> <li><code>test_selfdestruct_created_in_same_tx_with_revert</code></li> <li><code>test_selfdestruct_not_created_in_same_tx_with_revert</code></li> </ul> </li> </ul> </li> <li>EIP-7516 Blobgasfee<ul> <li>Test Blobgasfee Opcode<ul> <li><code>test_blobbasefee_stack_overflow</code></li> <li><code>test_blobbasefee_out_of_gas</code></li> <li><code>test_blobbasefee_before_fork</code></li> <li><code>test_blobbasefee_during_fork</code></li> </ul> </li> </ul> </li> </ul> </li> <li>Shanghai<ul> <li>EIP-3651 Warm COINBASE<ul> <li>Spec</li> <li>Test Warm COINBASE<ul> <li><code>test_warm_coinbase_call_out_of_gas</code></li> <li><code>test_warm_coinbase_gas_usage</code></li> </ul> </li> </ul> </li> <li>EIP-3855 PUSH0<ul> <li>Spec</li> <li>Test PUSH0<ul> <li><code>test_push0_contracts</code></li> <li><code>test_push0_contract_during_call_contexts</code></li> </ul> </li> </ul> </li> <li>EIP-3860 Initcode<ul> <li>Spec</li> <li>Test Initcode<ul> <li><code>test_contract_creating_tx</code></li> <li><code>test_gas_usage</code></li> <li><code>test_create_opcode_initcode</code></li> </ul> </li> <li>Test With EOF<ul> <li><code>test_legacy_create_edge_code_size</code></li> </ul> </li> </ul> </li> <li>EIP-4895 Withdrawals<ul> <li>Spec</li> <li>Test Withdrawals<ul> <li><code>test_use_value_in_tx</code></li> <li><code>test_use_value_in_contract</code></li> <li><code>test_balance_within_block</code></li> <li><code>test_multiple_withdrawals_same_address</code></li> <li><code>test_many_withdrawals</code></li> <li><code>test_self_destructing_account</code></li> <li><code>test_newly_created_contract</code></li> <li><code>test_no_evm_execution</code></li> <li><code>test_zero_amount</code></li> <li><code>test_large_amount</code></li> <li><code>test_withdrawing_to_precompiles</code></li> </ul> </li> </ul> </li> </ul> </li> <li>Paris<ul> <li>Security<ul> <li>Test SELFDESTRUCT BALANCE Bug<ul> <li><code>test_tx_selfdestruct_balance_bug</code></li> </ul> </li> </ul> </li> </ul> </li> <li>Berlin<ul> <li>EIP-2930 Access List<ul> <li>Test ACL<ul> <li><code>test_access_list</code></li> </ul> </li> </ul> </li> </ul> </li> <li>Istanbul<ul> <li>EIP-1344 CHAINID<ul> <li>Test CHAINID<ul> <li><code>test_chainid</code></li> </ul> </li> </ul> </li> <li>EIP-152 Blake2<ul> <li>Test Blake2<ul> <li><code>test_blake2b</code></li> </ul> </li> </ul> </li> </ul> </li> <li>Constantinople<ul> <li>EIP-1014 CREATE2<ul> <li>Spec</li> <li>Test CREATE Returndata<ul> <li><code>test_create2_return_data</code></li> </ul> </li> <li>Test Recreate<ul> <li><code>test_recreate</code></li> </ul> </li> </ul> </li> </ul> </li> <li>Byzantium<ul> <li>EIP-198 Modexp Precompile<ul> <li>Test Modexp<ul> <li><code>test_modexp</code></li> </ul> </li> </ul> </li> </ul> </li> <li>Homestead<ul> <li>Coverage<ul> <li>Test Coverage<ul> <li><code>test_coverage</code></li> </ul> </li> </ul> </li> <li>Yul<ul> <li>Test Yul Example<ul> <li><code>test_yul</code></li> </ul> </li> </ul> </li> </ul> </li> <li>Frontier<ul> <li>Examples<ul> <li>Test Block Intermediate State<ul> <li><code>test_block_intermidiate_state</code></li> </ul> </li> </ul> </li> <li>Opcodes<ul> <li>Test All Opcodes<ul> <li><code>test_all_opcodes</code></li> <li><code>test_cover_revert</code></li> </ul> </li> <li>Test CALL AND CALLCODE Gas Calculation<ul> <li><code>test_value_transfer_gas_calculation</code></li> </ul> </li> <li>Test CALLDATACOPY<ul> <li><code>test_calldatacopy</code></li> </ul> </li> <li>Test Dup<ul> <li><code>test_dup</code></li> </ul> </li> <li>Test Push<ul> <li><code>test_push</code></li> <li><code>test_stack_overflow</code></li> </ul> </li> <li>Test SELFDESTRUCT<ul> <li><code>test_double_kill</code></li> </ul> </li> </ul> </li> <li>Precompiles<ul> <li>Test Precompile Absence<ul> <li><code>test_precompile_absence</code></li> </ul> </li> <li>Test Precompiles<ul> <li><code>test_precompiles</code></li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"consuming_tests/","title":"Consuming Tests (Fixtures) Generated by execution-spec-tests","text":"<p>ethereum/execution-spec-tests generates JSON test fixtures in different formats that can be consumed by execution clients either directly or via Hive:</p> Format Consumed by the client Location in <code>.tar.gz</code> release State Tests directly via a <code>statetest</code>-like command (e.g., go-ethereum/cmd/evm/staterunner.go) <code>./fixtures/state_tests/</code> Blockchain Tests directly via a <code>blocktest</code>-like command (e.g., go-ethereum/cmd/evm/blockrunner.go) <code>./fixtures/blockchain_tests/</code> Blockchain Engine Tests in the Hive <code>pyspec</code> simulator via the Engine API and other RPC endpoints <code>./fixtures/blockchain_tests_engine/</code> Transaction Tests directly via a <code>t9</code>-like command (e.g., go-ethereum's <code>evm t9</code>) <code>./fixtures/transaction_tests/</code> <p>Here's a top-level comparison of the different methods of consuming tests:</p> Consumed via Scope Pros Cons <code>statetest</code> or <code>blocktest</code>-like command Module test - Fast feedback loop- Less complex - Smaller coverage scope- Requires a dedicated interface to the client EVM to consume the JSON fixtures and execute tests <code>hive --sim ethereum/pyspec</code> System test / Integration test - Wider Coverage Scope- Tests more of the client stack - Slower feedback loop- Harder to debug- Post-Merge forks only (requires the Engine API) <p>Running <code>blocktest</code>, <code>statetest</code>, directly within the execution-spec-tests framework</p> <p>It's possible to execute <code>evm blocktest</code> directly within the execution-spec-tests framework. This is intended to verify fixture generation, see Debugging <code>t8n</code> Tools.</p> <p>Generating test fixtures using a <code>t8n</code> tool via <code>fill</code> is not considered to be the actual test</p> <p>The <code>fill</code> command uses <code>t8n</code> tools to generate fixtures. Whilst this will provide basic sanity checking of EVM behavior and a sub-set of post conditions are typically checked within test cases, it is not considered the actual test. The actual test is the execution of the fixture against the EVM which will check the entire post allocation and typically use different code paths than <code>t8n</code> commands.</p>"},{"location":"consuming_tests/#release-formats","title":"Release Formats","text":"<p>The ethereum/execution-spec-tests repository provides releases of fixtures in various formats (as of 2023-10-16):</p> Release Artifact Consumer Fork/feature scope <code>fixtures_stable.tar.gz</code> Clients All tests until the last stable fork (\"must pass\") <code>fixtures_develop.tar.gz</code> Clients All tests until the last development fork"},{"location":"consuming_tests/#obtaining-the-most-recent-release-artifacts","title":"Obtaining the Most Recent Release Artifacts","text":"<p>Artifacts can be downloaded directly from the release page. The following script demonstrates how the most recent release version of a specific artifact can be downloaded using the Github API:</p> <pre><code>#!/bin/bash\n\n# requires jq\n# sudo apt install jq\n\n# The following two artifacts are intended for consumption by clients:\n# - fixtures.tar.gz: Generated up to the last deployed fork.\n# - fixtures_develop.tar.gz: Generated up to and including the latest dev fork.\n# As of March 2024, dev is Prague, deployed is Cancun.\n\nARTIFACT=\"fixtures_develop.tar.gz\"  \n\nOWNER=\"ethereum\"\nREPO=\"execution-spec-tests\"\n\nDOWNLOAD_URL=$(curl -s https://api.github.com/repos/$OWNER/$REPO/releases/latest \\\n                   | jq -r '.assets[] | select(.name==\"'$ARTIFACT'\").browser_download_url')\n\n# Sanity check for the download URL: contains a version tag prefixed with \"v\"\nif [[ \"$DOWNLOAD_URL\" =~ v[0-9]+\\.[0-9]+\\.[0-9]+ ]]; then\n    curl -LO $DOWNLOAD_URL\nelse\n    echo \"Error: URL does not contain a valid version tag (URL: ${DOWNLOAD_URL}).\"\n    exit 1\nfi\n</code></pre>"},{"location":"consuming_tests/blockchain_test/","title":"Blockchain Tests","text":"<p>The Blockchain Test fixture format tests are included in the fixtures subdirectory <code>blockchain_tests</code>.</p> <p>These are produced by the <code>StateTest</code> and <code>BlockchainTest</code> test specs.</p>"},{"location":"consuming_tests/blockchain_test/#description","title":"Description","text":"<p>The blockchain test fixture format is used to test block validation and the consensus rules of the Ethereum blockchain.</p> <p>It does so by defining a pre-execution state, a series of blocks, and a post-execution state, verifying that, after all the blocks have been processed, appended if valid or rejected if invalid, the result is the expected post-execution state.</p> <p>A single JSON fixture file is composed of a JSON object where each key-value pair is a different <code>Fixture</code> test object, with the key string representing the test name.</p> <p>The JSON file path plus the test name are used as the unique test identifier.</p>"},{"location":"consuming_tests/blockchain_test/#consumption","title":"Consumption","text":"<p>For each <code>Fixture</code> test object in the JSON fixture file, perform the following steps:</p> <ol> <li>Use <code>network</code> to configure the execution fork schedule according to the <code>Fork</code> type definition.</li> <li>Use <code>pre</code> as the starting state allocation of the execution environment for the test and calculate the genesis state root.</li> <li>Decode <code>genesisRLP</code> to obtain the genesis block header, if the block cannot be decoded, fail the test.</li> <li>Compare the genesis block header with <code>genesisBlockHeader</code>, if any field does not match, fail the test.</li> <li>Compare the state root calculated on step 2 with the state root in the genesis block header, if they do not match, fail the test.</li> <li>Set the genesis block as the current head of the chain.</li> <li> <p>If <code>blocks</code> contains at least one block, perform the following steps for each <code>FixtureBlock</code> or <code>InvalidFixtureBlock</code>:</p> <ol> <li> <p>Determine whether the current block is valid or invalid:</p> <ol> <li>If the <code>expectException</code> field is not present, it is valid, and object must be decoded as a <code>FixtureBlock</code>.</li> <li>If the <code>expectException</code> field is present, it is invalid, and object must be decoded as a <code>InvalidFixtureBlock</code>.</li> </ol> </li> <li> <p>Attempt to decode field <code>rlp</code> as the current block</p> <ol> <li>If the block cannot be decoded:<ul> <li>If an rlp decoding exception is not expected for the current block, fail the test.</li> <li>If an rlp decoding error is expected, pass the test (Note: A block with an expected exception will be the last block in the fixture).</li> </ul> </li> <li>If the block can be decoded, proceed to the next step.</li> </ol> </li> <li> <p>Attempt to apply the current decoded block on top of the current head of the chain</p> <ol> <li>If the block cannot be applied:<ul> <li>If an exception is expected on the current block and it matches the exception obtained upon execution, pass the test. (Note: A block with an expected exception will be the last block in the fixture)</li> <li>If an exception is not expected on the current block, fail the test</li> </ul> </li> <li>If the block can be applied:<ul> <li>If an exception is expected on the current block, fail the test</li> <li>If an exception is not expected on the current block, set the decoded block as the current head of the chain and proceed to the next block until you reach the last block in the fixture.</li> </ul> </li> </ol> </li> </ol> </li> <li> <p>Compare the hash of the current head of the chain against <code>lastblockhash</code>, if they do not match, fail the test.</p> </li> <li>Compare all accounts and the fields described in <code>post</code> against the current state, if any do not match, fail the test.</li> </ol>"},{"location":"consuming_tests/blockchain_test/#structures","title":"Structures","text":""},{"location":"consuming_tests/blockchain_test/#fixture","title":"<code>Fixture</code>","text":""},{"location":"consuming_tests/blockchain_test/#-network-fork","title":"- <code>network</code>: <code>Fork</code>","text":""},{"location":"consuming_tests/blockchain_test/#to-be-deprecated","title":"TO BE DEPRECATED","text":"<p>Fork configuration for the test.</p> <p>This field is going to be replaced by the value contained in <code>config.network</code>.</p>"},{"location":"consuming_tests/blockchain_test/#-pre-alloc","title":"- <code>pre</code>: <code>Alloc</code>","text":"<p>Starting account allocation for the test. State root calculated from this allocation must match the one in the genesis block.</p>"},{"location":"consuming_tests/blockchain_test/#-genesisrlp-bytes","title":"- <code>genesisRLP</code>: <code>Bytes</code>","text":"<p>RLP serialized version of the genesis block.</p>"},{"location":"consuming_tests/blockchain_test/#-genesisblockheader-fixtureheader","title":"- <code>genesisBlockHeader</code>: <code>FixtureHeader</code>","text":"<p>Genesis block header.</p>"},{"location":"consuming_tests/blockchain_test/#-blocks-listfixtureblockinvalidfixtureblock","title":"- <code>blocks</code>: <code>List</code><code>[</code><code>FixtureBlock</code><code>|</code><code>InvalidFixtureBlock</code><code>]</code>","text":"<p>List of blocks to be processed after the genesis block.</p>"},{"location":"consuming_tests/blockchain_test/#-lastblockhash-hash","title":"- <code>lastblockhash</code>: <code>Hash</code>","text":"<p>Hash of the last valid block, or the genesis block hash if the list of blocks is empty, or contains a single invalid block.</p>"},{"location":"consuming_tests/blockchain_test/#-post-alloc","title":"- <code>post</code>: <code>Alloc</code>","text":"<p>Account allocation for verification after all the blocks have been processed.</p>"},{"location":"consuming_tests/blockchain_test/#-sealengine-str","title":"- <code>sealEngine</code>: <code>str</code>","text":"<p>Deprecated: Seal engine used to mine the blocks.</p>"},{"location":"consuming_tests/blockchain_test/#-config-fixtureconfig","title":"- <code>config</code>: <code>FixtureConfig</code>","text":"<p>Chain configuration object to be applied to the client running the blockchain test.</p>"},{"location":"consuming_tests/blockchain_test/#fixtureconfig","title":"<code>FixtureConfig</code>","text":""},{"location":"consuming_tests/blockchain_test/#-network-fork_1","title":"- <code>network</code>: <code>Fork</code>","text":"<p>Fork configuration for the test. It is guaranteed that this field contains the same value as the root field <code>network</code>.</p>"},{"location":"consuming_tests/blockchain_test/#-blobschedule-blobschedule","title":"- <code>blobSchedule</code>: <code>BlobSchedule</code>","text":"<p>Optional; present from Cancun on. Maps forks to their blob schedule configurations as defined by EIP-7840.</p>"},{"location":"consuming_tests/blockchain_test/#fixtureheader","title":"<code>FixtureHeader</code>","text":""},{"location":"consuming_tests/blockchain_test/#-parenthash-hash","title":"- <code>parentHash</code>: <code>Hash</code>","text":"<p>Hash of the parent block.</p>"},{"location":"consuming_tests/blockchain_test/#-unclehash-hash","title":"- <code>uncleHash</code>: <code>Hash</code>","text":"<p>Hash of the uncle block list.</p>"},{"location":"consuming_tests/blockchain_test/#-coinbase-address","title":"- <code>coinbase</code>: <code>Address</code>","text":"<p>Address of the account that will receive the rewards for building the block.</p>"},{"location":"consuming_tests/blockchain_test/#-stateroot-hash","title":"- <code>stateRoot</code>: <code>Hash</code>","text":"<p>Root hash of the state trie.</p>"},{"location":"consuming_tests/blockchain_test/#-transactionstrie-hash","title":"- <code>transactionsTrie</code>: <code>Hash</code>","text":"<p>Root hash of the transactions trie.</p>"},{"location":"consuming_tests/blockchain_test/#-receipttrie-hash","title":"- <code>receiptTrie</code>: <code>Hash</code>","text":"<p>Root hash of the receipts trie.</p>"},{"location":"consuming_tests/blockchain_test/#-bloom-bloom","title":"- <code>bloom</code>: <code>Bloom</code>","text":"<p>Bloom filter composed of the logs of all the transactions in the block.</p>"},{"location":"consuming_tests/blockchain_test/#-difficulty-zeropaddedhexnumber","title":"- <code>difficulty</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>Difficulty of the block.</p>"},{"location":"consuming_tests/blockchain_test/#-number-zeropaddedhexnumber","title":"- <code>number</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>Number of the block.</p>"},{"location":"consuming_tests/blockchain_test/#-gaslimit-zeropaddedhexnumber","title":"- <code>gasLimit</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>Total gas limit of the block.</p>"},{"location":"consuming_tests/blockchain_test/#-gasused-zeropaddedhexnumber","title":"- <code>gasUsed</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>Total gas used by all the transactions in the block.</p>"},{"location":"consuming_tests/blockchain_test/#-timestamp-zeropaddedhexnumber","title":"- <code>timestamp</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>Timestamp of the block.</p>"},{"location":"consuming_tests/blockchain_test/#-extradata-bytes","title":"- <code>extraData</code>: <code>Bytes</code>","text":"<p>Extra data of the block.</p>"},{"location":"consuming_tests/blockchain_test/#-mixhash-hash","title":"- <code>mixHash</code>: <code>Hash</code>","text":"<p>Mix hash or PrevRandao of the block.</p>"},{"location":"consuming_tests/blockchain_test/#-nonce-headernonce","title":"- <code>nonce</code>: <code>HeaderNonce</code>","text":"<p>Nonce of the block.</p>"},{"location":"consuming_tests/blockchain_test/#-hash-hash","title":"- <code>hash</code>: <code>Hash</code>","text":"<p>Hash of the block.</p>"},{"location":"consuming_tests/blockchain_test/#-basefeepergas-zeropaddedhexnumber-fork-london","title":"- <code>baseFeePerGas</code>: <code>ZeroPaddedHexNumber</code> <code>(fork: London)</code>","text":"<p>Base fee per gas of the block.</p>"},{"location":"consuming_tests/blockchain_test/#-withdrawalsroot-hash-fork-shanghai","title":"- <code>withdrawalsRoot</code>: <code>Hash</code> <code>(fork: Shanghai)</code>","text":"<p>Root hash of the withdrawals trie.</p>"},{"location":"consuming_tests/blockchain_test/#-blobgasused-zeropaddedhexnumber-fork-cancun","title":"- <code>blobGasUsed</code>: <code>ZeroPaddedHexNumber</code> <code>(fork: Cancun)</code>","text":"<p>Total blob gas used by all the transactions in the block.</p>"},{"location":"consuming_tests/blockchain_test/#-excessblobgas-zeropaddedhexnumber-fork-cancun","title":"- <code>excessBlobGas</code>: <code>ZeroPaddedHexNumber</code> <code>(fork: Cancun)</code>","text":"<p>Excess blob gas of the block used to calculate the blob fee per gas for this block.</p>"},{"location":"consuming_tests/blockchain_test/#-parentbeaconblockroot-hash-fork-cancun","title":"- <code>parentBeaconBlockRoot</code>: <code>Hash</code> <code>(fork: Cancun)</code>","text":"<p>Root hash of the parent beacon block.</p>"},{"location":"consuming_tests/blockchain_test/#fixtureblock","title":"<code>FixtureBlock</code>","text":""},{"location":"consuming_tests/blockchain_test/#-rlp-bytes","title":"- <code>rlp</code>: <code>Bytes</code>","text":"<p>RLP serialized version of the block. Field is only optional when embedded in a <code>InvalidFixtureBlock</code> as the <code>rlp_decoded</code> field.</p>"},{"location":"consuming_tests/blockchain_test/#-blockheader-fixtureheader","title":"- <code>blockHeader</code>: <code>FixtureHeader</code>","text":"<p>Decoded block header fields included in the block RLP.</p>"},{"location":"consuming_tests/blockchain_test/#-blocknumber-number","title":"- <code>blocknumber</code>: <code>Number</code>","text":"<p>Block number.</p>"},{"location":"consuming_tests/blockchain_test/#-transactions-listfixturetransaction","title":"- <code>transactions</code>: <code>List</code><code>[</code><code>FixtureTransaction</code><code>]</code>","text":"<p>List of decoded transactions included in the block RLP.</p>"},{"location":"consuming_tests/blockchain_test/#-uncleheaders-listfixtureheader","title":"- <code>uncleHeaders</code>: <code>List</code><code>[</code><code>FixtureHeader</code><code>]</code>","text":"<p>List of uncle headers included in the block RLP. An empty list post merge.</p>"},{"location":"consuming_tests/blockchain_test/#-withdrawals-optionallistfixturewithdrawal-fork-shanghai","title":"- <code>withdrawals</code>: <code>Optional</code><code>[</code><code>List</code><code>[</code><code>FixtureWithdrawal</code><code>]]</code> <code>(fork: Shanghai)</code>","text":"<p>Optional list of withdrawals included in the block RLP.</p>"},{"location":"consuming_tests/blockchain_test/#invalidfixtureblock","title":"<code>InvalidFixtureBlock</code>","text":""},{"location":"consuming_tests/blockchain_test/#-expectexception-transactionexceptionblockexception","title":"- <code>expectException</code>: <code>TransactionException</code><code>|</code><code>BlockException</code>","text":"<p>Expected exception that invalidates the block.</p>"},{"location":"consuming_tests/blockchain_test/#-rlp-bytes_1","title":"- <code>rlp</code>: <code>Bytes</code>","text":"<p>RLP serialized version of the block.</p>"},{"location":"consuming_tests/blockchain_test/#-rlp_decoded-optionalfixtureblock","title":"- <code>rlp_decoded</code>: <code>Optional</code><code>[</code><code>FixtureBlock</code><code>]</code>","text":"<p>Decoded block attributes included in the block RLP.</p>"},{"location":"consuming_tests/blockchain_test/#fixturetransaction","title":"<code>FixtureTransaction</code>","text":""},{"location":"consuming_tests/blockchain_test/#-type-zeropaddedhexnumber","title":"- <code>type</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>Transaction type.</p>"},{"location":"consuming_tests/blockchain_test/#-chainid-zeropaddedhexnumber","title":"- <code>chainId</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>Chain ID of the transaction.</p>"},{"location":"consuming_tests/blockchain_test/#-nonce-zeropaddedhexnumber","title":"- <code>nonce</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>Nonce of the account that sends the transaction</p>"},{"location":"consuming_tests/blockchain_test/#-gasprice-zeropaddedhexnumber","title":"- <code>gasPrice</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>Gas price for the transaction (Transaction types 0 &amp; 1)</p>"},{"location":"consuming_tests/blockchain_test/#-maxpriorityfeepergas-hexnumber-fork-london","title":"- <code>maxPriorityFeePerGas</code>: <code>HexNumber</code> <code>(fork: London)</code>","text":"<p>Max priority fee per gas to pay (Transaction types 2 &amp; 3)</p>"},{"location":"consuming_tests/blockchain_test/#-maxfeepergas-hexnumber-fork-london","title":"- <code>maxFeePerGas</code>: <code>HexNumber</code> <code>(fork: London)</code>","text":"<p>Max base fee per gas to pay (Transaction types 2 &amp; 3)</p>"},{"location":"consuming_tests/blockchain_test/#-gaslimit-zeropaddedhexnumber_1","title":"- <code>gasLimit</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>Gas limit of the transaction</p>"},{"location":"consuming_tests/blockchain_test/#-to-address-null","title":"- <code>to</code>: <code>Address</code><code>| null</code>","text":"<p>Destination address of the transaction, or <code>null</code> to create a contract</p>"},{"location":"consuming_tests/blockchain_test/#-value-zeropaddedhexnumber","title":"- <code>value</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>Value of the transaction</p>"},{"location":"consuming_tests/blockchain_test/#-data-bytes","title":"- <code>data</code>: <code>Bytes</code>","text":"<p>Data bytes of the transaction</p>"},{"location":"consuming_tests/blockchain_test/#-accesslist-listmappingaddresslisthash-fork-berlin","title":"- <code>accessList</code>: <code>List</code><code>[</code><code>Mapping</code><code>[</code><code>Address</code><code>,</code><code>List</code><code>[</code><code>Hash</code><code>]]]</code> <code>(fork: Berlin)</code>","text":"<p>Account access lists (Transaction types 1, 2 &amp; 3)</p>"},{"location":"consuming_tests/blockchain_test/#-maxfeeperblobgas-zeropaddedhexnumber-fork-cancun","title":"- <code>maxFeePerBlobGas</code>: <code>ZeroPaddedHexNumber</code> <code>(fork: Cancun)</code>","text":"<p>Max fee per blob gas to pay (Transaction type 3)</p>"},{"location":"consuming_tests/blockchain_test/#-blobversionedhashes-listhash-fork-cancun","title":"- <code>blobVersionedHashes</code>: <code>List</code><code>[</code><code>Hash</code><code>]</code> <code>(fork: Cancun)</code>","text":"<p>Max fee per blob gas to pay (Transaction type 3)</p>"},{"location":"consuming_tests/blockchain_test/#-v-zeropaddedhexnumber","title":"- <code>v</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>V value of the transaction signature</p>"},{"location":"consuming_tests/blockchain_test/#-r-zeropaddedhexnumber","title":"- <code>r</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>R value of the transaction signature</p>"},{"location":"consuming_tests/blockchain_test/#-s-zeropaddedhexnumber","title":"- <code>s</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>S value of the transaction signature</p>"},{"location":"consuming_tests/blockchain_test/#-sender-address","title":"- <code>sender</code>: <code>Address</code>","text":"<p>Sender address of the transaction</p>"},{"location":"consuming_tests/blockchain_test/#-secretkey-hash","title":"- <code>secretKey</code>: <code>Hash</code>","text":"<p>Private key that must be used to sign the transaction</p>"},{"location":"consuming_tests/blockchain_test/#fixturewithdrawal","title":"<code>FixtureWithdrawal</code>","text":""},{"location":"consuming_tests/blockchain_test/#-index-zeropaddedhexnumber","title":"- <code>index</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>Index of the withdrawal</p>"},{"location":"consuming_tests/blockchain_test/#-validatorindex-zeropaddedhexnumber","title":"- <code>validatorIndex</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>Withdrawing validator index</p>"},{"location":"consuming_tests/blockchain_test/#-address-address","title":"- <code>address</code>: <code>Address</code>","text":"<p>Address to withdraw to</p>"},{"location":"consuming_tests/blockchain_test/#-amount-zeropaddedhexnumber","title":"- <code>amount</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>Amount of the withdrawal</p>"},{"location":"consuming_tests/blockchain_test_engine/","title":"Blockchain Engine Tests","text":"<p>The Blockchain Engine Test fixture format tests are included in the fixtures subdirectory <code>blockchain_tests_engine</code>, and use Engine API directives instead of the usual BlockchainTest format.</p> <p>These are produced by the <code>StateTest</code> and <code>BlockchainTest</code> test specs.</p>"},{"location":"consuming_tests/blockchain_test_engine/#description","title":"Description","text":"<p>The Blockchain Engine Test fixture format is used to test block validation and the consensus rules of the Ethereum blockchain, when a block is delivered through the Engine API as a <code>engine_newPayloadVX</code> directive.</p> <p>It does so by defining a pre-execution state, a series of blocks as <code>engine_newPayloadVX</code> directives, and a post-execution state, verifying that, after all the blocks have been processed, appended if valid or rejected if invalid, the result is the expected post-execution state.</p> <p>A single JSON fixture file is composed of a JSON object where each key-value pair is a different <code>HiveFixture</code> test object, with the key string representing the test name.</p> <p>The JSON file path plus the test name are used as the unique test identifier.</p>"},{"location":"consuming_tests/blockchain_test_engine/#consumption","title":"Consumption","text":"<p>For each <code>HiveFixture</code> test object in the JSON fixture file, perform the following steps:</p> <ol> <li> <p>Start a full node using:</p> <ul> <li><code>network</code> to configure the execution fork schedule according to the <code>Fork</code> type definition.</li> <li><code>pre</code> as the starting state allocation of the execution environment for the test and calculate the genesis state root.</li> <li><code>genesisBlockHeader</code> as the genesis block header.</li> </ul> </li> <li> <p>Verify the head of the chain is the genesis block, and the state root matches the one calculated on step 1, otherwise fail the test.</p> </li> <li> <p>For each <code>FixtureEngineNewPayload</code> in <code>engineNewPayloads</code>:</p> <ol> <li>Deliver the payload using the <code>engine_newPayloadVX</code> directive, using:<ul> <li><code>version</code> as the version of the directive.</li> <li><code>executionPayload</code> as the payload.</li> <li><code>blob_versioned_hashes</code>, if present, as the list of hashes of the versioned blobs that are part of the execution payload.</li> <li><code>parentBeaconBlockRoot</code>, if present, as the hash of the parent beacon block root.</li> </ul> </li> <li>If <code>errorCode</code> is present:<ul> <li>Verify the directive returns an error, and the error code matches the one in <code>errorCode</code>, otherwise fail the test.</li> <li>Proceed to the next payload.</li> </ul> </li> <li>If <code>valid</code> is <code>false</code>, verify that the directive returns <code>status</code> field of PayloadStatusV1 as <code>INVALID</code>, otherwise fail the test.</li> <li>If <code>valid</code> is <code>true</code>, verify that the directive returns <code>status</code> field of PayloadStatusV1 as <code>VALID</code>, otherwise fail the test.</li> </ol> </li> </ol>"},{"location":"consuming_tests/blockchain_test_engine/#structures","title":"Structures","text":""},{"location":"consuming_tests/blockchain_test_engine/#hivefixture","title":"<code>HiveFixture</code>","text":""},{"location":"consuming_tests/blockchain_test_engine/#-network-fork","title":"- <code>network</code>: <code>Fork</code>","text":""},{"location":"consuming_tests/blockchain_test_engine/#to-be-deprecated","title":"TO BE DEPRECATED","text":"<p>Fork configuration for the test.</p> <p>This field is going to be replaced by the value contained in <code>config.network</code>.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-genesisblockheader-fixtureheader","title":"- <code>genesisBlockHeader</code>: <code>FixtureHeader</code>","text":"<p>Genesis block header.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-enginenewpayloads-listfixtureenginenewpayload","title":"- <code>engineNewPayloads</code>: <code>List</code><code>[</code><code>FixtureEngineNewPayload</code><code>]</code>","text":"<p>List of <code>engine_newPayloadVX</code> directives to be processed after the genesis block.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-enginefcuversion-number","title":"- <code>engineFcuVersion</code>: <code>Number</code>","text":"<p>Version of the <code>engine_forkchoiceUpdatedVX</code> directive to use to set the head of the chain.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-pre-alloc","title":"- <code>pre</code>: <code>Alloc</code>","text":"<p>Starting account allocation for the test. State root calculated from this allocation must match the one in the genesis block.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-lastblockhash-hash","title":"- <code>lastblockhash</code>: <code>Hash</code>","text":"<p>Hash of the last valid block, or the genesis block hash if the list of blocks is empty, or contains a single invalid block.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-post-alloc","title":"- <code>post</code>: <code>Alloc</code>","text":"<p>Account allocation for verification after all the blocks have been processed.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-config-fixtureconfig","title":"- <code>config</code>: <code>FixtureConfig</code>","text":"<p>Chain configuration object to be applied to the client running the blockchain engine test.</p>"},{"location":"consuming_tests/blockchain_test_engine/#fixtureconfig","title":"<code>FixtureConfig</code>","text":""},{"location":"consuming_tests/blockchain_test_engine/#-network-fork_1","title":"- <code>network</code>: <code>Fork</code>","text":"<p>Fork configuration for the test. It is guaranteed that this field contains the same value as the root field <code>network</code>.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-blobschedule-blobschedule","title":"- <code>blobSchedule</code>: <code>BlobSchedule</code>","text":"<p>Optional; present from Cancun on. Maps forks to their blob schedule configurations as defined by EIP-7840.</p>"},{"location":"consuming_tests/blockchain_test_engine/#fixtureenginenewpayload","title":"<code>FixtureEngineNewPayload</code>","text":""},{"location":"consuming_tests/blockchain_test_engine/#-executionpayload-fixtureexecutionpayload","title":"- <code>executionPayload</code>: <code>FixtureExecutionPayload</code>","text":"<p>Execution payload.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-blob_versioned_hashes-optionallisthash-fork-cancun","title":"- <code>blob_versioned_hashes</code>: <code>Optional</code><code>[</code><code>List</code><code>[</code><code>Hash</code><code>]]</code> <code>(fork: Cancun)</code>","text":"<p>List of hashes of the versioned blobs that are part of the execution payload. They can mismatch the hashes of the versioned blobs in the execution payload, for negative-testing reasons.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-parentbeaconblockroot-optionalhash-fork-cancun","title":"- <code>parentBeaconBlockRoot</code>: <code>Optional</code><code>[</code><code>Hash</code><code>]</code> <code>(fork: Cancun)</code>","text":"<p>Hash of the parent beacon block root.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-validationerror-transactionexceptionblockexception","title":"- <code>validationError</code>: <code>TransactionException</code><code>|</code><code>BlockException</code>","text":"<p>Validation error expected when executing the payload.</p> <p>When the payload is valid, this field is not present, and a <code>VALID</code> status is expected in the <code>status</code> field of PayloadStatusV1.</p> <p>If this field is present, the <code>status</code> field of PayloadStatusV1 is expected to be <code>INVALID</code>.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-version-number","title":"- <code>version</code>: <code>Number</code>","text":"<p>Version of the <code>engine_newPayloadVX</code> directive to use to deliver the payload.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-errorcode-optionalnumber","title":"- <code>errorCode</code>: <code>Optional</code><code>[</code><code>Number</code><code>]</code>","text":"<p>Error code to be returned by the <code>engine_newPayloadVX</code> directive.</p>"},{"location":"consuming_tests/blockchain_test_engine/#fixtureexecutionpayload","title":"<code>FixtureExecutionPayload</code>","text":""},{"location":"consuming_tests/blockchain_test_engine/#-parenthash-hash","title":"- <code>parentHash</code>: <code>Hash</code>","text":"<p>Hash of the parent block.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-feerecipient-address","title":"- <code>feeRecipient</code>: <code>Address</code>","text":"<p>Address of the account that will receive the rewards for building the block.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-stateroot-hash","title":"- <code>stateRoot</code>: <code>Hash</code>","text":"<p>Root hash of the state trie.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-receiptsroot-hash","title":"- <code>receiptsRoot</code>: <code>Hash</code>","text":"<p>Root hash of the receipts trie.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-logsbloom-bloom","title":"- <code>logsBloom</code>: <code>Bloom</code>","text":"<p>Bloom filter composed of the logs of all the transactions in the block.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-blocknumber-hexnumber","title":"- <code>blockNumber</code>: <code>HexNumber</code>","text":"<p>Number of the block.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-gaslimit-hexnumber","title":"- <code>gasLimit</code>: <code>HexNumber</code>","text":"<p>Total gas limit of the block.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-gasused-hexnumber","title":"- <code>gasUsed</code>: <code>HexNumber</code>","text":"<p>Total gas used by all the transactions in the block.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-timestamp-hexnumber","title":"- <code>timestamp</code>: <code>HexNumber</code>","text":"<p>Timestamp of the block.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-extradata-bytes","title":"- <code>extraData</code>: <code>Bytes</code>","text":"<p>Extra data of the block.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-prevrandao-hash","title":"- <code>prevRandao</code>: <code>Hash</code>","text":"<p>PrevRandao of the block.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-blockhash-hash","title":"- <code>blockHash</code>: <code>Hash</code>","text":"<p>Hash of the block.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-transactions-listbytes","title":"- <code>transactions</code>: <code>List</code><code>[</code><code>Bytes</code><code>]</code>","text":"<p>List of transactions in the block, in serialized format.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-withdrawals-listfixturewithdrawal","title":"- <code>withdrawals</code>: <code>List</code><code>[</code><code>FixtureWithdrawal</code><code>]</code>","text":"<p>List of withdrawals in the block.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-basefeepergas-hexnumber-fork-london","title":"- <code>baseFeePerGas</code>: <code>HexNumber</code> <code>(fork: London)</code>","text":"<p>Base fee per gas of the block.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-blobgasused-hexnumber-fork-cancun","title":"- <code>blobGasUsed</code>: <code>HexNumber</code> <code>(fork: Cancun)</code>","text":"<p>Total blob gas used by all the transactions in the block.</p>"},{"location":"consuming_tests/blockchain_test_engine/#-excessblobgas-hexnumber-fork-cancun","title":"- <code>excessBlobGas</code>: <code>HexNumber</code> <code>(fork: Cancun)</code>","text":"<p>Excess blob gas of the block used to calculate the blob fee per gas for this block.</p>"},{"location":"consuming_tests/blockchain_test_engine/#fixturewithdrawal","title":"<code>FixtureWithdrawal</code>","text":""},{"location":"consuming_tests/blockchain_test_engine/#-index-hexnumber","title":"- <code>index</code>: <code>HexNumber</code>","text":"<p>Index of the withdrawal</p>"},{"location":"consuming_tests/blockchain_test_engine/#-validatorindex-hexnumber","title":"- <code>validatorIndex</code>: <code>HexNumber</code>","text":"<p>Withdrawing validator index</p>"},{"location":"consuming_tests/blockchain_test_engine/#-address-address","title":"- <code>address</code>: <code>Address</code>","text":"<p>Address to withdraw to</p>"},{"location":"consuming_tests/blockchain_test_engine/#-amount-hexnumber","title":"- <code>amount</code>: <code>HexNumber</code>","text":"<p>Amount of the withdrawal</p>"},{"location":"consuming_tests/common_types/","title":"Common Types","text":""},{"location":"consuming_tests/common_types/#basic-types","title":"Basic Types","text":""},{"location":"consuming_tests/common_types/#address","title":"<code>Address</code>","text":"<p>Bytes of a 20-byte fixed length.</p>"},{"location":"consuming_tests/common_types/#bloom","title":"<code>Bloom</code>","text":"<p>Bytes of a 256-byte fixed length.</p>"},{"location":"consuming_tests/common_types/#bytes","title":"<code>Bytes</code>","text":"<p>Hexadecimal representation of binary data of any length encoded as a JSON string, with a \"0x\" prefix.</p>"},{"location":"consuming_tests/common_types/#emptyaddress","title":"<code>EmptyAddress</code>","text":"<p>An empty JSON string <code>\"\"</code>, used to represent an empty address. E.g. in the <code>to</code> field of a transaction when it is a contract creation.</p>"},{"location":"consuming_tests/common_types/#hash","title":"<code>Hash</code>","text":"<p>Bytes of a 32-byte fixed length.</p>"},{"location":"consuming_tests/common_types/#headernonce","title":"<code>HeaderNonce</code>","text":"<p>Bytes of a 8-byte fixed length.</p>"},{"location":"consuming_tests/common_types/#hexnumber","title":"<code>HexNumber</code>","text":"<p>Hexadecimal number with \"0x\" prefix encoded as a JSON string.</p>"},{"location":"consuming_tests/common_types/#list","title":"<code>List</code>","text":"<p>A JSON array where each element is a specific type, also defined in this document. E.g. <code>List[Address]</code> is a JSON array where each element is an Ethereum address.</p>"},{"location":"consuming_tests/common_types/#mapping","title":"<code>Mapping</code>","text":"<p>A JSON object where the keys and values are specific types, also defined in this document. E.g. <code>Mapping[Address, Account]</code> is a JSON object where the keys are Ethereum addresses, and the values are Ethereum accounts.</p>"},{"location":"consuming_tests/common_types/#number","title":"<code>Number</code>","text":"<p>Decimal number encoded as a JSON string.</p>"},{"location":"consuming_tests/common_types/#optional","title":"<code>Optional</code>","text":"<p>Marks a field as optional, meaning that the field can be missing from the JSON object.</p>"},{"location":"consuming_tests/common_types/#zeropaddedhexnumber","title":"<code>ZeroPaddedHexNumber</code>","text":"<p>Hexadecimal number with \"0x\" prefix encoded as a JSON string, with a single zero used to pad odd number of digits, and zero represented as \"0x00\".</p>"},{"location":"consuming_tests/common_types/#composite-types","title":"Composite Types","text":""},{"location":"consuming_tests/common_types/#storage-mappinghashhash","title":"<code>Storage</code>: <code>Mapping</code><code>[</code><code>Hash</code><code>,</code><code>Hash</code><code>]</code>","text":"<p>Storage represented as a JSON object, where the keys and values are represented with the <code>Hash</code> type.</p>"},{"location":"consuming_tests/common_types/#account","title":"<code>Account</code>","text":"<p>An Ethereum account represented as a JSON object with the following fields:</p>"},{"location":"consuming_tests/common_types/#-balance-zeropaddedhexnumber","title":"- <code>balance</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>Balance of the account.</p>"},{"location":"consuming_tests/common_types/#-nonce-zeropaddedhexnumber","title":"- <code>nonce</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>Nonce of the account.</p>"},{"location":"consuming_tests/common_types/#-code-bytes","title":"- <code>code</code>: <code>Bytes</code>","text":"<p>Code of the account.</p>"},{"location":"consuming_tests/common_types/#-storage-storage","title":"- <code>storage</code>: <code>Storage</code>","text":"<p>Storage of the account.</p>"},{"location":"consuming_tests/common_types/#alloc-mappingaddressaccount","title":"<code>Alloc</code>: <code>Mapping</code><code>[</code><code>Address</code><code>,</code><code>Account</code><code>]</code>","text":"<p>State allocation represented as a JSON object, where the keys are the addresses of the accounts, and the values are the accounts.</p>"},{"location":"consuming_tests/common_types/#blobschedule-mappingforkforkblobschedule","title":"<code>BlobSchedule</code>: <code>Mapping</code><code>[</code><code>Fork</code><code>,</code><code>ForkBlobSchedule</code><code>]</code>","text":"<p>Maps forks to blob schedule configurations as defined by EIP-7840.</p>"},{"location":"consuming_tests/common_types/#forkblobschedule","title":"<code>ForkBlobSchedule</code>","text":"<p>A fork blob schedule as defined by EIP-7840 as a JSON dictionary with the following entries:</p>"},{"location":"consuming_tests/common_types/#-target-zeropaddedhexnumber","title":"- <code>target</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>The target blob count for a block.</p>"},{"location":"consuming_tests/common_types/#-max-zeropaddedhexnumber","title":"- <code>max</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>The maximum possible blob count for a block.</p>"},{"location":"consuming_tests/common_types/#-base_fee_update_fraction-zeropaddedhexnumber","title":"- <code>base_fee_update_fraction</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>The blob base fee update fraction (adjusts the responsiveness of blob gas pricing per fork).</p>"},{"location":"consuming_tests/common_types/#fork","title":"Fork","text":"<p>Fork type is represented as a JSON string that can be set to one of the following values:</p>"},{"location":"consuming_tests/common_types/#frontier","title":"<code>\"Frontier\"</code>","text":"<ul> <li>Chain ID: <code>0x00</code></li> </ul>"},{"location":"consuming_tests/common_types/#homestead","title":"<code>\"Homestead\"</code>","text":"<ul> <li>Chain ID: <code>0x01</code></li> <li>Homestead Block: <code>0x00</code></li> </ul>"},{"location":"consuming_tests/common_types/#byzantium","title":"<code>\"Byzantium\"</code>","text":"<ul> <li>Chain ID: <code>0x01</code></li> <li>Homestead Block: <code>0x00</code></li> <li>EIP150 Block: <code>0x00</code></li> <li>EIP155 Block: <code>0x00</code></li> <li>EIP158 Block: <code>0x00</code></li> <li>DAO Fork Block: <code>0x00</code></li> <li>Byzantium Block: <code>0x00</code></li> </ul>"},{"location":"consuming_tests/common_types/#constantinople","title":"<code>\"Constantinople\"</code>","text":"<ul> <li>Chain ID: <code>0x01</code></li> <li>Homestead Block: <code>0x00</code></li> <li>EIP150 Block: <code>0x00</code></li> <li>EIP155 Block: <code>0x00</code></li> <li>EIP158 Block: <code>0x00</code></li> <li>DAO Fork Block: <code>0x00</code></li> <li>Byzantium Block: <code>0x00</code></li> <li>Constantinople Block: <code>0x00</code></li> </ul>"},{"location":"consuming_tests/common_types/#constantinoplefix","title":"<code>\"ConstantinopleFix\"</code>","text":"<ul> <li>Chain ID: <code>0x01</code></li> <li>Homestead Block: <code>0x00</code></li> <li>EIP150 Block: <code>0x00</code></li> <li>EIP155 Block: <code>0x00</code></li> <li>EIP158 Block: <code>0x00</code></li> <li>DAO Fork Block: <code>0x00</code></li> <li>Byzantium Block: <code>0x00</code></li> <li>Constantinople Block: <code>0x00</code></li> <li>Constantinople Fix Block: <code>0x00</code></li> </ul>"},{"location":"consuming_tests/common_types/#istanbul","title":"<code>\"Istanbul\"</code>","text":"<ul> <li>Chain ID: <code>0x01</code></li> <li>Homestead Block: <code>0x00</code></li> <li>EIP150 Block: <code>0x00</code></li> <li>EIP155 Block: <code>0x00</code></li> <li>EIP158 Block: <code>0x00</code></li> <li>DAO Fork Block: <code>0x00</code></li> <li>Byzantium Block: <code>0x00</code></li> <li>Constantinople Block: <code>0x00</code></li> <li>Constantinople Fix Block: <code>0x00</code></li> <li>Istanbul Block: <code>0x00</code></li> </ul>"},{"location":"consuming_tests/common_types/#muirglacier","title":"<code>\"MuirGlacier\"</code>","text":"<ul> <li>Chain ID: <code>0x01</code></li> <li>Homestead Block: <code>0x00</code></li> <li>EIP150 Block: <code>0x00</code></li> <li>EIP155 Block: <code>0x00</code></li> <li>EIP158 Block: <code>0x00</code></li> <li>DAO Fork Block: <code>0x00</code></li> <li>Byzantium Block: <code>0x00</code></li> <li>Constantinople Block: <code>0x00</code></li> <li>Constantinople Fix Block: <code>0x00</code></li> <li>Istanbul Block: <code>0x00</code></li> <li>Muir Glacier Block: <code>0x00</code></li> </ul>"},{"location":"consuming_tests/common_types/#berlin","title":"<code>\"Berlin\"</code>","text":"<ul> <li>Chain ID: <code>0x01</code></li> <li>Homestead Block: <code>0x00</code></li> <li>EIP150 Block: <code>0x00</code></li> <li>EIP155 Block: <code>0x00</code></li> <li>EIP158 Block: <code>0x00</code></li> <li>DAO Fork Block: <code>0x00</code></li> <li>Byzantium Block: <code>0x00</code></li> <li>Constantinople Block: <code>0x00</code></li> <li>Constantinople Fix Block: <code>0x00</code></li> <li>Istanbul Block: <code>0x00</code></li> <li>Muir Glacier Block: <code>0x00</code></li> <li>Berlin Block: <code>0x00</code></li> </ul>"},{"location":"consuming_tests/common_types/#berlintolondonat5","title":"<code>\"BerlinToLondonAt5\"</code>","text":"<ul> <li>Chain ID: <code>0x01</code></li> <li>Homestead Block: <code>0x00</code></li> <li>EIP150 Block: <code>0x00</code></li> <li>EIP155 Block: <code>0x00</code></li> <li>EIP158 Block: <code>0x00</code></li> <li>DAO Fork Block: <code>0x00</code></li> <li>Byzantium Block: <code>0x00</code></li> <li>Constantinople Block: <code>0x00</code></li> <li>Constantinople Fix Block: <code>0x00</code></li> <li>Istanbul Block: <code>0x00</code></li> <li>Muir Glacier Block: <code>0x00</code></li> <li>Berlin Block: <code>0x00</code></li> <li>London Block: <code>0x05</code></li> </ul>"},{"location":"consuming_tests/common_types/#london","title":"<code>\"London\"</code>","text":"<ul> <li>Chain ID: <code>0x01</code></li> <li>Homestead Block: <code>0x00</code></li> <li>EIP150 Block: <code>0x00</code></li> <li>EIP155 Block: <code>0x00</code></li> <li>EIP158 Block: <code>0x00</code></li> <li>DAO Fork Block: <code>0x00</code></li> <li>Byzantium Block: <code>0x00</code></li> <li>Constantinople Block: <code>0x00</code></li> <li>Constantinople Fix Block: <code>0x00</code></li> <li>Istanbul Block: <code>0x00</code></li> <li>Muir Glacier Block: <code>0x00</code></li> <li>Berlin Block: <code>0x00</code></li> <li>London Block: <code>0x00</code></li> </ul>"},{"location":"consuming_tests/common_types/#arrowglacier","title":"<code>\"ArrowGlacier\"</code>","text":"<ul> <li>Chain ID: <code>0x01</code></li> <li>Homestead Block: <code>0x00</code></li> <li>EIP150 Block: <code>0x00</code></li> <li>EIP155 Block: <code>0x00</code></li> <li>EIP158 Block: <code>0x00</code></li> <li>DAO Fork Block: <code>0x00</code></li> <li>Byzantium Block: <code>0x00</code></li> <li>Constantinople Block: <code>0x00</code></li> <li>Constantinople Fix Block: <code>0x00</code></li> <li>Istanbul Block: <code>0x00</code></li> <li>Muir Glacier Block: <code>0x00</code></li> <li>Berlin Block: <code>0x00</code></li> <li>London Block: <code>0x00</code></li> <li>Arrow Glacier Block: <code>0x00</code></li> </ul>"},{"location":"consuming_tests/common_types/#grayglacier","title":"<code>\"GrayGlacier\"</code>","text":"<ul> <li>Chain ID: <code>0x01</code></li> <li>Homestead Block: <code>0x00</code></li> <li>EIP150 Block: <code>0x00</code></li> <li>EIP155 Block: <code>0x00</code></li> <li>EIP158 Block: <code>0x00</code></li> <li>DAO Fork Block: <code>0x00</code></li> <li>Byzantium Block: <code>0x00</code></li> <li>Constantinople Block: <code>0x00</code></li> <li>Constantinople Fix Block: <code>0x00</code></li> <li>Istanbul Block: <code>0x00</code></li> <li>Muir Glacier Block: <code>0x00</code></li> <li>Berlin Block: <code>0x00</code></li> <li>London Block: <code>0x00</code></li> <li>Arrow Glacier Block: <code>0x00</code></li> <li>Gray Glacier Block: <code>0x00</code></li> </ul>"},{"location":"consuming_tests/common_types/#merge","title":"<code>\"Merge\"</code>","text":"<ul> <li>Chain ID: <code>0x01</code></li> <li>Homestead Block: <code>0x00</code></li> <li>EIP150 Block: <code>0x00</code></li> <li>EIP155 Block: <code>0x00</code></li> <li>EIP158 Block: <code>0x00</code></li> <li>DAO Fork Block: <code>0x00</code></li> <li>Byzantium Block: <code>0x00</code></li> <li>Constantinople Block: <code>0x00</code></li> <li>Constantinople Fix Block: <code>0x00</code></li> <li>Istanbul Block: <code>0x00</code></li> <li>Muir Glacier Block: <code>0x00</code></li> <li>Berlin Block: <code>0x00</code></li> <li>London Block: <code>0x00</code></li> <li>Arrow Glacier Block: <code>0x00</code></li> <li>Gray Glacier Block: <code>0x00</code></li> <li>Terminal Total Difficulty: <code>0x00</code></li> </ul>"},{"location":"consuming_tests/common_types/#mergetoshanghaiattime15k","title":"<code>\"MergeToShanghaiAtTime15k\"</code>","text":"<ul> <li>Chain ID: <code>0x01</code></li> <li>Homestead Block: <code>0x00</code></li> <li>EIP150 Block: <code>0x00</code></li> <li>EIP155 Block: <code>0x00</code></li> <li>EIP158 Block: <code>0x00</code></li> <li>DAO Fork Block: <code>0x00</code></li> <li>Byzantium Block: <code>0x00</code></li> <li>Constantinople Block: <code>0x00</code></li> <li>Constantinople Fix Block: <code>0x00</code></li> <li>Istanbul Block: <code>0x00</code></li> <li>Muir Glacier Block: <code>0x00</code></li> <li>Berlin Block: <code>0x00</code></li> <li>London Block: <code>0x00</code></li> <li>Arrow Glacier Block: <code>0x00</code></li> <li>Gray Glacier Block: <code>0x00</code></li> <li>Terminal Total Difficulty: <code>0x00</code></li> <li>Shanghai Time: <code>0x3a98</code></li> </ul>"},{"location":"consuming_tests/common_types/#shanghai","title":"<code>\"Shanghai\"</code>","text":"<ul> <li>Chain ID: <code>0x01</code></li> <li>Homestead Block: <code>0x00</code></li> <li>EIP150 Block: <code>0x00</code></li> <li>EIP155 Block: <code>0x00</code></li> <li>EIP158 Block: <code>0x00</code></li> <li>DAO Fork Block: <code>0x00</code></li> <li>Byzantium Block: <code>0x00</code></li> <li>Constantinople Block: <code>0x00</code></li> <li>Constantinople Fix Block: <code>0x00</code></li> <li>Istanbul Block: <code>0x00</code></li> <li>Muir Glacier Block: <code>0x00</code></li> <li>Berlin Block: <code>0x00</code></li> <li>London Block: <code>0x00</code></li> <li>Arrow Glacier Block: <code>0x00</code></li> <li>Gray Glacier Block: <code>0x00</code></li> <li>Terminal Total Difficulty: <code>0x00</code></li> <li>Shanghai Time: <code>0x00</code></li> </ul>"},{"location":"consuming_tests/common_types/#shanghaitocancunattime15k","title":"<code>\"ShanghaiToCancunAtTime15k\"</code>","text":"<ul> <li>Chain ID: <code>0x01</code></li> <li>Homestead Block: <code>0x00</code></li> <li>EIP150 Block: <code>0x00</code></li> <li>EIP155 Block: <code>0x00</code></li> <li>EIP158 Block: <code>0x00</code></li> <li>DAO Fork Block: <code>0x00</code></li> <li>Byzantium Block: <code>0x00</code></li> <li>Constantinople Block: <code>0x00</code></li> <li>Constantinople Fix Block: <code>0x00</code></li> <li>Istanbul Block: <code>0x00</code></li> <li>Muir Glacier Block: <code>0x00</code></li> <li>Berlin Block: <code>0x00</code></li> <li>London Block: <code>0x00</code></li> <li>Arrow Glacier Block: <code>0x00</code></li> <li>Gray Glacier Block: <code>0x00</code></li> <li>Terminal Total Difficulty: <code>0x00</code></li> <li>Shanghai Time: <code>0x0</code></li> <li>Cancun Time: <code>0x3a98</code></li> </ul>"},{"location":"consuming_tests/common_types/#cancun","title":"<code>\"Cancun\"</code>","text":"<ul> <li>Chain ID: <code>0x01</code></li> <li>Homestead Block: <code>0x00</code></li> <li>EIP150 Block: <code>0x00</code></li> <li>EIP155 Block: <code>0x00</code></li> <li>EIP158 Block: <code>0x00</code></li> <li>DAO Fork Block: <code>0x00</code></li> <li>Byzantium Block: <code>0x00</code></li> <li>Constantinople Block: <code>0x00</code></li> <li>Constantinople Fix Block: <code>0x00</code></li> <li>Istanbul Block: <code>0x00</code></li> <li>Muir Glacier Block: <code>0x00</code></li> <li>Berlin Block: <code>0x00</code></li> <li>London Block: <code>0x00</code></li> <li>Arrow Glacier Block: <code>0x00</code></li> <li>Gray Glacier Block: <code>0x00</code></li> <li>Terminal Total Difficulty: <code>0x00</code></li> <li>Shanghai Time: <code>0x00</code></li> <li>Cancun Time: <code>0x00</code></li> </ul>"},{"location":"consuming_tests/eof_test/","title":"EOF Tests","text":"<p>The EOF Test fixture format tests are included in the fixtures subdirectory <code>eof_tests</code>.</p> <p>These are produced by the <code>EOFTest</code> test spec.</p>"},{"location":"consuming_tests/eof_test/#description","title":"Description","text":"<p>The EOF test fixture format is used to test the EOF container validation function of the Ethereum Virtual Machine (EVM).</p> <p>It simply defines a binary code in hexadecimal format and a boolean value that indicates whether the code is valid or not.</p>"},{"location":"consuming_tests/eof_test/#consumption","title":"Consumption","text":"<p>TODO: Update this section</p>"},{"location":"consuming_tests/eof_test/#structures","title":"Structures","text":"<p>TODO: Update this section</p>"},{"location":"consuming_tests/exceptions/","title":"Exceptions","text":"<p>Exception types are represented as a JSON string in the test fixtures.</p> <p>The exception converted into a string is composed of the exception type name, followed by a period, followed by the specific exception name.</p> <p>For example, the exception <code>INSUFFICIENT_ACCOUNT_FUNDS</code> of type <code>TransactionException</code> is represented as <code>\"TransactionException.INSUFFICIENT_ACCOUNT_FUNDS\"</code>.</p> <p>The JSON string can contain multiple exception types, separated by the <code>|</code> character, denoting that the transaction or block can throw either one of the exceptions.</p>"},{"location":"consuming_tests/exceptions/#transactionexception","title":"<code>TransactionException</code>","text":"<p>               Bases: <code>ExceptionBase</code></p> <p>Exception raised when a transaction is invalid, and thus cannot be executed.</p> <p>If a transaction with any of these exceptions is included in a block, the block is invalid.</p> Source code in <code>src/ethereum_test_exceptions/exceptions.py</code> <pre><code>@unique\nclass TransactionException(ExceptionBase):\n    \"\"\"\n    Exception raised when a transaction is invalid, and thus cannot be executed.\n\n    If a transaction with any of these exceptions is included in a block, the block is invalid.\n    \"\"\"\n\n    TYPE_NOT_SUPPORTED = auto()\n    \"\"\"\n    Transaction type is not supported on this chain configuration.\n    \"\"\"\n    SENDER_NOT_EOA = auto()\n    \"\"\"\n    Transaction is coming from address that is not exist anymore.\n    \"\"\"\n    ADDRESS_TOO_SHORT = auto()\n    \"\"\"\n    Transaction `to` is not allowed to be less than 20 bytes.\n    \"\"\"\n    ADDRESS_TOO_LONG = auto()\n    \"\"\"\n    Transaction `to` is not allowed to be more than 20 bytes.\n    \"\"\"\n    NONCE_MISMATCH_TOO_HIGH = auto()\n    \"\"\"\n    Transaction nonce &gt; sender.nonce.\n    \"\"\"\n    NONCE_MISMATCH_TOO_LOW = auto()\n    \"\"\"\n    Transaction nonce &lt; sender.nonce.\n    \"\"\"\n    NONCE_TOO_BIG = auto()\n    \"\"\"\n    Transaction `nonce` is not allowed to be max_uint64 - 1 (this is probably TransactionTest).\n    \"\"\"\n    NONCE_IS_MAX = auto()\n    \"\"\"\n    Transaction `nonce` is not allowed to be max_uint64 - 1 (this is StateTests).\n    \"\"\"\n    NONCE_OVERFLOW = auto()\n    \"\"\"\n    Transaction `nonce` is not allowed to be more than uint64.\n    \"\"\"\n    GASLIMIT_OVERFLOW = auto()\n    \"\"\"\n    Transaction gaslimit exceeds 2^64-1 maximum value.\n    \"\"\"\n    VALUE_OVERFLOW = auto()\n    \"\"\"\n    Transaction value exceeds 2^256-1 maximum value.\n    \"\"\"\n    GASPRICE_OVERFLOW = auto()\n    \"\"\"\n    Transaction gasPrice exceeds 2^256-1 maximum value.\n    \"\"\"\n    GASLIMIT_PRICE_PRODUCT_OVERFLOW = auto()\n    \"\"\"\n    Transaction gasPrice * gasLimit exceeds 2^256-1 maximum value.\n    \"\"\"\n    INVALID_SIGNATURE_VRS = auto()\n    \"\"\"\n    Invalid transaction v, r, s values.\n    \"\"\"\n    RLP_INVALID_SIGNATURE_R = auto()\n    \"\"\"\n    Error reading transaction signature R value.\n    \"\"\"\n    RLP_INVALID_SIGNATURE_S = auto()\n    \"\"\"\n    Error reading transaction signature S value.\n    \"\"\"\n    RLP_LEADING_ZEROS_GASLIMIT = auto()\n    \"\"\"\n    Error reading transaction gaslimit field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_GASPRICE = auto()\n    \"\"\"\n    Error reading transaction gasprice field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_VALUE = auto()\n    \"\"\"\n    Error reading transaction value field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_NONCE = auto()\n    \"\"\"\n    Error reading transaction nonce field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_R = auto()\n    \"\"\"\n    Error reading transaction signature R field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_S = auto()\n    \"\"\"\n    Error reading transaction signature S field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_V = auto()\n    \"\"\"\n    Error reading transaction signature V field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_BASEFEE = auto()\n    \"\"\"\n    Error reading transaction basefee field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_PRIORITY_FEE = auto()\n    \"\"\"\n    Error reading transaction priority fee field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_DATA_SIZE = auto()\n    \"\"\"\n    Error reading transaction data field RLP, (rlp field length has leading zeros).\n    \"\"\"\n    RLP_LEADING_ZEROS_NONCE_SIZE = auto()\n    \"\"\"\n    Error reading transaction nonce field RLP, (rlp field length has leading zeros).\n    \"\"\"\n    RLP_TOO_FEW_ELEMENTS = auto()\n    \"\"\"\n    Error reading transaction RLP, structure has too few elements than expected.\n    \"\"\"\n    RLP_TOO_MANY_ELEMENTS = auto()\n    \"\"\"\n    Error reading transaction RLP, structure has too many elements than expected.\n    \"\"\"\n    RLP_ERROR_EOF = auto()\n    \"\"\"\n    Error reading transaction RLP, rlp stream unexpectedly finished.\n    \"\"\"\n    RLP_ERROR_SIZE = auto()\n    \"\"\"\n    Error reading transaction RLP, rlp size is invalid.\n    \"\"\"\n    RLP_ERROR_SIZE_LEADING_ZEROS = auto()\n    \"\"\"\n    Error reading transaction RLP, field size has leading zeros.\n    \"\"\"\n    INVALID_CHAINID = auto()\n    \"\"\"\n    Transaction chain id encoding is incorrect.\n    \"\"\"\n    RLP_INVALID_DATA = auto()\n    \"\"\"\n    Transaction data field is invalid rlp.\n    \"\"\"\n    RLP_INVALID_GASLIMIT = auto()\n    \"\"\"\n    Transaction gaslimit field is invalid rlp.\n    \"\"\"\n    RLP_INVALID_NONCE = auto()\n    \"\"\"\n    Transaction nonce field is invalid rlp.\n    \"\"\"\n    RLP_INVALID_TO = auto()\n    \"\"\"\n    Transaction to field is invalid rlp.\n    \"\"\"\n    RLP_INVALID_ACCESS_LIST_ADDRESS_TOO_LONG = auto()\n    \"\"\"\n    Transaction access list address is &gt; 20 bytes.\n    \"\"\"\n    RLP_INVALID_ACCESS_LIST_ADDRESS_TOO_SHORT = auto()\n    \"\"\"\n    Transaction access list address is &lt; 20 bytes.\n    \"\"\"\n    RLP_INVALID_ACCESS_LIST_STORAGE_TOO_LONG = auto()\n    \"\"\"\n    Transaction access list storage hash &gt; 32 bytes.\n    \"\"\"\n    RLP_INVALID_ACCESS_LIST_STORAGE_TOO_SHORT = auto()\n    \"\"\"\n    Transaction access list storage hash &lt; 32 bytes.\n    \"\"\"\n    RLP_INVALID_HEADER = auto()\n    \"\"\"\n    Transaction failed to read from RLP as rlp header is invalid.\n    \"\"\"\n    RLP_INVALID_VALUE = auto()\n    \"\"\"\n    Transaction value field is invalid rlp/structure.\n    \"\"\"\n    EC_RECOVERY_FAIL = auto()\n    \"\"\"\n    Transaction has correct signature, but ec recovery failed.\n    \"\"\"\n    INSUFFICIENT_ACCOUNT_FUNDS = auto()\n    \"\"\"\n    Transaction's sender does not have enough funds to pay for the transaction.\n    \"\"\"\n    INSUFFICIENT_MAX_FEE_PER_GAS = auto()\n    \"\"\"\n    Transaction's max-fee-per-gas is lower than the block base-fee.\n    \"\"\"\n    PRIORITY_OVERFLOW = auto()\n    \"\"\"\n    Transaction's max-priority-fee-per-gas is exceeds 2^256-1 maximum value.\n    \"\"\"\n    PRIORITY_GREATER_THAN_MAX_FEE_PER_GAS = auto()\n    \"\"\"\n    Transaction's max-priority-fee-per-gas is greater than the max-fee-per-gas.\n    \"\"\"\n    PRIORITY_GREATER_THAN_MAX_FEE_PER_GAS_2 = auto()\n    \"\"\"\n    Transaction's max-priority-fee-per-gas is greater than the max-fee-per-gas (TransactionTests).\n    \"\"\"\n    INSUFFICIENT_MAX_FEE_PER_BLOB_GAS = auto()\n    \"\"\"\n    Transaction's max-fee-per-blob-gas is lower than the block's blob-gas price.\n    \"\"\"\n    INTRINSIC_GAS_TOO_LOW = auto()\n    \"\"\"\n    Transaction's gas limit is too low.\n    \"\"\"\n    INITCODE_SIZE_EXCEEDED = auto()\n    \"\"\"\n    Transaction's initcode for a contract-creating transaction is too large.\n    \"\"\"\n    TYPE_3_TX_PRE_FORK = auto()\n    \"\"\"\n    Transaction type 3 included before activation fork.\n    \"\"\"\n    TYPE_3_TX_ZERO_BLOBS_PRE_FORK = auto()\n    \"\"\"\n    Transaction type 3, with zero blobs, included before activation fork.\n    \"\"\"\n    TYPE_3_TX_INVALID_BLOB_VERSIONED_HASH = auto()\n    \"\"\"\n    Transaction contains a blob versioned hash with an invalid version.\n    \"\"\"\n    TYPE_3_TX_WITH_FULL_BLOBS = auto()\n    \"\"\"\n    Transaction contains full blobs (network-version of the transaction).\n    \"\"\"\n    TYPE_3_TX_BLOB_COUNT_EXCEEDED = auto()\n    \"\"\"\n    Transaction contains too many blob versioned hashes.\n    \"\"\"\n    TYPE_3_TX_CONTRACT_CREATION = auto()\n    \"\"\"\n    Transaction is a type 3 transaction and has an empty `to`.\n    \"\"\"\n    TYPE_3_TX_MAX_BLOB_GAS_ALLOWANCE_EXCEEDED = auto()\n    \"\"\"\n    Transaction causes block to go over blob gas limit.\n    \"\"\"\n    GAS_ALLOWANCE_EXCEEDED = auto()\n    \"\"\"\n    Transaction causes block to go over blob gas limit.\n    \"\"\"\n    TYPE_3_TX_ZERO_BLOBS = auto()\n    \"\"\"\n    Transaction is type 3, but has no blobs.\n    \"\"\"\n    TYPE_4_EMPTY_AUTHORIZATION_LIST = auto()\n    \"\"\"\n    Transaction is type 4, but has an empty authorization list.\n    \"\"\"\n    TYPE_4_INVALID_AUTHORITY_SIGNATURE = auto()\n    \"\"\"\n    Transaction authority signature is invalid\n    \"\"\"\n    TYPE_4_INVALID_AUTHORITY_SIGNATURE_S_TOO_HIGH = auto()\n    \"\"\"\n    Transaction authority signature is invalid\n    \"\"\"\n    TYPE_4_TX_CONTRACT_CREATION = auto()\n    \"\"\"\n    Transaction is a type 4 transaction and has an empty `to`.\n    \"\"\"\n    TYPE_4_INVALID_AUTHORIZATION_FORMAT = auto()\n    \"\"\"\n    Transaction is type 4, but contains an authorization that has an invalid format.\n    \"\"\"\n</code></pre>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.TYPE_NOT_SUPPORTED","title":"<code>TYPE_NOT_SUPPORTED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction type is not supported on this chain configuration.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.SENDER_NOT_EOA","title":"<code>SENDER_NOT_EOA = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction is coming from address that is not exist anymore.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.ADDRESS_TOO_SHORT","title":"<code>ADDRESS_TOO_SHORT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction <code>to</code> is not allowed to be less than 20 bytes.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.ADDRESS_TOO_LONG","title":"<code>ADDRESS_TOO_LONG = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction <code>to</code> is not allowed to be more than 20 bytes.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.NONCE_MISMATCH_TOO_HIGH","title":"<code>NONCE_MISMATCH_TOO_HIGH = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction nonce &gt; sender.nonce.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.NONCE_MISMATCH_TOO_LOW","title":"<code>NONCE_MISMATCH_TOO_LOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction nonce &lt; sender.nonce.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.NONCE_TOO_BIG","title":"<code>NONCE_TOO_BIG = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction <code>nonce</code> is not allowed to be max_uint64 - 1 (this is probably TransactionTest).</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.NONCE_IS_MAX","title":"<code>NONCE_IS_MAX = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction <code>nonce</code> is not allowed to be max_uint64 - 1 (this is StateTests).</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.NONCE_OVERFLOW","title":"<code>NONCE_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction <code>nonce</code> is not allowed to be more than uint64.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.GASLIMIT_OVERFLOW","title":"<code>GASLIMIT_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction gaslimit exceeds 2^64-1 maximum value.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.VALUE_OVERFLOW","title":"<code>VALUE_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction value exceeds 2^256-1 maximum value.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.GASPRICE_OVERFLOW","title":"<code>GASPRICE_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction gasPrice exceeds 2^256-1 maximum value.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.GASLIMIT_PRICE_PRODUCT_OVERFLOW","title":"<code>GASLIMIT_PRICE_PRODUCT_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction gasPrice * gasLimit exceeds 2^256-1 maximum value.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.INVALID_SIGNATURE_VRS","title":"<code>INVALID_SIGNATURE_VRS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Invalid transaction v, r, s values.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_SIGNATURE_R","title":"<code>RLP_INVALID_SIGNATURE_R = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction signature R value.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_SIGNATURE_S","title":"<code>RLP_INVALID_SIGNATURE_S = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction signature S value.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_LEADING_ZEROS_GASLIMIT","title":"<code>RLP_LEADING_ZEROS_GASLIMIT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction gaslimit field RLP.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_LEADING_ZEROS_GASPRICE","title":"<code>RLP_LEADING_ZEROS_GASPRICE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction gasprice field RLP.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_LEADING_ZEROS_VALUE","title":"<code>RLP_LEADING_ZEROS_VALUE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction value field RLP.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_LEADING_ZEROS_NONCE","title":"<code>RLP_LEADING_ZEROS_NONCE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction nonce field RLP.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_LEADING_ZEROS_R","title":"<code>RLP_LEADING_ZEROS_R = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction signature R field RLP.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_LEADING_ZEROS_S","title":"<code>RLP_LEADING_ZEROS_S = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction signature S field RLP.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_LEADING_ZEROS_V","title":"<code>RLP_LEADING_ZEROS_V = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction signature V field RLP.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_LEADING_ZEROS_BASEFEE","title":"<code>RLP_LEADING_ZEROS_BASEFEE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction basefee field RLP.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_LEADING_ZEROS_PRIORITY_FEE","title":"<code>RLP_LEADING_ZEROS_PRIORITY_FEE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction priority fee field RLP.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_LEADING_ZEROS_DATA_SIZE","title":"<code>RLP_LEADING_ZEROS_DATA_SIZE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction data field RLP, (rlp field length has leading zeros).</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_LEADING_ZEROS_NONCE_SIZE","title":"<code>RLP_LEADING_ZEROS_NONCE_SIZE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction nonce field RLP, (rlp field length has leading zeros).</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_TOO_FEW_ELEMENTS","title":"<code>RLP_TOO_FEW_ELEMENTS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction RLP, structure has too few elements than expected.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_TOO_MANY_ELEMENTS","title":"<code>RLP_TOO_MANY_ELEMENTS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction RLP, structure has too many elements than expected.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_ERROR_EOF","title":"<code>RLP_ERROR_EOF = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction RLP, rlp stream unexpectedly finished.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_ERROR_SIZE","title":"<code>RLP_ERROR_SIZE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction RLP, rlp size is invalid.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_ERROR_SIZE_LEADING_ZEROS","title":"<code>RLP_ERROR_SIZE_LEADING_ZEROS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction RLP, field size has leading zeros.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.INVALID_CHAINID","title":"<code>INVALID_CHAINID = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction chain id encoding is incorrect.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_DATA","title":"<code>RLP_INVALID_DATA = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction data field is invalid rlp.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_GASLIMIT","title":"<code>RLP_INVALID_GASLIMIT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction gaslimit field is invalid rlp.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_NONCE","title":"<code>RLP_INVALID_NONCE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction nonce field is invalid rlp.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_TO","title":"<code>RLP_INVALID_TO = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction to field is invalid rlp.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_ACCESS_LIST_ADDRESS_TOO_LONG","title":"<code>RLP_INVALID_ACCESS_LIST_ADDRESS_TOO_LONG = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction access list address is &gt; 20 bytes.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_ACCESS_LIST_ADDRESS_TOO_SHORT","title":"<code>RLP_INVALID_ACCESS_LIST_ADDRESS_TOO_SHORT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction access list address is &lt; 20 bytes.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_ACCESS_LIST_STORAGE_TOO_LONG","title":"<code>RLP_INVALID_ACCESS_LIST_STORAGE_TOO_LONG = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction access list storage hash &gt; 32 bytes.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_ACCESS_LIST_STORAGE_TOO_SHORT","title":"<code>RLP_INVALID_ACCESS_LIST_STORAGE_TOO_SHORT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction access list storage hash &lt; 32 bytes.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_HEADER","title":"<code>RLP_INVALID_HEADER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction failed to read from RLP as rlp header is invalid.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_VALUE","title":"<code>RLP_INVALID_VALUE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction value field is invalid rlp/structure.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.EC_RECOVERY_FAIL","title":"<code>EC_RECOVERY_FAIL = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction has correct signature, but ec recovery failed.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.INSUFFICIENT_ACCOUNT_FUNDS","title":"<code>INSUFFICIENT_ACCOUNT_FUNDS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's sender does not have enough funds to pay for the transaction.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.INSUFFICIENT_MAX_FEE_PER_GAS","title":"<code>INSUFFICIENT_MAX_FEE_PER_GAS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's max-fee-per-gas is lower than the block base-fee.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.PRIORITY_OVERFLOW","title":"<code>PRIORITY_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's max-priority-fee-per-gas is exceeds 2^256-1 maximum value.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.PRIORITY_GREATER_THAN_MAX_FEE_PER_GAS","title":"<code>PRIORITY_GREATER_THAN_MAX_FEE_PER_GAS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's max-priority-fee-per-gas is greater than the max-fee-per-gas.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.PRIORITY_GREATER_THAN_MAX_FEE_PER_GAS_2","title":"<code>PRIORITY_GREATER_THAN_MAX_FEE_PER_GAS_2 = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's max-priority-fee-per-gas is greater than the max-fee-per-gas (TransactionTests).</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.INSUFFICIENT_MAX_FEE_PER_BLOB_GAS","title":"<code>INSUFFICIENT_MAX_FEE_PER_BLOB_GAS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's max-fee-per-blob-gas is lower than the block's blob-gas price.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.INTRINSIC_GAS_TOO_LOW","title":"<code>INTRINSIC_GAS_TOO_LOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's gas limit is too low.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.INITCODE_SIZE_EXCEEDED","title":"<code>INITCODE_SIZE_EXCEEDED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's initcode for a contract-creating transaction is too large.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.TYPE_3_TX_PRE_FORK","title":"<code>TYPE_3_TX_PRE_FORK = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction type 3 included before activation fork.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.TYPE_3_TX_ZERO_BLOBS_PRE_FORK","title":"<code>TYPE_3_TX_ZERO_BLOBS_PRE_FORK = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction type 3, with zero blobs, included before activation fork.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.TYPE_3_TX_INVALID_BLOB_VERSIONED_HASH","title":"<code>TYPE_3_TX_INVALID_BLOB_VERSIONED_HASH = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction contains a blob versioned hash with an invalid version.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.TYPE_3_TX_WITH_FULL_BLOBS","title":"<code>TYPE_3_TX_WITH_FULL_BLOBS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction contains full blobs (network-version of the transaction).</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.TYPE_3_TX_BLOB_COUNT_EXCEEDED","title":"<code>TYPE_3_TX_BLOB_COUNT_EXCEEDED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction contains too many blob versioned hashes.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.TYPE_3_TX_CONTRACT_CREATION","title":"<code>TYPE_3_TX_CONTRACT_CREATION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction is a type 3 transaction and has an empty <code>to</code>.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.TYPE_3_TX_MAX_BLOB_GAS_ALLOWANCE_EXCEEDED","title":"<code>TYPE_3_TX_MAX_BLOB_GAS_ALLOWANCE_EXCEEDED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction causes block to go over blob gas limit.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.GAS_ALLOWANCE_EXCEEDED","title":"<code>GAS_ALLOWANCE_EXCEEDED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction causes block to go over blob gas limit.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.TYPE_3_TX_ZERO_BLOBS","title":"<code>TYPE_3_TX_ZERO_BLOBS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction is type 3, but has no blobs.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.TYPE_4_EMPTY_AUTHORIZATION_LIST","title":"<code>TYPE_4_EMPTY_AUTHORIZATION_LIST = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction is type 4, but has an empty authorization list.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.TYPE_4_INVALID_AUTHORITY_SIGNATURE","title":"<code>TYPE_4_INVALID_AUTHORITY_SIGNATURE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction authority signature is invalid</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.TYPE_4_INVALID_AUTHORITY_SIGNATURE_S_TOO_HIGH","title":"<code>TYPE_4_INVALID_AUTHORITY_SIGNATURE_S_TOO_HIGH = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction authority signature is invalid</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.TYPE_4_TX_CONTRACT_CREATION","title":"<code>TYPE_4_TX_CONTRACT_CREATION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction is a type 4 transaction and has an empty <code>to</code>.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.TransactionException.TYPE_4_INVALID_AUTHORIZATION_FORMAT","title":"<code>TYPE_4_INVALID_AUTHORIZATION_FORMAT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction is type 4, but contains an authorization that has an invalid format.</p>"},{"location":"consuming_tests/exceptions/#blockexception","title":"<code>BlockException</code>","text":"<p>               Bases: <code>ExceptionBase</code></p> <p>Exception raised when a block is invalid, but not due to a transaction.</p> <p>E.g. all transactions in the block are valid, and can be applied to the state, but the block header contains an invalid field.</p> Source code in <code>src/ethereum_test_exceptions/exceptions.py</code> <pre><code>@unique\nclass BlockException(ExceptionBase):\n    \"\"\"\n    Exception raised when a block is invalid, but not due to a transaction.\n\n    E.g. all transactions in the block are valid, and can be applied to the state, but the\n    block header contains an invalid field.\n    \"\"\"\n\n    TOO_MANY_UNCLES = auto()\n    \"\"\"\n    Block declares too many uncles over the allowed limit.\n    \"\"\"\n    UNCLE_IN_CHAIN = auto()\n    \"\"\"\n    Block declares uncle header that is already imported into chain.\n    \"\"\"\n    UNCLE_IS_ANCESTOR = auto()\n    \"\"\"\n    Block declares uncle header that is directly a parent of this block.\n    \"\"\"\n    UNCLE_IS_BROTHER = auto()\n    \"\"\"\n    Block declares two similar uncle headers.\n    \"\"\"\n    UNCLE_PARENT_INCORRECT = auto()\n    \"\"\"\n    Block declares uncle header that is an outdated block to be an uncle.\n    \"\"\"\n    EXTRA_DATA_TOO_BIG = auto()\n    \"\"\"\n    Block header's extra data &gt;32 bytes.\n    \"\"\"\n    EXTRA_DATA_INVALID_DAO = auto()\n    \"\"\"\n    Block header's extra data after dao fork must be a fixed pre defined hash.\n    \"\"\"\n    UNKNOWN_PARENT = auto()\n    \"\"\"\n    Block header's parent hash does not correspond to any of existing blocks on chain.\n    \"\"\"\n    UNCLE_UNKNOWN_PARENT = auto()\n    \"\"\"\n    Uncle header's parent hash does not correspond to any of existing blocks on chain.\n    \"\"\"\n    UNKNOWN_PARENT_ZERO = auto()\n    \"\"\"\n    Block header's parent hash is zero hash.\n    \"\"\"\n    GASLIMIT_TOO_BIG = auto()\n    \"\"\"\n    Block header's gas limit &gt; 0x7fffffffffffffff.\n    \"\"\"\n    INVALID_BLOCK_NUMBER = auto()\n    \"\"\"\n    Block header's number != parent header's number + 1.\n    \"\"\"\n    INVALID_BLOCK_TIMESTAMP_OLDER_THAN_PARENT = auto()\n    \"\"\"\n    Block header's timestamp &lt;= parent header's timestamp.\n    \"\"\"\n    INVALID_DIFFICULTY = auto()\n    \"\"\"\n    Block header's difficulty does not match the difficulty formula calculated from previous block.\n    \"\"\"\n    INVALID_LOG_BLOOM = auto()\n    \"\"\"\n    Block header's logs bloom hash does not match the actually computed log bloom.\n    \"\"\"\n    INVALID_STATE_ROOT = auto()\n    \"\"\"\n    Block header's state root hash does not match the actually computed hash of the state.\n    \"\"\"\n    INVALID_RECEIPTS_ROOT = auto()\n    \"\"\"\n    Block header's receipts root hash does not match the actually computed hash of receipts.\n    \"\"\"\n    INVALID_TRANSACTIONS_ROOT = auto()\n    \"\"\"\n    Block header's transactions root hash does not match the actually computed hash of tx tree.\n    \"\"\"\n    INVALID_UNCLES_HASH = auto()\n    \"\"\"\n    Block header's uncle hash does not match the actually computed hash of block's uncles.\n    \"\"\"\n    GAS_USED_OVERFLOW = auto()\n    \"\"\"\n    Block transactions consume more gas than block header allow.\n    \"\"\"\n    INVALID_GASLIMIT = auto()\n    \"\"\"\n    Block header's gas limit does not match the gas limit formula calculated from previous block.\n    \"\"\"\n    INVALID_BASEFEE_PER_GAS = auto()\n    \"\"\"\n    Block header's base_fee_per_gas field is calculated incorrect.\n    \"\"\"\n    INVALID_GAS_USED = auto()\n    \"\"\"\n    Block header's actual gas used does not match the provided header's value\n    \"\"\"\n    INVALID_WITHDRAWALS_ROOT = auto()\n    \"\"\"\n    Block header's withdrawals root does not match calculated withdrawals root.\n    \"\"\"\n    INCORRECT_BLOCK_FORMAT = auto()\n    \"\"\"\n    Block's format is incorrect, contains invalid fields, is missing fields, or contains fields of\n    a fork that is not active yet.\n    \"\"\"\n    BLOB_GAS_USED_ABOVE_LIMIT = auto()\n    \"\"\"\n    Block's blob gas used in header is above the limit.\n    \"\"\"\n    INCORRECT_BLOB_GAS_USED = auto()\n    \"\"\"\n    Block's blob gas used in header is incorrect.\n    \"\"\"\n    INCORRECT_EXCESS_BLOB_GAS = auto()\n    \"\"\"\n    Block's excess blob gas in header is incorrect.\n    \"\"\"\n    RLP_STRUCTURES_ENCODING = auto()\n    \"\"\"\n    Block's rlp encoding is valid but ethereum structures in it are invalid.\n    \"\"\"\n    RLP_WITHDRAWALS_NOT_READ = auto()\n    \"\"\"\n    Block's rlp encoding is missing withdrawals.\n    \"\"\"\n    RLP_INVALID_FIELD_OVERFLOW_64 = auto()\n    \"\"\"\n    One of block's fields rlp is overflow 2**64 value.\n    \"\"\"\n    RLP_INVALID_ADDRESS = auto()\n    \"\"\"\n    Block withdrawals address is rlp of invalid address != 20 bytes.\n    \"\"\"\n    INVALID_REQUESTS = auto()\n    \"\"\"\n    Block's requests are invalid.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_LEGACY = auto()\n    \"\"\"\n    Legacy block import is impossible in this chain configuration.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_LEGACY_WRONG_PARENT = auto()\n    \"\"\"\n    Legacy block import is impossible, trying to import on top of a block that is not legacy.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_LONDON_WRONG_PARENT = auto()\n    \"\"\"\n    Trying to import london (basefee) block on top of block that is not 1559.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_PARIS_WRONG_POW = auto()\n    \"\"\"\n    Trying to import paris(merge) block with PoW enabled.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_PARIS_WRONG_POS = auto()\n    \"\"\"\n    Trying to import paris(merge) block with PoS enabled before TTD is reached.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_LONDON_OVER_PARIS = auto()\n    \"\"\"\n    Trying to import london looking block over paris network (POS).\n    \"\"\"\n    IMPORT_IMPOSSIBLE_PARIS_OVER_SHANGHAI = auto()\n    \"\"\"\n    Trying to import paris block on top of shanghai block.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_SHANGHAI = auto()\n    \"\"\"\n    Shanghai block import is impossible in this chain configuration.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_UNCLES_OVER_PARIS = auto()\n    \"\"\"\n    Trying to import a block after paris fork that has not empty uncles hash.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_DIFFICULTY_OVER_PARIS = auto()\n    \"\"\"\n    Trying to import a block after paris fork that has difficulty != 0.\n    \"\"\"\n</code></pre>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.TOO_MANY_UNCLES","title":"<code>TOO_MANY_UNCLES = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block declares too many uncles over the allowed limit.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.UNCLE_IN_CHAIN","title":"<code>UNCLE_IN_CHAIN = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block declares uncle header that is already imported into chain.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.UNCLE_IS_ANCESTOR","title":"<code>UNCLE_IS_ANCESTOR = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block declares uncle header that is directly a parent of this block.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.UNCLE_IS_BROTHER","title":"<code>UNCLE_IS_BROTHER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block declares two similar uncle headers.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.UNCLE_PARENT_INCORRECT","title":"<code>UNCLE_PARENT_INCORRECT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block declares uncle header that is an outdated block to be an uncle.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.EXTRA_DATA_TOO_BIG","title":"<code>EXTRA_DATA_TOO_BIG = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's extra data &gt;32 bytes.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.EXTRA_DATA_INVALID_DAO","title":"<code>EXTRA_DATA_INVALID_DAO = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's extra data after dao fork must be a fixed pre defined hash.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.UNKNOWN_PARENT","title":"<code>UNKNOWN_PARENT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's parent hash does not correspond to any of existing blocks on chain.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.UNCLE_UNKNOWN_PARENT","title":"<code>UNCLE_UNKNOWN_PARENT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Uncle header's parent hash does not correspond to any of existing blocks on chain.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.UNKNOWN_PARENT_ZERO","title":"<code>UNKNOWN_PARENT_ZERO = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's parent hash is zero hash.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.GASLIMIT_TOO_BIG","title":"<code>GASLIMIT_TOO_BIG = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's gas limit &gt; 0x7fffffffffffffff.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.INVALID_BLOCK_NUMBER","title":"<code>INVALID_BLOCK_NUMBER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's number != parent header's number + 1.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.INVALID_BLOCK_TIMESTAMP_OLDER_THAN_PARENT","title":"<code>INVALID_BLOCK_TIMESTAMP_OLDER_THAN_PARENT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's timestamp &lt;= parent header's timestamp.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.INVALID_DIFFICULTY","title":"<code>INVALID_DIFFICULTY = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's difficulty does not match the difficulty formula calculated from previous block.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.INVALID_LOG_BLOOM","title":"<code>INVALID_LOG_BLOOM = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's logs bloom hash does not match the actually computed log bloom.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.INVALID_STATE_ROOT","title":"<code>INVALID_STATE_ROOT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's state root hash does not match the actually computed hash of the state.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.INVALID_RECEIPTS_ROOT","title":"<code>INVALID_RECEIPTS_ROOT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's receipts root hash does not match the actually computed hash of receipts.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.INVALID_TRANSACTIONS_ROOT","title":"<code>INVALID_TRANSACTIONS_ROOT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's transactions root hash does not match the actually computed hash of tx tree.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.INVALID_UNCLES_HASH","title":"<code>INVALID_UNCLES_HASH = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's uncle hash does not match the actually computed hash of block's uncles.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.GAS_USED_OVERFLOW","title":"<code>GAS_USED_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block transactions consume more gas than block header allow.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.INVALID_GASLIMIT","title":"<code>INVALID_GASLIMIT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's gas limit does not match the gas limit formula calculated from previous block.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.INVALID_BASEFEE_PER_GAS","title":"<code>INVALID_BASEFEE_PER_GAS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's base_fee_per_gas field is calculated incorrect.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.INVALID_GAS_USED","title":"<code>INVALID_GAS_USED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's actual gas used does not match the provided header's value</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.INVALID_WITHDRAWALS_ROOT","title":"<code>INVALID_WITHDRAWALS_ROOT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's withdrawals root does not match calculated withdrawals root.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.INCORRECT_BLOCK_FORMAT","title":"<code>INCORRECT_BLOCK_FORMAT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block's format is incorrect, contains invalid fields, is missing fields, or contains fields of a fork that is not active yet.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.BLOB_GAS_USED_ABOVE_LIMIT","title":"<code>BLOB_GAS_USED_ABOVE_LIMIT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block's blob gas used in header is above the limit.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.INCORRECT_BLOB_GAS_USED","title":"<code>INCORRECT_BLOB_GAS_USED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block's blob gas used in header is incorrect.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.INCORRECT_EXCESS_BLOB_GAS","title":"<code>INCORRECT_EXCESS_BLOB_GAS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block's excess blob gas in header is incorrect.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.RLP_STRUCTURES_ENCODING","title":"<code>RLP_STRUCTURES_ENCODING = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block's rlp encoding is valid but ethereum structures in it are invalid.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.RLP_WITHDRAWALS_NOT_READ","title":"<code>RLP_WITHDRAWALS_NOT_READ = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block's rlp encoding is missing withdrawals.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.RLP_INVALID_FIELD_OVERFLOW_64","title":"<code>RLP_INVALID_FIELD_OVERFLOW_64 = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>One of block's fields rlp is overflow 2**64 value.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.RLP_INVALID_ADDRESS","title":"<code>RLP_INVALID_ADDRESS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block withdrawals address is rlp of invalid address != 20 bytes.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.INVALID_REQUESTS","title":"<code>INVALID_REQUESTS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block's requests are invalid.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.IMPORT_IMPOSSIBLE_LEGACY","title":"<code>IMPORT_IMPOSSIBLE_LEGACY = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Legacy block import is impossible in this chain configuration.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.IMPORT_IMPOSSIBLE_LEGACY_WRONG_PARENT","title":"<code>IMPORT_IMPOSSIBLE_LEGACY_WRONG_PARENT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Legacy block import is impossible, trying to import on top of a block that is not legacy.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.IMPORT_IMPOSSIBLE_LONDON_WRONG_PARENT","title":"<code>IMPORT_IMPOSSIBLE_LONDON_WRONG_PARENT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Trying to import london (basefee) block on top of block that is not 1559.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.IMPORT_IMPOSSIBLE_PARIS_WRONG_POW","title":"<code>IMPORT_IMPOSSIBLE_PARIS_WRONG_POW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Trying to import paris(merge) block with PoW enabled.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.IMPORT_IMPOSSIBLE_PARIS_WRONG_POS","title":"<code>IMPORT_IMPOSSIBLE_PARIS_WRONG_POS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Trying to import paris(merge) block with PoS enabled before TTD is reached.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.IMPORT_IMPOSSIBLE_LONDON_OVER_PARIS","title":"<code>IMPORT_IMPOSSIBLE_LONDON_OVER_PARIS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Trying to import london looking block over paris network (POS).</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.IMPORT_IMPOSSIBLE_PARIS_OVER_SHANGHAI","title":"<code>IMPORT_IMPOSSIBLE_PARIS_OVER_SHANGHAI = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Trying to import paris block on top of shanghai block.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.IMPORT_IMPOSSIBLE_SHANGHAI","title":"<code>IMPORT_IMPOSSIBLE_SHANGHAI = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Shanghai block import is impossible in this chain configuration.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.IMPORT_IMPOSSIBLE_UNCLES_OVER_PARIS","title":"<code>IMPORT_IMPOSSIBLE_UNCLES_OVER_PARIS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Trying to import a block after paris fork that has not empty uncles hash.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.BlockException.IMPORT_IMPOSSIBLE_DIFFICULTY_OVER_PARIS","title":"<code>IMPORT_IMPOSSIBLE_DIFFICULTY_OVER_PARIS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Trying to import a block after paris fork that has difficulty != 0.</p>"},{"location":"consuming_tests/exceptions/#eofexception","title":"<code>EOFException</code>","text":"<p>               Bases: <code>ExceptionBase</code></p> <p>Exception raised when an EOF container is invalid.</p> Source code in <code>src/ethereum_test_exceptions/exceptions.py</code> <pre><code>@unique\nclass EOFException(ExceptionBase):\n    \"\"\"Exception raised when an EOF container is invalid.\"\"\"\n\n    DEFAULT_EXCEPTION = auto()\n    \"\"\"\n    Expect some exception, not yet known.\n    \"\"\"\n\n    UNDEFINED_EXCEPTION = auto()\n    \"\"\"\n    Indicates that exception string is not mapped to an exception enum.\n    \"\"\"\n\n    UNDEFINED_INSTRUCTION = auto()\n    \"\"\"\n    EOF container has undefined instruction in it's body code.\n    \"\"\"\n\n    UNKNOWN_VERSION = auto()\n    \"\"\"\n    EOF container has an unknown version.\n    \"\"\"\n    INCOMPLETE_MAGIC = auto()\n    \"\"\"\n    EOF container has not enough bytes to read magic.\n    \"\"\"\n    INVALID_MAGIC = auto()\n    \"\"\"\n    EOF container has not allowed magic version byte.\n    \"\"\"\n    INVALID_VERSION = auto()\n    \"\"\"\n    EOF container version bytes mismatch.\n    \"\"\"\n    INVALID_NON_RETURNING_FLAG = auto()\n    \"\"\"\n    EOF container's section has non-returning flag set incorrectly.\n    \"\"\"\n    INVALID_RJUMP_DESTINATION = auto()\n    \"\"\"\n    Code has RJUMP instruction with invalid parameters.\n    \"\"\"\n    MISSING_TYPE_HEADER = auto()\n    \"\"\"\n    EOF container missing types section.\n    \"\"\"\n    INVALID_TYPE_SECTION_SIZE = auto()\n    \"\"\"\n    EOF container types section has wrong size.\n    \"\"\"\n    INVALID_TYPE_BODY = auto()\n    \"\"\"\n    EOF container types body section bytes are wrong.\n    \"\"\"\n    MISSING_CODE_HEADER = auto()\n    \"\"\"\n    EOF container missing code section.\n    \"\"\"\n    INVALID_CODE_SECTION = auto()\n    \"\"\"\n    EOF container code section bytes are incorrect.\n    \"\"\"\n    INCOMPLETE_CODE_HEADER = auto()\n    \"\"\"\n    EOF container code header missing bytes.\n    \"\"\"\n    INCOMPLETE_DATA_HEADER = auto()\n    \"\"\"\n    EOF container data header missing bytes.\n    \"\"\"\n    ZERO_SECTION_SIZE = auto()\n    \"\"\"\n    EOF container data header construction is wrong.\n    \"\"\"\n    MISSING_DATA_SECTION = auto()\n    \"\"\"\n    EOF container missing data section\n    \"\"\"\n    INCOMPLETE_CONTAINER = auto()\n    \"\"\"\n    EOF container bytes are incomplete.\n    \"\"\"\n    INVALID_SECTION_BODIES_SIZE = auto()\n    \"\"\"\n    Sections bodies does not match sections headers.\n    \"\"\"\n    TRAILING_BYTES = auto()\n    \"\"\"\n    EOF container has bytes beyond data section.\n    \"\"\"\n    MISSING_TERMINATOR = auto()\n    \"\"\"\n    EOF container missing terminator bytes between header and body.\n    \"\"\"\n    MISSING_HEADERS_TERMINATOR = auto()\n    \"\"\"\n    Some type of another exception about missing headers terminator.\n    \"\"\"\n    INVALID_FIRST_SECTION_TYPE = auto()\n    \"\"\"\n    EOF container header does not have types section first.\n    \"\"\"\n    INCOMPLETE_SECTION_NUMBER = auto()\n    \"\"\"\n    EOF container header has section that is missing declaration bytes.\n    \"\"\"\n    INCOMPLETE_SECTION_SIZE = auto()\n    \"\"\"\n    EOF container header has section that is defined incorrectly.\n    \"\"\"\n    TOO_MANY_CODE_SECTIONS = auto()\n    \"\"\"\n    EOF container header has too many code sections.\n    \"\"\"\n    MISSING_STOP_OPCODE = auto()\n    \"\"\"\n    EOF container's code missing STOP bytecode at it's end.\n    \"\"\"\n    INPUTS_OUTPUTS_NUM_ABOVE_LIMIT = auto()\n    \"\"\"\n    EOF container code section inputs/outputs number is above the limit\n    \"\"\"\n    UNREACHABLE_INSTRUCTIONS = auto()\n    \"\"\"\n    EOF container's code have instructions that are unreachable.\n    \"\"\"\n    UNREACHABLE_CODE_SECTIONS = auto()\n    \"\"\"\n    EOF container's body have code sections that are unreachable.\n    \"\"\"\n    STACK_UNDERFLOW = auto()\n    \"\"\"\n    EOF container's code produces an stack underflow.\n    \"\"\"\n    STACK_OVERFLOW = auto()\n    \"\"\"\n    EOF container's code produces an stack overflow.\n    \"\"\"\n    STACK_HEIGHT_MISMATCH = auto()\n    \"\"\"\n    EOF container section stack height mismatch.\n    \"\"\"\n    MAX_STACK_HEIGHT_ABOVE_LIMIT = auto()\n    \"\"\"\n    EOF container's specified max stack height is above the limit.\n    \"\"\"\n    STACK_HIGHER_THAN_OUTPUTS = auto()\n    \"\"\"\n    EOF container section stack height is higher than the outputs.\n    when returning\n    \"\"\"\n    JUMPF_DESTINATION_INCOMPATIBLE_OUTPUTS = auto()\n    \"\"\"\n    EOF container section JUMPF's to a destination section with incompatible outputs.\n    \"\"\"\n    INVALID_MAX_STACK_HEIGHT = auto()\n    \"\"\"\n    EOF container section's specified max stack height does not match the actual stack height.\n    \"\"\"\n    INVALID_DATALOADN_INDEX = auto()\n    \"\"\"\n    A DATALOADN instruction has out-of-bounds index for the data section.\n    \"\"\"\n    TRUNCATED_INSTRUCTION = auto()\n    \"\"\"\n    EOF container's code section has truncated instruction.\n    \"\"\"\n    TOPLEVEL_CONTAINER_TRUNCATED = auto()\n    \"\"\"\n    Top-level EOF container has data section truncated\n    \"\"\"\n    ORPHAN_SUBCONTAINER = auto()\n    \"\"\"\n    EOF container has an unreferenced subcontainer.\n    '\"\"\"\n    CONTAINER_SIZE_ABOVE_LIMIT = auto()\n    \"\"\"\n    EOF container is above size limit\n    \"\"\"\n    INVALID_CONTAINER_SECTION_INDEX = auto()\n    \"\"\"\n    Instruction references container section that does not exist.\n    \"\"\"\n    INCOMPATIBLE_CONTAINER_KIND = auto()\n    \"\"\"\n    Incompatible instruction found in a container of a specific kind.\n    \"\"\"\n    AMBIGUOUS_CONTAINER_KIND = auto()\n    \"\"\"\n    The kind of a sub-container cannot be uniquely deduced.\n    \"\"\"\n    TOO_MANY_CONTAINERS = auto()\n    \"\"\"\n    EOF container header has too many sub-containers.\n    \"\"\"\n    INVALID_CODE_SECTION_INDEX = auto()\n    \"\"\"\n    CALLF Operation referes to a non-existent code section\n    \"\"\"\n    UNEXPECTED_HEADER_KIND = auto()\n    \"\"\"\n    Header parsing encounterd a section kind it wasn't expecting\n    \"\"\"\n    CALLF_TO_NON_RETURNING = auto()\n    \"\"\"\n    CALLF instruction targeting a non-returning code section\n    \"\"\"\n    EOFCREATE_WITH_TRUNCATED_CONTAINER = auto()\n    \"\"\"\n    EOFCREATE with truncated container\n    \"\"\"\n</code></pre>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.DEFAULT_EXCEPTION","title":"<code>DEFAULT_EXCEPTION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Expect some exception, not yet known.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.UNDEFINED_EXCEPTION","title":"<code>UNDEFINED_EXCEPTION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Indicates that exception string is not mapped to an exception enum.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.UNDEFINED_INSTRUCTION","title":"<code>UNDEFINED_INSTRUCTION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container has undefined instruction in it's body code.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.UNKNOWN_VERSION","title":"<code>UNKNOWN_VERSION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container has an unknown version.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.INCOMPLETE_MAGIC","title":"<code>INCOMPLETE_MAGIC = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container has not enough bytes to read magic.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.INVALID_MAGIC","title":"<code>INVALID_MAGIC = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container has not allowed magic version byte.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.INVALID_VERSION","title":"<code>INVALID_VERSION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container version bytes mismatch.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.INVALID_NON_RETURNING_FLAG","title":"<code>INVALID_NON_RETURNING_FLAG = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's section has non-returning flag set incorrectly.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.INVALID_RJUMP_DESTINATION","title":"<code>INVALID_RJUMP_DESTINATION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Code has RJUMP instruction with invalid parameters.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.MISSING_TYPE_HEADER","title":"<code>MISSING_TYPE_HEADER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container missing types section.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.INVALID_TYPE_SECTION_SIZE","title":"<code>INVALID_TYPE_SECTION_SIZE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container types section has wrong size.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.INVALID_TYPE_BODY","title":"<code>INVALID_TYPE_BODY = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container types body section bytes are wrong.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.MISSING_CODE_HEADER","title":"<code>MISSING_CODE_HEADER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container missing code section.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.INVALID_CODE_SECTION","title":"<code>INVALID_CODE_SECTION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container code section bytes are incorrect.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.INCOMPLETE_CODE_HEADER","title":"<code>INCOMPLETE_CODE_HEADER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container code header missing bytes.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.INCOMPLETE_DATA_HEADER","title":"<code>INCOMPLETE_DATA_HEADER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container data header missing bytes.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.ZERO_SECTION_SIZE","title":"<code>ZERO_SECTION_SIZE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container data header construction is wrong.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.MISSING_DATA_SECTION","title":"<code>MISSING_DATA_SECTION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container missing data section</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.INCOMPLETE_CONTAINER","title":"<code>INCOMPLETE_CONTAINER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container bytes are incomplete.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.INVALID_SECTION_BODIES_SIZE","title":"<code>INVALID_SECTION_BODIES_SIZE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Sections bodies does not match sections headers.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.TRAILING_BYTES","title":"<code>TRAILING_BYTES = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container has bytes beyond data section.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.MISSING_TERMINATOR","title":"<code>MISSING_TERMINATOR = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container missing terminator bytes between header and body.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.MISSING_HEADERS_TERMINATOR","title":"<code>MISSING_HEADERS_TERMINATOR = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Some type of another exception about missing headers terminator.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.INVALID_FIRST_SECTION_TYPE","title":"<code>INVALID_FIRST_SECTION_TYPE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container header does not have types section first.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.INCOMPLETE_SECTION_NUMBER","title":"<code>INCOMPLETE_SECTION_NUMBER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container header has section that is missing declaration bytes.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.INCOMPLETE_SECTION_SIZE","title":"<code>INCOMPLETE_SECTION_SIZE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container header has section that is defined incorrectly.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.TOO_MANY_CODE_SECTIONS","title":"<code>TOO_MANY_CODE_SECTIONS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container header has too many code sections.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.MISSING_STOP_OPCODE","title":"<code>MISSING_STOP_OPCODE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's code missing STOP bytecode at it's end.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.INPUTS_OUTPUTS_NUM_ABOVE_LIMIT","title":"<code>INPUTS_OUTPUTS_NUM_ABOVE_LIMIT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container code section inputs/outputs number is above the limit</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.UNREACHABLE_INSTRUCTIONS","title":"<code>UNREACHABLE_INSTRUCTIONS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's code have instructions that are unreachable.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.UNREACHABLE_CODE_SECTIONS","title":"<code>UNREACHABLE_CODE_SECTIONS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's body have code sections that are unreachable.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.STACK_UNDERFLOW","title":"<code>STACK_UNDERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's code produces an stack underflow.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.STACK_OVERFLOW","title":"<code>STACK_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's code produces an stack overflow.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.STACK_HEIGHT_MISMATCH","title":"<code>STACK_HEIGHT_MISMATCH = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container section stack height mismatch.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.MAX_STACK_HEIGHT_ABOVE_LIMIT","title":"<code>MAX_STACK_HEIGHT_ABOVE_LIMIT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's specified max stack height is above the limit.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.STACK_HIGHER_THAN_OUTPUTS","title":"<code>STACK_HIGHER_THAN_OUTPUTS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container section stack height is higher than the outputs. when returning</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.JUMPF_DESTINATION_INCOMPATIBLE_OUTPUTS","title":"<code>JUMPF_DESTINATION_INCOMPATIBLE_OUTPUTS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container section JUMPF's to a destination section with incompatible outputs.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.INVALID_MAX_STACK_HEIGHT","title":"<code>INVALID_MAX_STACK_HEIGHT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container section's specified max stack height does not match the actual stack height.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.INVALID_DATALOADN_INDEX","title":"<code>INVALID_DATALOADN_INDEX = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A DATALOADN instruction has out-of-bounds index for the data section.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.TRUNCATED_INSTRUCTION","title":"<code>TRUNCATED_INSTRUCTION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's code section has truncated instruction.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.TOPLEVEL_CONTAINER_TRUNCATED","title":"<code>TOPLEVEL_CONTAINER_TRUNCATED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Top-level EOF container has data section truncated</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.ORPHAN_SUBCONTAINER","title":"<code>ORPHAN_SUBCONTAINER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container has an unreferenced subcontainer. '</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.CONTAINER_SIZE_ABOVE_LIMIT","title":"<code>CONTAINER_SIZE_ABOVE_LIMIT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container is above size limit</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.INVALID_CONTAINER_SECTION_INDEX","title":"<code>INVALID_CONTAINER_SECTION_INDEX = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Instruction references container section that does not exist.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.INCOMPATIBLE_CONTAINER_KIND","title":"<code>INCOMPATIBLE_CONTAINER_KIND = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Incompatible instruction found in a container of a specific kind.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.AMBIGUOUS_CONTAINER_KIND","title":"<code>AMBIGUOUS_CONTAINER_KIND = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The kind of a sub-container cannot be uniquely deduced.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.TOO_MANY_CONTAINERS","title":"<code>TOO_MANY_CONTAINERS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container header has too many sub-containers.</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.INVALID_CODE_SECTION_INDEX","title":"<code>INVALID_CODE_SECTION_INDEX = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>CALLF Operation referes to a non-existent code section</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.UNEXPECTED_HEADER_KIND","title":"<code>UNEXPECTED_HEADER_KIND = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Header parsing encounterd a section kind it wasn't expecting</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.CALLF_TO_NON_RETURNING","title":"<code>CALLF_TO_NON_RETURNING = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>CALLF instruction targeting a non-returning code section</p>"},{"location":"consuming_tests/exceptions/#ethereum_test_exceptions.EOFException.EOFCREATE_WITH_TRUNCATED_CONTAINER","title":"<code>EOFCREATE_WITH_TRUNCATED_CONTAINER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOFCREATE with truncated container</p>"},{"location":"consuming_tests/state_test/","title":"State Tests","text":"<p>The State Test fixture format tests are included in the fixtures subdirectory <code>state_tests</code>.</p> <p>These are produced by the <code>StateTest</code> and <code>StateTestOnly</code> test specs.</p>"},{"location":"consuming_tests/state_test/#description","title":"Description","text":"<p>The state test fixture format is used to test the state transition function of the Ethereum Virtual Machine (EVM).</p> <p>It does so by defining a transaction, a pre-execution state, and a post-execution state, and verifying that the transaction execution results in the expected post-execution state.</p> <p>A single JSON fixture file is composed of a JSON object where each key-value pair is a different <code>Fixture</code> test object, with the key string representing the test name.</p> <p>The JSON file path plus the test name are used as the unique test identifier.</p> <p>As opposed to other fixture formats, the state test fixture format could contain multiple test vectors per test object, each represented by an element in the mapping of lists of the <code>post</code> field.</p> <p>However tests generated by the <code>execution-spec-tests</code> repository do not use this feature, as every single test object contains only a single test vector.</p>"},{"location":"consuming_tests/state_test/#consumption","title":"Consumption","text":"<p>For each <code>Fixture</code> test object in the JSON fixture file, perform the following steps:</p> <ol> <li>Use <code>pre</code> as the starting state allocation of the execution environment for the test.</li> <li>Use <code>env</code> to configure the current execution environment.</li> <li> <p>For each <code>Fork</code> key of <code>post</code> in the test, and for each of the elements of the list of <code>FixtureForkPost</code> values:</p> <ol> <li>Configure the execution fork schedule according to the current <code>Fork</code> key.</li> <li>Using the <code>indexes</code> values, and the <code>transaction</code> object, decode the transaction to be executed.</li> <li>If the serialized version of the decoded transaction does not match <code>txbytes</code>, fail the test.</li> <li> <p>Attempt to apply the transaction using the current execution environment:</p> <ol> <li>If the transaction could not be applied to the current execution context:<ul> <li>If <code>expectException</code> is empty, fail the test.</li> <li>If <code>expectException</code> is not empty, revert the state to the pre-state.</li> </ul> </li> <li>If the transaction could be applied to the current execution context:<ul> <li>If <code>expectException</code> is not empty, fail the test.</li> </ul> </li> </ol> </li> <li> <p>Compare the resulting post-state root with the expected post-state root contained in the <code>hash</code> field of the current <code>FixtureForkPost</code>, and fail the test if they do not match.</p> </li> <li>Compare the resulting logs hash with the expected logs contained in the <code>logs</code> field of the current <code>FixtureForkPost</code>, and fail the test if they do not match.</li> </ol> </li> </ol>"},{"location":"consuming_tests/state_test/#structures","title":"Structures","text":""},{"location":"consuming_tests/state_test/#fixture","title":"<code>Fixture</code>","text":""},{"location":"consuming_tests/state_test/#-env-fixtureenvironment","title":"- <code>env</code>: <code>FixtureEnvironment</code>","text":"<p>Execution environment description for the test.</p>"},{"location":"consuming_tests/state_test/#-pre-alloc","title":"- <code>pre</code>: <code>Alloc</code>","text":"<p>Starting account allocation for the test.</p>"},{"location":"consuming_tests/state_test/#-transaction-fixturetransaction","title":"- <code>transaction</code>: <code>FixtureTransaction</code>","text":"<p>Transaction to be executed.</p>"},{"location":"consuming_tests/state_test/#-post-mappingforklist-fixtureforkpost","title":"- <code>post</code>: <code>Mapping</code><code>(</code><code>Fork</code><code>,</code><code>List</code><code>[</code> <code>FixtureForkPost</code> <code>])</code>","text":"<p>Mapping of lists of post for verification per fork, where each element represents a single possible outcome of the transaction execution after being applied to the <code>pre</code>.</p>"},{"location":"consuming_tests/state_test/#-config-fixtureconfig","title":"- <code>config</code>: <code>FixtureConfig</code>","text":"<p>Chain configuration object.</p>"},{"location":"consuming_tests/state_test/#fixtureconfig","title":"<code>FixtureConfig</code>","text":"<p>At the moment this object can contain only the <code>blobSchedule</code> that is necessary to apply the correct cap to the maximum amount of blobs that a transaction can have. Otherwise, in forks prior to Cancun for example, it will be an empty JSON object.</p>"},{"location":"consuming_tests/state_test/#-blobschedule-blobschedule","title":"- <code>blobSchedule</code>: <code>BlobSchedule</code>","text":"<p>Optional; present from Cancun on. Maps forks to their blob schedule configurations as defined by EIP-7840.</p>"},{"location":"consuming_tests/state_test/#fixtureenvironment","title":"<code>FixtureEnvironment</code>","text":""},{"location":"consuming_tests/state_test/#-currentcoinbase-address","title":"- <code>currentCoinbase</code>: <code>Address</code>","text":"<p>The address of the account that will receive the rewards for building the block.</p>"},{"location":"consuming_tests/state_test/#-currentgaslimit-zeropaddedhexnumber","title":"- <code>currentGasLimit</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>Total gas limit of the block where the transaction is executed.</p>"},{"location":"consuming_tests/state_test/#-currentnumber-zeropaddedhexnumber","title":"- <code>currentNumber</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>Number of the block where the transaction is executed.</p>"},{"location":"consuming_tests/state_test/#-currentdifficulty-zeropaddedhexnumber","title":"- <code>currentDifficulty</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>Difficulty of the block where the transaction is executed.</p>"},{"location":"consuming_tests/state_test/#-currenttimestamp-zeropaddedhexnumber","title":"- <code>currentTimestamp</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>Timestamp of the block where the transaction is executed.</p>"},{"location":"consuming_tests/state_test/#-currentbasefee-zeropaddedhexnumber-fork-london","title":"- <code>currentBaseFee</code>: <code>ZeroPaddedHexNumber</code> <code>(fork: London)</code>","text":"<p>Base fee of the block where the transaction is executed.</p>"},{"location":"consuming_tests/state_test/#-currentrandom-hash-fork-paris","title":"- <code>currentRandom</code>: <code>Hash</code> <code>(fork: Paris)</code>","text":"<p>Randao value of the block where the transaction is executed.</p>"},{"location":"consuming_tests/state_test/#-currentexcessblobgas-zeropaddedhexnumber-fork-cancun","title":"- <code>currentExcessBlobGas</code>: <code>ZeroPaddedHexNumber</code> <code>(fork: Cancun)</code>","text":"<p>Excess blob gas of the block where the transaction is executed.</p>"},{"location":"consuming_tests/state_test/#fixturetransaction","title":"<code>FixtureTransaction</code>","text":""},{"location":"consuming_tests/state_test/#-nonce-zeropaddedhexnumber","title":"- <code>nonce</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>Nonce of the account that sends the transaction</p>"},{"location":"consuming_tests/state_test/#-gasprice-zeropaddedhexnumber","title":"- <code>gasPrice</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>Gas price for the transaction (Transaction types 0 &amp; 1)</p>"},{"location":"consuming_tests/state_test/#-maxpriorityfeepergas-hexnumber","title":"- <code>maxPriorityFeePerGas</code>: <code>HexNumber</code>","text":"<p>Max priority fee per gas to pay (Transaction types 2 &amp; 3)</p>"},{"location":"consuming_tests/state_test/#-maxfeepergas-hexnumber","title":"- <code>maxFeePerGas</code>: <code>HexNumber</code>","text":"<p>Max base fee per gas to pay (Transaction types 2 &amp; 3)</p>"},{"location":"consuming_tests/state_test/#-gaslimit-listzeropaddedhexnumber","title":"- <code>gasLimit</code>: <code>List</code><code>[</code><code>ZeroPaddedHexNumber</code><code>]</code>","text":"<p>List of gas limits used on each indexed test combination</p>"},{"location":"consuming_tests/state_test/#-to-addressemptyaddress","title":"- <code>to</code>: <code>Address</code><code>|</code><code>EmptyAddress</code>","text":"<p>Destination address of the transaction, or an empty string to create a contract</p>"},{"location":"consuming_tests/state_test/#-value-listzeropaddedhexnumber","title":"- <code>value</code>: <code>List</code><code>[</code><code>ZeroPaddedHexNumber</code><code>]</code>","text":"<p>List of values used on each indexed test combination</p>"},{"location":"consuming_tests/state_test/#-data-listbytes","title":"- <code>data</code>: <code>List</code><code>[</code><code>Bytes</code><code>]</code>","text":"<p>List of data bytes used on each indexed test combination</p>"},{"location":"consuming_tests/state_test/#-accesslists-listlistmappingaddresslisthash-fork-berlin","title":"- <code>accessLists</code>: <code>List</code><code>[</code><code>List</code><code>[</code><code>Mapping</code><code>[</code><code>Address</code><code>,</code><code>List</code><code>[</code><code>Hash</code><code>]]]]</code> <code>(fork: Berlin)</code>","text":"<p>List of account access lists used on each indexed test combination (Transaction types 1, 2 &amp; 3)</p>"},{"location":"consuming_tests/state_test/#-maxfeeperblobgas-hexnumber-fork-cancun","title":"- <code>maxFeePerBlobGas</code>: <code>HexNumber</code> <code>(fork: Cancun)</code>","text":"<p>Max fee per blob gas to pay (Transaction type 3)</p>"},{"location":"consuming_tests/state_test/#-blobversionedhashes-listhash-fork-cancun","title":"- <code>blobVersionedHashes</code>: <code>List</code><code>[</code><code>Hash</code><code>]</code> <code>(fork: Cancun)</code>","text":"<p>List of blob versioned hashes the transaction includes (Transaction type 3)</p>"},{"location":"consuming_tests/state_test/#-sender-address","title":"- <code>sender</code>: <code>Address</code>","text":"<p>Sender address of the transaction</p>"},{"location":"consuming_tests/state_test/#-secretkey-hash","title":"- <code>secretKey</code>: <code>Hash</code>","text":"<p>Private key that must be used to sign the transaction</p>"},{"location":"consuming_tests/state_test/#fixtureforkpost","title":"<code>FixtureForkPost</code>","text":""},{"location":"consuming_tests/state_test/#-indexes-fixtureforkpostindexes","title":"- <code>indexes</code>: <code>FixtureForkPostIndexes</code>","text":"<p>Transaction field indexes that must be used to obtain the transaction to be executed</p>"},{"location":"consuming_tests/state_test/#-txbytes-bytes","title":"- <code>txbytes</code>: <code>Bytes</code>","text":"<p>Serialized bytes version of the <code>FixtureTransaction</code> that was executed to produce this post-state</p>"},{"location":"consuming_tests/state_test/#-hash-hash","title":"- <code>hash</code>: <code>Hash</code>","text":"<p>Expected state root value that results of applying the transaction to the pre-state</p>"},{"location":"consuming_tests/state_test/#-logs-hash","title":"- <code>logs</code>: <code>Hash</code>","text":"<p>Hash of the RLP representation of the state logs result of applying the transaction to the pre-state (TODO: double-check this.)</p>"},{"location":"consuming_tests/state_test/#-expectexception-transactionexception","title":"- <code>expectException</code>: <code>TransactionException</code>","text":"<p>Exception that is expected to be thrown by the transaction execution (Field is missing if the transaction is expected to succeed)</p>"},{"location":"consuming_tests/state_test/#-state-alloc","title":"- <code>state</code>: <code>Alloc</code>","text":"<p>Dictionary that represents the allocation after execution of the transaction.</p>"},{"location":"consuming_tests/state_test/#fixtureforkpostindexes","title":"<code>FixtureForkPostIndexes</code>","text":""},{"location":"consuming_tests/state_test/#-data-int","title":"- <code>data</code>: <code>int</code>","text":"<p>Index of the data field in the transaction</p>"},{"location":"consuming_tests/state_test/#-gas-int","title":"- <code>gas</code>: <code>int</code>","text":"<p>Index of the gas limit field in the transaction</p>"},{"location":"consuming_tests/state_test/#-value-int","title":"- <code>value</code>: <code>int</code>","text":"<p>Index of the value field in the transaction</p>"},{"location":"consuming_tests/transaction_test/","title":"Transaction Tests","text":"<p>The Transaction Test fixture format tests are included in the fixtures subdirectory <code>transaction_tests</code>.</p> <p>These are produced by the <code>TransactionTest</code> test spec.</p>"},{"location":"consuming_tests/transaction_test/#description","title":"Description","text":"<p>The transaction test fixture format is used to test client's transaction RLP parsing without executing the transaction on the EVM.</p> <p>It does so by defining a transaction binary RLP representation, and whether the transaction should be accepted or rejected by the client in each fork.</p> <p>A single JSON fixture file is composed of a JSON object where each key-value pair is a different <code>Fixture</code> test object, with the key string representing the test name.</p> <p>The JSON file path plus the test name are used as the unique test identifier.</p> <p>The transaction test fixture format could contain multiple test vectors per test object, each represented by an element in the mapping of lists of the <code>result</code> field.</p> <p>However tests generated by the <code>execution-spec-tests</code> repository do not use this feature, as every single test object contains only a single test vector.</p>"},{"location":"consuming_tests/transaction_test/#consumption","title":"Consumption","text":"<p>For each <code>Fixture</code> test object in the JSON fixture file, perform the following steps:</p> <ol> <li>Obtain the <code>txbytes</code> serialized bytes of the transaction to be parsed.</li> <li> <p>For each <code>Fork</code> key of <code>result</code> in the test:</p> <ol> <li>Assume the fork schedule according to the current <code>Fork</code> key.</li> <li>Using the <code>txbytes</code>, attempt to decode the transaction.</li> <li>If the transaction could not be decoded:<ul> <li>If the <code>hash</code> field is present, fail the test.</li> <li>Compare the exception thrown with the expected exception contained in the <code>exception</code> field, and fail the test if they do not match.</li> <li>Proceed to the next fork.</li> </ul> </li> <li>If the transaction could be decoded:<ul> <li>Compare the calculated hash with the expected hash contained in the <code>hash</code> field, and fail the test if they do not match.</li> <li>Compare the calculated intrinsic gas with the expected intrinsic gas contained in the <code>intrinsicGas</code> field, and fail the test if they do not match.</li> <li>Compare the calculated sender with the expected sender contained in the <code>sender</code> field, and fail the test if they do not match.</li> </ul> </li> </ol> </li> </ol>"},{"location":"consuming_tests/transaction_test/#structures","title":"Structures","text":""},{"location":"consuming_tests/transaction_test/#fixture","title":"<code>Fixture</code>","text":""},{"location":"consuming_tests/transaction_test/#-txbytes-bytes","title":"- <code>txbytes</code>: <code>Bytes</code>","text":"<p>Serialized bytes of the transaction under test.</p>"},{"location":"consuming_tests/transaction_test/#-result-mappingforkfixtureresult","title":"- <code>result</code>: <code>Mapping</code><code>[</code><code>Fork</code><code>,</code><code>FixtureResult</code> <code>]</code>","text":"<p>Mapping of results for verification per fork, where each key-value represents a single possible outcome of the transaction parsed in the given fork.</p>"},{"location":"consuming_tests/transaction_test/#fixtureresult","title":"<code>FixtureResult</code>","text":""},{"location":"consuming_tests/transaction_test/#-hash-hash-none","title":"- <code>hash</code>: <code>Hash</code> <code>| None</code>","text":"<p>Calculated hash of the transaction (Field is missing if the transaction is expected to fail).</p>"},{"location":"consuming_tests/transaction_test/#-intrinsicgas-zeropaddedhexnumber","title":"- <code>intrinsicGas</code>: <code>ZeroPaddedHexNumber</code>","text":"<p>Total intrinsic gas cost of the transaction (Field is missing if the transaction is expected to fail).</p>"},{"location":"consuming_tests/transaction_test/#-sender-address","title":"- <code>sender</code>: <code>Address</code>","text":"<p>Sender address of the transaction (Field is missing if the transaction is expected to fail).</p>"},{"location":"consuming_tests/transaction_test/#-exception-transactionexception","title":"- <code>exception</code>: <code>TransactionException</code>","text":"<p>Exception that is expected to be thrown by the transaction parsing (Field is missing if the transaction is expected to succeed).</p>"},{"location":"dev/","title":"Developer Documentation","text":"<p>This documentation is aimed at maintainers of <code>execution-spec-tests</code> but may be helpful during test case development:</p> <ul> <li>Managing configurations: Instructions for setting up and modifying test configurations.</li> <li>Interactive usage: Guide on interactive use of EEST packages using <code>ipython</code>.</li> <li>Generating documentation: Steps to create and build documentation for the project.</li> <li>Documenting CLI commands: Instructions for documenting command line interfaces (CLIs).</li> <li>Coding style: Standards and best practices for code formatting and to maintain consistency across the repository.</li> <li>Enabling pre-commit checks: A guide for setting up pre-commit hooks to enforce code quality before commits.</li> <li>Running github actions locally: Instructions for testing GitHub Actions workflows on your local machine to streamline development and debugging.</li> <li>Porting tests: A guide to porting legacy ethereum tests to EEST.</li> </ul>"},{"location":"dev/coding_style/","title":"Coding Style","text":""},{"location":"dev/coding_style/#formatting-and-line-length","title":"Formatting and Line Length","text":"<p>The Python code in execution-spec-tests is black formatted with a maximum line length of 100. Using VS Code with <code>editor.formatOnSave</code> is a big help to ensure files conform to the repo's coding style, see VS Code Setup to configure this and other useful settings.</p>"},{"location":"dev/coding_style/#ignoring-bulk-change-commits","title":"Ignoring Bulk Change Commits","text":"<p>The max line length was changed from 80 to 100 in Q2 2023. To ignore this bulk change commit in git blame output, use the <code>.git-blame-ignore-revs</code> file, for example:</p> <pre><code>git blame --ignore-revs-file .git-blame-ignore-revs docs/gen_test_case_reference.py\n</code></pre> <p>To use the revs file persistently with <code>git blame</code>, run</p> <pre><code>git config blame.ignoreRevsFile .git-blame-ignore-revs\n</code></pre>"},{"location":"dev/configurations/","title":"Managing Configurations","text":"<p>Configurations are managed by the <code>config</code> package. It provides both environment and application configurations.</p> <pre><code>.\n\u251c\u2500\u2500 src\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 config  [Application wide environment and configurations]\n\u2502       \u251c\u2500\u2500 \ud83d\udcc4 __init__.py\n\u2502       \u251c\u2500\u2500 \ud83d\udcc4 app.py [Configurations for application framework]\n\u2502       \u251c\u2500\u2500 \ud83d\udcc4 docs.py [Configurations for documentation]\n\u2502       \u2514\u2500\u2500 \ud83d\udcc4 env.py  [Exposes `env.yaml` to the application]\n\u2514\u2500\u2500 \ud83d\udcc4 env.yaml [Environment file (git ignored)]\n</code></pre>"},{"location":"dev/configurations/#environment-configurations","title":"Environment Configurations","text":"<p>Application-wide environment configuration, which varies across staging, production, and development environments are read from <code>env.yaml</code> in the project root.</p> <p>This file will not be tracked by git, making it safe for storing local secrets.</p> <p>To get started, run the command eest make env cli to initialize your environment configuration.</p>"},{"location":"dev/configurations/#usage","title":"Usage","text":""},{"location":"dev/configurations/#1-generate-env-file","title":"1. Generate env file","text":"<p>Run the <code>eest make env</code> cli tool.</p> <pre><code>uv run eest make env\n\ud83c\udf89 Success! Config file created at: &lt;path&gt;/env.yaml\n</code></pre> <p>which should generate an <code>env.yaml</code> in the project root.</p> <pre><code>remote_nodes:\n  - name: mainnet_archive\n    # Replace with your Ethereum RPC node URL\n    node_url: http://example.com\n    # Optional: Headers for RPC requests\n    rpc_headers:\n      client-secret: &lt;secret&gt;\n</code></pre>"},{"location":"dev/configurations/#2-import-envconfig","title":"2. Import <code>EnvConfig</code>","text":"<pre><code>from config import EnvConfig\nEnvConfig().remote_nodes[0].name\n'mainnet_archive'\n</code></pre>"},{"location":"dev/configurations/#application-configuration","title":"Application configuration","text":"<p>Application configuration are pydantic classes.</p> <pre><code>from config import DocsConfig\nDocsConfig().TARGET_FORK\n'Prague'\n</code></pre>"},{"location":"dev/docs/","title":"Documentation","text":"<p>The <code>execution-spec-tests</code> documentation is generated via <code>mkdocs</code> and hosted remotely on Github Pages at ethereum.github.io/execution-spec-tests.</p>"},{"location":"dev/docs/#prerequisites","title":"Prerequisites","text":"<pre><code>uv sync --all-extras\n</code></pre>"},{"location":"dev/docs/#build-and-verify-the-documentation","title":"Build and Verify the Documentation","text":"<p>One time build in strict mode:</p> <pre><code>uv run mkdocs build --strict\n</code></pre> <p>Perform all docs related checks via <code>tox</code> in parallel:</p> <pre><code>uvx --with=tox-uv tox -e spellcheck,markdownlint,mkdocs --parallel\n</code></pre>"},{"location":"dev/docs/#local-deployment-and-test","title":"Local Deployment and Test","text":"<p>This runs continually: Deploys the site locally and re-generates the site upon modifications to <code>docs/**/*.md</code> or <code>tests/**/*.py</code>:</p> <pre><code>uv run mkdocs serve\n</code></pre> <p>For more help (including ensuring a clean build), see the <code>gen_test_doc</code> pytest plugin's documentation:</p> <p>A pytest plugin that generates test case documentation for use in mkdocs.</p> <p>It generates the top-level \"Test Case Reference\" section in EEST's mkdocs site.</p>"},{"location":"dev/docs/#src.pytest_plugins.filler.gen_test_doc.gen_test_doc--note","title":"Note:","text":"<ul> <li>No output directory is specified for the generated output; file IO occurs     via the <code>mkdocs-gen-files</code> plugin. <code>mkdocs serve</code> writes intermediate files     to our local <code>docs/</code> directory and then copies it to the site directory.     We modify <code>docs/navigation.md</code> and write all other output underneath     <code>docs/tests</code>. If mkdocs is interrupted, these intermediate artifacts are     left in <code>docs/</code>.</li> </ul>"},{"location":"dev/docs/#src.pytest_plugins.filler.gen_test_doc.gen_test_doc--usage","title":"Usage:","text":"<p>Ensuring a clean build</p> <p>In case mkdocs has polluted the <code>docs/</code> directory with intermediate files, run:</p> <pre><code>git restore docs/navigation.md  # Careful if you have local modifications!\nrm -rf docs/tests docs/docs site\n</code></pre> <p>To test doc generation, run the plugin without mkdocs:</p> <pre><code>uv run fill -p pytest_plugins.filler.gen_test_doc.gen_test_doc --gen-docs --fork=&lt;fork&gt; tests\n</code></pre> <p>Or to build and view the site:</p> <pre><code>uv run mkdocs serve\n</code></pre>"},{"location":"dev/docs/#remote-deployment-and-versioning","title":"Remote Deployment and Versioning","text":"<p>The execution-specs-test docs are hosted on Github pages at the repo's Github pages. Versions are updated/deployed automatically as part of Github Actions, but this can also be performed on the command-line.</p> <p>Our mkdocs configuration uses mike as a version provider. All deployments should be made via <code>mike</code> (whether as part of CI/CD or executed locally).</p> <p>The deployed versions of the docs managed via <code>mike</code> are kept in the gh-pages branch. When you run <code>mike</code> it commits to this branch and optionally pushes the changes directly to remote.</p>"},{"location":"dev/docs/#aliases","title":"Aliases","text":"<p>We currently have two aliases (which both point to <code>main</code> as of #998):</p> <ul> <li><code>latest</code>: the current state of the main branch.</li> <li><code>development</code>: the current state of the main branch.</li> </ul> <p>These aliases point to specific versions, as configured below. It's possible to share links containing either of these aliases or to specific versions, i.e, the following are all valid links:</p> <ul> <li>https://ethereum.github.io/execution-spec-tests/ (redirects to latest/main)</li> <li>https://ethereum.github.io/execution-spec-tests/latest (redirects to main)</li> <li>https://ethereum.github.io/execution-spec-tests/development (redirects main)</li> <li>https://ethereum.github.io/execution-spec-tests/main</li> <li>https://ethereum.github.io/execution-spec-tests/v1.0.0</li> </ul>"},{"location":"dev/docs/#cicd-doc-deployment-via-github-actions","title":"CI/CD: Doc Deployment via Github Actions","text":"<p>There are two workflows that automatically deploy updated/new versions of the docs:</p> Workflow <code>yaml</code> File What When <code>docs_main.yaml</code> Update \"main\" version of docs Push to 'main' branch, (e.g., on PR merge) <code>docs_tags.yaml</code> Deploy new version of docs; tag is used as version name Upon creating a tag matching <code>v*</code>"},{"location":"dev/docs/#build-and-deployment-without-alias-update","title":"Build and Deployment (without alias update)","text":"<p>Build a new version and deploy it to remote (this version will then show up in the version selector list):</p> <pre><code>uv run mike deploy -rebase --push v1.2.3\n</code></pre> <p>Local deployment</p> <p>If you deploy locally, the documentation will be built with any changes made in your local repository. Check out the tag to deploy tagged versions.</p>"},{"location":"dev/docs/#build-deploy-and-update-the-alias","title":"Build, Deploy and Update the Alias","text":"<p>Build, deploy and update the version an alias points to with:</p> <pre><code>uv run mike deploy --rebase --push --update-aliases v1.2.3 latest\n</code></pre> <p>where <code>v1.2.3</code> indicates the version's name and <code>development</code> is the alias. This will overwrite the version if it already exists.  </p> <p>Updating the 'main' version locally</p> <p>\"main\" is just a version name (intended to reflect that it is build from the main branch). However, <code>mike</code> will build the docs site from the current local repository state (including local modifications). Therefore, make sure you're on the HEAD of the main branch before executing (unless you know what you're doing )!</p> <pre><code>uv run mike deploy --rebase --push main\n</code></pre> <p>If the alias accidentally go change:</p> <pre><code>uv run mike deploy --rebase --push --update-aliases main development\n</code></pre>"},{"location":"dev/docs/#viewing-and-deleting-versions","title":"Viewing and Deleting Versions","text":"<p>List versions:</p> <pre><code>uv run mike list\n</code></pre> <p>Delete a version:</p> <pre><code>uv run mike delete v1.2.3a1-eof\n</code></pre>"},{"location":"dev/docs/#set-default-version","title":"Set Default Version","text":"<p>Set the default version of the docs to open upon loading the page:</p> <pre><code>uv run mike set-default --push latest\n</code></pre> <p>Typically, this must only be executed once for a repo.</p>"},{"location":"dev/docs/#implementation","title":"Implementation","text":""},{"location":"dev/docs/#plugins","title":"Plugins","text":"<p>The documentation flow uses <code>mkdocs</code> and the following additional plugins:</p> <ul> <li>mkdocs: The main doc generation tool.</li> <li>mkdocs-material: Provides many additional features and styling for mkdocs.</li> <li>mkdocstrings and mkdocstrings-python: To generate documentation from Python docstrings.</li> <li>mkdocs-gen-files: To generate markdown files automatically for each test case Python module. See this page for example usage. This plugin is used to programmatically generate the nav section for the generated test case reference documentation.</li> <li>mkdocs-literate-nav: Is used to define the navigation layout for non-generated content and was created to work well with <code>mkdocs-gen-files</code> to add nav content for generated content.</li> <li>blueswen/mkdocs-glightbox - for improved image and inline content display.</li> </ul>"},{"location":"dev/docs/#the-test-case-reference-section","title":"The \"Test Case Reference\" Section","text":"<p>This section is auto-generated via a combination of:</p> <ol> <li>mkdocstrings and mkdocstrings-python,</li> <li>mkdocs-gen-files,</li> <li>mkdocs-literate-nav.</li> </ol> <p>It auto-generates a sequence of nested pages (with nav entries) of all python modules detected under <code>./tests</code>. Each page contains a stub to the doc generated by mkdocstrings from the module's docstrings and source code. The mkdocs-gen-files and mkdocs-literate-nav plugins were created exactly for this purpose.</p> <p>No action is necessary if a new test directory or module is added to <code>./tests</code>, it will be picked up automatically.</p> <p>Working with generated content</p> <p>The files in the <code>./tests</code> directory are watched by <code>mkdocs serve</code>. Run <code>mkdocs serve</code> and edit the source docstrings: The browser will reload with the new content automatically.</p>"},{"location":"dev/docs/#navigation","title":"Navigation","text":"<p>All pages that are to be included in the documentation and the navigation bar must be included in <code>navigation.md</code>, except \"Test Case Reference\" entries. This is enabled by mkdocs-literate-nav. The nav entries for the automatically generated \"Test Case Reference\" section are generated in mkdocs-gen-files and appended to <code>navigation.md</code>.</p> <p>Current nav ordering limitations</p> <p>The \"Test Case Reference\" section must currently be the last section in the nav. This is because our mkdocs flow:</p> <ol> <li>Reads <code>navigation.md</code>.</li> <li>Generates the Test Case Reference documentation and appends the Test Case Reference entries to <code>navigation.md</code></li> <li>Generates the nav.</li> </ol> <p>If necessary, we could probably split <code>navigation.md</code> into two files</p> <ul> <li><code>navigation-pre-test-case-reference.md</code>,</li> <li><code>navigation-post-test-case-reference.md</code>,</li> </ul> <p>and create an arbitrary ordering in the Test Case Reference doc gen script. But this is untested.</p>"},{"location":"dev/docs/#read-the-docs","title":"Read the Docs","text":"<p>Originally, documentation was hosted at readthedocs.io. Currently, this now defunct page (execution-spec-tests.readthedocs.io) is configured to redirect to the Github Pages site. This is achieved by following the steps listed in the second half of this answer on stackoverflow. A public repo with a dummy Sphinx project is required to achieve this: danceratopz/est-docs-redirect.</p>"},{"location":"dev/documenting_clis/","title":"Documenting CLIs","text":"<p>EEST command line interfaces (CLIs) are documented using the <code>click</code> library's built-in help system and the <code>mkdocs-click</code> extension for mkdocs. This allows generation of CLI documentation directly from the (click) source code, ensuring that the documentation is always up-to-date with the code.</p> <p>Current limitations:</p> <ol> <li><code>mkdocs serve</code> does not automatically update the CLI documentation when the source code changes. You must restart the server to see the changes.</li> <li><code>mkdocs-click</code> does not automatically generate a short help string from sub-command docstrings. You must provide a short help string for each sub-command in the source code with <code>@click.command(short_help=\"...\")</code>.</li> </ol> <p>See the markdown and corresponding Python docstrings for the <code>evm_bytes</code> CLI documentation as an example of how to document a CLI using <code>mkdocs-click</code>.</p>"},{"location":"dev/interactive_usage/","title":"Working with EEST Libraries Interactively","text":"<p>You can work with EEST Python packages interactively with <code>ipython</code> using:</p> <pre><code>uvx  --with-editable . ipython\n</code></pre> <p>This command will create a virtual environment, install EEST's packages in \"editable mode\" (source changes get reflected in the interactive shell), and start an <code>ipython</code> shell. You can then import any of the packages and experiment with them interactively.</p> <p>Example: Working with <code>ethereum_test_forks</code></p> <p>See which defined forks are \"ignored\" by default:</p> <pre><code>from ethereum_test_forks import forks, get_forks\nforks = set([fork for fork in get_forks() if fork.ignore()])\nprint(forks)\n# -&gt; {MuirGlacier, ArrowGlacier, GrayGlacier}\n</code></pre>"},{"location":"dev/interactive_usage/#required-ipython-configuration","title":"Required <code>ipython</code> Configuration","text":"<p>To enable autoreload of changed modules in the current <code>ipython</code> session, type:</p> <pre><code>%load_ext autoreload\n%autoreload 2\n</code></pre> <p>To make this configuration persistent, add/uncomment the following lines to <code>~/.ipython/profile_default/ipython_config.py</code>:</p> <pre><code>c.InteractiveShellApp.exec_lines = [\"%autoreload 2\"]\nc.InteractiveShellApp.extensions = [\"autoreload\"]\n</code></pre>"},{"location":"dev/porting_legacy_tests/","title":"A Guide to Porting Original Ethereum Tests to EEST","text":""},{"location":"dev/porting_legacy_tests/#background","title":"Background","text":"<p>EEST is the successor to ethereum/tests (aka \"original tests\"), a repository that defined EVM test cases from the Frontier phase up to and including The Merge. These test cases are specified as YAML (and occasionally JSON) files in the <code>./src/</code> sub-directory. JSON test fixtures, which are fully-populated tests that can be executed against clients, are generated using ethereum/retesteth. These JSON artifacts are regenerated when needed and added to the repository, typically in the <code>./GeneralStateTests/</code> sub-directory.</p> <p>From Shanghai onward, new test cases \u2014 especially for new features introduced in hard forks\u2014are defined in Python within EEST. While the existing test cases remain important for client testing, porting ethereum/tests to EEST will help maintain and generate tests for newer forks. This also ensures feature parity, as client teams will only need to obtain test fixture releases from one source.</p> <p>While automating the conversion of the remaining YAML (or JSON) test cases to Python is possible, manually porting individual test cases offers several benefits:</p> <ul> <li>Reducing the number of test cases by combining multiple YAML (or JSON) cases into a single Python test function using parametrization.</li> <li>Potentially improving coverage by parametrizing the Python version.</li> <li>Producing higher quality code and documentation, which are typically clearer than an automated conversion.</li> <li>Ensuring better organization of tests within the <code>./tests</code> folder of execution-spec-tests by fork and EIP.</li> </ul>"},{"location":"dev/porting_legacy_tests/#porting-an-original-test","title":"Porting an original test","text":"<ol> <li> <p>Select one or more YAML test cases from ethereum/tests to port and create an issue in this repository AND comment on this tracker issue.</p> </li> <li> <p>Add a new test in the appropriate fork folder, following the guidelines for choosing a test type.</p> </li> <li> <p>Submit a PR with the ported tests:</p> <ol> <li>Add the list of ported YAML files to <code>converted-ethereum-tests.txt</code>.</li> <li>Open a PR to remove the ported tests from the original tests repository.</li> </ol> </li> </ol> <p>See also: \ud83d\udcc4 Getting started with EEST.</p>"},{"location":"dev/porting_legacy_tests/#filling-tests","title":"Filling tests","text":"<p>EEST uses pytest to run tests against EELS (an EVM implementation for testing). This process is known as \"filling\" and verifies the assertions in your tests. You can use the fill CLI for this. For example, see how to fill the <code>PUSH</code> opcode.</p> <pre><code>uv run fill tests/frontier/opcodes/test_push.py\n</code></pre> <p>See also: \ud83d\udcc4 Documentation for the <code>fill</code> command.</p> <p>If the tests can't currently be filled, please explain the issue (feel free to also open a Discussion).</p>"},{"location":"dev/porting_legacy_tests/#debugging-tests","title":"Debugging tests","text":"<p>By default, EVM logs are stored in the <code>logs</code> folder at the repository root. You can check the <code>output</code> folder to review transaction results. If needed, review a previous PR that ported tests (e.g., the PR porting the <code>PUSH</code> opcode, and other port PRs).</p>"},{"location":"dev/porting_legacy_tests/#test-coverage","title":"Test coverage","text":"<p>It's crucial that ported tests maintain coverage parity with original tests. This ensures that no critical functions are left untested and prevents the introduction of bugs. A CI workflow automatically checks for coverage.</p> <p>If coverage action fails (See: \ud83d\udcc4 An example of a failing test coverage), it's recommended to run the coverage action locally (see: \ud83d\udcc4 How to run GitHub actions locally), which should generate a <code>evmtest_coverage</code> directory:</p> <pre><code>\u276f tree evmtest_coverage  -L 2\nevmtest_coverage\n\u2514\u2500\u2500 coverage\n    \u251c\u2500\u2500 BASE\n    \u251c\u2500\u2500 BASE_TESTS\n    \u251c\u2500\u2500 coverage_BASE.lcov\n    \u251c\u2500\u2500 coverage_PATCH.lcov\n    \u251c\u2500\u2500 DIFF\n    \u251c\u2500\u2500 difflog.txt\n    \u251c\u2500\u2500 PATCH\n    \u2514\u2500\u2500 PATCH_TESTS\n</code></pre> <p>Here <code>BASE</code>is original tests, <code>PATCH</code> is the ported test, and <code>DIFF</code> is the coverage difference on EVMONE. Open <code>evmtest_coverage/coverage/DIFF/index.html</code> in browser:</p> <p></p> Label Description <code>LBC</code> Lost base coverage: Code that was tested before, but is untested now. <code>UBC</code> Uncovered baseline code: Code that was untested before and untested now. <code>GBC</code> Gained baseline coverage: Code that was untested before, but is tested now. <code>CBC</code> Covered baseline code: Code that was tested before and is tested now. <p>Follow the hyperlinks for lost base coverage (<code>LBC</code>) to address coverage gaps. Here is an example coverage loss:</p> <p></p> <p>Lost line coverage from a coverage report. In this case, caused by a missing invocation of <code>CALLDATALOAD</code>.</p> <p>Expected coverage loss</p> <p>EEST uses pytest, a popular Python testing framework, to help orchestrate testing Ethereum specifications, while original tests relied on large, static contracts and the EVM to handle much of the execution. This difference can lead to coverage gaps. EEST favors dynamic contract creation for each test vector, while original tests preferred a single static contract with multiple test vectors determined by transaction input data.</p> <p>It's important to note that coverage helps identify missing test paths. If you believe the coverage loss is due to differences in \"setup\" code between frameworks and doesn't impact the feature you're testing, explain this in your PR. A team member can help with the review.</p> <p>Also note that yul tests and possibly other tests used <code>CALLDATALOAD</code> that might no longer needed when designing a test with python. But we must always investigate if an opcode is not covered anymore to see if its okay.</p> <p>For example, review the discussion in this PR.</p>"},{"location":"dev/precommit/","title":"Enabling Pre-Commit Checks","text":"<p>There's a pre-commit config file available in the repository root (<code>.pre-commit-config.yaml</code>) that can be used to enable automatic checks upon commit - the commit will not go through if the checks don't pass.</p> <p>To enable pre-commit, the following must be run once:</p> <pre><code>uvx pre-commit install\n</code></pre> <p>Bypassing pre-commit checks</p> <p>Enabling of pre-commit checks is not mandatory (it cannot be enforced) and even if it is enabled, it can always be bypassed with:</p> <pre><code>git commit --no-verify\n</code></pre>"},{"location":"dev/test_actions_locally/","title":"Running Github Actions Locally","text":"<p>The Github Actions workflows can be tested locally using nektos/act without pushing changes to the remote. The local repository state will be used in the executed workflow.</p>"},{"location":"dev/test_actions_locally/#prerequisites","title":"Prerequisites","text":"<ol> <li> <p>A docker installation without <code>sudo</code> prefix requirement (see also dockerdocs):</p> <pre><code>sudo usermod -aG docker $USER\n</code></pre> </li> <li> <p>Install the Github CLI (<code>gh</code>): linux, macos.</p> </li> <li> <p>Authenticate your Github account with the Github CLI:</p> <pre><code>gh auth login\n</code></pre> <p>This is required to set <code>GITHUB_TOKEN</code> to the output of <code>gh auth token</code> when running the workflows.</p> </li> <li> <p>Install the <code>act</code> tool as a Github extension (nektos/act docs):</p> <pre><code>gh extension install https://github.com/nektos/gh-act\n</code></pre> <p>or use one of the other available methods.</p> </li> </ol> <p>Updating nektos/act to the latest version via the Github CLI</p> <p>The <code>act</code> tool can be updated via the Github CLI:</p> <pre><code>gh extension upgrade nektos/act\n</code></pre>"},{"location":"dev/test_actions_locally/#listing-the-available-workflows","title":"Listing the Available Workflows","text":"<pre><code>gh act --list\n</code></pre> <p>will output something similar to:</p> <pre><code>INFO[0000] Using docker host 'unix:///var/run/docker.sock', and daemon socket 'unix:///var/run/docker.sock'\nStage  Job ID                Job name                                                      Workflow name                             Workflow file          Events                             \n0      evmone-coverage-diff  evmone-coverage-diff                                          Evmone Coverage Report                    coverage.yaml          pull_request                       \n0      deploy                deploy                                                        Deploy Docs Main                          docs_main.yaml         push                               \n0      deploy                deploy                                                        Deploy Docs Tags                          docs_tags.yaml         push                               \n0      features              features                                                      Build and Package Fixtures                fixtures.yaml          push,workflow_dispatch             \n0      feature-names         feature-names                                                 Build and Package Fixtures for a feature  fixtures_feature.yaml  push,workflow_dispatch             \n0      lint                  Lint python sources with ruff                                 Tox                                       tox_verify.yaml        push,pull_request,workflow_dispatch\n0      typecheck             Typecheck python sources with mypy                            Tox                                       tox_verify.yaml        push,pull_request,workflow_dispatch\n0      spellcheck            Spellcheck sources with pyspelling                            Tox                                       tox_verify.yaml        push,pull_request,workflow_dispatch\n0      markdownlint          Lint markdown files with markdownlint                         Tox                                       tox_verify.yaml        push,pull_request,workflow_dispatch\n0      mkdocs                Build html documentation with mkdocs                          Tox                                       tox_verify.yaml        push,pull_request,workflow_dispatch\n0      pytest_framework      Run unit tests, ${{ matrix.os }}, ${{ matrix.python }}        Tox                                       tox_verify.yaml        push,pull_request,workflow_dispatch\n0      tests_deployed        Fill tests, deployed, ${{ matrix.os }}, ${{ matrix.python }}  Tox                                       tox_verify.yaml        push,pull_request,workflow_dispatch\n1      build                 build                                                         Build and Package Fixtures                fixtures.yaml          push,workflow_dispatch             \n1      build                 build                                                         Build and Package Fixtures for a feature  fixtures_feature.yaml  push,workflow_dispatch             \n2      release               release                                                       Build and Package Fixtures                fixtures.yaml          push,workflow_dispatch             \n2      release               release                                                       Build and Package Fixtures for a feature  fixtures_feature.yaml  push,workflow_dispatch\n</code></pre> <p>The <code>Job ID</code> is required to run a specific workflow and is provided to the <code>-j</code> option of <code>gh act</code>.</p>"},{"location":"dev/test_actions_locally/#running-workflows-that-require-github-vars","title":"Running Workflows that require Github Vars","text":"<p>Create a text file containing the required variables and variables, e.g., <code>.act_github_vars</code> (this is in <code>.gitignore</code>):</p> <pre><code>UV_VERSION=0.5.15\nDEFAULT_PYTHON_VERSION=3.12\n</code></pre> <p>and use the <code>--var-file</code> option to specify the file:</p> <pre><code>gh act --workflows .github/workflows/tox_verify.yaml -s GITHUB_TOKEN=$(gh auth token) --var-file=gh_vars.txt -j lint \n</code></pre>"},{"location":"dev/test_actions_locally/#running-workflows-that-use-a-matrix-strategy","title":"Running Workflows that use a Matrix Strategy","text":"<p>This is optional, recent versions will automatically detect the matrix strategy and run supported values. To run a specific matrix value, use the <code>--matrix</code> option:</p> <pre><code>gh act --workflows .github/workflows/tox_verify.yaml -s GITHUB_TOKEN=$(gh auth token) --matrix python:3.12 -j pytest_framework\n</code></pre>"},{"location":"dev/test_actions_locally/#running-release-workflows","title":"Running Release Workflows","text":"<p>Release builds require the <code>ref</code> input to be specified. To test a release build locally:</p> <ol> <li> <p>Create a JSON file specifying the input data required for a release build (the release tag), e.g, <code>event.json</code>:</p> <pre><code>{\n    \"ref\": \"refs/tags/stable@v4.2.0\"\n}\n</code></pre> </li> <li> <p>Run <code>act</code> and specify the workflow file, the Github token, and the event file:</p> <pre><code>gh act -j build --workflows .github/workflows/fixtures_feature.yaml -s GITHUB_TOKEN=$(gh auth token) -e event.json\n</code></pre> </li> </ol>"},{"location":"dev/test_actions_locally/#manually-specifying-the-docker-image","title":"Manually Specifying the Docker Image","text":"<p>It's possible to specify the Docker image used by the <code>act</code> tool for a specific platform defined in a workflow using the <code>-P</code> (<code>--platform</code>) option. For example, use map <code>ubuntu-latest</code> in the workflow to use <code>ubuntu-24.04</code>:</p> <pre><code>-P ubuntu-latest=ubuntu:24.04\n</code></pre> <p>This can be added to any <code>gh act</code> command.</p>"},{"location":"executing_tests/","title":"Executing Tests on Local Networks or Hive","text":"<p>ethereum/execution-spec-tests is capable of running tests on local networks or on Hive with a few considerations. This page describes how to do so.</p>"},{"location":"executing_tests/#the-execute-command-and-pytest-plugin","title":"The <code>execute</code> command and <code>pytest</code> plugin","text":"<p>The <code>execute</code> command is capable of parse and execute all tests in the <code>tests</code> directory, collect the transactions it requires, send them to a client connected to a network, wait for the network to include them in a block and, finally, check the resulting state of the involved smart-contracts against the expected state to validate the behavior of the clients.</p> <p>It will not check for the state of the network itself, only the state of the smart-contracts, accounts and transactions involved in the tests, so it is possible that the network becomes unstable or forks during the execution of the tests, but this will not be detected by the command.</p> <p>The way this is achieved is by using a pytest plugin that will collect all the tests the same way as the fill plugin does, but instead of compiling the transactions and sending them as a batch to the transition tool, they are prepared and sent to the client one by one.</p> <p>Before sending the actual test transactions to the client, the plugin uses a special pre-allocation object that collects the contracts and EOAs that are used by the tests and, instead of pre-allocating them in a dictionary as the fill plugin does, it sends transactions to deploy contracts or fund the accounts for them to be available in the network.</p> <p>The pre-allocation object requires a seed account with funds available in the network to be able to deploy contracts and fund accounts. In the case of a live remote network, the seed account needs to be provided via a command-line parameter, but in the case of a local hive network, the seed account is automatically created and funded by the plugin via the genesis file.</p> <p>At the end of each test, the plugin will also check the remaining balance of all accounts and will attempt to automatically recover the funds back to the seed account in order to execute the following tests.</p>"},{"location":"executing_tests/#differences-between-the-fill-and-execute-plugins","title":"Differences between the <code>fill</code> and <code>execute</code> plugins","text":"<p>The test execution with the <code>execute</code> plugin is different from the <code>fill</code> plugin in a few ways:</p>"},{"location":"executing_tests/#eoa-and-contract-addresses","title":"EOA and Contract Addresses","text":"<p>The <code>fill</code> plugin will pre-allocate all the accounts and contracts that are used in the tests, so the addresses of the accounts and contracts will be known before the tests are executed, Further more, the test contracts will start from the same address on different tests, so there are collisions on the account addresses used across different tests. This is not the case with the <code>execute</code> plugin, as the accounts and contracts are deployed on the fly, from sender keys that are randomly generated and therefore are different in each execution.</p> <p>Reasoning behind the random generation of the sender keys is that one can execute the same test multiple times in the same network and the plugin will not fail because the accounts and contracts are already deployed.</p>"},{"location":"executing_tests/#transactions-gas-price","title":"Transactions Gas Price","text":"<p>The <code>fill</code> plugin will use a fixed and minimum gas price for all the transactions it uses for testing, but this is not possible with the <code>execute</code> plugin, as the gas price is determined by the current state of the network.</p> <p>At the moment, the <code>execute</code> plugin does not query the client for the current gas price, but instead uses a fixed increment to the gas price in order to avoid the transactions to be stuck in the mempool.</p>"},{"location":"executing_tests/#running-tests-on-a-hive-single-client-local-network","title":"Running Tests on a Hive Single-Client Local Network","text":"<p>Tests can be executed on a local hive-controlled single-client network by running the <code>execute hive</code> command.</p> <p>This command requires hive to be running in <code>--dev</code> mode:</p> <pre><code>./hive --dev --client go-ethereum\n</code></pre> <p>This will start hive in dev mode with the single go-ethereum client available for launching tests.</p> <p>By default, the hive server will be listening on <code>http://127.0.0.1:3000</code>, but this can be changed by setting the <code>--dev.addr</code> flag:</p> <pre><code>./hive --dev --client go-ethereum --dev.addr http://127.0.0.1:5000\n</code></pre> <p>The <code>execute hive</code> can now be executed to connect to the hive server, but the environment variable <code>HIVE_SIMULATOR</code> needs to be set to the address of the hive server:</p> <pre><code>export HIVE_SIMULATOR=http://127.0.0.1:3000\n</code></pre> <p>And the tests can be executed with:</p> <pre><code>uv run execute hive --fork=Cancun\n</code></pre> <p>This will execute all available tests in the <code>tests</code> directory on the <code>Cancun</code> fork by connecting to the hive server running on <code>http://127.0.0.1:3000</code> and launching a single client with the appropriate genesis file.</p> <p>The genesis file is passed to the client with the appropriate configuration for the fork schedule, system contracts and pre-allocated seed account.</p> <p>All tests will be executed in the same network, in the same client, and serially, but when the <code>-n auto</code> parameter is passed to the command, the tests can also be executed in parallel.</p> <p>One important feature of the <code>execute hive</code> command is that, since there is no consensus client running in the network, the command drives the chain by the use of the Engine API to prompt the execution client to generate new blocks and include the transactions in them.</p>"},{"location":"executing_tests/#running-test-on-a-live-remote-network","title":"Running Test on a Live Remote Network","text":"<p>Tests can be executed on a live remote network by running the <code>execute remote</code> command.</p> <p>The command requires the <code>--fork</code> flag which must match the fork that is currently active in the network (fork transition tests are not supported yet).</p> <p>The <code>execute remote</code> command requires to be pointed to an RPC endpoint of a client that is connected to the network, which can be specified by using the <code>--rpc-endpoint</code> flag:</p> <pre><code>uv run execute remote --fork=Prague --rpc-endpoint=https://rpc.endpoint.io\n</code></pre> <p>Another requirement is that the command is provided with a seed account that has funds available in the network to deploy contracts and fund accounts. This can be done by setting the <code>--rpc-seed-key</code> flag:</p> <pre><code>uv run execute remote --fork=Prague --rpc-endpoint=https://rpc.endpoint.io --rpc-seed-key 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\n</code></pre> <p>The value needs to be a private key that is used to sign the transactions that deploy the contracts and fund the accounts.</p> <p>One last requirement is that the <code>--rpc-chain-id</code> flag is set to the chain id of the network that is being tested:</p> <pre><code>uv run execute remote --fork=Prague --rpc-endpoint=https://rpc.endpoint.io --rpc-seed-key 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f --rpc-chain-id 12345\n</code></pre> <p>The <code>execute remote</code> command will connect to the client via the RPC endpoint and will start executing every test in the <code>./tests</code> folder in the same way as the <code>execute hive</code> command, but instead of using the Engine API to generate blocks, it will send the transactions to the client via the RPC endpoint.</p> <p>It is recommended to only run a subset of the tests when executing on a live network. To do so, a path to a specific test can be provided to the command:</p> <pre><code>uv run execute remote --fork=Prague --rpc-endpoint=https://rpc.endpoint.io --rpc-seed-key 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f --rpc-chain-id 12345 ./tests/prague/eip7702_set_code_tx/test_set_code_txs.py::test_set_code_to_sstore\n</code></pre>"},{"location":"executing_tests/#execute-command-test-execution","title":"<code>execute</code> Command Test Execution","text":"<p>After executing wither <code>execute hive</code> or <code>execute remote</code>, the command will first create a random sender account from which all required test accounts will be deployed and funded, and this account is funded by sweeping (by default) the seed account.</p> <p>The sweep amount can be configured by setting the <code>--seed-account-sweep-amount</code> flag:</p> <pre><code>--seed-account-sweep-amount \"1000 ether\"\n</code></pre> <p>Once the sender account is funded, the command will start executing tests one by one by sending the transactions from this account to the network.</p> <p>Test transactions are not sent from the main sender account though, they are sent from a different unique account that is created for each test (accounts returned by <code>pre.fund_eoa</code>).</p> <p>If the command is run using the <code>-n</code> flag, the tests will be executed in parallel, and each process will have its own separate sender account, so the amount that is swept from the seed account is divided by the number of processes, so this has to be taken into account when setting the sweep amount and also when funding the seed account.</p> <p>After finishing each test the command will check the remaining balance of all accounts and will attempt to recover the funds back to the sender account, and at the end of all tests, the remaining balance of the sender account will be swept back to the seed account.</p> <p>There are instances where it will be impossible to recover the funds back from a test, for example, funds that are sent to a contract that has no built-in way to send them back, the funds will be stuck in the contract and they will not be recoverable.</p>"},{"location":"filling_tests/","title":"Filling Tests","text":"<p>Execution of test cases against clients is a two-step process:</p> <ol> <li>JSON test fixtures are generated from the Python test cases found in <code>./tests</code> using <code>fill</code> and an EVM transition tool (<code>t8n</code>) implementation.</li> <li>Clients \"consume\" the JSON fixtures via either a dedicated, client-specific interface or a testing environment such as Hive.</li> </ol> <p>The process of generating fixtures is often referred to as \"filling\" the tests.</p> <p>The <code>execute</code> command</p> <p>The <code>execute</code> command directly executes Python test cases against a client via its RPC without using generated JSON fixtures. For all other methods of testing clients, the JSON fixtures are required. For more information, see Executing Tests.</p>"},{"location":"filling_tests/#transition-tools-t8n","title":"Transition Tools (<code>t8n</code>)","text":"<p>The <code>fill</code> command requires an EVM <code>t8n</code> tool provided by most clients in order to generate the JSON fixtures. The <code>t8n</code> tool is mainly responsible for calculating the post-state of the EVM after executing a transaction, most relevantly, it calculates the updated state root.</p>"},{"location":"filling_tests/#ethereum-execution-layer-specification-eels","title":"Ethereum Execution Layer Specification (EELS)","text":"<p>By default, the Ethereum Execution Layer Specification (EELS) reference implementation of the <code>t8n</code> tool is used to generate test fixtures for all forks that have been deployed to Ethereum mainnet. We strong encourage EIP authors to provide a reference implementation of their EIP in EELS, so that it can be used to generate test fixtures for features under active development.</p>"},{"location":"filling_tests/#limitations-of-filling","title":"Limitations of Filling","text":"<p>The \"fill-consume\" method follows a differential testing approach: A reference implementation is used to generate JSON test fixtures, which can then be executed against other EVM clients. However:</p> <p>Successfully filling does not guarantee correctness</p> <p>Some tests cases, particularly those without straightforward post-checks, such as certain gas calculations, may allow subtle inconsistencies to slip through during filling.</p> <p>Consequently, filling the tests does not ensure the client\u2019s correctness. Clients must consume the tests to be considered correctly tested, even if that client was used to fill the tests.</p>"},{"location":"filling_tests/debugging_t8n_tools/","title":"Debugging Transition Tools","text":"<p>There are two flags that can help debugging <code>t8n</code> tools or the execution-spec-tests framework:</p> <ol> <li><code>--evm-dump-dir</code> (Default: /logs/evm): Write debug information from <code>t8n</code> tool calls to the specified directory. <li><code>--traces</code>: Collect traces of the execution from the transition tool.</li> <li><code>--verify-fixtures</code>: Run go-ethereum's <code>evm blocktest</code> command to verify the generated test fixtures.</li>"},{"location":"filling_tests/debugging_t8n_tools/#evm-dump-directory","title":"EVM Dump Directory","text":"<p>The <code>--evm-dump-dir</code> flag tells the framework to write the inputs and outputs of every call made to the <code>t8n</code> command to the specified output directory. The aim is to help debugging or simply understand how a test is interacting with the EVM. The default location is <code>logs/evm</code> in the project root.</p> <p>Each test case receives its own sub-directory under the <code>--evm-dump-dir</code> that contains these files which can be easily accessed from the HTML test report generated by <code>fill</code> (located by default in the root of the <code>--output</code> directory).</p> <p></p> <p>In particular, a script <code>t8n.sh</code> is generated for each call to the <code>t8n</code> command which can be used to reproduce the call to trigger errors or attach a debugger without the need to execute Python.</p> <p>For example, running:</p> <pre><code>fill tests/berlin/eip2930_access_list/ --fork Berlin -m blockchain_test \\\n    --evm-dump-dir=/tmp/evm-dump --traces\n</code></pre> <p>will produce the directory structure:</p> <pre><code>\ud83d\udcc2 /tmp/evm-dump\n\u2514\u2500\u2500 \ud83d\udcc2 berlin__eip2930_access_list__test_acl__test_access_list\n    \u2514\u2500\u2500 \ud83d\udcc2 fork_Berlin_blockchain_test\n        \u2514\u2500\u2500 \ud83d\udcc2 0\n         \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 args.py\n         \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 input\n         \u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 alloc.json\n         \u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 env.json\n         \u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 txs.json\n         \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 output\n         \u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 alloc.json\n         \u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 result.json\n         \u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 txs.rlp\n         \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 returncode.txt\n         \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 stderr.txt\n         \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 stdin.txt\n         \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 stdout.txt\n         \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 t8n.sh\n            \u2514\u2500\u2500 \ud83d\udcc4 trace-0-0x5c4f07ce52f0a276a06aabdfff16cc693b5e007c018f9a42431e68200e2da515.jsonl\n</code></pre> <p>where the directory <code>0</code> is the starting index of the different calls made to the <code>t8n</code> tool executed during the test, and since the test only contains one block, there is only one directory present.</p> <p>Note, there may be more directories present <code>1</code>, <code>2</code>, <code>3</code>,... if the test executes more blocks.</p> <p>Each directory contains files containing information corresponding to the call, for example, the <code>args.py</code> file contains the arguments passed to the <code>t8n</code> command and the <code>output/alloc.json</code> file contains the output of the <code>t8n</code> command's <code>--output-alloc</code> flag.</p>"},{"location":"filling_tests/debugging_t8n_tools/#the-t8nsh-script","title":"The <code>t8n.sh</code> Script","text":"<p>The <code>t8n.sh</code> script written to the debug directory can be used to reproduce a specific call made to the <code>t8n</code> command during the test session. For example, if a Besu <code>t8n-server</code> has been started on port <code>3001</code>, the request made by the test for first block can be reproduced as:</p> <pre><code>/tmp/besu/test_access_list_fork_Berlin/0/t8n.sh 3001\n</code></pre> <p>which writes the response the from the <code>t8n-server</code> to the console output:</p> <pre><code>{\n  \"alloc\" : {\n    \"0x000000000000000000000000000000000000aaaa\" : {\n      \"code\" : \"0x5854505854\",\n      \"balance\" : \"0x4\",\n      \"nonce\" : \"0x1\"\n    },\n    \"0x2adc25665018aa1fe0e6bc666dac8fc2697ff9ba\" : {\n      \"balance\" : \"0x1bc16d674ecb26ce\"\n    },\n    \"0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b\" : {\n      \"balance\" : \"0x2cd931\",\n      \"nonce\" : \"0x1\"\n    }\n  },\n  \"body\" : \"0xf8a0b89e01f89b0180078304ef0094000000000000000000000000000000000000aaaa0180f838f7940000000000000000000000000000000000000000e1a0000000000000000000000000000000000000000000000000000000000000000001a02e16eb72206c93c471b5894800495ee9c64ae2d9823bcc4d6adeb5d9d9af0dd4a03be6691e933a0816c59d059a556c27c6753e6ce76d1e357b9201865c80b28df3\",\n  \"result\" : {\n    \"stateRoot\" : \"0x51799508f764047aee6606bc6a00863856f83ee5b91555f00c8a3cbdfbec5acb\",\n    ...\n    ...\n  }\n}\n</code></pre> <p>The <code>t8n.sh</code> is written to the debug directory for all supported t8n tools.</p>"},{"location":"filling_tests/debugging_t8n_tools/#verifying-test-fixtures-via-evm-blocktest","title":"Verifying Test Fixtures via <code>evm blocktest</code>","text":"<p>The <code>--verify-fixtures</code> flag can be used to run go-ethereum's <code>evm blocktest</code> command in order to verify the generated JSON test fixtures.</p> <p>For example, running:</p> <pre><code>fill tests/berlin/eip2930_access_list/ --fork Berlin -m blockchain_test \\\n    --evm-dump-dir==/tmp/evm-dump \\\n    --evm-bin=../evmone/build/bin/evmone-t8n \\\n    --verify-fixtures-bin=../go-ethereum/build/bin/evm \\\n    --verify-fixtures\n</code></pre> <p>will additionally run the <code>evm blocktest</code> command on every JSON fixture file and write its output to the EVM dump directory:</p> <pre><code>\ud83d\udcc2 /tmp/evm-dump\n\u2514\u2500\u2500 \ud83d\udcc2 berlin__eip2930_access_list__test_acl__test_access_list\n    \u251c\u2500\u2500 \ud83d\udcc4 fixtures.json\n    \u251c\u2500\u2500 \ud83d\udcc2 fork_Berlin_blockchain_test\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 0\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 args.py\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 input\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 alloc.json\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 env.json\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 txs.json\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 output\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 alloc.json\n    \u2502   ... ... ...\n    \u2502\n    \u251c\u2500\u2500 \ud83d\udcc4 verify_fixtures_args.py\n    \u251c\u2500\u2500 \ud83d\udcc4 verify_fixtures_returncode.txt\n    \u251c\u2500\u2500 \ud83d\udcc4 verify_fixtures.sh\n    \u251c\u2500\u2500 \ud83d\udcc4 verify_fixtures_stderr.txt\n    \u2514\u2500\u2500 \ud83d\udcc4 verify_fixtures_stdout.txt\n</code></pre> <p>where the <code>verify_fixtures.sh</code> script can be used to reproduce the <code>evm blocktest</code> command.</p>"},{"location":"filling_tests/debugging_t8n_tools/#further-verify-fixtures-examples","title":"Further <code>--verify-fixtures</code> Examples","text":"<ol> <li> <p>No fixture verification performed:</p> <pre><code>fill\n</code></pre> </li> <li> <p>Verify fixtures: Use the first <code>evm</code> binary in the <code>PATH</code> to execute both the <code>t8n</code> and <code>blocktest</code> commands (i.e., same binary used; this must be a geth binary):</p> <pre><code>fill --verify-fixtures\n</code></pre> </li> <li> <p>Explicitly specify the evm binary to execute the <code>blocktest</code> command (the first evm binary in the <code>PATH</code> is used for <code>t8n</code> commands; <code>--verify-fixtures</code> is not necessary):</p> <pre><code>fill --verify-fixtures-bin=../go-ethereum/build/bin/evm\n</code></pre> </li> <li> <p>Explicitly set two different <code>evm</code> binaries to execute the <code>t8n</code> and <code>blocktest</code> commands; write debug data to the specified <code>--evm-dump-dir</code>:</p> <pre><code>fill --evm-bin=../evmone/build/bin/evmone-t8n \\\n  --verify-fixtures-bin=../go-ethereum/build/bin/evm \\\n  --evm-dump-dir=/tmp/evm-dump\n</code></pre> </li> <li> <p>Additionally use <code>--single-fixture-per-file</code> to improve the granularity of the reporting of the <code>evm blocktest</code> command by writing the fixture generated by each parametrized test case to its own file.</p> <pre><code>fill --evm-bin=../evmone/build/bin/evmone-t8n \\\n  --verify-fixtures-bin=../go-ethereum/build/bin/evm \\\n  --evm-dump-dir=/tmp/evm-dump \\\n  --single-fixture-per-file\n</code></pre> </li> </ol> <p>Execution scope of <code>evm blocktest</code></p> <p>Note, by default, that <code>evm blocktest</code> is not executed per parametrized test case, but rather per test function. This is because each fixture JSON file contains fixtures for all the parametrized test cases for one test function. This means only one error will be reported, even if multiple fixtures fail within one fixture file.</p> <p>Additionally, it is only executed after all the test cases in the module have been executed<sup>1</sup> and will only report the first failing test fixture in all files, even if there are multiple failing fixture files.</p> <p>This means, by default, that the feedback is not as granular as for test case execution. To improve granularity, and get feedback per parametrized test case use <code>--single-fixture-per-file</code>.</p> <ol> <li> <p> This limitation is required to enable support of the <code>pytest-xdist</code> plugin for concurrent test execution across multiple CPUs. To achieve this we use the we apply the <code>--dist loadscope</code> xdist flag in our <code>pytest.ini</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"filling_tests/filling_tests_command_line/","title":"Filling Tests at a Prompt","text":"<p>The execution-spec-tests test framework uses the pytest framework for test case collection and execution. The <code>fill</code> command is essentially an alias for <code>pytest</code>, which uses several custom pytest plugins to run transition tools against test cases and generate JSON fixtures.</p> <p>Options specific to execution-spec-tests</p> <p>The command-line options specific to filling tests can be listed via:</p> <pre><code>fill --help\n</code></pre> <p>See Custom <code>fill</code> Command-Line Options for all options.</p>"},{"location":"filling_tests/filling_tests_command_line/#collection-test-exploration","title":"Collection - Test Exploration","text":"<p>The test cases implemented in the <code>./tests</code> sub-directory can be listed in the console using:</p> <pre><code>fill --collect-only\n</code></pre> <p>and can be filtered (by test path, function and parameter substring):</p> <pre><code>fill --collect-only -k warm_coinbase\n</code></pre> <p>Docstrings are additionally displayed when ran verbosely:</p> <pre><code>fill --collect-only -k warm_coinbase -vv\n</code></pre>"},{"location":"filling_tests/filling_tests_command_line/#execution","title":"Execution","text":"<p>By default, test cases are filled for all forks already deployed to mainnet, but not for forks still under active development, i.e., as of time of writing, Q2 2023:</p> <pre><code>fill\n</code></pre> <p>will generate fixtures for test cases from Frontier to Shanghai.</p> <p>To generate all the test fixtures defined in the <code>./tests/shanghai</code> sub-directory and write them to the <code>./fixtures-shanghai</code> directory, run <code>fill</code> in the top-level directory as:</p> <pre><code>fill ./tests/shanghai --output=\"fixtures-shanghai\"\n</code></pre> <p>Test case verification</p> <p>Note, that the (limited set of) test <code>post</code> conditions are tested against the output of the <code>evm t8n</code> command during test generation.</p> <p>To generate all the test fixtures in the <code>tests/shanghai/eip3651_warm_coinbase/test_warm_coinbase.py</code> module, for example, run:</p> <pre><code>fill tests/shanghai/eip3651_warm_coinbase/test_warm_coinbase.py\n</code></pre> <p>To generate specific test fixtures from a specific test function or even test function and parameter set, obtain the corresponding test ID using:</p> <pre><code>fill --collect-only -q -k test_warm_coinbase\n</code></pre> <p>This filters the tests by <code>test_warm_coinbase</code>. Then find the relevant test ID in the console output and provide it to fill, for example, for a test function:</p> <pre><code>fill tests/shanghai/eip3651_warm_coinbase/test_warm_coinbase.py::test_warm_coinbase_gas_usage\n</code></pre> <p>or, for a test function and specific parameter combination:</p> <pre><code>fill tests/shanghai/eip3651_warm_coinbase/test_warm_coinbase.py::test_warm_coinbase_gas_usage[fork_Paris-DELEGATECALL]\n</code></pre>"},{"location":"filling_tests/filling_tests_command_line/#execution-for-development-forks","title":"Execution for Development Forks","text":"<p>By default, test cases are not filled for upcoming Ethereum forks so that they can be readily filled using the <code>evm</code> tool from the latest <code>geth</code> release.</p> <p>In order to fill test cases for an upcoming fork, ensure that the <code>evm</code> tool used supports that fork and features under test and use the <code>--until</code> or <code>--fork</code> flag.</p> <p>For example, as of Q2 2023, the current fork under active development is <code>Cancun</code>: <pre><code>fill --until Cancun\n</code></pre></p> <p>See: Filling Tests for Features under Development.</p>"},{"location":"filling_tests/filling_tests_command_line/#debugging-the-t8n-command","title":"Debugging the <code>t8n</code> Command","text":"<p>The <code>--evm-dump-dir</code> flag can be used to dump the inputs and outputs of every call made to the <code>t8n</code> command for debugging purposes, see Debugging Transition Tools.</p>"},{"location":"filling_tests/filling_tests_command_line/#other-useful-pytest-command-line-options","title":"Other Useful Pytest Command-Line Options","text":"<pre><code>fill -vv            # More verbose output\nfill -x             # Exit instantly on first error or failed test case\nfill --pdb -nauto   # Drop into the debugger upon error in a test case\nfill -s             # Print stdout from tests to the console during execution\n</code></pre>"},{"location":"filling_tests/filling_tests_command_line/#custom-fill-command-line-options","title":"Custom <code>fill</code> Command-Line Options","text":"<p>To see all the options available to fill, including pytest and pytest plugin options, use <code>--pytest-help</code>.</p> <p>To list the options that only specific to fill, use:</p> <pre><code>fill --help\n</code></pre> <p>Output:</p> <pre><code>usage: fill [-h] [--strict-alloc] [--ca-start CA_START] [--ca-incr CA_INCR]\n            [--evm-code-type EVM_CODE_TYPE] [--solc-bin SOLC_BIN]\n            [--solc-version SOLC_VERSION] [--evm-bin EVM_BIN] [--traces]\n            [--verify-fixtures] [--verify-fixtures-bin VERIFY_FIXTURES_BIN]\n            [--filler-path FILLER_PATH] [--output OUTPUT] [--flat-output]\n            [--single-fixture-per-file] [--no-html] [--strict-alloc]\n            [--ca-start CA_START] [--ca-incr CA_INCR] [--build-name BUILD_NAME]\n            [--evm-dump-dir EVM_DUMP_DIR] [--forks] [--fork FORK] [--from FROM]\n            [--until UNTIL]\n\noptions:\n  -h, --help            show this help message and exit\n\nArguments defining pre-allocation behavior.:\n  --strict-alloc        [DEBUG ONLY] Disallows deploying a contract in a\n                        predefined address.\n  --ca-start CA_START, --contract-address-start CA_START\n                        The starting address from which tests will deploy\n                        contracts.\n  --ca-incr CA_INCR, --contract-address-increment CA_INCR\n                        The address increment value to each deployed contract by\n                        a test.\n  --evm-code-type EVM_CODE_TYPE\n                        Type of EVM code to deploy in each test by default.\n\nArguments defining the solc executable:\n  --solc-bin SOLC_BIN   Path to a solc executable (for Yul source compilation).\n                        No default; if unspecified `--solc-version` is used.\n  --solc-version SOLC_VERSION\n                        Version of the solc compiler to use. Default: 0.8.24.\n\nArguments defining evm executable behavior:\n  --evm-bin EVM_BIN     Path to an evm executable that provides `t8n`. Default:\n                        First 'evm' entry in PATH.\n  --traces              Collect traces of the execution information from the\n                        transition tool.\n  --verify-fixtures     Verify generated fixture JSON files using geth's evm\n                        blocktest command. By default, the same evm binary as for\n                        the t8n tool is used. A different (geth) evm binary may\n                        be specified via --verify-fixtures-bin, this must be\n                        specified if filling with a non-geth t8n tool that does\n                        not support blocktest.\n  --verify-fixtures-bin VERIFY_FIXTURES_BIN\n                        Path to an evm executable that provides the `blocktest`\n                        command. Default: The first (geth) 'evm' entry in PATH.\n\nArguments defining filler location and output:\n  --filler-path FILLER_PATH\n                        Path to filler directives\n  --output OUTPUT       Directory path to store the generated test fixtures. If\n                        the specified path ends in '.tar.gz', then the specified\n                        tarball is additionally created (the fixtures are still\n                        written to the specified path without the '.tar.gz'\n                        suffix). Can be deleted. Default: './fixtures'.\n  --flat-output         Output each test case in the directory without the folder\n                        structure.\n  --single-fixture-per-file\n                        Don't group fixtures in JSON files by test function;\n                        write each fixture to its own file. This can be used to\n                        increase the granularity of --verify-fixtures.\n  --no-html             Don't generate an HTML test report (in the output\n                        directory). The --html flag can be used to specify a\n                        different path.\n  --build-name BUILD_NAME\n                        Specify a build name for the fixtures.ini file, e.g.,\n                        'stable'.\n  --index               Generate an index file for all produced fixtures.\n\nArguments defining debug behavior:\n  --evm-dump-dir EVM_DUMP_DIR, --t8n-dump-dir EVM_DUMP_DIR\n                        Path to dump the transition tool debug output.  (Default: &lt;repo&gt;/logs/evm)\n\nSpecify the fork range to generate fixtures for:\n  --forks               Display forks supported by the test framework and exit.\n  --fork FORK           Only fill tests for the specified fork.\n  --from FROM           Fill tests from and including the specified fork.\n  --until UNTIL         Fill tests until and including the specified fork.\n\nExit: After displaying help.\n</code></pre>"},{"location":"filling_tests/filling_tests_dev_fork/","title":"Filling Tests for Features under Development","text":""},{"location":"filling_tests/filling_tests_dev_fork/#requirements","title":"Requirements","text":"<p>By default, execution-spec-tests only generates fixtures for forks that have been deployed to mainnet. In order to generate fixtures for evm features that are actively under development:</p> <ol> <li>A version of the <code>evm</code> and <code>solc</code> tools that implement the feature must be available (although, typically only a developer version of the <code>evm</code> tool is required, usually the latest stable release of <code>solc</code> is adequate), and,</li> <li> <p>The development fork to test must be explicitly specified on the command-line:</p> via the <code>--fork</code> flagvia the <code>--from</code> flagvia the <code>--until</code> flag <pre><code>fill -k 4844 --fork=Cancun -v\n</code></pre> <pre><code>fill -k 4844 --from=Cancun -v\n</code></pre> <pre><code>fill -k 4844 --until=Cancun -v\n</code></pre> </li> </ol> <p>Specifying the <code>evm</code> binary via <code>evm-bin</code></p> <p>It is possible to explicitly specify the <code>evm</code> binary used to generate fixtures via the <code>--evm-bin</code> flag, for example,</p> <pre><code>fill --fork=Cancun --evm-bin=/opt/bin/evm -v\n</code></pre>"},{"location":"filling_tests/filling_tests_dev_fork/#further-help","title":"Further Help","text":"<ol> <li><code>geth</code>/<code>evm</code> build documentation.</li> <li><code>solc</code> build documentation.</li> </ol> <p>Verifying <code>evm</code> and <code>solc</code> versions used</p> <p>The versions used to generate fixtures are displayed in the console output:   </p>"},{"location":"filling_tests/filling_tests_dev_fork/#vs-code-setup","title":"VS Code Setup","text":"<p>By default, VS Code's Testing View will only show tests for stable forks. To show tests for development forks, uncomment the relevant line in the <code>python.testing.pytestArgs</code> configuration section of included settings file (<code>.vscode/settings.json</code>) to enable the <code>--until=FORK</code> flag. See VS Code Setup for help finding the settings files.</p>"},{"location":"filling_tests/filling_tests_vs_code/","title":"Filling Tests in VS Code","text":"<p>Prerequisite: VS Code Setup.</p>"},{"location":"filling_tests/filling_tests_vs_code/#exploring-test-cases","title":"Exploring Test Cases","text":"<p>Implemented test cases can be explored in VS Code's \"Testing\" View; click on the conical flask highlighted in the screenshot below.</p> <p> </p> <p>Testing EVM Features Under Active Development</p> <p>See the VS Code section in Filling Tests for Features under Development to explore tests targeting EVM features under development.</p>"},{"location":"filling_tests/filling_tests_vs_code/#filling-and-debugging-test-cases","title":"Filling and Debugging Test Cases","text":""},{"location":"filling_tests/getting_started/","title":"Getting Started: Filling Tests","text":"<p>This guide describes how to get started with <code>fill</code> and commonly-used command-line options.</p> <ol> <li> <p>Explore test cases via <code>--collect-only</code> and search for test cases that combine <code>PUSH0</code> and <code>DELEGATECALL</code> in the EVM functionality introduced in the Shanghai hard fork:</p> <pre><code>uv run fill --collect-only -k \"push0 and delegatecall\" tests/shanghai/\n</code></pre> <p>The <code>fill</code> command is based on <code>pytest</code>. The above command uses the optional pytest arguments:</p> <ul> <li><code>--collect-only</code> only collect test cases; don't execute them.</li> <li><code>-k &lt;expression&gt;</code> filter test cases by their test case ID based on the given expression.</li> <li><code>tests/shanghai</code> the directory containing the test cases (tells <code>fill</code> to only discover test cases in this directory; default: <code>tests/</code>).</li> </ul> <p>Expected console output:  </p> </li> <li> <p>Fill <code>state_test</code> fixtures for these test cases:</p> <pre><code>uv run fill -k \"push0 and delegatecall\" tests/shanghai/ -m state_test -v\n</code></pre> <p>where:</p> <ul> <li><code>-m state_test</code> only fills test cases marked as a <code>state_test</code> (see all available markers via <code>uv run fill --markers</code>).</li> <li><code>-v</code> enables verbose output.</li> </ul> <p>Expected console output:  </p> </li> <li> <p>Verify the generated fixtures:</p> <p>a. Check the corresponding fixture file has been generated:</p> <pre><code>head fixtures/state_tests/shanghai/eip3855_push0/push0/push0_contract_during_call_contexts.json\n</code></pre> <p>b. Open the generated HTML test using the link provided at the bottom of the console output. This is written to the output directory at:</p> <pre><code>./fixtures/.meta/report_fill.html\n</code></pre> </li> </ol>"},{"location":"filling_tests/getting_started/#next-steps","title":"Next Steps","text":"<ol> <li>Learn useful command-line flags.</li> <li>Execute tests for features under development via the <code>--fork</code> flag.</li> <li>Optional: Configure VS Code to auto-format Python code and execute tests within VS Code.</li> <li>Implement a new test case, see Writing Tests.</li> </ol>"},{"location":"filling_tests/transition_tool_support/","title":"Transition Tool Support","text":"<p>The following transition tools are supported by the framework:</p> Client <code>t8n</code> Tool Tracing Support ethereum/evmone <code>evmone-t8n</code> Yes ethereum/execution-specs <code>ethereum-spec-evm-resolver</code> Yes ethereumjs <code>ethereumjs-t8ntool.sh</code> No ethereum/go-ethereum <code>evm t8n</code> Yes hyperledger/besu <code>evmtool t8n-server</code> Yes status-im/nimbus-eth1 <code>t8n</code> Yes"},{"location":"getting_started/getting_help/","title":"Getting Help","text":"<p>The tests in this repository are a community effort to help improve the development cycle of all Ethereum execution clients.</p> <p>We encourage contributions and recognize that Python is not everyone's  primary language - if you stumble over issues or need help, please reach out to one of the execution-spec-tests maintainers either directly or in the <code>#el-testing</code> channel in the Ethereum R&amp;D Discord Server.</p>"},{"location":"getting_started/getting_help/#contact-the-maintainers","title":"Contact the Maintainers","text":"<p>Write to:</p> <ul> <li>Dan on Discord or Telegram (<code>danceratopz</code>).</li> <li>Spencer on Discord or Telegram (<code>spencertaylorbrown</code>/<code>@techbro_ccoli</code>).</li> <li>Mario on Discord or Telegram (<code>marioevz</code>/<code>@marioevz</code>).</li> </ul> <p> </p>"},{"location":"getting_started/installation/","title":"Installation","text":""},{"location":"getting_started/installation/#prerequisites","title":"Prerequisites","text":"<p>The tools provided by execution-spec-tests use <code>uv</code> (docs.astral.sh/uv) to manage their dependencies and virtual environment.</p> <p>It's typically recommended to use the latest version of <code>uv</code>, currently <code>uv&gt;=0.5.22</code> is required.</p> <p>The latest version of <code>uv</code> can be installed via <code>curl</code> (recommended; can self-update via <code>uv self update</code>) or pip (requires Python, can't self-update):</p> curlpip <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <pre><code>pip install uv\n</code></pre> <p>If installed via <code>curl</code>, <code>uv</code> will download Python for your target platform if one of the required versions (Python 3.10, 3.11 or 3.12) is not available natively.</p>"},{"location":"getting_started/installation/#installation_1","title":"Installation","text":"<p>Clone execution-spec-tests and install its dependencies:</p> <pre><code>git clone https://github.com/ethereum/execution-spec-tests\ncd execution-spec-tests\nuv sync --all-extras\nuv run solc-select use 0.8.24 --always-install\n</code></pre>"},{"location":"getting_started/installation/#installation-troubleshooting","title":"Installation Troubleshooting","text":"<p>If you encounter issues during installation, see the Installation Troubleshooting guide.</p>"},{"location":"getting_started/installation_troubleshooting/","title":"Installation Troubleshooting","text":"<p>This page provides guidance on how to troubleshoot common issues that may arise when installing ethereum/execution-spec-tests.</p>"},{"location":"getting_started/installation_troubleshooting/#problem-failed-building-wheel-for-coincurve","title":"Problem: <code>Failed building wheel for coincurve</code>","text":"<p>Problem: <code>Failed building wheel for coincurve</code></p> <p>Installing EEST and its dependencies via <code>uv sync --all-extras</code> fails with:</p> <pre><code>Stored in directory: /tmp/...\n  Building wheel for coincurve (pyproject.toml) ... error\n  error: subprocess-exited-with-error\n\n  \u00d7 Building wheel for coincurve (pyproject.toml) did not run successfully.\n  \u2502 exit code: 1\n  \u2570\u2500&gt; [27 lines of output]\n      ...\n        571 | #include &lt;secp256k1_extrakeys.h&gt;\n            |          ^~~~~~~~~~~~~~~~~~~~~~~\n      compilation terminated.\n      error: command '/usr/bin/gcc' failed with exit code 1\n      [end of output]\n\n  note: This error originates from a subprocess, and is likely not a problem with pip.\n  ERROR: Failed building wheel for coincurve\n</code></pre> <p>Solution: Install the <code>libsecp256k1</code> library</p> <p>On Ubuntu, you can install this library with:</p> <pre><code>sudo apt update\nsudo apt-get install libsecp256k1-dev\n</code></pre>"},{"location":"getting_started/installation_troubleshooting/#problem-solc-installation-issues","title":"Problem: <code>solc</code> Installation issues","text":"<p>Problem: <code>Failed to install solc ... CERTIFICATE_VERIFY_FAILED</code></p> <p>When running either <code>uv run solc-select use 0.8.24 --always-install</code> or <code>fill</code> you encounter the following error:</p> <pre><code>Exit: Failed to install solc version 0.8.24: &lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:992)&gt;\n</code></pre> UbuntumacOS <p>Solution: Update your system\u2019s CA certificates</p> <p>On Ubuntu, run the following commands:</p> <pre><code>sudo apt-get update\nsudo apt-get install ca-certificates\n</code></pre> <p>Solution: Update your system\u2019s CA certificates</p> <p>On macOS, Python provides a built-in script to install the required certificates:</p> <pre><code>/Applications/Python\\ 3.11/Install\\ Certificates.command\n</code></pre>"},{"location":"getting_started/installation_troubleshooting/#problem-valueerror-unsupported-hash-type-ripemd160","title":"Problem: <code>ValueError: unsupported hash type ripemd160</code>","text":"<p>Problem: <code>Running fill fails with tests that use the RIPEMD160 precompile (0x03)</code></p> <p>When running <code>fill</code>, you encounter the following error:</p> <pre><code>ValueError: unsupported hash type ripemd160\n# or\nValueError: [digital envelope routines] unsupported\n</code></pre> <p>This is due to the removal of certain cryptographic primitives in OpenSSL 3. These were re-introduced in OpenSSL v3.0.7.</p> <p>Solution: Modify OpenSSL configuration</p> <p>On platforms where OpenSSL v3.0.7 is unavailable (e.g., Ubuntu 22.04), modify your OpenSSL configuration to enable RIPEMD160. Make the following changes in the OpenSSL config file:</p> <pre><code>[openssl_init]\nproviders = provider_sect\n\n# List of providers to load\n[provider_sect]\ndefault = default_sect\nlegacy = legacy_sect\n\n[default_sect]\nactivate = 1\n\n[legacy_sect]\nactivate = 1\n</code></pre> <p>This will enable the legacy cryptographic algorithms, including RIPEMD160. See ethereum/execution-specs#506 for more information.</p>"},{"location":"getting_started/installation_troubleshooting/#other-issues-not-listed","title":"Other Issues Not Listed?","text":"<p>If you're facing an issue that's not listed here, you can easily report it on GitHub for resolution.</p> <p>Click here to report a documentation issue related to installation</p> <p>Please include the following details in your report:</p> <ol> <li>The command that triggered the issue.</li> <li>Any relevant error messages or screenshots.</li> </ol>"},{"location":"getting_started/repository_overview/","title":"Repository Overview","text":""},{"location":"getting_started/repository_overview/#repository-overview","title":"Repository Overview","text":"<p>The most relevant folders and files in the repo are:</p> <pre><code>\ud83d\udcc1 execution-test-specs/\n\u251c\u2500\u2574\ud83d\udcc1 tests/                     # test cases\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 eips/\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 vm/\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 ...\n\u251c\u2500\u2574\ud83d\udcc1 fixtures/                  # default fixture output dir\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 blockchain_tests/\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 blockchain_tests_engine/\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 state_tests/\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 ...\n\u251c\u2500\u2574\ud83d\udcc1 src/                       # library &amp; framework packages\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 ethereum_test_fork/\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 ethereum_test_tools/\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 ...\n\u251c\u2500\u2574\ud83d\udcc1 docs/                      # markdown documentation\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 getting_started\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 dev\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 ...\n\u251c\u2500\u2574\ud83d\udcc1 .vscode/                   # visual studio code config\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 settings.recommended.json # copy to settings.json\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 launch.recommended.json\n\u2502   \u2514\u2500\u2500 \ud83d\udcc4 extensions.json\n\u2514\u2500\u2500 \ud83d\udcc4 whitelist.txt             # spellcheck dictionary\n</code></pre>"},{"location":"getting_started/repository_overview/#tests","title":"<code>tests/</code>","text":"<p>Contains the implementation of the Ethereum consensus tests available in this repository.</p>"},{"location":"getting_started/repository_overview/#src","title":"<code>src/</code>","text":"<p>Contains various packages that help to define test cases and to interface with the <code>evm t8n</code> command. Additionally, it contains some packages that enable test case execution by customizing pytest which acts as the test framework.</p>"},{"location":"getting_started/repository_overview/#docs","title":"<code>docs/</code>","text":"<p>Contains documentation configuration and source files.</p>"},{"location":"getting_started/repository_overview/#vscode","title":"<code>.vscode/</code>","text":"<p>See VS Code Setup.</p>"},{"location":"getting_started/setup_vs_code/","title":"VS Code Setup","text":"<p>VS Code setup is optional, but does offer the following advantages:</p> <ul> <li>Auto-format your Python code to conform to the repository's code standards (ruff).</li> <li>Inline linting and auto-completion (thanks to Python type hints).</li> <li>Spell-check your code and docs.</li> <li>Graphical exploration of test cases and easy test execution/debug.</li> </ul>"},{"location":"getting_started/setup_vs_code/#installation","title":"Installation","text":"<p>Please refer to the Visual Studio Code docs for help with installation.</p>"},{"location":"getting_started/setup_vs_code/#vs-code-settings-file","title":"VS Code Settings file","text":"<p>The ethereum/execution-spec-tests repo includes configuration files for VS Code in the <code>.vscode/</code> sub-directory:</p> <pre><code>\ud83d\udcc1 execution-test-specs/\n\u2514\u2500\u2500\ud83d\udcc1 .vscode/\n    \u251c\u2500\u2500 \ud83d\udcc4 settings.json\n    \u251c\u2500\u2500 \ud83d\udcc4 extensions.json\n    \u2514\u2500\u2500 \ud83d\udcc4 launch.recommended.json\n</code></pre> <p>By default, the repository settings are applied via <code>.vscode/settings.json</code>.</p> <p>To enable the recommended launch configurations (that include some useful debugging configurations), copy the recommended launch configuration file to <code>.vscode/launch.json</code>:</p> <pre><code>cp .vscode/launch.recommended.json .vscode/launch.json\n</code></pre>"},{"location":"getting_started/setup_vs_code/#vs-code-extension-configuration","title":"VS Code Extension Configuration","text":"<p>The extensions listed in <code>.vscode/extensions.json</code> are required for a smooth developer experience.</p> <ol> <li> <p>Open the root folder of your local <code>execution-spec-tests</code> clone in VS Code, it will prompt you to install the repository's required extensions (from <code>.vscode/extensions.json</code> - you will be required to trust the <code>executions-spec-tests</code> repository first). These extensions are used to format, lint, type check and run tests on the codebase. After all the required extensions are installed a VS Code reload will be required.</p> </li> <li> <p>If previously installed, ensure that the following <code>ms-python</code> extensions are disabled for the <code>execution-spec-tests</code> workspace to ensure there are no conflicts with the <code>ruff</code> formatter. In the VS Code Extensions tab, search for the each of the extensions below, and if installed and enabled, open the \"Disabled\" menu and select \"Disable (Workspace)\". This ensures that the extensions will be available with other workspaces that may need them.</p> <ul> <li><code>ms-python.isort</code></li> <li><code>ms-python.flake8</code></li> <li><code>ms-python.black-formatter</code></li> </ul> <p> </p> </li> </ol>"},{"location":"getting_started/setup_vs_code/#configuration-for-testing-evm-features-under-active-development","title":"Configuration for Testing EVM Features Under Active Development","text":"<p>An additional step is required to enable fixture generations for features from forks that are under active development and have not been deployed to mainnet, see Filling Tests for Features under Development.</p>"},{"location":"library/","title":"Library (Tools) Reference Documentation","text":"<p>Execution spec tests consists of several packages that implement helper classes and tools that enable and simplify test case implementation. This section contains their reference documentation:</p> <ul> <li><code>ethereum_test_base_types</code> - provides the basic types on top of which other testing libraries are built.</li> <li><code>ethereum_test_exceptions</code> - provides definitions for exceptions used in all tests.</li> <li><code>ethereum_test_fixtures</code> - provides definitions of all test fixture types that are produced in this repository and can be consumed by clients.</li> <li><code>ethereum_test_forks</code> - provides definitions for supported forks used in tests.</li> <li><code>ethereum_test_specs</code> - provides definitions for all spec types used to define test cases, and generate different kinds of test fixtures.</li> <li><code>ethereum_test_tools</code> - provides primitives and helpers to test Ethereum execution clients.</li> <li><code>ethereum_test_types</code> - provides Ethereum types built on top of the base types which are used to define test cases and interact with other libraries.</li> <li><code>ethereum_test_vm</code> - provides definitions for the Ethereum Virtual Machine (EVM) as used to define bytecode in test cases.</li> <li><code>ethereum_clis</code> - a wrapper for the transition (<code>t8n</code>) tool.</li> <li><code>pytest_plugins</code> - contains pytest customizations that provide additional functionality for generating test fixtures.</li> </ul>"},{"location":"library/ethereum_clis/","title":"Ethereum CLIs Package","text":"<p>Library of Python wrappers for the different implementations of transition tools.</p>"},{"location":"library/ethereum_clis/#ethereum_clis.BesuTransitionTool","title":"<code>BesuTransitionTool</code>","text":"<p>               Bases: <code>TransitionTool</code></p> <p>Besu EvmTool Transition tool frontend wrapper class.</p> Source code in <code>src/ethereum_clis/clis/besu.py</code> <pre><code>class BesuTransitionTool(TransitionTool):\n    \"\"\"Besu EvmTool Transition tool frontend wrapper class.\"\"\"\n\n    default_binary = Path(\"evm\")\n    detect_binary_pattern = re.compile(r\"^Besu evm .*$\")\n    binary: Path\n    cached_version: Optional[str] = None\n    trace: bool\n    process: Optional[subprocess.Popen] = None\n    server_url: str\n    besu_trace_dir: Optional[tempfile.TemporaryDirectory]\n\n    def __init__(\n        self,\n        *,\n        binary: Optional[Path] = None,\n        trace: bool = False,\n    ):\n        \"\"\"Initialize the BesuTransitionTool class.\"\"\"\n        super().__init__(exception_mapper=BesuExceptionMapper(), binary=binary, trace=trace)\n        args = [str(self.binary), \"t8n\", \"--help\"]\n        try:\n            result = subprocess.run(args, capture_output=True, text=True)\n        except subprocess.CalledProcessError as e:\n            raise Exception(\n                f\"evm process unexpectedly returned a non-zero status code: {e}.\"\n            ) from e\n        except Exception as e:\n            raise Exception(f\"Unexpected exception calling evm tool: {e}.\") from e\n        self.help_string = result.stdout\n        self.besu_trace_dir = tempfile.TemporaryDirectory() if self.trace else None\n\n    def start_server(self):\n        \"\"\"\n        Start the t8n-server process, extract the port, and leave it running\n        for future re-use.\n        \"\"\"\n        args = [\n            str(self.binary),\n            \"t8n-server\",\n            \"--port=0\",  # OS assigned server port\n        ]\n\n        if self.trace:\n            args.append(\"--trace\")\n            args.append(f\"--output.basedir={self.besu_trace_dir.name}\")\n\n        self.process = subprocess.Popen(\n            args=args,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n        )\n\n        while True:\n            line = str(self.process.stdout.readline())\n\n            if not line or \"Failed to start transition server\" in line:\n                raise Exception(\"Failed starting Besu subprocess\\n\" + line)\n            if \"Transition server listening on\" in line:\n                port = re.search(\"Transition server listening on (\\\\d+)\", line).group(1)\n                self.server_url = f\"http://localhost:{port}/\"\n                break\n\n    def shutdown(self):\n        \"\"\"Stop the t8n-server process if it was started.\"\"\"\n        if self.process:\n            self.process.kill()\n        if self.besu_trace_dir:\n            self.besu_trace_dir.cleanup()\n\n    def evaluate(\n        self,\n        *,\n        alloc: Alloc,\n        txs: List[Transaction],\n        env: Environment,\n        fork: Fork,\n        chain_id: int,\n        reward: int,\n        blob_schedule: BlobSchedule | None = None,\n        eips: Optional[List[int]] = None,\n        debug_output_path: str = \"\",\n        state_test: bool = False,\n        slow_request: bool = False,\n    ) -&gt; TransitionToolOutput:\n        \"\"\"Execute `evm t8n` with the specified arguments.\"\"\"\n        if not self.process:\n            self.start_server()\n\n        fork_name = fork.transition_tool_name(\n            block_number=env.number,\n            timestamp=env.timestamp,\n        )\n        if eips is not None:\n            fork_name = \"+\".join([fork_name] + [str(eip) for eip in eips])\n\n        input_json = TransitionToolInput(\n            alloc=alloc,\n            txs=txs,\n            env=env,\n        ).model_dump(mode=\"json\", **model_dump_config)\n\n        state_json = {\n            \"fork\": fork_name,\n            \"chainid\": chain_id,\n            \"reward\": reward,\n        }\n\n        post_data = {\"state\": state_json, \"input\": input_json}\n\n        if debug_output_path:\n            post_data_string = json.dumps(post_data, indent=4)\n            additional_indent = \" \" * 16  # for pretty indentation in t8n.sh\n            indented_post_data_string = \"{\\n\" + \"\\n\".join(\n                additional_indent + line for line in post_data_string[1:].splitlines()\n            )\n            t8n_script = textwrap.dedent(\n                f\"\"\"\\\n                #!/bin/bash\n                # Use $1 as t8n-server port if provided, else default to 3000\n                PORT=${{1:-3000}}\n                curl http://localhost:${{PORT}}/ -X POST -H \"Content-Type: application/json\" \\\\\n                --data '{indented_post_data_string}'\n                \"\"\"\n            )\n            dump_files_to_directory(\n                debug_output_path,\n                {\n                    \"state.json\": state_json,\n                    \"input/alloc.json\": input_json[\"alloc\"],\n                    \"input/env.json\": input_json[\"env\"],\n                    \"input/txs.json\": input_json[\"txs\"],\n                    \"t8n.sh+x\": t8n_script,\n                },\n            )\n\n        response = requests.post(self.server_url, json=post_data, timeout=5)\n        response.raise_for_status()  # exception visible in pytest failure output\n        output: TransitionToolOutput = TransitionToolOutput.model_validate(response.json())\n\n        if debug_output_path:\n            dump_files_to_directory(\n                debug_output_path,\n                {\n                    \"response.txt\": response.text,\n                    \"status_code.txt\": response.status_code,\n                    \"time_elapsed_seconds.txt\": response.elapsed.total_seconds(),\n                },\n            )\n\n        if response.status_code != 200:\n            raise Exception(\n                f\"t8n-server returned status code {response.status_code}, \"\n                f\"response: {response.text}\"\n            )\n\n        if debug_output_path:\n            dump_files_to_directory(\n                debug_output_path,\n                {\n                    \"output/alloc.json\": output.alloc.model_dump(mode=\"json\", **model_dump_config),\n                    \"output/result.json\": output.result.model_dump(\n                        mode=\"json\", **model_dump_config\n                    ),\n                    \"output/txs.rlp\": str(output.body),\n                },\n            )\n\n        if self.trace and self.besu_trace_dir:\n            self.collect_traces(output.result.receipts, self.besu_trace_dir, debug_output_path)\n            for i, r in enumerate(output.result.receipts):\n                trace_file_name = f\"trace-{i}-{r.transaction_hash}.jsonl\"\n                os.remove(os.path.join(self.besu_trace_dir.name, trace_file_name))\n\n        return output\n\n    def is_fork_supported(self, fork: Fork) -&gt; bool:\n        \"\"\"Return True if the fork is supported by the tool.\"\"\"\n        return fork.transition_tool_name() in self.help_string\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.BesuTransitionTool.__init__","title":"<code>__init__(*, binary=None, trace=False)</code>","text":"<p>Initialize the BesuTransitionTool class.</p> Source code in <code>src/ethereum_clis/clis/besu.py</code> <pre><code>def __init__(\n    self,\n    *,\n    binary: Optional[Path] = None,\n    trace: bool = False,\n):\n    \"\"\"Initialize the BesuTransitionTool class.\"\"\"\n    super().__init__(exception_mapper=BesuExceptionMapper(), binary=binary, trace=trace)\n    args = [str(self.binary), \"t8n\", \"--help\"]\n    try:\n        result = subprocess.run(args, capture_output=True, text=True)\n    except subprocess.CalledProcessError as e:\n        raise Exception(\n            f\"evm process unexpectedly returned a non-zero status code: {e}.\"\n        ) from e\n    except Exception as e:\n        raise Exception(f\"Unexpected exception calling evm tool: {e}.\") from e\n    self.help_string = result.stdout\n    self.besu_trace_dir = tempfile.TemporaryDirectory() if self.trace else None\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.BesuTransitionTool.start_server","title":"<code>start_server()</code>","text":"<p>Start the t8n-server process, extract the port, and leave it running for future re-use.</p> Source code in <code>src/ethereum_clis/clis/besu.py</code> <pre><code>def start_server(self):\n    \"\"\"\n    Start the t8n-server process, extract the port, and leave it running\n    for future re-use.\n    \"\"\"\n    args = [\n        str(self.binary),\n        \"t8n-server\",\n        \"--port=0\",  # OS assigned server port\n    ]\n\n    if self.trace:\n        args.append(\"--trace\")\n        args.append(f\"--output.basedir={self.besu_trace_dir.name}\")\n\n    self.process = subprocess.Popen(\n        args=args,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT,\n    )\n\n    while True:\n        line = str(self.process.stdout.readline())\n\n        if not line or \"Failed to start transition server\" in line:\n            raise Exception(\"Failed starting Besu subprocess\\n\" + line)\n        if \"Transition server listening on\" in line:\n            port = re.search(\"Transition server listening on (\\\\d+)\", line).group(1)\n            self.server_url = f\"http://localhost:{port}/\"\n            break\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.BesuTransitionTool.shutdown","title":"<code>shutdown()</code>","text":"<p>Stop the t8n-server process if it was started.</p> Source code in <code>src/ethereum_clis/clis/besu.py</code> <pre><code>def shutdown(self):\n    \"\"\"Stop the t8n-server process if it was started.\"\"\"\n    if self.process:\n        self.process.kill()\n    if self.besu_trace_dir:\n        self.besu_trace_dir.cleanup()\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.BesuTransitionTool.evaluate","title":"<code>evaluate(*, alloc, txs, env, fork, chain_id, reward, blob_schedule=None, eips=None, debug_output_path='', state_test=False, slow_request=False)</code>","text":"<p>Execute <code>evm t8n</code> with the specified arguments.</p> Source code in <code>src/ethereum_clis/clis/besu.py</code> <pre><code>def evaluate(\n    self,\n    *,\n    alloc: Alloc,\n    txs: List[Transaction],\n    env: Environment,\n    fork: Fork,\n    chain_id: int,\n    reward: int,\n    blob_schedule: BlobSchedule | None = None,\n    eips: Optional[List[int]] = None,\n    debug_output_path: str = \"\",\n    state_test: bool = False,\n    slow_request: bool = False,\n) -&gt; TransitionToolOutput:\n    \"\"\"Execute `evm t8n` with the specified arguments.\"\"\"\n    if not self.process:\n        self.start_server()\n\n    fork_name = fork.transition_tool_name(\n        block_number=env.number,\n        timestamp=env.timestamp,\n    )\n    if eips is not None:\n        fork_name = \"+\".join([fork_name] + [str(eip) for eip in eips])\n\n    input_json = TransitionToolInput(\n        alloc=alloc,\n        txs=txs,\n        env=env,\n    ).model_dump(mode=\"json\", **model_dump_config)\n\n    state_json = {\n        \"fork\": fork_name,\n        \"chainid\": chain_id,\n        \"reward\": reward,\n    }\n\n    post_data = {\"state\": state_json, \"input\": input_json}\n\n    if debug_output_path:\n        post_data_string = json.dumps(post_data, indent=4)\n        additional_indent = \" \" * 16  # for pretty indentation in t8n.sh\n        indented_post_data_string = \"{\\n\" + \"\\n\".join(\n            additional_indent + line for line in post_data_string[1:].splitlines()\n        )\n        t8n_script = textwrap.dedent(\n            f\"\"\"\\\n            #!/bin/bash\n            # Use $1 as t8n-server port if provided, else default to 3000\n            PORT=${{1:-3000}}\n            curl http://localhost:${{PORT}}/ -X POST -H \"Content-Type: application/json\" \\\\\n            --data '{indented_post_data_string}'\n            \"\"\"\n        )\n        dump_files_to_directory(\n            debug_output_path,\n            {\n                \"state.json\": state_json,\n                \"input/alloc.json\": input_json[\"alloc\"],\n                \"input/env.json\": input_json[\"env\"],\n                \"input/txs.json\": input_json[\"txs\"],\n                \"t8n.sh+x\": t8n_script,\n            },\n        )\n\n    response = requests.post(self.server_url, json=post_data, timeout=5)\n    response.raise_for_status()  # exception visible in pytest failure output\n    output: TransitionToolOutput = TransitionToolOutput.model_validate(response.json())\n\n    if debug_output_path:\n        dump_files_to_directory(\n            debug_output_path,\n            {\n                \"response.txt\": response.text,\n                \"status_code.txt\": response.status_code,\n                \"time_elapsed_seconds.txt\": response.elapsed.total_seconds(),\n            },\n        )\n\n    if response.status_code != 200:\n        raise Exception(\n            f\"t8n-server returned status code {response.status_code}, \"\n            f\"response: {response.text}\"\n        )\n\n    if debug_output_path:\n        dump_files_to_directory(\n            debug_output_path,\n            {\n                \"output/alloc.json\": output.alloc.model_dump(mode=\"json\", **model_dump_config),\n                \"output/result.json\": output.result.model_dump(\n                    mode=\"json\", **model_dump_config\n                ),\n                \"output/txs.rlp\": str(output.body),\n            },\n        )\n\n    if self.trace and self.besu_trace_dir:\n        self.collect_traces(output.result.receipts, self.besu_trace_dir, debug_output_path)\n        for i, r in enumerate(output.result.receipts):\n            trace_file_name = f\"trace-{i}-{r.transaction_hash}.jsonl\"\n            os.remove(os.path.join(self.besu_trace_dir.name, trace_file_name))\n\n    return output\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.BesuTransitionTool.is_fork_supported","title":"<code>is_fork_supported(fork)</code>","text":"<p>Return True if the fork is supported by the tool.</p> Source code in <code>src/ethereum_clis/clis/besu.py</code> <pre><code>def is_fork_supported(self, fork: Fork) -&gt; bool:\n    \"\"\"Return True if the fork is supported by the tool.\"\"\"\n    return fork.transition_tool_name() in self.help_string\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.EthereumJSTransitionTool","title":"<code>EthereumJSTransitionTool</code>","text":"<p>               Bases: <code>TransitionTool</code></p> <p>EthereumJS Transition tool interface wrapper class.</p> Source code in <code>src/ethereum_clis/clis/ethereumjs.py</code> <pre><code>class EthereumJSTransitionTool(TransitionTool):\n    \"\"\"EthereumJS Transition tool interface wrapper class.\"\"\"\n\n    default_binary = Path(\"ethereumjs-t8ntool.sh\")\n    detect_binary_pattern = re.compile(r\"^ethereumjs t8n\\b\")\n    version_flag: str = \"--version\"\n    t8n_use_stream = False\n\n    binary: Path\n    cached_version: Optional[str] = None\n    trace: bool\n\n    def __init__(\n        self,\n        *,\n        binary: Optional[Path] = None,\n        trace: bool = False,\n    ):\n        \"\"\"Initialize the EthereumJS Transition tool interface.\"\"\"\n        super().__init__(exception_mapper=EthereumJSExceptionMapper(), binary=binary, trace=trace)\n\n    def is_fork_supported(self, fork: Fork) -&gt; bool:\n        \"\"\"\n        Return True if the fork is supported by the tool.\n        Currently, EthereumJS-t8n provides no way to determine supported forks.\n        \"\"\"\n        return True\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.EthereumJSTransitionTool.__init__","title":"<code>__init__(*, binary=None, trace=False)</code>","text":"<p>Initialize the EthereumJS Transition tool interface.</p> Source code in <code>src/ethereum_clis/clis/ethereumjs.py</code> <pre><code>def __init__(\n    self,\n    *,\n    binary: Optional[Path] = None,\n    trace: bool = False,\n):\n    \"\"\"Initialize the EthereumJS Transition tool interface.\"\"\"\n    super().__init__(exception_mapper=EthereumJSExceptionMapper(), binary=binary, trace=trace)\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.EthereumJSTransitionTool.is_fork_supported","title":"<code>is_fork_supported(fork)</code>","text":"<p>Return True if the fork is supported by the tool. Currently, EthereumJS-t8n provides no way to determine supported forks.</p> Source code in <code>src/ethereum_clis/clis/ethereumjs.py</code> <pre><code>def is_fork_supported(self, fork: Fork) -&gt; bool:\n    \"\"\"\n    Return True if the fork is supported by the tool.\n    Currently, EthereumJS-t8n provides no way to determine supported forks.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.EvmoneExceptionMapper","title":"<code>EvmoneExceptionMapper</code>","text":"<p>               Bases: <code>ExceptionMapper</code></p> <p>Translate between EEST exceptions and error strings returned by Evmone.</p> Source code in <code>src/ethereum_clis/clis/evmone.py</code> <pre><code>class EvmoneExceptionMapper(ExceptionMapper):\n    \"\"\"Translate between EEST exceptions and error strings returned by Evmone.\"\"\"\n\n    @property\n    def _mapping_data(self):\n        return [\n            ExceptionMessage(\n                TransactionException.TYPE_4_TX_CONTRACT_CREATION,\n                \"set code transaction must \",\n            ),\n            ExceptionMessage(\n                TransactionException.TYPE_4_INVALID_AUTHORITY_SIGNATURE,\n                \"invalid authorization signature\",\n            ),\n            ExceptionMessage(\n                TransactionException.TYPE_4_INVALID_AUTHORITY_SIGNATURE_S_TOO_HIGH,\n                \"authorization signature s value too high\",\n            ),\n            ExceptionMessage(\n                TransactionException.TYPE_4_EMPTY_AUTHORIZATION_LIST,\n                \"empty authorization list\",\n            ),\n            ExceptionMessage(\n                TransactionException.INTRINSIC_GAS_TOO_LOW,\n                \"intrinsic gas too low\",\n            ),\n            ExceptionMessage(\n                TransactionException.TYPE_3_TX_MAX_BLOB_GAS_ALLOWANCE_EXCEEDED,\n                \"lob gas limit exceeded\",\n            ),\n            ExceptionMessage(\n                TransactionException.INITCODE_SIZE_EXCEEDED,\n                \"max initcode size exceeded\",\n            ),\n            ExceptionMessage(\n                TransactionException.INSUFFICIENT_ACCOUNT_FUNDS,\n                \"insufficient funds for gas * price + value\",\n            ),\n            ExceptionMessage(\n                TransactionException.INSUFFICIENT_MAX_FEE_PER_GAS,\n                \"max fee per gas less than block base fee\",\n            ),\n            ExceptionMessage(\n                TransactionException.INSUFFICIENT_MAX_FEE_PER_BLOB_GAS,\n                \"fee per gas less than block base fee\",\n            ),\n            ExceptionMessage(\n                TransactionException.TYPE_3_TX_PRE_FORK,\n                \"transaction type not supported\",\n            ),\n            ExceptionMessage(\n                TransactionException.TYPE_3_TX_INVALID_BLOB_VERSIONED_HASH,\n                \"invalid blob hash version\",\n            ),\n            ExceptionMessage(\n                TransactionException.TYPE_3_TX_BLOB_COUNT_EXCEEDED,\n                \"blob gas limit exceeded\",\n            ),\n            ExceptionMessage(\n                TransactionException.TYPE_3_TX_ZERO_BLOBS,\n                \"empty blob hashes list\",\n            ),\n            ExceptionMessage(\n                TransactionException.NONCE_MISMATCH_TOO_LOW,\n                \"nonce too low\",\n            ),\n            ExceptionMessage(\n                TransactionException.NONCE_MISMATCH_TOO_HIGH,\n                \"nonce too high\",\n            ),\n            # TODO EVMONE needs to differentiate when the section is missing in the header or body\n            ExceptionMessage(EOFException.MISSING_STOP_OPCODE, \"err: no_terminating_instruction\"),\n            ExceptionMessage(EOFException.MISSING_CODE_HEADER, \"err: code_section_missing\"),\n            ExceptionMessage(EOFException.MISSING_TYPE_HEADER, \"err: type_section_missing\"),\n            # TODO EVMONE these exceptions are too similar, this leeds to ambiguity\n            ExceptionMessage(EOFException.MISSING_TERMINATOR, \"err: header_terminator_missing\"),\n            ExceptionMessage(\n                EOFException.MISSING_HEADERS_TERMINATOR, \"err: section_headers_not_terminated\"\n            ),\n            ExceptionMessage(EOFException.INVALID_VERSION, \"err: eof_version_unknown\"),\n            ExceptionMessage(\n                EOFException.INVALID_NON_RETURNING_FLAG, \"err: invalid_non_returning_flag\"\n            ),\n            ExceptionMessage(EOFException.INVALID_MAGIC, \"err: invalid_prefix\"),\n            ExceptionMessage(\n                EOFException.INVALID_FIRST_SECTION_TYPE, \"err: invalid_first_section_type\"\n            ),\n            ExceptionMessage(\n                EOFException.INVALID_SECTION_BODIES_SIZE, \"err: invalid_section_bodies_size\"\n            ),\n            ExceptionMessage(\n                EOFException.INVALID_TYPE_SECTION_SIZE, \"err: invalid_type_section_size\"\n            ),\n            ExceptionMessage(EOFException.INCOMPLETE_SECTION_SIZE, \"err: incomplete_section_size\"),\n            ExceptionMessage(\n                EOFException.INCOMPLETE_SECTION_NUMBER, \"err: incomplete_section_number\"\n            ),\n            ExceptionMessage(EOFException.TOO_MANY_CODE_SECTIONS, \"err: too_many_code_sections\"),\n            ExceptionMessage(EOFException.ZERO_SECTION_SIZE, \"err: zero_section_size\"),\n            ExceptionMessage(EOFException.MISSING_DATA_SECTION, \"err: data_section_missing\"),\n            ExceptionMessage(EOFException.UNDEFINED_INSTRUCTION, \"err: undefined_instruction\"),\n            ExceptionMessage(\n                EOFException.INPUTS_OUTPUTS_NUM_ABOVE_LIMIT, \"err: inputs_outputs_num_above_limit\"\n            ),\n            ExceptionMessage(\n                EOFException.UNREACHABLE_INSTRUCTIONS, \"err: unreachable_instructions\"\n            ),\n            ExceptionMessage(\n                EOFException.INVALID_RJUMP_DESTINATION, \"err: invalid_rjump_destination\"\n            ),\n            ExceptionMessage(\n                EOFException.UNREACHABLE_CODE_SECTIONS, \"err: unreachable_code_sections\"\n            ),\n            ExceptionMessage(EOFException.STACK_UNDERFLOW, \"err: stack_underflow\"),\n            ExceptionMessage(EOFException.STACK_OVERFLOW, \"err: stack_overflow\"),\n            ExceptionMessage(\n                EOFException.MAX_STACK_HEIGHT_ABOVE_LIMIT, \"err: max_stack_height_above_limit\"\n            ),\n            ExceptionMessage(\n                EOFException.STACK_HIGHER_THAN_OUTPUTS, \"err: stack_higher_than_outputs_required\"\n            ),\n            ExceptionMessage(\n                EOFException.JUMPF_DESTINATION_INCOMPATIBLE_OUTPUTS,\n                \"err: jumpf_destination_incompatible_outputs\",\n            ),\n            ExceptionMessage(\n                EOFException.INVALID_MAX_STACK_HEIGHT, \"err: invalid_max_stack_height\"\n            ),\n            ExceptionMessage(EOFException.INVALID_DATALOADN_INDEX, \"err: invalid_dataloadn_index\"),\n            ExceptionMessage(EOFException.TRUNCATED_INSTRUCTION, \"err: truncated_instruction\"),\n            ExceptionMessage(\n                EOFException.TOPLEVEL_CONTAINER_TRUNCATED, \"err: toplevel_container_truncated\"\n            ),\n            ExceptionMessage(EOFException.ORPHAN_SUBCONTAINER, \"err: unreferenced_subcontainer\"),\n            ExceptionMessage(\n                EOFException.CONTAINER_SIZE_ABOVE_LIMIT, \"err: container_size_above_limit\"\n            ),\n            ExceptionMessage(\n                EOFException.INVALID_CONTAINER_SECTION_INDEX,\n                \"err: invalid_container_section_index\",\n            ),\n            ExceptionMessage(\n                EOFException.INCOMPATIBLE_CONTAINER_KIND, \"err: incompatible_container_kind\"\n            ),\n            ExceptionMessage(\n                EOFException.AMBIGUOUS_CONTAINER_KIND, \"err: ambiguous_container_kind\"\n            ),\n            ExceptionMessage(EOFException.STACK_HEIGHT_MISMATCH, \"err: stack_height_mismatch\"),\n            ExceptionMessage(EOFException.TOO_MANY_CONTAINERS, \"err: too_many_container_sections\"),\n            ExceptionMessage(\n                EOFException.INVALID_CODE_SECTION_INDEX, \"err: invalid_code_section_index\"\n            ),\n            ExceptionMessage(\n                EOFException.CALLF_TO_NON_RETURNING, \"err: callf_to_non_returning_function\"\n            ),\n            ExceptionMessage(\n                EOFException.EOFCREATE_WITH_TRUNCATED_CONTAINER,\n                \"err: eofcreate_with_truncated_container\",\n            ),\n        ]\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.EvmOneTransitionTool","title":"<code>EvmOneTransitionTool</code>","text":"<p>               Bases: <code>TransitionTool</code></p> <p>Evmone <code>evmone-t8n</code> Transition tool interface wrapper class.</p> Source code in <code>src/ethereum_clis/clis/evmone.py</code> <pre><code>class EvmOneTransitionTool(TransitionTool):\n    \"\"\"Evmone `evmone-t8n` Transition tool interface wrapper class.\"\"\"\n\n    default_binary = Path(\"evmone-t8n\")\n    detect_binary_pattern = re.compile(r\"^evmone-t8n\\b\")\n    t8n_use_stream = False\n\n    binary: Path\n    cached_version: Optional[str] = None\n    trace: bool\n\n    def __init__(\n        self,\n        *,\n        binary: Optional[Path] = None,\n        trace: bool = False,\n    ):\n        \"\"\"Initialize the Evmone Transition tool interface.\"\"\"\n        super().__init__(exception_mapper=EvmoneExceptionMapper(), binary=binary, trace=trace)\n\n    def is_fork_supported(self, fork: Fork) -&gt; bool:\n        \"\"\"\n        Return True if the fork is supported by the tool.\n        Currently, evmone-t8n provides no way to determine supported forks.\n        \"\"\"\n        return True\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.EvmOneTransitionTool.__init__","title":"<code>__init__(*, binary=None, trace=False)</code>","text":"<p>Initialize the Evmone Transition tool interface.</p> Source code in <code>src/ethereum_clis/clis/evmone.py</code> <pre><code>def __init__(\n    self,\n    *,\n    binary: Optional[Path] = None,\n    trace: bool = False,\n):\n    \"\"\"Initialize the Evmone Transition tool interface.\"\"\"\n    super().__init__(exception_mapper=EvmoneExceptionMapper(), binary=binary, trace=trace)\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.EvmOneTransitionTool.is_fork_supported","title":"<code>is_fork_supported(fork)</code>","text":"<p>Return True if the fork is supported by the tool. Currently, evmone-t8n provides no way to determine supported forks.</p> Source code in <code>src/ethereum_clis/clis/evmone.py</code> <pre><code>def is_fork_supported(self, fork: Fork) -&gt; bool:\n    \"\"\"\n    Return True if the fork is supported by the tool.\n    Currently, evmone-t8n provides no way to determine supported forks.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.ExecutionSpecsTransitionTool","title":"<code>ExecutionSpecsTransitionTool</code>","text":"<p>               Bases: <code>TransitionTool</code></p> <p>Ethereum Specs EVM Resolver <code>ethereum-spec-evm-resolver</code> Transition Tool wrapper class.</p> <p><code>ethereum-spec-evm-resolver</code> is installed by default for <code>execution-spec-tests</code>: <pre><code>uv run fill --evm-bin=ethereum-spec-evm-resolver\n</code></pre></p> <p>To use a specific version of the <code>ethereum-spec-evm-resolver</code> tool, update it to the desired version in <code>pyproject.toml</code>.</p> <p>The <code>ethereum-spec-evm-resolver</code> tool essentially wraps around the EELS evm daemon. It can handle requests for different EVM forks, even when those forks are implemented by different versions of EELS hosted in different places.</p> Source code in <code>src/ethereum_clis/clis/execution_specs.py</code> <pre><code>class ExecutionSpecsTransitionTool(TransitionTool):\n    \"\"\"\n    Ethereum Specs EVM Resolver `ethereum-spec-evm-resolver` Transition Tool wrapper class.\n\n    `ethereum-spec-evm-resolver` is installed by default for `execution-spec-tests`:\n    ```console\n    uv run fill --evm-bin=ethereum-spec-evm-resolver\n    ```\n\n    To use a specific version of the `ethereum-spec-evm-resolver` tool, update it to the\n    desired version in `pyproject.toml`.\n\n    The `ethereum-spec-evm-resolver` tool essentially wraps around the EELS evm daemon. It can\n    handle requests for different EVM forks, even when those forks are implemented by different\n    versions of EELS hosted in different places.\n    \"\"\"\n\n    default_binary = Path(\"ethereum-spec-evm-resolver\")\n    detect_binary_pattern = re.compile(r\"^ethereum-spec-evm-resolver\\b\")\n    t8n_use_server: bool = True\n    server_dir: Optional[TemporaryDirectory] = None\n\n    def __init__(\n        self,\n        *,\n        binary: Optional[Path] = None,\n        trace: bool = False,\n    ):\n        \"\"\"Initialize the Ethereum Specs EVM Resolver Transition Tool interface.\"\"\"\n        os.environ.setdefault(\"NO_PROXY\", \"*\")  # Disable proxy for local connections\n        super().__init__(\n            exception_mapper=ExecutionSpecsExceptionMapper(), binary=binary, trace=trace\n        )\n        args = [str(self.binary), \"--help\"]\n        try:\n            result = subprocess.run(args, capture_output=True, text=True)\n        except subprocess.CalledProcessError as e:\n            raise Exception(\n                \"ethereum-spec-evm-resolver process unexpectedly returned a non-zero status code: \"\n                f\"{e}.\"\n            ) from e\n        except Exception as e:\n            raise Exception(\n                f\"Unexpected exception calling ethereum-spec-evm-resolver: {e}.\"\n            ) from e\n        self.help_string = result.stdout\n\n    def start_server(self):\n        \"\"\"\n        Start the t8n-server process, extract the port, and leave it running\n        for future re-use.\n        \"\"\"\n        self.server_dir = TemporaryDirectory()\n        self.server_file_path = Path(self.server_dir.name) / \"t8n.sock\"\n        replaced_str = str(self.server_file_path).replace(\"/\", \"%2F\")\n        self.server_url = f\"http+unix://{replaced_str}/\"\n        self.process = subprocess.Popen(\n            args=[\n                str(self.binary),\n                \"daemon\",\n                \"--uds\",\n                self.server_file_path,\n            ],\n        )\n        start = time.time()\n        while True:\n            if self.server_file_path.exists():\n                break\n            if time.time() - start &gt; DAEMON_STARTUP_TIMEOUT_SECONDS:\n                raise Exception(\"Failed starting ethereum-spec-evm subprocess\")\n            time.sleep(0)  # yield to other processes\n\n    def shutdown(self):\n        \"\"\"Stop the t8n-server process if it was started.\"\"\"\n        if self.process:\n            self.process.terminate()\n        if self.server_dir:\n            self.server_dir.cleanup()\n            self.server_dir = None\n\n    def is_fork_supported(self, fork: Fork) -&gt; bool:\n        \"\"\"\n        Return True if the fork is supported by the tool.\n\n        If the fork is a transition fork, we want to check the fork it transitions to.\n\n        `ethereum-spec-evm` appends newlines to forks in the help string.\n        \"\"\"\n        return (fork.transition_tool_name() + \"\\n\") in self.help_string\n\n    def _generate_post_args(\n        self, t8n_data: TransitionTool.TransitionToolData\n    ) -&gt; Dict[str, List[str] | str]:\n        \"\"\"\n        Generate the arguments for the POST request to the t8n-server.\n\n        EELS T8N expects `--state-test` when running a state test.\n        \"\"\"\n        return {\"arg\": \"--state-test\"} if t8n_data.state_test else {}\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.ExecutionSpecsTransitionTool.__init__","title":"<code>__init__(*, binary=None, trace=False)</code>","text":"<p>Initialize the Ethereum Specs EVM Resolver Transition Tool interface.</p> Source code in <code>src/ethereum_clis/clis/execution_specs.py</code> <pre><code>def __init__(\n    self,\n    *,\n    binary: Optional[Path] = None,\n    trace: bool = False,\n):\n    \"\"\"Initialize the Ethereum Specs EVM Resolver Transition Tool interface.\"\"\"\n    os.environ.setdefault(\"NO_PROXY\", \"*\")  # Disable proxy for local connections\n    super().__init__(\n        exception_mapper=ExecutionSpecsExceptionMapper(), binary=binary, trace=trace\n    )\n    args = [str(self.binary), \"--help\"]\n    try:\n        result = subprocess.run(args, capture_output=True, text=True)\n    except subprocess.CalledProcessError as e:\n        raise Exception(\n            \"ethereum-spec-evm-resolver process unexpectedly returned a non-zero status code: \"\n            f\"{e}.\"\n        ) from e\n    except Exception as e:\n        raise Exception(\n            f\"Unexpected exception calling ethereum-spec-evm-resolver: {e}.\"\n        ) from e\n    self.help_string = result.stdout\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.ExecutionSpecsTransitionTool.start_server","title":"<code>start_server()</code>","text":"<p>Start the t8n-server process, extract the port, and leave it running for future re-use.</p> Source code in <code>src/ethereum_clis/clis/execution_specs.py</code> <pre><code>def start_server(self):\n    \"\"\"\n    Start the t8n-server process, extract the port, and leave it running\n    for future re-use.\n    \"\"\"\n    self.server_dir = TemporaryDirectory()\n    self.server_file_path = Path(self.server_dir.name) / \"t8n.sock\"\n    replaced_str = str(self.server_file_path).replace(\"/\", \"%2F\")\n    self.server_url = f\"http+unix://{replaced_str}/\"\n    self.process = subprocess.Popen(\n        args=[\n            str(self.binary),\n            \"daemon\",\n            \"--uds\",\n            self.server_file_path,\n        ],\n    )\n    start = time.time()\n    while True:\n        if self.server_file_path.exists():\n            break\n        if time.time() - start &gt; DAEMON_STARTUP_TIMEOUT_SECONDS:\n            raise Exception(\"Failed starting ethereum-spec-evm subprocess\")\n        time.sleep(0)  # yield to other processes\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.ExecutionSpecsTransitionTool.shutdown","title":"<code>shutdown()</code>","text":"<p>Stop the t8n-server process if it was started.</p> Source code in <code>src/ethereum_clis/clis/execution_specs.py</code> <pre><code>def shutdown(self):\n    \"\"\"Stop the t8n-server process if it was started.\"\"\"\n    if self.process:\n        self.process.terminate()\n    if self.server_dir:\n        self.server_dir.cleanup()\n        self.server_dir = None\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.ExecutionSpecsTransitionTool.is_fork_supported","title":"<code>is_fork_supported(fork)</code>","text":"<p>Return True if the fork is supported by the tool.</p> <p>If the fork is a transition fork, we want to check the fork it transitions to.</p> <p><code>ethereum-spec-evm</code> appends newlines to forks in the help string.</p> Source code in <code>src/ethereum_clis/clis/execution_specs.py</code> <pre><code>def is_fork_supported(self, fork: Fork) -&gt; bool:\n    \"\"\"\n    Return True if the fork is supported by the tool.\n\n    If the fork is a transition fork, we want to check the fork it transitions to.\n\n    `ethereum-spec-evm` appends newlines to forks in the help string.\n    \"\"\"\n    return (fork.transition_tool_name() + \"\\n\") in self.help_string\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.GethFixtureConsumer","title":"<code>GethFixtureConsumer</code>","text":"<p>               Bases: <code>GethEvm</code>, <code>FixtureConsumerTool</code></p> <p>Geth's implementation of the fixture consumer.</p> Source code in <code>src/ethereum_clis/clis/geth.py</code> <pre><code>class GethFixtureConsumer(\n    GethEvm,\n    FixtureConsumerTool,\n    fixture_formats=[StateFixture, BlockchainFixture],\n):\n    \"\"\"Geth's implementation of the fixture consumer.\"\"\"\n\n    def consume_blockchain_test(\n        self,\n        fixture_path: Path,\n        fixture_name: Optional[str] = None,\n        debug_output_path: Optional[Path] = None,\n    ):\n        \"\"\"\n        Consume a single blockchain test.\n\n        The `evm blocktest` command takes the `--run` argument which can be used to select a\n        specific fixture from the fixture file when executing.\n        \"\"\"\n        subcommand = \"blocktest\"\n        global_options = []\n        subcommand_options = []\n        if debug_output_path:\n            global_options += [\"--verbosity\", \"100\"]\n            subcommand_options += [\"--trace\"]\n\n        if fixture_name:\n            subcommand_options += [\"--run\", re.escape(fixture_name)]\n\n        command = (\n            [str(self.binary)]\n            + global_options\n            + [subcommand]\n            + subcommand_options\n            + [str(fixture_path)]\n        )\n\n        result = self._run_command(command)\n\n        if debug_output_path:\n            self._consume_debug_dump(command, result, fixture_path, debug_output_path)\n\n        if result.returncode != 0:\n            raise Exception(\n                f\"Unexpected exit code:\\n{' '.join(command)}\\n\\n Error:\\n{result.stderr}\"\n            )\n\n    @cache  # noqa\n    def consume_state_test_file(\n        self,\n        fixture_path: Path,\n        debug_output_path: Optional[Path] = None,\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Consume an entire state test file.\n\n        The `evm statetest` will always execute all the tests contained in a file without the\n        possibility of selecting a single test, so this function is cached in order to only call\n        the command once and `consume_state_test` can simply select the result that\n        was requested.\n        \"\"\"\n        subcommand = \"statetest\"\n        global_options: List[str] = []\n        subcommand_options: List[str] = []\n        if debug_output_path:\n            global_options += [\"--verbosity\", \"100\"]\n            subcommand_options += [\"--trace\"]\n\n        command = (\n            [str(self.binary)]\n            + global_options\n            + [subcommand]\n            + subcommand_options\n            + [str(fixture_path)]\n        )\n        result = self._run_command(command)\n\n        if debug_output_path:\n            self._consume_debug_dump(command, result, fixture_path, debug_output_path)\n\n        if result.returncode != 0:\n            raise Exception(\n                f\"Unexpected exit code:\\n{' '.join(command)}\\n\\n Error:\\n{result.stderr}\"\n            )\n\n        result_json = json.loads(result.stdout)\n        if not isinstance(result_json, list):\n            raise Exception(f\"Unexpected result from evm statetest: {result_json}\")\n        return result_json\n\n    def consume_state_test(\n        self,\n        fixture_path: Path,\n        fixture_name: Optional[str] = None,\n        debug_output_path: Optional[Path] = None,\n    ):\n        \"\"\"\n        Consume a single state test.\n\n        Uses the cached result from `consume_state_test_file` in order to not call the command\n        every time an select a single result from there.\n        \"\"\"\n        file_results = self.consume_state_test_file(\n            fixture_path=fixture_path,\n            debug_output_path=debug_output_path,\n        )\n        if fixture_name:\n            test_result = [\n                test_result for test_result in file_results if test_result[\"name\"] == fixture_name\n            ]\n            assert len(test_result) &lt; 2, f\"Multiple test results for {fixture_name}\"\n            assert len(test_result) == 1, f\"Test result for {fixture_name} missing\"\n            assert test_result[0][\"pass\"], f\"State test failed: {test_result[0]['error']}\"\n        else:\n            if any(not test_result[\"pass\"] for test_result in file_results):\n                exception_text = \"State test failed: \\n\" + \"\\n\".join(\n                    f\"{test_result['name']}: \" + test_result[\"error\"]\n                    for test_result in file_results\n                    if not test_result[\"pass\"]\n                )\n                raise Exception(exception_text)\n\n    def consume_fixture(\n        self,\n        fixture_format: FixtureFormat,\n        fixture_path: Path,\n        fixture_name: Optional[str] = None,\n        debug_output_path: Optional[Path] = None,\n    ):\n        \"\"\"Execute the appropriate geth fixture consumer for the fixture at `fixture_path`.\"\"\"\n        if fixture_format == BlockchainFixture:\n            self.consume_blockchain_test(\n                fixture_path=fixture_path,\n                fixture_name=fixture_name,\n                debug_output_path=debug_output_path,\n            )\n        elif fixture_format == StateFixture:\n            self.consume_state_test(\n                fixture_path=fixture_path,\n                fixture_name=fixture_name,\n                debug_output_path=debug_output_path,\n            )\n        else:\n            raise Exception(\n                f\"Fixture format {fixture_format.format_name} not supported by {self.binary}\"\n            )\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.GethFixtureConsumer.consume_blockchain_test","title":"<code>consume_blockchain_test(fixture_path, fixture_name=None, debug_output_path=None)</code>","text":"<p>Consume a single blockchain test.</p> <p>The <code>evm blocktest</code> command takes the <code>--run</code> argument which can be used to select a specific fixture from the fixture file when executing.</p> Source code in <code>src/ethereum_clis/clis/geth.py</code> <pre><code>def consume_blockchain_test(\n    self,\n    fixture_path: Path,\n    fixture_name: Optional[str] = None,\n    debug_output_path: Optional[Path] = None,\n):\n    \"\"\"\n    Consume a single blockchain test.\n\n    The `evm blocktest` command takes the `--run` argument which can be used to select a\n    specific fixture from the fixture file when executing.\n    \"\"\"\n    subcommand = \"blocktest\"\n    global_options = []\n    subcommand_options = []\n    if debug_output_path:\n        global_options += [\"--verbosity\", \"100\"]\n        subcommand_options += [\"--trace\"]\n\n    if fixture_name:\n        subcommand_options += [\"--run\", re.escape(fixture_name)]\n\n    command = (\n        [str(self.binary)]\n        + global_options\n        + [subcommand]\n        + subcommand_options\n        + [str(fixture_path)]\n    )\n\n    result = self._run_command(command)\n\n    if debug_output_path:\n        self._consume_debug_dump(command, result, fixture_path, debug_output_path)\n\n    if result.returncode != 0:\n        raise Exception(\n            f\"Unexpected exit code:\\n{' '.join(command)}\\n\\n Error:\\n{result.stderr}\"\n        )\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.GethFixtureConsumer.consume_state_test_file","title":"<code>consume_state_test_file(fixture_path, debug_output_path=None)</code>  <code>cached</code>","text":"<p>Consume an entire state test file.</p> <p>The <code>evm statetest</code> will always execute all the tests contained in a file without the possibility of selecting a single test, so this function is cached in order to only call the command once and <code>consume_state_test</code> can simply select the result that was requested.</p> Source code in <code>src/ethereum_clis/clis/geth.py</code> <pre><code>@cache  # noqa\ndef consume_state_test_file(\n    self,\n    fixture_path: Path,\n    debug_output_path: Optional[Path] = None,\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Consume an entire state test file.\n\n    The `evm statetest` will always execute all the tests contained in a file without the\n    possibility of selecting a single test, so this function is cached in order to only call\n    the command once and `consume_state_test` can simply select the result that\n    was requested.\n    \"\"\"\n    subcommand = \"statetest\"\n    global_options: List[str] = []\n    subcommand_options: List[str] = []\n    if debug_output_path:\n        global_options += [\"--verbosity\", \"100\"]\n        subcommand_options += [\"--trace\"]\n\n    command = (\n        [str(self.binary)]\n        + global_options\n        + [subcommand]\n        + subcommand_options\n        + [str(fixture_path)]\n    )\n    result = self._run_command(command)\n\n    if debug_output_path:\n        self._consume_debug_dump(command, result, fixture_path, debug_output_path)\n\n    if result.returncode != 0:\n        raise Exception(\n            f\"Unexpected exit code:\\n{' '.join(command)}\\n\\n Error:\\n{result.stderr}\"\n        )\n\n    result_json = json.loads(result.stdout)\n    if not isinstance(result_json, list):\n        raise Exception(f\"Unexpected result from evm statetest: {result_json}\")\n    return result_json\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.GethFixtureConsumer.consume_state_test","title":"<code>consume_state_test(fixture_path, fixture_name=None, debug_output_path=None)</code>","text":"<p>Consume a single state test.</p> <p>Uses the cached result from <code>consume_state_test_file</code> in order to not call the command every time an select a single result from there.</p> Source code in <code>src/ethereum_clis/clis/geth.py</code> <pre><code>def consume_state_test(\n    self,\n    fixture_path: Path,\n    fixture_name: Optional[str] = None,\n    debug_output_path: Optional[Path] = None,\n):\n    \"\"\"\n    Consume a single state test.\n\n    Uses the cached result from `consume_state_test_file` in order to not call the command\n    every time an select a single result from there.\n    \"\"\"\n    file_results = self.consume_state_test_file(\n        fixture_path=fixture_path,\n        debug_output_path=debug_output_path,\n    )\n    if fixture_name:\n        test_result = [\n            test_result for test_result in file_results if test_result[\"name\"] == fixture_name\n        ]\n        assert len(test_result) &lt; 2, f\"Multiple test results for {fixture_name}\"\n        assert len(test_result) == 1, f\"Test result for {fixture_name} missing\"\n        assert test_result[0][\"pass\"], f\"State test failed: {test_result[0]['error']}\"\n    else:\n        if any(not test_result[\"pass\"] for test_result in file_results):\n            exception_text = \"State test failed: \\n\" + \"\\n\".join(\n                f\"{test_result['name']}: \" + test_result[\"error\"]\n                for test_result in file_results\n                if not test_result[\"pass\"]\n            )\n            raise Exception(exception_text)\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.GethFixtureConsumer.consume_fixture","title":"<code>consume_fixture(fixture_format, fixture_path, fixture_name=None, debug_output_path=None)</code>","text":"<p>Execute the appropriate geth fixture consumer for the fixture at <code>fixture_path</code>.</p> Source code in <code>src/ethereum_clis/clis/geth.py</code> <pre><code>def consume_fixture(\n    self,\n    fixture_format: FixtureFormat,\n    fixture_path: Path,\n    fixture_name: Optional[str] = None,\n    debug_output_path: Optional[Path] = None,\n):\n    \"\"\"Execute the appropriate geth fixture consumer for the fixture at `fixture_path`.\"\"\"\n    if fixture_format == BlockchainFixture:\n        self.consume_blockchain_test(\n            fixture_path=fixture_path,\n            fixture_name=fixture_name,\n            debug_output_path=debug_output_path,\n        )\n    elif fixture_format == StateFixture:\n        self.consume_state_test(\n            fixture_path=fixture_path,\n            fixture_name=fixture_name,\n            debug_output_path=debug_output_path,\n        )\n    else:\n        raise Exception(\n            f\"Fixture format {fixture_format.format_name} not supported by {self.binary}\"\n        )\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.GethTransitionTool","title":"<code>GethTransitionTool</code>","text":"<p>               Bases: <code>GethEvm</code>, <code>TransitionTool</code></p> <p>go-ethereum <code>evm</code> Transition tool interface wrapper class.</p> Source code in <code>src/ethereum_clis/clis/geth.py</code> <pre><code>class GethTransitionTool(GethEvm, TransitionTool):\n    \"\"\"go-ethereum `evm` Transition tool interface wrapper class.\"\"\"\n\n    subcommand: Optional[str] = \"t8n\"\n    trace: bool\n    t8n_use_stream = True\n\n    def __init__(self, *, binary: Path, trace: bool = False):\n        \"\"\"Initialize the GethTransitionTool class.\"\"\"\n        GethEvm.__init__(self, binary=binary, trace=trace)\n        TransitionTool.__init__(\n            self, exception_mapper=self.exception_mapper, binary=binary, trace=trace\n        )\n        help_command = [str(self.binary), str(self.subcommand), \"--help\"]\n        result = self._run_command(help_command)\n        self.help_string = result.stdout\n\n    def is_fork_supported(self, fork: Fork) -&gt; bool:\n        \"\"\"\n        Return True if the fork is supported by the tool.\n\n        If the fork is a transition fork, we want to check the fork it transitions to.\n        \"\"\"\n        return fork.transition_tool_name() in self.help_string\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.GethTransitionTool.__init__","title":"<code>__init__(*, binary, trace=False)</code>","text":"<p>Initialize the GethTransitionTool class.</p> Source code in <code>src/ethereum_clis/clis/geth.py</code> <pre><code>def __init__(self, *, binary: Path, trace: bool = False):\n    \"\"\"Initialize the GethTransitionTool class.\"\"\"\n    GethEvm.__init__(self, binary=binary, trace=trace)\n    TransitionTool.__init__(\n        self, exception_mapper=self.exception_mapper, binary=binary, trace=trace\n    )\n    help_command = [str(self.binary), str(self.subcommand), \"--help\"]\n    result = self._run_command(help_command)\n    self.help_string = result.stdout\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.GethTransitionTool.is_fork_supported","title":"<code>is_fork_supported(fork)</code>","text":"<p>Return True if the fork is supported by the tool.</p> <p>If the fork is a transition fork, we want to check the fork it transitions to.</p> Source code in <code>src/ethereum_clis/clis/geth.py</code> <pre><code>def is_fork_supported(self, fork: Fork) -&gt; bool:\n    \"\"\"\n    Return True if the fork is supported by the tool.\n\n    If the fork is a transition fork, we want to check the fork it transitions to.\n    \"\"\"\n    return fork.transition_tool_name() in self.help_string\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.Nethtest","title":"<code>Nethtest</code>","text":"<p>               Bases: <code>EthereumCLI</code></p> <p>Nethermind <code>nethtest</code> binary base class.</p> Source code in <code>src/ethereum_clis/clis/nethermind.py</code> <pre><code>class Nethtest(EthereumCLI):\n    \"\"\"Nethermind `nethtest` binary base class.\"\"\"\n\n    default_binary = Path(\"nethtest\")\n    detect_binary_pattern = re.compile(r\"^\\d+\\.\\d+\\.\\d+-[a-zA-Z0-9]+(\\+[a-f0-9]{40})?$\")\n    version_flag: str = \"--version\"\n    cached_version: Optional[str] = None\n\n    def __init__(\n        self,\n        binary: Path,\n        trace: bool = False,\n        exception_mapper: ExceptionMapper | None = None,\n    ):\n        \"\"\"Initialize the Nethtest class.\"\"\"\n        self.binary = binary\n        self.trace = trace\n        # TODO: Implement NethermindExceptionMapper\n        self.exception_mapper = exception_mapper if exception_mapper else None\n\n    def _run_command(self, command: List[str]) -&gt; subprocess.CompletedProcess:\n        try:\n            return subprocess.run(\n                command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True\n            )\n        except subprocess.CalledProcessError as e:\n            raise Exception(\"Command failed with non-zero status.\") from e\n        except Exception as e:\n            raise Exception(\"Unexpected exception calling evm tool.\") from e\n\n    def _consume_debug_dump(\n        self,\n        command: Tuple[str, ...],\n        result: subprocess.CompletedProcess,\n        debug_output_path: Path,\n    ):\n        consume_direct_call = \" \".join(command)\n        consume_direct_script = textwrap.dedent(\n            f\"\"\"\\\n            #!/bin/bash\n            {consume_direct_call}\n            \"\"\"\n        )\n        dump_files_to_directory(\n            str(debug_output_path),\n            {\n                \"consume_direct_args.py\": command,\n                \"consume_direct_returncode.txt\": result.returncode,\n                \"consume_direct_stdout.txt\": result.stdout,\n                \"consume_direct_stderr.txt\": result.stderr,\n                \"consume_direct.sh+x\": consume_direct_script,\n            },\n        )\n\n    @cache  # noqa\n    def help(self, subcommand: str | None = None) -&gt; str:\n        \"\"\"Return the help string, optionally for a subcommand.\"\"\"\n        help_command = [str(self.binary)]\n        if subcommand:\n            help_command.append(subcommand)\n        help_command.append(\"--help\")\n        return self._run_command(help_command).stdout\n\n    @cache  # noqa\n    def has_eof_support(self) -&gt; bool:\n        \"\"\"\n        Return True if the `nethtest` binary supports the `--eofTest` flag.\n\n        Currently, nethtest EOF support is only available in nethermind's feature/evm/eof\n        branch https://github.com/NethermindEth/nethermind/tree/feature/evm/eof\n        \"\"\"\n        return \"--eofTest\" in self.help()\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.Nethtest.__init__","title":"<code>__init__(binary, trace=False, exception_mapper=None)</code>","text":"<p>Initialize the Nethtest class.</p> Source code in <code>src/ethereum_clis/clis/nethermind.py</code> <pre><code>def __init__(\n    self,\n    binary: Path,\n    trace: bool = False,\n    exception_mapper: ExceptionMapper | None = None,\n):\n    \"\"\"Initialize the Nethtest class.\"\"\"\n    self.binary = binary\n    self.trace = trace\n    # TODO: Implement NethermindExceptionMapper\n    self.exception_mapper = exception_mapper if exception_mapper else None\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.Nethtest.help","title":"<code>help(subcommand=None)</code>  <code>cached</code>","text":"<p>Return the help string, optionally for a subcommand.</p> Source code in <code>src/ethereum_clis/clis/nethermind.py</code> <pre><code>@cache  # noqa\ndef help(self, subcommand: str | None = None) -&gt; str:\n    \"\"\"Return the help string, optionally for a subcommand.\"\"\"\n    help_command = [str(self.binary)]\n    if subcommand:\n        help_command.append(subcommand)\n    help_command.append(\"--help\")\n    return self._run_command(help_command).stdout\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.Nethtest.has_eof_support","title":"<code>has_eof_support()</code>  <code>cached</code>","text":"<p>Return True if the <code>nethtest</code> binary supports the <code>--eofTest</code> flag.</p> <p>Currently, nethtest EOF support is only available in nethermind's feature/evm/eof branch https://github.com/NethermindEth/nethermind/tree/feature/evm/eof</p> Source code in <code>src/ethereum_clis/clis/nethermind.py</code> <pre><code>@cache  # noqa\ndef has_eof_support(self) -&gt; bool:\n    \"\"\"\n    Return True if the `nethtest` binary supports the `--eofTest` flag.\n\n    Currently, nethtest EOF support is only available in nethermind's feature/evm/eof\n    branch https://github.com/NethermindEth/nethermind/tree/feature/evm/eof\n    \"\"\"\n    return \"--eofTest\" in self.help()\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.NethtestFixtureConsumer","title":"<code>NethtestFixtureConsumer</code>","text":"<p>               Bases: <code>Nethtest</code>, <code>FixtureConsumerTool</code></p> <p>Nethermind implementation of the fixture consumer.</p> Source code in <code>src/ethereum_clis/clis/nethermind.py</code> <pre><code>class NethtestFixtureConsumer(\n    Nethtest,\n    FixtureConsumerTool,\n    fixture_formats=[StateFixture, BlockchainFixture, EOFFixture],\n):\n    \"\"\"Nethermind implementation of the fixture consumer.\"\"\"\n\n    def _build_command_with_options(\n        self,\n        fixture_format: FixtureFormat,\n        fixture_path: Path,\n        fixture_name: Optional[str] = None,\n        debug_output_path: Optional[Path] = None,\n    ) -&gt; Tuple[str, ...]:\n        assert fixture_name, \"Fixture name must be provided for nethtest.\"\n        command = [str(self.binary)]\n        if fixture_format is BlockchainFixture:\n            command += [\"--blockTest\", \"--filter\", f\"{re.escape(fixture_name)}\"]\n        elif fixture_format is StateFixture:\n            # TODO: consider using `--filter` here to readily access traces from the output\n            pass  # no additional options needed\n        elif fixture_format is EOFFixture:\n            command += [\"--eofTest\"]\n        else:\n            raise Exception(\n                f\"Fixture format {fixture_format.format_name} not supported by {self.binary}\"\n            )\n        command += [\"--input\", str(fixture_path)]\n        if debug_output_path:\n            command += [\"--trace\"]\n        return tuple(command)\n\n    @cache  # noqa\n    def consume_state_test_file(\n        self,\n        fixture_path: Path,\n        command: Tuple[str],\n        debug_output_path: Optional[Path] = None,\n    ) -&gt; Tuple[List[Dict[str, Any]], str]:\n        \"\"\"\n        Consume an entire state test file.\n\n        The `evm statetest` will always execute all the tests contained in a file without the\n        possibility of selecting a single test, so this function is cached in order to only call\n        the command once and `consume_state_test` can simply select the result that\n        was requested.\n        \"\"\"\n        result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\n\n        if debug_output_path:\n            self._consume_debug_dump(command, result, debug_output_path)\n\n        if result.returncode != 0:\n            raise Exception(\n                f\"Unexpected exit code:\\n{' '.join(command)}\\n\\n Error:\\n{result.stderr}\"\n            )\n\n        try:\n            result_json = json.loads(result.stdout)\n        except json.JSONDecodeError as e:\n            raise Exception(\n                f\"Failed to parse JSON output on stdout from nethtest:\\n{result.stdout}\"\n            ) from e\n\n        if not isinstance(result_json, list):\n            raise Exception(f\"Unexpected result from evm statetest: {result_json}\")\n        return result_json, result.stderr\n\n    def consume_state_test(\n        self,\n        command: Tuple[str, ...],\n        fixture_path: Path,\n        fixture_name: Optional[str] = None,\n        debug_output_path: Optional[Path] = None,\n    ):\n        \"\"\"\n        Consume a single state test.\n\n        Uses the cached result from `consume_state_test_file` in order to not call the command\n        every time an select a single result from there.\n        \"\"\"\n        file_results, stderr = self.consume_state_test_file(\n            fixture_path=fixture_path,\n            command=command,\n            debug_output_path=debug_output_path,\n        )\n\n        if fixture_name:\n            # TODO: this check is too fragile; extend for ethereum/tests?\n            nethtest_suffix = \"_d0g0v0_\"\n            assert all(\n                test_result[\"name\"].endswith(nethtest_suffix) for test_result in file_results\n            ), (\n                \"consume direct with nethtest doesn't support the multi-data statetest format \"\n                \"used in ethereum/tests (yet)\"\n            )\n            test_result = [\n                test_result\n                for test_result in file_results\n                if test_result[\"name\"].removesuffix(nethtest_suffix)\n                == f\"{fixture_name.split('/')[-1]}\"\n                # TODO: the following was required for nethermind's feature/evm/eof branch\n                # nethtest version: 1.32.0-unstable+025871675bd2e0839f93d2b70416ebae9dbae012\n                # == f\"{fixture_name.split('.py::')[-1]}\"\n            ]\n            assert len(test_result) &lt; 2, f\"Multiple test results for {fixture_name}\"\n            assert len(test_result) == 1, f\"Test result for {fixture_name} missing\"\n            assert test_result[0][\"pass\"], (\n                f\"State test '{fixture_name}' failed, available stderr:\\n {stderr}\"\n            )\n        else:\n            if any(not test_result[\"pass\"] for test_result in file_results):\n                exception_text = \"State test failed: \\n\" + \"\\n\".join(\n                    f\"{test_result['name']}: \" + test_result[\"error\"]\n                    for test_result in file_results\n                    if not test_result[\"pass\"]\n                )\n                raise Exception(exception_text)\n\n    def consume_blockchain_test(\n        self,\n        command: Tuple[str, ...],\n        fixture_path: Path,\n        fixture_name: Optional[str] = None,\n        debug_output_path: Optional[Path] = None,\n    ):\n        \"\"\"Execute the the fixture at `fixture_path` via `nethtest`.\"\"\"\n        result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\n\n        if debug_output_path:\n            self._consume_debug_dump(command, result, debug_output_path)\n\n        if result.returncode != 0:\n            raise Exception(\n                f\"nethtest exited with non-zero exit code ({result.returncode}).\\n\"\n                f\"stdout:\\n{result.stdout}\\n\"\n                f\"stderr:\\n{result.stderr}\\n\"\n                f\"{' '.join(command)}\"\n            )\n\n    @cache  # noqa\n    def consume_eof_test_file(\n        self,\n        fixture_path: Path,\n        command: Tuple[str],\n        debug_output_path: Optional[Path] = None,\n    ) -&gt; Tuple[Dict[Any, Any], str, str]:\n        \"\"\"Consume an entire EOF fixture file.\"\"\"\n        result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\n\n        pattern = re.compile(r\"^(test_.+?)\\s+(PASS|FAIL)$\", re.MULTILINE)\n        test_results = {\n            match.group(1): match.group(2) == \"PASS\"  # Convert \"PASS\" to True and \"FAIL\" to False\n            for match in pattern.finditer(result.stdout)\n        }\n\n        if debug_output_path:\n            self._consume_debug_dump(command, result, debug_output_path)\n\n        if result.returncode != 0:\n            raise Exception(\n                f\"Unexpected exit code:\\n{' '.join(command)}\\n\\n Error:\\n{result.stderr}\"\n            )\n\n        return test_results, result.stdout, result.stderr\n\n    def consume_eof_test(self, command, fixture_path, fixture_name, debug_output_path):\n        \"\"\"Execute the the EOF fixture at `fixture_path` via `nethtest`.\"\"\"\n        if not self.has_eof_support():\n            pytest.skip(\"This version of nethtest does not support the `--eofTest` flag.\")\n        file_results, stdout, stderr = self.consume_eof_test_file(\n            fixture_path=fixture_path,\n            command=command,\n            debug_output_path=debug_output_path,\n        )\n        modified_fixture_name = fixture_name.split(\"::\")[-1].replace(\"\\\\x\", \"/x\")\n        assert modified_fixture_name in file_results, (\n            f\"Test result for {fixture_name} missing, available stdout:\\n{stdout}.\\n\"\n            f\"Parsed test results: {file_results}\"\n        )\n        if stderr:\n            available_stderr = f\"Available stderr:\\n{stderr}\"\n        else:\n            available_stderr = \"(No output available.)\"\n        assert file_results[modified_fixture_name], (\n            f\"EOF test '{fixture_name}' failed. {available_stderr}\"\n        )\n\n    def consume_fixture(\n        self,\n        fixture_format: FixtureFormat,\n        fixture_path: Path,\n        fixture_name: Optional[str] = None,\n        debug_output_path: Optional[Path] = None,\n    ):\n        \"\"\"Execute the appropriate geth fixture consumer for the fixture at `fixture_path`.\"\"\"\n        command = self._build_command_with_options(\n            fixture_format, fixture_path, fixture_name, debug_output_path\n        )\n        if fixture_format == BlockchainFixture:\n            self.consume_blockchain_test(\n                command=command,\n                fixture_path=fixture_path,\n                fixture_name=fixture_name,\n                debug_output_path=debug_output_path,\n            )\n        elif fixture_format == StateFixture:\n            self.consume_state_test(\n                command=command,\n                fixture_path=fixture_path,\n                fixture_name=fixture_name,\n                debug_output_path=debug_output_path,\n            )\n        elif fixture_format == EOFFixture:\n            self.consume_eof_test(\n                command=command,\n                fixture_path=fixture_path,\n                fixture_name=fixture_name,\n                debug_output_path=debug_output_path,\n            )\n        else:\n            raise Exception(\n                f\"Fixture format {fixture_format.format_name} not supported by {self.binary}\"\n            )\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.NethtestFixtureConsumer.consume_state_test_file","title":"<code>consume_state_test_file(fixture_path, command, debug_output_path=None)</code>  <code>cached</code>","text":"<p>Consume an entire state test file.</p> <p>The <code>evm statetest</code> will always execute all the tests contained in a file without the possibility of selecting a single test, so this function is cached in order to only call the command once and <code>consume_state_test</code> can simply select the result that was requested.</p> Source code in <code>src/ethereum_clis/clis/nethermind.py</code> <pre><code>@cache  # noqa\ndef consume_state_test_file(\n    self,\n    fixture_path: Path,\n    command: Tuple[str],\n    debug_output_path: Optional[Path] = None,\n) -&gt; Tuple[List[Dict[str, Any]], str]:\n    \"\"\"\n    Consume an entire state test file.\n\n    The `evm statetest` will always execute all the tests contained in a file without the\n    possibility of selecting a single test, so this function is cached in order to only call\n    the command once and `consume_state_test` can simply select the result that\n    was requested.\n    \"\"\"\n    result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\n\n    if debug_output_path:\n        self._consume_debug_dump(command, result, debug_output_path)\n\n    if result.returncode != 0:\n        raise Exception(\n            f\"Unexpected exit code:\\n{' '.join(command)}\\n\\n Error:\\n{result.stderr}\"\n        )\n\n    try:\n        result_json = json.loads(result.stdout)\n    except json.JSONDecodeError as e:\n        raise Exception(\n            f\"Failed to parse JSON output on stdout from nethtest:\\n{result.stdout}\"\n        ) from e\n\n    if not isinstance(result_json, list):\n        raise Exception(f\"Unexpected result from evm statetest: {result_json}\")\n    return result_json, result.stderr\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.NethtestFixtureConsumer.consume_state_test","title":"<code>consume_state_test(command, fixture_path, fixture_name=None, debug_output_path=None)</code>","text":"<p>Consume a single state test.</p> <p>Uses the cached result from <code>consume_state_test_file</code> in order to not call the command every time an select a single result from there.</p> Source code in <code>src/ethereum_clis/clis/nethermind.py</code> <pre><code>def consume_state_test(\n    self,\n    command: Tuple[str, ...],\n    fixture_path: Path,\n    fixture_name: Optional[str] = None,\n    debug_output_path: Optional[Path] = None,\n):\n    \"\"\"\n    Consume a single state test.\n\n    Uses the cached result from `consume_state_test_file` in order to not call the command\n    every time an select a single result from there.\n    \"\"\"\n    file_results, stderr = self.consume_state_test_file(\n        fixture_path=fixture_path,\n        command=command,\n        debug_output_path=debug_output_path,\n    )\n\n    if fixture_name:\n        # TODO: this check is too fragile; extend for ethereum/tests?\n        nethtest_suffix = \"_d0g0v0_\"\n        assert all(\n            test_result[\"name\"].endswith(nethtest_suffix) for test_result in file_results\n        ), (\n            \"consume direct with nethtest doesn't support the multi-data statetest format \"\n            \"used in ethereum/tests (yet)\"\n        )\n        test_result = [\n            test_result\n            for test_result in file_results\n            if test_result[\"name\"].removesuffix(nethtest_suffix)\n            == f\"{fixture_name.split('/')[-1]}\"\n            # TODO: the following was required for nethermind's feature/evm/eof branch\n            # nethtest version: 1.32.0-unstable+025871675bd2e0839f93d2b70416ebae9dbae012\n            # == f\"{fixture_name.split('.py::')[-1]}\"\n        ]\n        assert len(test_result) &lt; 2, f\"Multiple test results for {fixture_name}\"\n        assert len(test_result) == 1, f\"Test result for {fixture_name} missing\"\n        assert test_result[0][\"pass\"], (\n            f\"State test '{fixture_name}' failed, available stderr:\\n {stderr}\"\n        )\n    else:\n        if any(not test_result[\"pass\"] for test_result in file_results):\n            exception_text = \"State test failed: \\n\" + \"\\n\".join(\n                f\"{test_result['name']}: \" + test_result[\"error\"]\n                for test_result in file_results\n                if not test_result[\"pass\"]\n            )\n            raise Exception(exception_text)\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.NethtestFixtureConsumer.consume_blockchain_test","title":"<code>consume_blockchain_test(command, fixture_path, fixture_name=None, debug_output_path=None)</code>","text":"<p>Execute the the fixture at <code>fixture_path</code> via <code>nethtest</code>.</p> Source code in <code>src/ethereum_clis/clis/nethermind.py</code> <pre><code>def consume_blockchain_test(\n    self,\n    command: Tuple[str, ...],\n    fixture_path: Path,\n    fixture_name: Optional[str] = None,\n    debug_output_path: Optional[Path] = None,\n):\n    \"\"\"Execute the the fixture at `fixture_path` via `nethtest`.\"\"\"\n    result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\n\n    if debug_output_path:\n        self._consume_debug_dump(command, result, debug_output_path)\n\n    if result.returncode != 0:\n        raise Exception(\n            f\"nethtest exited with non-zero exit code ({result.returncode}).\\n\"\n            f\"stdout:\\n{result.stdout}\\n\"\n            f\"stderr:\\n{result.stderr}\\n\"\n            f\"{' '.join(command)}\"\n        )\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.NethtestFixtureConsumer.consume_eof_test_file","title":"<code>consume_eof_test_file(fixture_path, command, debug_output_path=None)</code>  <code>cached</code>","text":"<p>Consume an entire EOF fixture file.</p> Source code in <code>src/ethereum_clis/clis/nethermind.py</code> <pre><code>@cache  # noqa\ndef consume_eof_test_file(\n    self,\n    fixture_path: Path,\n    command: Tuple[str],\n    debug_output_path: Optional[Path] = None,\n) -&gt; Tuple[Dict[Any, Any], str, str]:\n    \"\"\"Consume an entire EOF fixture file.\"\"\"\n    result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\n\n    pattern = re.compile(r\"^(test_.+?)\\s+(PASS|FAIL)$\", re.MULTILINE)\n    test_results = {\n        match.group(1): match.group(2) == \"PASS\"  # Convert \"PASS\" to True and \"FAIL\" to False\n        for match in pattern.finditer(result.stdout)\n    }\n\n    if debug_output_path:\n        self._consume_debug_dump(command, result, debug_output_path)\n\n    if result.returncode != 0:\n        raise Exception(\n            f\"Unexpected exit code:\\n{' '.join(command)}\\n\\n Error:\\n{result.stderr}\"\n        )\n\n    return test_results, result.stdout, result.stderr\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.NethtestFixtureConsumer.consume_eof_test","title":"<code>consume_eof_test(command, fixture_path, fixture_name, debug_output_path)</code>","text":"<p>Execute the the EOF fixture at <code>fixture_path</code> via <code>nethtest</code>.</p> Source code in <code>src/ethereum_clis/clis/nethermind.py</code> <pre><code>def consume_eof_test(self, command, fixture_path, fixture_name, debug_output_path):\n    \"\"\"Execute the the EOF fixture at `fixture_path` via `nethtest`.\"\"\"\n    if not self.has_eof_support():\n        pytest.skip(\"This version of nethtest does not support the `--eofTest` flag.\")\n    file_results, stdout, stderr = self.consume_eof_test_file(\n        fixture_path=fixture_path,\n        command=command,\n        debug_output_path=debug_output_path,\n    )\n    modified_fixture_name = fixture_name.split(\"::\")[-1].replace(\"\\\\x\", \"/x\")\n    assert modified_fixture_name in file_results, (\n        f\"Test result for {fixture_name} missing, available stdout:\\n{stdout}.\\n\"\n        f\"Parsed test results: {file_results}\"\n    )\n    if stderr:\n        available_stderr = f\"Available stderr:\\n{stderr}\"\n    else:\n        available_stderr = \"(No output available.)\"\n    assert file_results[modified_fixture_name], (\n        f\"EOF test '{fixture_name}' failed. {available_stderr}\"\n    )\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.NethtestFixtureConsumer.consume_fixture","title":"<code>consume_fixture(fixture_format, fixture_path, fixture_name=None, debug_output_path=None)</code>","text":"<p>Execute the appropriate geth fixture consumer for the fixture at <code>fixture_path</code>.</p> Source code in <code>src/ethereum_clis/clis/nethermind.py</code> <pre><code>def consume_fixture(\n    self,\n    fixture_format: FixtureFormat,\n    fixture_path: Path,\n    fixture_name: Optional[str] = None,\n    debug_output_path: Optional[Path] = None,\n):\n    \"\"\"Execute the appropriate geth fixture consumer for the fixture at `fixture_path`.\"\"\"\n    command = self._build_command_with_options(\n        fixture_format, fixture_path, fixture_name, debug_output_path\n    )\n    if fixture_format == BlockchainFixture:\n        self.consume_blockchain_test(\n            command=command,\n            fixture_path=fixture_path,\n            fixture_name=fixture_name,\n            debug_output_path=debug_output_path,\n        )\n    elif fixture_format == StateFixture:\n        self.consume_state_test(\n            command=command,\n            fixture_path=fixture_path,\n            fixture_name=fixture_name,\n            debug_output_path=debug_output_path,\n        )\n    elif fixture_format == EOFFixture:\n        self.consume_eof_test(\n            command=command,\n            fixture_path=fixture_path,\n            fixture_name=fixture_name,\n            debug_output_path=debug_output_path,\n        )\n    else:\n        raise Exception(\n            f\"Fixture format {fixture_format.format_name} not supported by {self.binary}\"\n        )\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.NimbusTransitionTool","title":"<code>NimbusTransitionTool</code>","text":"<p>               Bases: <code>TransitionTool</code></p> <p>Nimbus <code>evm</code> Transition tool interface wrapper class.</p> Source code in <code>src/ethereum_clis/clis/nimbus.py</code> <pre><code>class NimbusTransitionTool(TransitionTool):\n    \"\"\"Nimbus `evm` Transition tool interface wrapper class.\"\"\"\n\n    default_binary = Path(\"t8n\")\n    detect_binary_pattern = re.compile(r\"^Nimbus-t8n\\b\")\n    version_flag: str = \"--version\"\n\n    binary: Path\n    cached_version: Optional[str] = None\n    trace: bool\n\n    def __init__(\n        self,\n        *,\n        binary: Optional[Path] = None,\n        trace: bool = False,\n    ):\n        \"\"\"Initialize the Nimbus Transition tool interface.\"\"\"\n        super().__init__(exception_mapper=NimbusExceptionMapper(), binary=binary, trace=trace)\n        args = [str(self.binary), \"--help\"]\n        try:\n            result = subprocess.run(args, capture_output=True, text=True)\n        except subprocess.CalledProcessError as e:\n            raise Exception(\n                f\"evm process unexpectedly returned a non-zero status code: {e}.\"\n            ) from e\n        except Exception as e:\n            raise Exception(f\"Unexpected exception calling evm tool: {e}.\") from e\n        self.help_string = result.stdout\n\n    def version(self) -&gt; str:\n        \"\"\"Get `evm` binary version.\"\"\"\n        if self.cached_version is None:\n            self.cached_version = re.sub(r\"\\x1b\\[0m\", \"\", super().version()).strip()\n\n        return self.cached_version\n\n    def is_fork_supported(self, fork: Fork) -&gt; bool:\n        \"\"\"\n        Return True if the fork is supported by the tool.\n\n        If the fork is a transition fork, we want to check the fork it transitions to.\n        \"\"\"\n        return fork.transition_tool_name() in self.help_string\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.NimbusTransitionTool.__init__","title":"<code>__init__(*, binary=None, trace=False)</code>","text":"<p>Initialize the Nimbus Transition tool interface.</p> Source code in <code>src/ethereum_clis/clis/nimbus.py</code> <pre><code>def __init__(\n    self,\n    *,\n    binary: Optional[Path] = None,\n    trace: bool = False,\n):\n    \"\"\"Initialize the Nimbus Transition tool interface.\"\"\"\n    super().__init__(exception_mapper=NimbusExceptionMapper(), binary=binary, trace=trace)\n    args = [str(self.binary), \"--help\"]\n    try:\n        result = subprocess.run(args, capture_output=True, text=True)\n    except subprocess.CalledProcessError as e:\n        raise Exception(\n            f\"evm process unexpectedly returned a non-zero status code: {e}.\"\n        ) from e\n    except Exception as e:\n        raise Exception(f\"Unexpected exception calling evm tool: {e}.\") from e\n    self.help_string = result.stdout\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.NimbusTransitionTool.version","title":"<code>version()</code>","text":"<p>Get <code>evm</code> binary version.</p> Source code in <code>src/ethereum_clis/clis/nimbus.py</code> <pre><code>def version(self) -&gt; str:\n    \"\"\"Get `evm` binary version.\"\"\"\n    if self.cached_version is None:\n        self.cached_version = re.sub(r\"\\x1b\\[0m\", \"\", super().version()).strip()\n\n    return self.cached_version\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.NimbusTransitionTool.is_fork_supported","title":"<code>is_fork_supported(fork)</code>","text":"<p>Return True if the fork is supported by the tool.</p> <p>If the fork is a transition fork, we want to check the fork it transitions to.</p> Source code in <code>src/ethereum_clis/clis/nimbus.py</code> <pre><code>def is_fork_supported(self, fork: Fork) -&gt; bool:\n    \"\"\"\n    Return True if the fork is supported by the tool.\n\n    If the fork is a transition fork, we want to check the fork it transitions to.\n    \"\"\"\n    return fork.transition_tool_name() in self.help_string\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.CLINotFoundInPathError","title":"<code>CLINotFoundInPathError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised if the specified CLI binary is not found in the path.</p> Source code in <code>src/ethereum_clis/ethereum_cli.py</code> <pre><code>class CLINotFoundInPathError(Exception):\n    \"\"\"Exception raised if the specified CLI binary is not found in the path.\"\"\"\n\n    def __init__(self, message=\"The CLI binary was not found in the path\", binary=None):\n        \"\"\"Initialize the exception.\"\"\"\n        if binary:\n            message = f\"{message} ({binary})\"\n        super().__init__(message)\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.CLINotFoundInPathError.__init__","title":"<code>__init__(message='The CLI binary was not found in the path', binary=None)</code>","text":"<p>Initialize the exception.</p> Source code in <code>src/ethereum_clis/ethereum_cli.py</code> <pre><code>def __init__(self, message=\"The CLI binary was not found in the path\", binary=None):\n    \"\"\"Initialize the exception.\"\"\"\n    if binary:\n        message = f\"{message} ({binary})\"\n    super().__init__(message)\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.UnknownCLIError","title":"<code>UnknownCLIError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised if an unknown CLI is encountered.</p> Source code in <code>src/ethereum_clis/ethereum_cli.py</code> <pre><code>class UnknownCLIError(Exception):\n    \"\"\"Exception raised if an unknown CLI is encountered.\"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.FixtureConsumerTool","title":"<code>FixtureConsumerTool</code>","text":"<p>               Bases: <code>FixtureConsumer</code>, <code>EthereumCLI</code></p> <p>Fixture consumer tool abstract base class which should be inherited by all fixture consumer tool implementations.</p> Source code in <code>src/ethereum_clis/fixture_consumer_tool.py</code> <pre><code>class FixtureConsumerTool(FixtureConsumer, EthereumCLI):\n    \"\"\"\n    Fixture consumer tool abstract base class which should be inherited by all fixture consumer\n    tool implementations.\n    \"\"\"\n\n    registered_tools: List[Type[\"FixtureConsumerTool\"]] = []\n    default_tool: Type[\"FixtureConsumerTool\"] | None = None\n\n    def __init_subclass__(cls, *, fixture_formats: List[FixtureFormat]):\n        \"\"\"Register all subclasses of FixtureConsumerTool as possible tools.\"\"\"\n        FixtureConsumerTool.register_tool(cls)\n        cls.fixture_formats = fixture_formats\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.FixtureConsumerTool.__init_subclass__","title":"<code>__init_subclass__(*, fixture_formats)</code>","text":"<p>Register all subclasses of FixtureConsumerTool as possible tools.</p> Source code in <code>src/ethereum_clis/fixture_consumer_tool.py</code> <pre><code>def __init_subclass__(cls, *, fixture_formats: List[FixtureFormat]):\n    \"\"\"Register all subclasses of FixtureConsumerTool as possible tools.\"\"\"\n    FixtureConsumerTool.register_tool(cls)\n    cls.fixture_formats = fixture_formats\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.TransitionTool","title":"<code>TransitionTool</code>","text":"<p>               Bases: <code>EthereumCLI</code></p> <p>Transition tool abstract base class which should be inherited by all transition tool implementations.</p> Source code in <code>src/ethereum_clis/transition_tool.py</code> <pre><code>class TransitionTool(EthereumCLI):\n    \"\"\"\n    Transition tool abstract base class which should be inherited by all transition tool\n    implementations.\n    \"\"\"\n\n    traces: List[List[List[Dict]]] | None = None\n\n    registered_tools: List[Type[\"TransitionTool\"]] = []\n    default_tool: Optional[Type[\"TransitionTool\"]] = None\n\n    subcommand: Optional[str] = None\n    cached_version: Optional[str] = None\n    t8n_use_stream: bool = False\n    t8n_use_server: bool = False\n    server_url: str\n    process: Optional[subprocess.Popen] = None\n\n    @abstractmethod\n    def __init__(\n        self,\n        *,\n        exception_mapper: ExceptionMapper,\n        binary: Optional[Path] = None,\n        trace: bool = False,\n    ):\n        \"\"\"Abstract initialization method that all subclasses must implement.\"\"\"\n        self.exception_mapper = exception_mapper\n        super().__init__(binary=binary)\n        self.trace = trace\n        self._info_metadata: Optional[Dict[str, Any]] = {}\n\n    def __init_subclass__(cls):\n        \"\"\"Register all subclasses of TransitionTool as possible tools.\"\"\"\n        TransitionTool.register_tool(cls)\n\n    @abstractmethod\n    def is_fork_supported(self, fork: Fork) -&gt; bool:\n        \"\"\"Return True if the fork is supported by the tool.\"\"\"\n        pass\n\n    def start_server(self):\n        \"\"\"\n        Start the t8n-server process, extract the port, and leave it running\n        for future re-use.\n        \"\"\"\n        pass\n\n    def shutdown(self):\n        \"\"\"Perform any cleanup tasks related to the tested tool.\"\"\"\n        pass\n\n    def reset_traces(self):\n        \"\"\"Reset the internal trace storage for a new test to begin.\"\"\"\n        self.traces = None\n\n    def append_traces(self, new_traces: List[List[Dict]]):\n        \"\"\"Append a list of traces of a state transition to the current list.\"\"\"\n        if self.traces is None:\n            self.traces = []\n        self.traces.append(new_traces)\n\n    def get_traces(self) -&gt; List[List[List[Dict]]] | None:\n        \"\"\"Return the accumulated traces.\"\"\"\n        return self.traces\n\n    def collect_traces(\n        self,\n        receipts: List[TransactionReceipt],\n        temp_dir: tempfile.TemporaryDirectory,\n        debug_output_path: str = \"\",\n    ) -&gt; None:\n        \"\"\"Collect the traces from the t8n tool output and store them in the traces list.\"\"\"\n        traces: List[List[Dict]] = []\n        for i, r in enumerate(receipts):\n            trace_file_name = f\"trace-{i}-{r.transaction_hash}.jsonl\"\n            if debug_output_path:\n                shutil.copy(\n                    os.path.join(temp_dir.name, trace_file_name),\n                    os.path.join(debug_output_path, trace_file_name),\n                )\n            with open(os.path.join(temp_dir.name, trace_file_name), \"r\") as trace_file:\n                tx_traces: List[Dict] = []\n                for trace_line in trace_file.readlines():\n                    tx_traces.append(json.loads(trace_line))\n                traces.append(tx_traces)\n        self.append_traces(traces)\n\n    @dataclass\n    class TransitionToolData:\n        \"\"\"Transition tool files and data to pass between methods.\"\"\"\n\n        alloc: Alloc\n        txs: List[Transaction]\n        env: Environment\n        fork_name: str\n        chain_id: int\n        reward: int\n        blob_schedule: BlobSchedule | None\n        state_test: bool\n\n        def to_input(self) -&gt; TransitionToolInput:\n            \"\"\"Convert the data to a TransactionToolInput object.\"\"\"\n            return TransitionToolInput(\n                alloc=self.alloc,\n                txs=self.txs,\n                env=self.env,\n            )\n\n        def get_request_data(self) -&gt; TransitionToolRequest:\n            \"\"\"Convert the data to a TransitionToolRequest object.\"\"\"\n            return TransitionToolRequest(\n                state=TransitionToolContext(\n                    fork=self.fork_name,\n                    chain_id=self.chain_id,\n                    reward=self.reward,\n                    blob_schedule=self.blob_schedule,\n                ),\n                input=self.to_input(),\n            )\n\n    def _evaluate_filesystem(\n        self,\n        *,\n        t8n_data: TransitionToolData,\n        debug_output_path: str = \"\",\n    ) -&gt; TransitionToolOutput:\n        \"\"\"Execute a transition tool using the filesystem for its inputs and outputs.\"\"\"\n        temp_dir = tempfile.TemporaryDirectory()\n        os.mkdir(os.path.join(temp_dir.name, \"input\"))\n        os.mkdir(os.path.join(temp_dir.name, \"output\"))\n\n        input_contents = t8n_data.to_input().model_dump(mode=\"json\", **model_dump_config)\n\n        input_paths = {\n            k: os.path.join(temp_dir.name, \"input\", f\"{k}.json\") for k in input_contents.keys()\n        }\n        for key, file_path in input_paths.items():\n            write_json_file(input_contents[key], file_path)\n\n        output_paths = {\n            output: os.path.join(\"output\", f\"{output}.json\") for output in [\"alloc\", \"result\"]\n        }\n        output_paths[\"body\"] = os.path.join(\"output\", \"txs.rlp\")\n\n        # Construct args for evmone-t8n binary\n        args = [\n            str(self.binary),\n            \"--state.fork\",\n            t8n_data.fork_name,\n            \"--input.alloc\",\n            input_paths[\"alloc\"],\n            \"--input.env\",\n            input_paths[\"env\"],\n            \"--input.txs\",\n            input_paths[\"txs\"],\n            \"--output.basedir\",\n            temp_dir.name,\n            \"--output.result\",\n            output_paths[\"result\"],\n            \"--output.alloc\",\n            output_paths[\"alloc\"],\n            \"--output.body\",\n            output_paths[\"body\"],\n            \"--state.reward\",\n            str(t8n_data.reward),\n            \"--state.chainid\",\n            str(t8n_data.chain_id),\n        ]\n\n        if self.trace:\n            args.append(\"--trace\")\n\n        result = subprocess.run(\n            args,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n\n        if debug_output_path:\n            if os.path.exists(debug_output_path):\n                shutil.rmtree(debug_output_path)\n            shutil.copytree(temp_dir.name, debug_output_path)\n            t8n_output_base_dir = os.path.join(debug_output_path, \"t8n.sh.out\")\n            t8n_call = \" \".join(args)\n            for file_path in input_paths.values():  # update input paths\n                t8n_call = t8n_call.replace(\n                    os.path.dirname(file_path), os.path.join(debug_output_path, \"input\")\n                )\n            t8n_call = t8n_call.replace(  # use a new output path for basedir and outputs\n                temp_dir.name,\n                t8n_output_base_dir,\n            )\n            t8n_script = textwrap.dedent(\n                f\"\"\"\\\n                #!/bin/bash\n                rm -rf {debug_output_path}/t8n.sh.out  # hard-coded to avoid surprises\n                mkdir -p {debug_output_path}/t8n.sh.out/output\n                {t8n_call}\n                \"\"\"\n            )\n            dump_files_to_directory(\n                debug_output_path,\n                {\n                    \"args.py\": args,\n                    \"returncode.txt\": result.returncode,\n                    \"stdout.txt\": result.stdout.decode(),\n                    \"stderr.txt\": result.stderr.decode(),\n                    \"t8n.sh+x\": t8n_script,\n                },\n            )\n\n        if result.returncode != 0:\n            raise Exception(\"failed to evaluate: \" + result.stderr.decode())\n\n        for key, file_path in output_paths.items():\n            output_paths[key] = os.path.join(temp_dir.name, file_path)\n\n        output_contents = {}\n        for key, file_path in output_paths.items():\n            if \"txs.rlp\" in file_path:\n                continue\n            with open(file_path, \"r+\") as file:\n                output_contents[key] = json.load(file)\n        output = TransitionToolOutput(**output_contents)\n        if self.trace:\n            self.collect_traces(output.result.receipts, temp_dir, debug_output_path)\n\n        temp_dir.cleanup()\n\n        return output\n\n    def _server_post(\n        self,\n        data: Dict[str, Any],\n        timeout: int,\n        url_args: Optional[Dict[str, List[str] | str]] = None,\n        retries: int = 5,\n    ) -&gt; Response:\n        \"\"\"Send a POST request to the t8n-server and return the response.\"\"\"\n        if url_args is None:\n            url_args = {}\n        post_delay = 0.1\n        while True:\n            try:\n                response = Session().post(\n                    f\"{self.server_url}?{urlencode(url_args, doseq=True)}\",\n                    json=data,\n                    timeout=timeout,\n                )\n                break\n            except RequestsConnectionError as e:\n                retries -= 1\n                if retries == 0:\n                    raise e\n                time.sleep(post_delay)\n                post_delay *= 2\n        response.raise_for_status()\n        if response.status_code != 200:\n            raise Exception(\n                f\"t8n-server returned status code {response.status_code}, \"\n                f\"response: {response.text}\"\n            )\n        return response\n\n    def _generate_post_args(self, t8n_data: TransitionToolData) -&gt; Dict[str, List[str] | str]:\n        \"\"\"Generate the arguments for the POST request to the t8n-server.\"\"\"\n        return {}\n\n    def _evaluate_server(\n        self,\n        *,\n        t8n_data: TransitionToolData,\n        debug_output_path: str = \"\",\n        timeout: int,\n    ) -&gt; TransitionToolOutput:\n        \"\"\"Execute the transition tool sending inputs and outputs via a server.\"\"\"\n        request_data = t8n_data.get_request_data()\n        request_data_json = request_data.model_dump(mode=\"json\", **model_dump_config)\n\n        temp_dir = tempfile.TemporaryDirectory()\n        request_data_json[\"trace\"] = self.trace\n        if self.trace:\n            request_data_json[\"output-basedir\"] = temp_dir.name\n\n        if debug_output_path:\n            request_info = (\n                f\"Server URL: {self.server_url}\\n\\n\"\n                f\"Request Data:\\n{json.dumps(request_data_json, indent=2)}\\n\"\n            )\n            dump_files_to_directory(\n                debug_output_path,\n                {\n                    \"input/alloc.json\": request_data.input.alloc,\n                    \"input/env.json\": request_data.input.env,\n                    \"input/txs.json\": [\n                        tx.model_dump(mode=\"json\", **model_dump_config)\n                        for tx in request_data.input.txs\n                    ],\n                    \"request_info.txt\": request_info,\n                },\n            )\n\n        response = self._server_post(\n            data=request_data_json, url_args=self._generate_post_args(t8n_data), timeout=timeout\n        )\n        response_json = response.json()\n\n        # pop optional test ``_info`` metadata from response, if present\n        self._info_metadata = response_json.pop(\"_info_metadata\", {})\n\n        output: TransitionToolOutput = TransitionToolOutput.model_validate(response_json)\n\n        if self.trace:\n            self.collect_traces(output.result.receipts, temp_dir, debug_output_path)\n        temp_dir.cleanup()\n\n        if debug_output_path:\n            response_info = (\n                f\"Status Code: {response.status_code}\\n\\n\"\n                f\"Headers:\\n{json.dumps(dict(response.headers), indent=2)}\\n\\n\"\n                f\"Content:\\n{response.text}\\n\"\n            )\n            dump_files_to_directory(\n                debug_output_path,\n                {\n                    \"output/alloc.json\": output.alloc,\n                    \"output/result.json\": output.result,\n                    \"output/txs.rlp\": str(output.body),\n                    \"response_info.txt\": response_info,\n                },\n            )\n\n        return output\n\n    def _evaluate_stream(\n        self,\n        *,\n        t8n_data: TransitionToolData,\n        debug_output_path: str = \"\",\n    ) -&gt; TransitionToolOutput:\n        \"\"\"Execute a transition tool using stdin and stdout for its inputs and outputs.\"\"\"\n        temp_dir = tempfile.TemporaryDirectory()\n        args = self.construct_args_stream(t8n_data, temp_dir)\n\n        stdin = t8n_data.to_input()\n\n        result = subprocess.run(\n            args,\n            input=stdin.model_dump_json(**model_dump_config).encode(),\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n\n        self.dump_debug_stream(debug_output_path, temp_dir, stdin, args, result)\n\n        if result.returncode != 0:\n            raise Exception(\"failed to evaluate: \" + result.stderr.decode())\n\n        output: TransitionToolOutput = TransitionToolOutput.model_validate_json(result.stdout)\n\n        if debug_output_path:\n            dump_files_to_directory(\n                debug_output_path,\n                {\n                    \"output/alloc.json\": output.alloc,\n                    \"output/result.json\": output.result,\n                    \"output/txs.rlp\": str(output.body),\n                },\n            )\n\n        if self.trace:\n            self.collect_traces(output.result.receipts, temp_dir, debug_output_path)\n            temp_dir.cleanup()\n\n        return output\n\n    def construct_args_stream(\n        self, t8n_data: TransitionToolData, temp_dir: tempfile.TemporaryDirectory\n    ) -&gt; List[str]:\n        \"\"\"Construct arguments for t8n interaction via streams.\"\"\"\n        command: list[str] = [str(self.binary)]\n        if self.subcommand:\n            command.append(self.subcommand)\n\n        args = command + [\n            \"--input.alloc=stdin\",\n            \"--input.txs=stdin\",\n            \"--input.env=stdin\",\n            \"--output.result=stdout\",\n            \"--output.alloc=stdout\",\n            \"--output.body=stdout\",\n            f\"--state.fork={t8n_data.fork_name}\",\n            f\"--state.chainid={t8n_data.chain_id}\",\n            f\"--state.reward={t8n_data.reward}\",\n        ]\n\n        if self.trace:\n            args.append(\"--trace\")\n            args.append(f\"--output.basedir={temp_dir.name}\")\n        return args\n\n    def dump_debug_stream(\n        self,\n        debug_output_path: str,\n        temp_dir: tempfile.TemporaryDirectory,\n        stdin: TransitionToolInput,\n        args: List[str],\n        result: subprocess.CompletedProcess,\n    ):\n        \"\"\"Export debug files if requested when interacting with t8n via streams.\"\"\"\n        if not debug_output_path:\n            return\n\n        t8n_call = \" \".join(args)\n        t8n_output_base_dir = os.path.join(debug_output_path, \"t8n.sh.out\")\n        if self.trace:\n            t8n_call = t8n_call.replace(temp_dir.name, t8n_output_base_dir)\n        t8n_script = textwrap.dedent(\n            f\"\"\"\\\n            #!/bin/bash\n            rm -rf {debug_output_path}/t8n.sh.out  # hard-coded to avoid surprises\n            mkdir {debug_output_path}/t8n.sh.out  # unused if tracing is not enabled\n            {t8n_call} &lt; {debug_output_path}/stdin.txt\n            \"\"\"\n        )\n        dump_files_to_directory(\n            debug_output_path,\n            {\n                \"args.py\": args,\n                \"input/alloc.json\": stdin.alloc,\n                \"input/env.json\": stdin.env,\n                \"input/txs.json\": [\n                    tx.model_dump(mode=\"json\", **model_dump_config) for tx in stdin.txs\n                ],\n                \"returncode.txt\": result.returncode,\n                \"stdin.txt\": stdin,\n                \"stdout.txt\": result.stdout.decode(),\n                \"stderr.txt\": result.stderr.decode(),\n                \"t8n.sh+x\": t8n_script,\n            },\n        )\n\n    def evaluate(\n        self,\n        *,\n        alloc: Alloc,\n        txs: List[Transaction],\n        env: Environment,\n        fork: Fork,\n        chain_id: int,\n        reward: int,\n        blob_schedule: BlobSchedule | None,\n        eips: Optional[List[int]] = None,\n        debug_output_path: str = \"\",\n        state_test: bool = False,\n        slow_request: bool = False,\n    ) -&gt; TransitionToolOutput:\n        \"\"\"\n        Execute the relevant evaluate method as required by the `t8n` tool.\n\n        If a client's `t8n` tool varies from the default behavior, this method\n        can be overridden.\n        \"\"\"\n        fork_name = fork.transition_tool_name(\n            block_number=env.number,\n            timestamp=env.timestamp,\n        )\n        if eips is not None:\n            fork_name = \"+\".join([fork_name] + [str(eip) for eip in eips])\n        if env.number == 0:\n            reward = -1\n        t8n_data = self.TransitionToolData(\n            alloc=alloc,\n            txs=txs,\n            env=env,\n            fork_name=fork_name,\n            chain_id=chain_id,\n            reward=reward,\n            blob_schedule=blob_schedule,\n            state_test=state_test,\n        )\n\n        if self.t8n_use_server:\n            if not self.process:\n                self.start_server()\n            return self._evaluate_server(\n                t8n_data=t8n_data,\n                debug_output_path=debug_output_path,\n                timeout=SLOW_REQUEST_TIMEOUT if slow_request else NORMAL_SERVER_TIMEOUT,\n            )\n\n        if self.t8n_use_stream:\n            return self._evaluate_stream(t8n_data=t8n_data, debug_output_path=debug_output_path)\n\n        return self._evaluate_filesystem(\n            t8n_data=t8n_data,\n            debug_output_path=debug_output_path,\n        )\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.TransitionTool.__init__","title":"<code>__init__(*, exception_mapper, binary=None, trace=False)</code>  <code>abstractmethod</code>","text":"<p>Abstract initialization method that all subclasses must implement.</p> Source code in <code>src/ethereum_clis/transition_tool.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    *,\n    exception_mapper: ExceptionMapper,\n    binary: Optional[Path] = None,\n    trace: bool = False,\n):\n    \"\"\"Abstract initialization method that all subclasses must implement.\"\"\"\n    self.exception_mapper = exception_mapper\n    super().__init__(binary=binary)\n    self.trace = trace\n    self._info_metadata: Optional[Dict[str, Any]] = {}\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.TransitionTool.__init_subclass__","title":"<code>__init_subclass__()</code>","text":"<p>Register all subclasses of TransitionTool as possible tools.</p> Source code in <code>src/ethereum_clis/transition_tool.py</code> <pre><code>def __init_subclass__(cls):\n    \"\"\"Register all subclasses of TransitionTool as possible tools.\"\"\"\n    TransitionTool.register_tool(cls)\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.TransitionTool.is_fork_supported","title":"<code>is_fork_supported(fork)</code>  <code>abstractmethod</code>","text":"<p>Return True if the fork is supported by the tool.</p> Source code in <code>src/ethereum_clis/transition_tool.py</code> <pre><code>@abstractmethod\ndef is_fork_supported(self, fork: Fork) -&gt; bool:\n    \"\"\"Return True if the fork is supported by the tool.\"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.TransitionTool.start_server","title":"<code>start_server()</code>","text":"<p>Start the t8n-server process, extract the port, and leave it running for future re-use.</p> Source code in <code>src/ethereum_clis/transition_tool.py</code> <pre><code>def start_server(self):\n    \"\"\"\n    Start the t8n-server process, extract the port, and leave it running\n    for future re-use.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.TransitionTool.shutdown","title":"<code>shutdown()</code>","text":"<p>Perform any cleanup tasks related to the tested tool.</p> Source code in <code>src/ethereum_clis/transition_tool.py</code> <pre><code>def shutdown(self):\n    \"\"\"Perform any cleanup tasks related to the tested tool.\"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.TransitionTool.reset_traces","title":"<code>reset_traces()</code>","text":"<p>Reset the internal trace storage for a new test to begin.</p> Source code in <code>src/ethereum_clis/transition_tool.py</code> <pre><code>def reset_traces(self):\n    \"\"\"Reset the internal trace storage for a new test to begin.\"\"\"\n    self.traces = None\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.TransitionTool.append_traces","title":"<code>append_traces(new_traces)</code>","text":"<p>Append a list of traces of a state transition to the current list.</p> Source code in <code>src/ethereum_clis/transition_tool.py</code> <pre><code>def append_traces(self, new_traces: List[List[Dict]]):\n    \"\"\"Append a list of traces of a state transition to the current list.\"\"\"\n    if self.traces is None:\n        self.traces = []\n    self.traces.append(new_traces)\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.TransitionTool.get_traces","title":"<code>get_traces()</code>","text":"<p>Return the accumulated traces.</p> Source code in <code>src/ethereum_clis/transition_tool.py</code> <pre><code>def get_traces(self) -&gt; List[List[List[Dict]]] | None:\n    \"\"\"Return the accumulated traces.\"\"\"\n    return self.traces\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.TransitionTool.collect_traces","title":"<code>collect_traces(receipts, temp_dir, debug_output_path='')</code>","text":"<p>Collect the traces from the t8n tool output and store them in the traces list.</p> Source code in <code>src/ethereum_clis/transition_tool.py</code> <pre><code>def collect_traces(\n    self,\n    receipts: List[TransactionReceipt],\n    temp_dir: tempfile.TemporaryDirectory,\n    debug_output_path: str = \"\",\n) -&gt; None:\n    \"\"\"Collect the traces from the t8n tool output and store them in the traces list.\"\"\"\n    traces: List[List[Dict]] = []\n    for i, r in enumerate(receipts):\n        trace_file_name = f\"trace-{i}-{r.transaction_hash}.jsonl\"\n        if debug_output_path:\n            shutil.copy(\n                os.path.join(temp_dir.name, trace_file_name),\n                os.path.join(debug_output_path, trace_file_name),\n            )\n        with open(os.path.join(temp_dir.name, trace_file_name), \"r\") as trace_file:\n            tx_traces: List[Dict] = []\n            for trace_line in trace_file.readlines():\n                tx_traces.append(json.loads(trace_line))\n            traces.append(tx_traces)\n    self.append_traces(traces)\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.TransitionTool.TransitionToolData","title":"<code>TransitionToolData</code>  <code>dataclass</code>","text":"<p>Transition tool files and data to pass between methods.</p> Source code in <code>src/ethereum_clis/transition_tool.py</code> <pre><code>@dataclass\nclass TransitionToolData:\n    \"\"\"Transition tool files and data to pass between methods.\"\"\"\n\n    alloc: Alloc\n    txs: List[Transaction]\n    env: Environment\n    fork_name: str\n    chain_id: int\n    reward: int\n    blob_schedule: BlobSchedule | None\n    state_test: bool\n\n    def to_input(self) -&gt; TransitionToolInput:\n        \"\"\"Convert the data to a TransactionToolInput object.\"\"\"\n        return TransitionToolInput(\n            alloc=self.alloc,\n            txs=self.txs,\n            env=self.env,\n        )\n\n    def get_request_data(self) -&gt; TransitionToolRequest:\n        \"\"\"Convert the data to a TransitionToolRequest object.\"\"\"\n        return TransitionToolRequest(\n            state=TransitionToolContext(\n                fork=self.fork_name,\n                chain_id=self.chain_id,\n                reward=self.reward,\n                blob_schedule=self.blob_schedule,\n            ),\n            input=self.to_input(),\n        )\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.TransitionTool.TransitionToolData.to_input","title":"<code>to_input()</code>","text":"<p>Convert the data to a TransactionToolInput object.</p> Source code in <code>src/ethereum_clis/transition_tool.py</code> <pre><code>def to_input(self) -&gt; TransitionToolInput:\n    \"\"\"Convert the data to a TransactionToolInput object.\"\"\"\n    return TransitionToolInput(\n        alloc=self.alloc,\n        txs=self.txs,\n        env=self.env,\n    )\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.TransitionTool.TransitionToolData.get_request_data","title":"<code>get_request_data()</code>","text":"<p>Convert the data to a TransitionToolRequest object.</p> Source code in <code>src/ethereum_clis/transition_tool.py</code> <pre><code>def get_request_data(self) -&gt; TransitionToolRequest:\n    \"\"\"Convert the data to a TransitionToolRequest object.\"\"\"\n    return TransitionToolRequest(\n        state=TransitionToolContext(\n            fork=self.fork_name,\n            chain_id=self.chain_id,\n            reward=self.reward,\n            blob_schedule=self.blob_schedule,\n        ),\n        input=self.to_input(),\n    )\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.TransitionTool.construct_args_stream","title":"<code>construct_args_stream(t8n_data, temp_dir)</code>","text":"<p>Construct arguments for t8n interaction via streams.</p> Source code in <code>src/ethereum_clis/transition_tool.py</code> <pre><code>def construct_args_stream(\n    self, t8n_data: TransitionToolData, temp_dir: tempfile.TemporaryDirectory\n) -&gt; List[str]:\n    \"\"\"Construct arguments for t8n interaction via streams.\"\"\"\n    command: list[str] = [str(self.binary)]\n    if self.subcommand:\n        command.append(self.subcommand)\n\n    args = command + [\n        \"--input.alloc=stdin\",\n        \"--input.txs=stdin\",\n        \"--input.env=stdin\",\n        \"--output.result=stdout\",\n        \"--output.alloc=stdout\",\n        \"--output.body=stdout\",\n        f\"--state.fork={t8n_data.fork_name}\",\n        f\"--state.chainid={t8n_data.chain_id}\",\n        f\"--state.reward={t8n_data.reward}\",\n    ]\n\n    if self.trace:\n        args.append(\"--trace\")\n        args.append(f\"--output.basedir={temp_dir.name}\")\n    return args\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.TransitionTool.dump_debug_stream","title":"<code>dump_debug_stream(debug_output_path, temp_dir, stdin, args, result)</code>","text":"<p>Export debug files if requested when interacting with t8n via streams.</p> Source code in <code>src/ethereum_clis/transition_tool.py</code> <pre><code>def dump_debug_stream(\n    self,\n    debug_output_path: str,\n    temp_dir: tempfile.TemporaryDirectory,\n    stdin: TransitionToolInput,\n    args: List[str],\n    result: subprocess.CompletedProcess,\n):\n    \"\"\"Export debug files if requested when interacting with t8n via streams.\"\"\"\n    if not debug_output_path:\n        return\n\n    t8n_call = \" \".join(args)\n    t8n_output_base_dir = os.path.join(debug_output_path, \"t8n.sh.out\")\n    if self.trace:\n        t8n_call = t8n_call.replace(temp_dir.name, t8n_output_base_dir)\n    t8n_script = textwrap.dedent(\n        f\"\"\"\\\n        #!/bin/bash\n        rm -rf {debug_output_path}/t8n.sh.out  # hard-coded to avoid surprises\n        mkdir {debug_output_path}/t8n.sh.out  # unused if tracing is not enabled\n        {t8n_call} &lt; {debug_output_path}/stdin.txt\n        \"\"\"\n    )\n    dump_files_to_directory(\n        debug_output_path,\n        {\n            \"args.py\": args,\n            \"input/alloc.json\": stdin.alloc,\n            \"input/env.json\": stdin.env,\n            \"input/txs.json\": [\n                tx.model_dump(mode=\"json\", **model_dump_config) for tx in stdin.txs\n            ],\n            \"returncode.txt\": result.returncode,\n            \"stdin.txt\": stdin,\n            \"stdout.txt\": result.stdout.decode(),\n            \"stderr.txt\": result.stderr.decode(),\n            \"t8n.sh+x\": t8n_script,\n        },\n    )\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.TransitionTool.evaluate","title":"<code>evaluate(*, alloc, txs, env, fork, chain_id, reward, blob_schedule, eips=None, debug_output_path='', state_test=False, slow_request=False)</code>","text":"<p>Execute the relevant evaluate method as required by the <code>t8n</code> tool.</p> <p>If a client's <code>t8n</code> tool varies from the default behavior, this method can be overridden.</p> Source code in <code>src/ethereum_clis/transition_tool.py</code> <pre><code>def evaluate(\n    self,\n    *,\n    alloc: Alloc,\n    txs: List[Transaction],\n    env: Environment,\n    fork: Fork,\n    chain_id: int,\n    reward: int,\n    blob_schedule: BlobSchedule | None,\n    eips: Optional[List[int]] = None,\n    debug_output_path: str = \"\",\n    state_test: bool = False,\n    slow_request: bool = False,\n) -&gt; TransitionToolOutput:\n    \"\"\"\n    Execute the relevant evaluate method as required by the `t8n` tool.\n\n    If a client's `t8n` tool varies from the default behavior, this method\n    can be overridden.\n    \"\"\"\n    fork_name = fork.transition_tool_name(\n        block_number=env.number,\n        timestamp=env.timestamp,\n    )\n    if eips is not None:\n        fork_name = \"+\".join([fork_name] + [str(eip) for eip in eips])\n    if env.number == 0:\n        reward = -1\n    t8n_data = self.TransitionToolData(\n        alloc=alloc,\n        txs=txs,\n        env=env,\n        fork_name=fork_name,\n        chain_id=chain_id,\n        reward=reward,\n        blob_schedule=blob_schedule,\n        state_test=state_test,\n    )\n\n    if self.t8n_use_server:\n        if not self.process:\n            self.start_server()\n        return self._evaluate_server(\n            t8n_data=t8n_data,\n            debug_output_path=debug_output_path,\n            timeout=SLOW_REQUEST_TIMEOUT if slow_request else NORMAL_SERVER_TIMEOUT,\n        )\n\n    if self.t8n_use_stream:\n        return self._evaluate_stream(t8n_data=t8n_data, debug_output_path=debug_output_path)\n\n    return self._evaluate_filesystem(\n        t8n_data=t8n_data,\n        debug_output_path=debug_output_path,\n    )\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.Result","title":"<code>Result</code>","text":"<p>               Bases: <code>CamelModel</code></p> <p>Result of a transition tool output.</p> Source code in <code>src/ethereum_clis/types.py</code> <pre><code>class Result(CamelModel):\n    \"\"\"Result of a transition tool output.\"\"\"\n\n    state_root: Hash\n    ommers_hash: Hash | None = Field(None, validation_alias=\"sha3Uncles\")\n    transactions_trie: Hash = Field(..., alias=\"txRoot\")\n    receipts_root: Hash\n    logs_hash: Hash\n    logs_bloom: Bloom\n    receipts: List[TransactionReceipt]\n    rejected_transactions: List[RejectedTransaction] = Field(\n        default_factory=list, alias=\"rejected\"\n    )\n    difficulty: HexNumber | None = Field(None, alias=\"currentDifficulty\")\n    gas_used: HexNumber\n    base_fee_per_gas: HexNumber | None = Field(None, alias=\"currentBaseFee\")\n    withdrawals_root: Hash | None = None\n    excess_blob_gas: HexNumber | None = Field(None, alias=\"currentExcessBlobGas\")\n    blob_gas_used: HexNumber | None = None\n    requests_hash: Hash | None = None\n    requests: List[Bytes] | None = None\n</code></pre>"},{"location":"library/ethereum_clis/#ethereum_clis.TransitionToolOutput","title":"<code>TransitionToolOutput</code>","text":"<p>               Bases: <code>CamelModel</code></p> <p>Transition tool output.</p> Source code in <code>src/ethereum_clis/types.py</code> <pre><code>class TransitionToolOutput(CamelModel):\n    \"\"\"Transition tool output.\"\"\"\n\n    alloc: Alloc\n    result: Result\n    body: Bytes | None = None\n</code></pre>"},{"location":"library/ethereum_test_base_types/","title":"Ethereum Test Base Types package","text":"<p>Common definitions and types.</p>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Address","title":"<code>Address</code>","text":"<p>               Bases: <code>FixedSizeBytes[20]</code></p> <p>Class that helps represent Ethereum addresses in tests.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>class Address(FixedSizeBytes[20]):  # type: ignore\n    \"\"\"Class that helps represent Ethereum addresses in tests.\"\"\"\n\n    label: str | None = None\n\n    def __new__(\n        cls,\n        input_bytes: \"FixedSizeBytesConvertible | Address\",\n        *args,\n        label: str | None = None,\n        **kwargs,\n    ):\n        \"\"\"Create a new Address object with an optional label.\"\"\"\n        instance = super(Address, cls).__new__(cls, input_bytes, *args, **kwargs)\n        if isinstance(input_bytes, Address) and label is None:\n            instance.label = input_bytes.label\n        else:\n            instance.label = label\n        return instance\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Address.__new__","title":"<code>__new__(input_bytes, *args, label=None, **kwargs)</code>","text":"<p>Create a new Address object with an optional label.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def __new__(\n    cls,\n    input_bytes: \"FixedSizeBytesConvertible | Address\",\n    *args,\n    label: str | None = None,\n    **kwargs,\n):\n    \"\"\"Create a new Address object with an optional label.\"\"\"\n    instance = super(Address, cls).__new__(cls, input_bytes, *args, **kwargs)\n    if isinstance(input_bytes, Address) and label is None:\n        instance.label = input_bytes.label\n    else:\n        instance.label = label\n    return instance\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Bloom","title":"<code>Bloom</code>","text":"<p>               Bases: <code>FixedSizeBytes[256]</code></p> <p>Class that helps represent blooms in tests.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>class Bloom(FixedSizeBytes[256]):  # type: ignore\n    \"\"\"Class that helps represent blooms in tests.\"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.BLSPublicKey","title":"<code>BLSPublicKey</code>","text":"<p>               Bases: <code>FixedSizeBytes[48]</code></p> <p>Class that helps represent BLS public keys in tests.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>class BLSPublicKey(FixedSizeBytes[48]):  # type: ignore\n    \"\"\"Class that helps represent BLS public keys in tests.\"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.BLSSignature","title":"<code>BLSSignature</code>","text":"<p>               Bases: <code>FixedSizeBytes[96]</code></p> <p>Class that helps represent BLS signatures in tests.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>class BLSSignature(FixedSizeBytes[96]):  # type: ignore\n    \"\"\"Class that helps represent BLS signatures in tests.\"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Bytes","title":"<code>Bytes</code>","text":"<p>               Bases: <code>bytes</code>, <code>ToStringSchema</code></p> <p>Class that helps represent bytes of variable length in tests.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>class Bytes(bytes, ToStringSchema):\n    \"\"\"Class that helps represent bytes of variable length in tests.\"\"\"\n\n    def __new__(cls, input_bytes: BytesConvertible = b\"\"):\n        \"\"\"Create a new Bytes object.\"\"\"\n        if type(input_bytes) is cls:\n            return input_bytes\n        return super(Bytes, cls).__new__(cls, to_bytes(input_bytes))\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return the hash of the bytes.\"\"\"\n        return super(Bytes, self).__hash__()\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the hexadecimal representation of the bytes.\"\"\"\n        return self.hex()\n\n    def hex(self, *args, **kwargs) -&gt; str:\n        \"\"\"Return the hexadecimal representation of the bytes.\"\"\"\n        return \"0x\" + super().hex(*args, **kwargs)\n\n    @classmethod\n    def or_none(cls, input_bytes: \"Bytes | BytesConvertible | None\") -&gt; \"Bytes | None\":\n        \"\"\"Convert the input to a Bytes while accepting None.\"\"\"\n        if input_bytes is None:\n            return input_bytes\n        return cls(input_bytes)\n\n    def keccak256(self) -&gt; \"Hash\":\n        \"\"\"Return the keccak256 hash of the opcode byte representation.\"\"\"\n        k = keccak.new(digest_bits=256)\n        return Hash(k.update(bytes(self)).digest())\n\n    def sha256(self) -&gt; \"Hash\":\n        \"\"\"Return the sha256 hash of the opcode byte representation.\"\"\"\n        return Hash(sha256(self).digest())\n\n    @staticmethod\n    def __get_pydantic_core_schema__(\n        source_type: Any, handler: GetCoreSchemaHandler\n    ) -&gt; PlainValidatorFunctionSchema:\n        \"\"\"Call the class constructor without info and appends the serialization schema.\"\"\"\n        return no_info_plain_validator_function(\n            source_type,\n            serialization=to_string_ser_schema(),\n            json_schema_input_schema=handler(\n                Annotated[str, StringConstraints(pattern=r\"^0x([0-9a-fA-F]{2})*$\")]\n            ),\n        )\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Bytes.__new__","title":"<code>__new__(input_bytes=b'')</code>","text":"<p>Create a new Bytes object.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def __new__(cls, input_bytes: BytesConvertible = b\"\"):\n    \"\"\"Create a new Bytes object.\"\"\"\n    if type(input_bytes) is cls:\n        return input_bytes\n    return super(Bytes, cls).__new__(cls, to_bytes(input_bytes))\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Bytes.__hash__","title":"<code>__hash__()</code>","text":"<p>Return the hash of the bytes.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return the hash of the bytes.\"\"\"\n    return super(Bytes, self).__hash__()\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Bytes.__str__","title":"<code>__str__()</code>","text":"<p>Return the hexadecimal representation of the bytes.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the hexadecimal representation of the bytes.\"\"\"\n    return self.hex()\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Bytes.hex","title":"<code>hex(*args, **kwargs)</code>","text":"<p>Return the hexadecimal representation of the bytes.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def hex(self, *args, **kwargs) -&gt; str:\n    \"\"\"Return the hexadecimal representation of the bytes.\"\"\"\n    return \"0x\" + super().hex(*args, **kwargs)\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Bytes.or_none","title":"<code>or_none(input_bytes)</code>  <code>classmethod</code>","text":"<p>Convert the input to a Bytes while accepting None.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>@classmethod\ndef or_none(cls, input_bytes: \"Bytes | BytesConvertible | None\") -&gt; \"Bytes | None\":\n    \"\"\"Convert the input to a Bytes while accepting None.\"\"\"\n    if input_bytes is None:\n        return input_bytes\n    return cls(input_bytes)\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Bytes.keccak256","title":"<code>keccak256()</code>","text":"<p>Return the keccak256 hash of the opcode byte representation.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def keccak256(self) -&gt; \"Hash\":\n    \"\"\"Return the keccak256 hash of the opcode byte representation.\"\"\"\n    k = keccak.new(digest_bits=256)\n    return Hash(k.update(bytes(self)).digest())\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Bytes.sha256","title":"<code>sha256()</code>","text":"<p>Return the sha256 hash of the opcode byte representation.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def sha256(self) -&gt; \"Hash\":\n    \"\"\"Return the sha256 hash of the opcode byte representation.\"\"\"\n    return Hash(sha256(self).digest())\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Bytes.__get_pydantic_core_schema__","title":"<code>__get_pydantic_core_schema__(source_type, handler)</code>  <code>staticmethod</code>","text":"<p>Call the class constructor without info and appends the serialization schema.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>@staticmethod\ndef __get_pydantic_core_schema__(\n    source_type: Any, handler: GetCoreSchemaHandler\n) -&gt; PlainValidatorFunctionSchema:\n    \"\"\"Call the class constructor without info and appends the serialization schema.\"\"\"\n    return no_info_plain_validator_function(\n        source_type,\n        serialization=to_string_ser_schema(),\n        json_schema_input_schema=handler(\n            Annotated[str, StringConstraints(pattern=r\"^0x([0-9a-fA-F]{2})*$\")]\n        ),\n    )\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.FixedSizeBytes","title":"<code>FixedSizeBytes</code>","text":"<p>               Bases: <code>Bytes</code></p> <p>Class that helps represent bytes of fixed length in tests.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>class FixedSizeBytes(Bytes):\n    \"\"\"Class that helps represent bytes of fixed length in tests.\"\"\"\n\n    byte_length: ClassVar[int]\n    _sized_: ClassVar[Type[\"FixedSizeBytes\"]]\n\n    def __class_getitem__(cls, length: int) -&gt; Type[\"FixedSizeBytes\"]:\n        \"\"\"Create a new FixedSizeBytes class with the given length.\"\"\"\n\n        class Sized(cls):  # type: ignore\n            byte_length = length\n\n        Sized._sized_ = Sized\n        return Sized\n\n    def __new__(\n        cls,\n        input_bytes: FixedSizeBytesConvertible | T,\n        *,\n        left_padding: bool = False,\n        right_padding: bool = False,\n    ):\n        \"\"\"Create a new FixedSizeBytes object.\"\"\"\n        if type(input_bytes) is cls:\n            return input_bytes\n        return super(FixedSizeBytes, cls).__new__(\n            cls,\n            to_fixed_size_bytes(\n                input_bytes,\n                cls.byte_length,\n                left_padding=left_padding,\n                right_padding=right_padding,\n            ),\n        )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return the hash of the bytes.\"\"\"\n        return super(FixedSizeBytes, self).__hash__()\n\n    @classmethod\n    def or_none(cls: Type[T], input_bytes: T | FixedSizeBytesConvertible | None) -&gt; T | None:\n        \"\"\"Convert the input to a Fixed Size Bytes while accepting None.\"\"\"\n        if input_bytes is None:\n            return input_bytes\n        return cls(input_bytes)\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Compare two FixedSizeBytes objects to be equal.\"\"\"\n        if other is None:\n            return False\n        if not isinstance(other, FixedSizeBytes):\n            assert (\n                isinstance(other, str)\n                or isinstance(other, int)\n                or isinstance(other, bytes)\n                or isinstance(other, SupportsBytes)\n            )\n            other = self._sized_(other)\n        return super().__eq__(other)\n\n    def __ne__(self, other: object) -&gt; bool:\n        \"\"\"Compare two FixedSizeBytes objects to be not equal.\"\"\"\n        return not self.__eq__(other)\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls: Type[Self], source_type: Any, handler: GetCoreSchemaHandler\n    ) -&gt; PlainValidatorFunctionSchema:\n        \"\"\"Call the class constructor without info and appends the serialization schema.\"\"\"\n        pattern = f\"^0x([0-9a-fA-F]{{{cls.byte_length * 2}}})*$\"\n        return no_info_plain_validator_function(\n            source_type,\n            serialization=to_string_ser_schema(),\n            json_schema_input_schema=handler(Annotated[str, StringConstraints(pattern=pattern)]),\n        )\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.FixedSizeBytes.__class_getitem__","title":"<code>__class_getitem__(length)</code>","text":"<p>Create a new FixedSizeBytes class with the given length.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def __class_getitem__(cls, length: int) -&gt; Type[\"FixedSizeBytes\"]:\n    \"\"\"Create a new FixedSizeBytes class with the given length.\"\"\"\n\n    class Sized(cls):  # type: ignore\n        byte_length = length\n\n    Sized._sized_ = Sized\n    return Sized\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.FixedSizeBytes.__new__","title":"<code>__new__(input_bytes, *, left_padding=False, right_padding=False)</code>","text":"<p>Create a new FixedSizeBytes object.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def __new__(\n    cls,\n    input_bytes: FixedSizeBytesConvertible | T,\n    *,\n    left_padding: bool = False,\n    right_padding: bool = False,\n):\n    \"\"\"Create a new FixedSizeBytes object.\"\"\"\n    if type(input_bytes) is cls:\n        return input_bytes\n    return super(FixedSizeBytes, cls).__new__(\n        cls,\n        to_fixed_size_bytes(\n            input_bytes,\n            cls.byte_length,\n            left_padding=left_padding,\n            right_padding=right_padding,\n        ),\n    )\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.FixedSizeBytes.__hash__","title":"<code>__hash__()</code>","text":"<p>Return the hash of the bytes.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return the hash of the bytes.\"\"\"\n    return super(FixedSizeBytes, self).__hash__()\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.FixedSizeBytes.or_none","title":"<code>or_none(input_bytes)</code>  <code>classmethod</code>","text":"<p>Convert the input to a Fixed Size Bytes while accepting None.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>@classmethod\ndef or_none(cls: Type[T], input_bytes: T | FixedSizeBytesConvertible | None) -&gt; T | None:\n    \"\"\"Convert the input to a Fixed Size Bytes while accepting None.\"\"\"\n    if input_bytes is None:\n        return input_bytes\n    return cls(input_bytes)\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.FixedSizeBytes.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two FixedSizeBytes objects to be equal.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Compare two FixedSizeBytes objects to be equal.\"\"\"\n    if other is None:\n        return False\n    if not isinstance(other, FixedSizeBytes):\n        assert (\n            isinstance(other, str)\n            or isinstance(other, int)\n            or isinstance(other, bytes)\n            or isinstance(other, SupportsBytes)\n        )\n        other = self._sized_(other)\n    return super().__eq__(other)\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.FixedSizeBytes.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compare two FixedSizeBytes objects to be not equal.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def __ne__(self, other: object) -&gt; bool:\n    \"\"\"Compare two FixedSizeBytes objects to be not equal.\"\"\"\n    return not self.__eq__(other)\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.FixedSizeBytes.__get_pydantic_core_schema__","title":"<code>__get_pydantic_core_schema__(source_type, handler)</code>  <code>classmethod</code>","text":"<p>Call the class constructor without info and appends the serialization schema.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(\n    cls: Type[Self], source_type: Any, handler: GetCoreSchemaHandler\n) -&gt; PlainValidatorFunctionSchema:\n    \"\"\"Call the class constructor without info and appends the serialization schema.\"\"\"\n    pattern = f\"^0x([0-9a-fA-F]{{{cls.byte_length * 2}}})*$\"\n    return no_info_plain_validator_function(\n        source_type,\n        serialization=to_string_ser_schema(),\n        json_schema_input_schema=handler(Annotated[str, StringConstraints(pattern=pattern)]),\n    )\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Hash","title":"<code>Hash</code>","text":"<p>               Bases: <code>FixedSizeBytes[32]</code></p> <p>Class that helps represent hashes in tests.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>class Hash(FixedSizeBytes[32]):  # type: ignore\n    \"\"\"Class that helps represent hashes in tests.\"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.HashInt","title":"<code>HashInt</code>","text":"<p>               Bases: <code>FixedSizeHexNumber[32]</code></p> <p>Class that helps represent hashes in tests.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>class HashInt(FixedSizeHexNumber[32]):  # type: ignore\n    \"\"\"Class that helps represent hashes in tests.\"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.HeaderNonce","title":"<code>HeaderNonce</code>","text":"<p>               Bases: <code>FixedSizeBytes[8]</code></p> <p>Class that helps represent the header nonce in tests.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>class HeaderNonce(FixedSizeBytes[8]):  # type: ignore\n    \"\"\"Class that helps represent the header nonce in tests.\"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.HexNumber","title":"<code>HexNumber</code>","text":"<p>               Bases: <code>Number</code></p> <p>Class that helps represent an hexadecimal numbers in tests.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>class HexNumber(Number):\n    \"\"\"Class that helps represent an hexadecimal numbers in tests.\"\"\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the string representation of the number.\"\"\"\n        return self.hex()\n\n    @staticmethod\n    def __get_pydantic_core_schema__(\n        source_type: Any, handler: GetCoreSchemaHandler\n    ) -&gt; PlainValidatorFunctionSchema:\n        \"\"\"Call the class constructor without info and appends the serialization schema.\"\"\"\n        return no_info_plain_validator_function(\n            source_type,\n            serialization=to_string_ser_schema(),\n            json_schema_input_schema=handler(\n                Annotated[str, StringConstraints(pattern=r\"^0x[0-9a-fA-F]*$\")]\n            ),\n        )\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.HexNumber.__str__","title":"<code>__str__()</code>","text":"<p>Return the string representation of the number.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the string representation of the number.\"\"\"\n    return self.hex()\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.HexNumber.__get_pydantic_core_schema__","title":"<code>__get_pydantic_core_schema__(source_type, handler)</code>  <code>staticmethod</code>","text":"<p>Call the class constructor without info and appends the serialization schema.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>@staticmethod\ndef __get_pydantic_core_schema__(\n    source_type: Any, handler: GetCoreSchemaHandler\n) -&gt; PlainValidatorFunctionSchema:\n    \"\"\"Call the class constructor without info and appends the serialization schema.\"\"\"\n    return no_info_plain_validator_function(\n        source_type,\n        serialization=to_string_ser_schema(),\n        json_schema_input_schema=handler(\n            Annotated[str, StringConstraints(pattern=r\"^0x[0-9a-fA-F]*$\")]\n        ),\n    )\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Number","title":"<code>Number</code>","text":"<p>               Bases: <code>int</code>, <code>ToStringSchema</code></p> <p>Class that helps represent numbers in tests.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>class Number(int, ToStringSchema):\n    \"\"\"Class that helps represent numbers in tests.\"\"\"\n\n    def __new__(cls, input_number: NumberConvertible | N):\n        \"\"\"Create a new Number object.\"\"\"\n        return super(Number, cls).__new__(cls, to_number(input_number))\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the string representation of the number.\"\"\"\n        return str(int(self))\n\n    def hex(self) -&gt; str:\n        \"\"\"Return the hexadecimal representation of the number.\"\"\"\n        return hex(self)\n\n    @classmethod\n    def or_none(cls: Type[N], input_number: N | NumberConvertible | None) -&gt; N | None:\n        \"\"\"Convert the input to a Number while accepting None.\"\"\"\n        if input_number is None:\n            return input_number\n        return cls(input_number)\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Number.__new__","title":"<code>__new__(input_number)</code>","text":"<p>Create a new Number object.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def __new__(cls, input_number: NumberConvertible | N):\n    \"\"\"Create a new Number object.\"\"\"\n    return super(Number, cls).__new__(cls, to_number(input_number))\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Number.__str__","title":"<code>__str__()</code>","text":"<p>Return the string representation of the number.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the string representation of the number.\"\"\"\n    return str(int(self))\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Number.hex","title":"<code>hex()</code>","text":"<p>Return the hexadecimal representation of the number.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def hex(self) -&gt; str:\n    \"\"\"Return the hexadecimal representation of the number.\"\"\"\n    return hex(self)\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Number.or_none","title":"<code>or_none(input_number)</code>  <code>classmethod</code>","text":"<p>Convert the input to a Number while accepting None.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>@classmethod\ndef or_none(cls: Type[N], input_number: N | NumberConvertible | None) -&gt; N | None:\n    \"\"\"Convert the input to a Number while accepting None.\"\"\"\n    if input_number is None:\n        return input_number\n    return cls(input_number)\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Wei","title":"<code>Wei</code>","text":"<p>               Bases: <code>Number</code></p> <p>Class that helps represent wei that can be parsed from strings.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>class Wei(Number):\n    \"\"\"Class that helps represent wei that can be parsed from strings.\"\"\"\n\n    def __new__(cls, input_number: NumberConvertible | N):\n        \"\"\"Create a new Number object.\"\"\"\n        if isinstance(input_number, str):\n            words = input_number.split()\n            multiplier = 1\n            assert len(words) &lt;= 2\n            value_str = words[0]\n            if len(words) &gt; 1:\n                unit = words[1].lower()\n                multiplier = cls._get_multiplier(unit)\n            value: float\n            if \"**\" in value_str:\n                base, exp = value_str.split(\"**\")\n                value = float(base) ** int(exp)\n            else:\n                value = float(value_str)\n            return super(Number, cls).__new__(cls, value * multiplier)\n        return super(Number, cls).__new__(cls, to_number(input_number))\n\n    @staticmethod\n    def _get_multiplier(unit: str) -&gt; int:\n        \"\"\"Return the multiplier for the given unit of wei, handling synonyms.\"\"\"\n        match unit:\n            case \"wei\":\n                return 1\n            case \"kwei\" | \"babbage\" | \"femtoether\":\n                return 10**3\n            case \"mwei\" | \"lovelace\" | \"picoether\":\n                return 10**6\n            case \"gwei\" | \"shannon\" | \"nanoether\" | \"nano\":\n                return 10**9\n            case \"szabo\" | \"microether\" | \"micro\":\n                return 10**12\n            case \"finney\" | \"milliether\" | \"milli\":\n                return 10**15\n            case \"ether\" | \"eth\":\n                return 10**18\n            case _:\n                raise ValueError(f\"Invalid unit {unit}\")\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Wei.__new__","title":"<code>__new__(input_number)</code>","text":"<p>Create a new Number object.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def __new__(cls, input_number: NumberConvertible | N):\n    \"\"\"Create a new Number object.\"\"\"\n    if isinstance(input_number, str):\n        words = input_number.split()\n        multiplier = 1\n        assert len(words) &lt;= 2\n        value_str = words[0]\n        if len(words) &gt; 1:\n            unit = words[1].lower()\n            multiplier = cls._get_multiplier(unit)\n        value: float\n        if \"**\" in value_str:\n            base, exp = value_str.split(\"**\")\n            value = float(base) ** int(exp)\n        else:\n            value = float(value_str)\n        return super(Number, cls).__new__(cls, value * multiplier)\n    return super(Number, cls).__new__(cls, to_number(input_number))\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.ZeroPaddedHexNumber","title":"<code>ZeroPaddedHexNumber</code>","text":"<p>               Bases: <code>HexNumber</code></p> <p>Class that helps represent zero padded hexadecimal numbers in tests.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>class ZeroPaddedHexNumber(HexNumber):\n    \"\"\"Class that helps represent zero padded hexadecimal numbers in tests.\"\"\"\n\n    def hex(self) -&gt; str:\n        \"\"\"Return the hexadecimal representation of the number.\"\"\"\n        if self == 0:\n            return \"0x00\"\n        hex_str = hex(self)[2:]\n        if len(hex_str) % 2 == 1:\n            return \"0x0\" + hex_str\n        return \"0x\" + hex_str\n\n    @staticmethod\n    def __get_pydantic_core_schema__(\n        source_type: Any, handler: GetCoreSchemaHandler\n    ) -&gt; PlainValidatorFunctionSchema:\n        \"\"\"Call the class constructor without info and appends the serialization schema.\"\"\"\n        return no_info_plain_validator_function(\n            source_type,\n            serialization=to_string_ser_schema(),\n            json_schema_input_schema=handler(\n                Annotated[str, StringConstraints(pattern=r\"^0x([0-9a-fA-F]{2})*$\")]\n            ),\n        )\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.ZeroPaddedHexNumber.hex","title":"<code>hex()</code>","text":"<p>Return the hexadecimal representation of the number.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def hex(self) -&gt; str:\n    \"\"\"Return the hexadecimal representation of the number.\"\"\"\n    if self == 0:\n        return \"0x00\"\n    hex_str = hex(self)[2:]\n    if len(hex_str) % 2 == 1:\n        return \"0x0\" + hex_str\n    return \"0x\" + hex_str\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.ZeroPaddedHexNumber.__get_pydantic_core_schema__","title":"<code>__get_pydantic_core_schema__(source_type, handler)</code>  <code>staticmethod</code>","text":"<p>Call the class constructor without info and appends the serialization schema.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>@staticmethod\ndef __get_pydantic_core_schema__(\n    source_type: Any, handler: GetCoreSchemaHandler\n) -&gt; PlainValidatorFunctionSchema:\n    \"\"\"Call the class constructor without info and appends the serialization schema.\"\"\"\n    return no_info_plain_validator_function(\n        source_type,\n        serialization=to_string_ser_schema(),\n        json_schema_input_schema=handler(\n            Annotated[str, StringConstraints(pattern=r\"^0x([0-9a-fA-F]{2})*$\")]\n        ),\n    )\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.AccessList","title":"<code>AccessList</code>","text":"<p>               Bases: <code>CamelModel</code></p> <p>Access List for transactions.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>class AccessList(CamelModel):\n    \"\"\"Access List for transactions.\"\"\"\n\n    address: Address\n    storage_keys: List[Hash]\n\n    def to_list(self) -&gt; List[Address | List[Hash]]:\n        \"\"\"Return access list as a list of serializable elements.\"\"\"\n        return [self.address, self.storage_keys]\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.AccessList.to_list","title":"<code>to_list()</code>","text":"<p>Return access list as a list of serializable elements.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def to_list(self) -&gt; List[Address | List[Hash]]:\n    \"\"\"Return access list as a list of serializable elements.\"\"\"\n    return [self.address, self.storage_keys]\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Account","title":"<code>Account</code>","text":"<p>               Bases: <code>CamelModel</code></p> <p>State associated with an address.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>class Account(CamelModel):\n    \"\"\"State associated with an address.\"\"\"\n\n    nonce: ZeroPaddedHexNumber = ZeroPaddedHexNumber(0)\n    \"\"\"\n    The scalar value equal to a) the number of transactions sent by\n    an Externally Owned Account, b) the amount of contracts created by a\n    contract.\n    \"\"\"\n    balance: ZeroPaddedHexNumber = ZeroPaddedHexNumber(0)\n    \"\"\"\n    The amount of Wei (10&lt;sup&gt;-18&lt;/sup&gt; Eth) the account has.\n    \"\"\"\n    code: Bytes = Bytes(b\"\")\n    \"\"\"\n    Bytecode contained by the account.\n    \"\"\"\n    storage: Storage = Field(default_factory=Storage)\n    \"\"\"\n    Storage within a contract.\n    \"\"\"\n\n    NONEXISTENT: ClassVar[None] = None\n    \"\"\"\n    Sentinel object used to specify when an account should not exist in the\n    state.\n    \"\"\"\n\n    @dataclass(kw_only=True)\n    class NonceMismatchError(Exception):\n        \"\"\"\n        Test expected a certain nonce value for an account but a different\n        value was found.\n        \"\"\"\n\n        address: Address\n        want: int | None\n        got: int | None\n\n        def __init__(self, address: Address, want: int | None, got: int | None, *args):\n            \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n            super().__init__(args)\n            self.address = address\n            self.want = want\n            self.got = got\n\n        def __str__(self):\n            \"\"\"Print exception string.\"\"\"\n            label_str = \"\"\n            if self.address.label is not None:\n                label_str = f\" ({self.address.label})\"\n            return (\n                f\"unexpected nonce for account {self.address}{label_str}: \"\n                + f\"want {self.want}, got {self.got}\"\n            )\n\n    @dataclass(kw_only=True)\n    class BalanceMismatchError(Exception):\n        \"\"\"\n        Test expected a certain balance for an account but a different\n        value was found.\n        \"\"\"\n\n        address: Address\n        want: int | None\n        got: int | None\n\n        def __init__(self, address: Address, want: int | None, got: int | None, *args):\n            \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n            super().__init__(args)\n            self.address = address\n            self.want = want\n            self.got = got\n\n        def __str__(self):\n            \"\"\"Print exception string.\"\"\"\n            label_str = \"\"\n            if self.address.label is not None:\n                label_str = f\" ({self.address.label})\"\n            return (\n                f\"unexpected balance for account {self.address}{label_str}: \"\n                + f\"want {self.want}, got {self.got}\"\n            )\n\n    @dataclass(kw_only=True)\n    class CodeMismatchError(Exception):\n        \"\"\"\n        Test expected a certain bytecode for an account but a different\n        one was found.\n        \"\"\"\n\n        address: Address\n        want: bytes | None\n        got: bytes | None\n\n        def __init__(self, address: Address, want: bytes | None, got: bytes | None, *args):\n            \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n            super().__init__(args)\n            self.address = address\n            self.want = want\n            self.got = got\n\n        def __str__(self):\n            \"\"\"Print exception string.\"\"\"\n            label_str = \"\"\n            if self.address.label is not None:\n                label_str = f\" ({self.address.label})\"\n            return (\n                f\"unexpected code for account {self.address}{label_str}: \"\n                + f\"want {self.want}, got {self.got}\"\n            )\n\n    def check_alloc(self: \"Account\", address: Address, account: \"Account\"):\n        \"\"\"\n        Check the returned alloc against an expected account in post state.\n        Raises exception on failure.\n        \"\"\"\n        if \"nonce\" in self.model_fields_set:\n            if self.nonce != account.nonce:\n                raise Account.NonceMismatchError(\n                    address=address,\n                    want=self.nonce,\n                    got=account.nonce,\n                )\n\n        if \"balance\" in self.model_fields_set:\n            if self.balance != account.balance:\n                raise Account.BalanceMismatchError(\n                    address=address,\n                    want=self.balance,\n                    got=account.balance,\n                )\n\n        if \"code\" in self.model_fields_set:\n            if self.code != account.code:\n                raise Account.CodeMismatchError(\n                    address=address,\n                    want=self.code,\n                    got=account.code,\n                )\n\n        if \"storage\" in self.model_fields_set:\n            self.storage.must_be_equal(address=address, other=account.storage)\n\n    def __bool__(self: \"Account\") -&gt; bool:\n        \"\"\"Return True on a non-empty account.\"\"\"\n        return any((self.nonce, self.balance, self.code, self.storage))\n\n    @classmethod\n    def with_code(cls: Type, code: BytesConvertible) -&gt; \"Account\":\n        \"\"\"Create account with provided `code` and nonce of `1`.\"\"\"\n        return Account(nonce=HexNumber(1), code=Bytes(code))\n\n    @classmethod\n    def merge(\n        cls: Type, account_1: \"Dict | Account | None\", account_2: \"Dict | Account | None\"\n    ) -&gt; \"Account\":\n        \"\"\"Create a merged account from two sources.\"\"\"\n\n        def to_kwargs_dict(account: \"Dict | Account | None\") -&gt; Dict:\n            if account is None:\n                return {}\n            if isinstance(account, dict):\n                return account\n            elif isinstance(account, cls):\n                return account.model_dump(exclude_unset=True)\n            raise TypeError(f\"Unexpected type for account merge: {type(account)}\")\n\n        kwargs = to_kwargs_dict(account_1)\n        kwargs.update(to_kwargs_dict(account_2))\n\n        return cls(**kwargs)\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Account.nonce","title":"<code>nonce: ZeroPaddedHexNumber = ZeroPaddedHexNumber(0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The scalar value equal to a) the number of transactions sent by an Externally Owned Account, b) the amount of contracts created by a contract.</p>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Account.balance","title":"<code>balance: ZeroPaddedHexNumber = ZeroPaddedHexNumber(0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The amount of Wei (10<sup>-18</sup> Eth) the account has.</p>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Account.code","title":"<code>code: Bytes = Bytes(b'')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Bytecode contained by the account.</p>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Account.storage","title":"<code>storage: Storage = Field(default_factory=Storage)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Storage within a contract.</p>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Account.NONEXISTENT","title":"<code>NONEXISTENT: None = None</code>  <code>class-attribute</code>","text":"<p>Sentinel object used to specify when an account should not exist in the state.</p>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Account.NonceMismatchError","title":"<code>NonceMismatchError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Test expected a certain nonce value for an account but a different value was found.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>@dataclass(kw_only=True)\nclass NonceMismatchError(Exception):\n    \"\"\"\n    Test expected a certain nonce value for an account but a different\n    value was found.\n    \"\"\"\n\n    address: Address\n    want: int | None\n    got: int | None\n\n    def __init__(self, address: Address, want: int | None, got: int | None, *args):\n        \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n        super().__init__(args)\n        self.address = address\n        self.want = want\n        self.got = got\n\n    def __str__(self):\n        \"\"\"Print exception string.\"\"\"\n        label_str = \"\"\n        if self.address.label is not None:\n            label_str = f\" ({self.address.label})\"\n        return (\n            f\"unexpected nonce for account {self.address}{label_str}: \"\n            + f\"want {self.want}, got {self.got}\"\n        )\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Account.NonceMismatchError.__init__","title":"<code>__init__(address, want, got, *args)</code>","text":"<p>Initialize the exception with the address, wanted and got values.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __init__(self, address: Address, want: int | None, got: int | None, *args):\n    \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n    super().__init__(args)\n    self.address = address\n    self.want = want\n    self.got = got\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Account.NonceMismatchError.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __str__(self):\n    \"\"\"Print exception string.\"\"\"\n    label_str = \"\"\n    if self.address.label is not None:\n        label_str = f\" ({self.address.label})\"\n    return (\n        f\"unexpected nonce for account {self.address}{label_str}: \"\n        + f\"want {self.want}, got {self.got}\"\n    )\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Account.BalanceMismatchError","title":"<code>BalanceMismatchError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Test expected a certain balance for an account but a different value was found.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>@dataclass(kw_only=True)\nclass BalanceMismatchError(Exception):\n    \"\"\"\n    Test expected a certain balance for an account but a different\n    value was found.\n    \"\"\"\n\n    address: Address\n    want: int | None\n    got: int | None\n\n    def __init__(self, address: Address, want: int | None, got: int | None, *args):\n        \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n        super().__init__(args)\n        self.address = address\n        self.want = want\n        self.got = got\n\n    def __str__(self):\n        \"\"\"Print exception string.\"\"\"\n        label_str = \"\"\n        if self.address.label is not None:\n            label_str = f\" ({self.address.label})\"\n        return (\n            f\"unexpected balance for account {self.address}{label_str}: \"\n            + f\"want {self.want}, got {self.got}\"\n        )\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Account.BalanceMismatchError.__init__","title":"<code>__init__(address, want, got, *args)</code>","text":"<p>Initialize the exception with the address, wanted and got values.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __init__(self, address: Address, want: int | None, got: int | None, *args):\n    \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n    super().__init__(args)\n    self.address = address\n    self.want = want\n    self.got = got\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Account.BalanceMismatchError.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __str__(self):\n    \"\"\"Print exception string.\"\"\"\n    label_str = \"\"\n    if self.address.label is not None:\n        label_str = f\" ({self.address.label})\"\n    return (\n        f\"unexpected balance for account {self.address}{label_str}: \"\n        + f\"want {self.want}, got {self.got}\"\n    )\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Account.CodeMismatchError","title":"<code>CodeMismatchError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Test expected a certain bytecode for an account but a different one was found.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>@dataclass(kw_only=True)\nclass CodeMismatchError(Exception):\n    \"\"\"\n    Test expected a certain bytecode for an account but a different\n    one was found.\n    \"\"\"\n\n    address: Address\n    want: bytes | None\n    got: bytes | None\n\n    def __init__(self, address: Address, want: bytes | None, got: bytes | None, *args):\n        \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n        super().__init__(args)\n        self.address = address\n        self.want = want\n        self.got = got\n\n    def __str__(self):\n        \"\"\"Print exception string.\"\"\"\n        label_str = \"\"\n        if self.address.label is not None:\n            label_str = f\" ({self.address.label})\"\n        return (\n            f\"unexpected code for account {self.address}{label_str}: \"\n            + f\"want {self.want}, got {self.got}\"\n        )\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Account.CodeMismatchError.__init__","title":"<code>__init__(address, want, got, *args)</code>","text":"<p>Initialize the exception with the address, wanted and got values.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __init__(self, address: Address, want: bytes | None, got: bytes | None, *args):\n    \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n    super().__init__(args)\n    self.address = address\n    self.want = want\n    self.got = got\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Account.CodeMismatchError.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __str__(self):\n    \"\"\"Print exception string.\"\"\"\n    label_str = \"\"\n    if self.address.label is not None:\n        label_str = f\" ({self.address.label})\"\n    return (\n        f\"unexpected code for account {self.address}{label_str}: \"\n        + f\"want {self.want}, got {self.got}\"\n    )\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Account.check_alloc","title":"<code>check_alloc(address, account)</code>","text":"<p>Check the returned alloc against an expected account in post state. Raises exception on failure.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def check_alloc(self: \"Account\", address: Address, account: \"Account\"):\n    \"\"\"\n    Check the returned alloc against an expected account in post state.\n    Raises exception on failure.\n    \"\"\"\n    if \"nonce\" in self.model_fields_set:\n        if self.nonce != account.nonce:\n            raise Account.NonceMismatchError(\n                address=address,\n                want=self.nonce,\n                got=account.nonce,\n            )\n\n    if \"balance\" in self.model_fields_set:\n        if self.balance != account.balance:\n            raise Account.BalanceMismatchError(\n                address=address,\n                want=self.balance,\n                got=account.balance,\n            )\n\n    if \"code\" in self.model_fields_set:\n        if self.code != account.code:\n            raise Account.CodeMismatchError(\n                address=address,\n                want=self.code,\n                got=account.code,\n            )\n\n    if \"storage\" in self.model_fields_set:\n        self.storage.must_be_equal(address=address, other=account.storage)\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Account.__bool__","title":"<code>__bool__()</code>","text":"<p>Return True on a non-empty account.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __bool__(self: \"Account\") -&gt; bool:\n    \"\"\"Return True on a non-empty account.\"\"\"\n    return any((self.nonce, self.balance, self.code, self.storage))\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Account.with_code","title":"<code>with_code(code)</code>  <code>classmethod</code>","text":"<p>Create account with provided <code>code</code> and nonce of <code>1</code>.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>@classmethod\ndef with_code(cls: Type, code: BytesConvertible) -&gt; \"Account\":\n    \"\"\"Create account with provided `code` and nonce of `1`.\"\"\"\n    return Account(nonce=HexNumber(1), code=Bytes(code))\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Account.merge","title":"<code>merge(account_1, account_2)</code>  <code>classmethod</code>","text":"<p>Create a merged account from two sources.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>@classmethod\ndef merge(\n    cls: Type, account_1: \"Dict | Account | None\", account_2: \"Dict | Account | None\"\n) -&gt; \"Account\":\n    \"\"\"Create a merged account from two sources.\"\"\"\n\n    def to_kwargs_dict(account: \"Dict | Account | None\") -&gt; Dict:\n        if account is None:\n            return {}\n        if isinstance(account, dict):\n            return account\n        elif isinstance(account, cls):\n            return account.model_dump(exclude_unset=True)\n        raise TypeError(f\"Unexpected type for account merge: {type(account)}\")\n\n    kwargs = to_kwargs_dict(account_1)\n    kwargs.update(to_kwargs_dict(account_2))\n\n    return cls(**kwargs)\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Alloc","title":"<code>Alloc</code>","text":"<p>               Bases: <code>EthereumTestRootModel[Dict[Address, Account | None]]</code></p> <p>Allocation of accounts in the state, pre and post test execution.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>class Alloc(EthereumTestRootModel[Dict[Address, Account | None]]):\n    \"\"\"Allocation of accounts in the state, pre and post test execution.\"\"\"\n\n    root: Dict[Address, Account | None] = Field(default_factory=dict, validate_default=True)\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.BlobSchedule","title":"<code>BlobSchedule</code>","text":"<p>               Bases: <code>EthereumTestRootModel[Dict[str, ForkBlobSchedule]]</code></p> <p>Blob schedule configuration dictionary.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>class BlobSchedule(EthereumTestRootModel[Dict[str, ForkBlobSchedule]]):\n    \"\"\"Blob schedule configuration dictionary.\"\"\"\n\n    root: Dict[str, ForkBlobSchedule] = Field(default_factory=dict, validate_default=True)\n\n    def append(self, *, fork: str, schedule: Any):\n        \"\"\"Append a new fork schedule.\"\"\"\n        if not isinstance(schedule, ForkBlobSchedule):\n            schedule = ForkBlobSchedule(**schedule)\n        self.root[fork] = schedule\n\n    def last(self) -&gt; ForkBlobSchedule | None:\n        \"\"\"Return the last schedule.\"\"\"\n        if len(self.root) == 0:\n            return None\n        return list(self.root.values())[-1]\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.BlobSchedule.append","title":"<code>append(*, fork, schedule)</code>","text":"<p>Append a new fork schedule.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def append(self, *, fork: str, schedule: Any):\n    \"\"\"Append a new fork schedule.\"\"\"\n    if not isinstance(schedule, ForkBlobSchedule):\n        schedule = ForkBlobSchedule(**schedule)\n    self.root[fork] = schedule\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.BlobSchedule.last","title":"<code>last()</code>","text":"<p>Return the last schedule.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def last(self) -&gt; ForkBlobSchedule | None:\n    \"\"\"Return the last schedule.\"\"\"\n    if len(self.root) == 0:\n        return None\n    return list(self.root.values())[-1]\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.ForkBlobSchedule","title":"<code>ForkBlobSchedule</code>","text":"<p>               Bases: <code>CamelModel</code></p> <p>Representation of the blob schedule of a given fork.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>class ForkBlobSchedule(CamelModel):\n    \"\"\"Representation of the blob schedule of a given fork.\"\"\"\n\n    target_blobs_per_block: HexNumber = Field(..., alias=\"target\")\n    max_blobs_per_block: HexNumber = Field(..., alias=\"max\")\n    base_fee_update_fraction: HexNumber = Field(...)\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage","title":"<code>Storage</code>","text":"<p>               Bases: <code>EthereumTestRootModel[Dict[StorageKeyValueType, StorageKeyValueType]]</code></p> <p>Definition of contract storage in the <code>pre</code> or <code>post</code> state of a test.</p> <p>This model accepts a dictionary with keys and values as any of: str, int, bytes, or any type that supports conversion to bytes, and automatically casts them to <code>HashInt</code>.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>class Storage(EthereumTestRootModel[Dict[StorageKeyValueType, StorageKeyValueType]]):\n    \"\"\"\n    Definition of contract storage in the `pre` or `post` state of a test.\n\n    This model accepts a dictionary with keys and values as any of: str, int,\n    bytes, or any type that supports conversion to bytes, and automatically\n    casts them to `HashInt`.\n    \"\"\"\n\n    # internal storage is maintained as a dict with HashInt keys and values.\n    root: Dict[StorageKeyValueType, StorageKeyValueType] = Field(default_factory=dict)\n\n    _current_slot: int = PrivateAttr(0)\n    _hint_map: Dict[StorageKeyValueType, str] = PrivateAttr(default_factory=dict)\n\n    StorageDictType: ClassVar[TypeAlias] = Dict[\n        str | int | bytes | SupportsBytes, str | int | bytes | SupportsBytes\n    ]\n    \"\"\"\n    Dictionary type to be used when defining an input to initialize a storage.\n    \"\"\"\n\n    @dataclass(kw_only=True)\n    class InvalidTypeError(Exception):\n        \"\"\"Invalid type used when describing test's expected storage key or value.\"\"\"\n\n        key_or_value: Any\n\n        def __init__(self, key_or_value: Any, *args):\n            \"\"\"Initialize the exception with the invalid type.\"\"\"\n            super().__init__(args)\n            self.key_or_value = key_or_value\n\n        def __str__(self):\n            \"\"\"Print exception string.\"\"\"\n            return f\"invalid type for key/value: {self.key_or_value}\"\n\n    @dataclass(kw_only=True)\n    class InvalidValueError(Exception):\n        \"\"\"\n        Invalid value used when describing test's expected storage key or\n        value.\n        \"\"\"\n\n        key_or_value: Any\n\n        def __init__(self, key_or_value: Any, *args):\n            \"\"\"Initialize the exception with the invalid value.\"\"\"\n            super().__init__(args)\n            self.key_or_value = key_or_value\n\n        def __str__(self):\n            \"\"\"Print exception string.\"\"\"\n            return f\"invalid value for key/value: {self.key_or_value}\"\n\n    @dataclass(kw_only=True)\n    class MissingKeyError(Exception):\n        \"\"\"Test expected to find a storage key set but key was missing.\"\"\"\n\n        key: int\n\n        def __init__(self, key: int, *args):\n            \"\"\"Initialize the exception with the missing key.\"\"\"\n            super().__init__(args)\n            self.key = key\n\n        def __str__(self):\n            \"\"\"Print exception string.\"\"\"\n            return \"key {0} not found in storage\".format(Hash(self.key))\n\n    @dataclass(kw_only=True)\n    class KeyValueMismatchError(Exception):\n        \"\"\"\n        Test expected a certain value in a storage key but value found\n        was different.\n        \"\"\"\n\n        address: Address\n        key: int\n        want: int\n        got: int\n        hint: str\n\n        def __init__(self, address: Address, key: int, want: int, got: int, hint: str = \"\", *args):\n            \"\"\"Initialize the exception with the address, key, wanted and got values.\"\"\"\n            super().__init__(args)\n            self.address = address\n            self.key = key\n            self.want = want\n            self.got = got\n            self.hint = hint\n\n        def __str__(self):\n            \"\"\"Print exception string.\"\"\"\n            label_str = \"\"\n            if self.address.label is not None:\n                label_str = f\" ({self.address.label})\"\n            return (\n                f\"incorrect value in address {self.address}{label_str} for \"\n                + f\"key {Hash(self.key)}{f' ({self.hint})' if self.hint else ''}:\"\n                + f\" want {HexNumber(self.want)} (dec:{int(self.want)}),\"\n                + f\" got {HexNumber(self.got)} (dec:{int(self.got)})\"\n            )\n\n    def __contains__(self, key: StorageKeyValueTypeConvertible | StorageKeyValueType) -&gt; bool:\n        \"\"\"Check for an item in the storage.\"\"\"\n        return StorageKeyValueTypeAdapter.validate_python(key) in self.root\n\n    def __getitem__(\n        self, key: StorageKeyValueTypeConvertible | StorageKeyValueType\n    ) -&gt; StorageKeyValueType:\n        \"\"\"Return an item from the storage.\"\"\"\n        return self.root[StorageKeyValueTypeAdapter.validate_python(key)]\n\n    def __setitem__(\n        self,\n        key: StorageKeyValueTypeConvertible | StorageKeyValueType,\n        value: StorageKeyValueTypeConvertible | StorageKeyValueType,\n    ):  # noqa: SC200\n        \"\"\"Set an item in the storage.\"\"\"\n        self.root[StorageKeyValueTypeAdapter.validate_python(key)] = (\n            StorageKeyValueTypeAdapter.validate_python(value)\n        )\n\n    def __delitem__(self, key: StorageKeyValueTypeConvertible | StorageKeyValueType):\n        \"\"\"Delete an item from the storage.\"\"\"\n        del self.root[StorageKeyValueTypeAdapter.validate_python(key)]\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the storage.\"\"\"\n        return iter(self.root)\n\n    def __eq__(self, other) -&gt; bool:\n        \"\"\"Return True if both storages are equal.\"\"\"\n        if not isinstance(other, Storage):\n            return False\n        return self.root == other.root\n\n    def __ne__(self, other) -&gt; bool:\n        \"\"\"Return True if both storages are not equal.\"\"\"\n        if not isinstance(other, Storage):\n            return False\n        return self.root != other.root\n\n    def __bool__(self) -&gt; bool:\n        \"\"\"Return True if the storage is not empty.\"\"\"\n        return any(v for v in self.root.values())\n\n    def __add__(self, other: \"Storage\") -&gt; \"Storage\":\n        \"\"\"Return a new storage that is the sum of two storages.\"\"\"\n        return Storage({**self.root, **other.root})\n\n    def keys(self) -&gt; set[StorageKeyValueType]:\n        \"\"\"Return the keys of the storage.\"\"\"\n        return set(self.root.keys())\n\n    def set_next_slot(self, slot: int) -&gt; \"Storage\":\n        \"\"\"Set the next slot to be used by `store_next`.\"\"\"\n        self._current_slot = slot\n        return self\n\n    def items(self):\n        \"\"\"Return the items of the storage.\"\"\"\n        return self.root.items()\n\n    def store_next(\n        self, value: StorageKeyValueTypeConvertible | StorageKeyValueType | bool, hint: str = \"\"\n    ) -&gt; StorageKeyValueType:\n        \"\"\"\n        Store a value in the storage and returns the key where the value is stored.\n\n        Increments the key counter so the next time this function is called,\n        the next key is used.\n        \"\"\"\n        slot = StorageKeyValueTypeAdapter.validate_python(self._current_slot)\n        self._current_slot += 1\n        if hint:\n            self._hint_map[slot] = hint\n        self[slot] = StorageKeyValueTypeAdapter.validate_python(value)\n        return slot\n\n    def peek_slot(self) -&gt; int:\n        \"\"\"Peek the next slot that will be used by `store_next`.\"\"\"\n        return self._current_slot\n\n    def contains(self, other: \"Storage\") -&gt; bool:\n        \"\"\"\n        Return True if self contains all keys with equal value as\n        contained by second storage.\n        Used for comparison with test expected post state and alloc returned\n        by the transition tool.\n        \"\"\"\n        for key in other.keys():\n            if key not in self:\n                return False\n            if self[key] != other[key]:\n                return False\n        return True\n\n    def must_contain(self, address: Address, other: \"Storage\"):\n        \"\"\"\n        Succeeds only if self contains all keys with equal value as\n        contained by second storage.\n        Used for comparison with test expected post state and alloc returned\n        by the transition tool.\n        Raises detailed exception when a difference is found.\n        \"\"\"\n        for key in other.keys():\n            if key not in self:\n                # storage[key]==0 is equal to missing storage\n                if other[key] != 0:\n                    raise Storage.MissingKeyError(key=key)\n            elif self[key] != other[key]:\n                raise Storage.KeyValueMismatchError(\n                    address=address,\n                    key=key,\n                    want=self[key],\n                    got=other[key],\n                    hint=self._hint_map.get(key, \"\"),\n                )\n\n    def must_be_equal(self, address: Address, other: \"Storage | None\"):\n        \"\"\"Succeed only if \"self\" is equal to \"other\" storage.\"\"\"\n        # Test keys contained in both storage objects\n        if other is None:\n            other = Storage({})\n        for key in self.keys() &amp; other.keys():\n            if self[key] != other[key]:\n                raise Storage.KeyValueMismatchError(\n                    address=address,\n                    key=key,\n                    want=self[key],\n                    got=other[key],\n                    hint=self._hint_map.get(key, \"\"),\n                )\n\n        # Test keys contained in either one of the storage objects\n        for key in self.keys() ^ other.keys():\n            if key in self:\n                if self[key] != 0:\n                    raise Storage.KeyValueMismatchError(\n                        address=address,\n                        key=key,\n                        want=self[key],\n                        got=0,\n                        hint=self._hint_map.get(key, \"\"),\n                    )\n\n            elif other[key] != 0:\n                raise Storage.KeyValueMismatchError(\n                    address=address,\n                    key=key,\n                    want=0,\n                    got=other[key],\n                    hint=self._hint_map.get(key, \"\"),\n                )\n\n    def canary(self) -&gt; \"Storage\":\n        \"\"\"\n        Return a canary storage filled with non-zero values where the current storage expects\n        zero values, to guarantee that the test overwrites the storage.\n        \"\"\"\n        return Storage({key: HashInt(0xBA5E) for key in self.keys() if self[key] == 0})\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.StorageDictType","title":"<code>StorageDictType: TypeAlias = Dict[str | int | bytes | SupportsBytes, str | int | bytes | SupportsBytes]</code>  <code>class-attribute</code>","text":"<p>Dictionary type to be used when defining an input to initialize a storage.</p>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.InvalidTypeError","title":"<code>InvalidTypeError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Invalid type used when describing test's expected storage key or value.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>@dataclass(kw_only=True)\nclass InvalidTypeError(Exception):\n    \"\"\"Invalid type used when describing test's expected storage key or value.\"\"\"\n\n    key_or_value: Any\n\n    def __init__(self, key_or_value: Any, *args):\n        \"\"\"Initialize the exception with the invalid type.\"\"\"\n        super().__init__(args)\n        self.key_or_value = key_or_value\n\n    def __str__(self):\n        \"\"\"Print exception string.\"\"\"\n        return f\"invalid type for key/value: {self.key_or_value}\"\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.InvalidTypeError.__init__","title":"<code>__init__(key_or_value, *args)</code>","text":"<p>Initialize the exception with the invalid type.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __init__(self, key_or_value: Any, *args):\n    \"\"\"Initialize the exception with the invalid type.\"\"\"\n    super().__init__(args)\n    self.key_or_value = key_or_value\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.InvalidTypeError.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __str__(self):\n    \"\"\"Print exception string.\"\"\"\n    return f\"invalid type for key/value: {self.key_or_value}\"\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.InvalidValueError","title":"<code>InvalidValueError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Invalid value used when describing test's expected storage key or value.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>@dataclass(kw_only=True)\nclass InvalidValueError(Exception):\n    \"\"\"\n    Invalid value used when describing test's expected storage key or\n    value.\n    \"\"\"\n\n    key_or_value: Any\n\n    def __init__(self, key_or_value: Any, *args):\n        \"\"\"Initialize the exception with the invalid value.\"\"\"\n        super().__init__(args)\n        self.key_or_value = key_or_value\n\n    def __str__(self):\n        \"\"\"Print exception string.\"\"\"\n        return f\"invalid value for key/value: {self.key_or_value}\"\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.InvalidValueError.__init__","title":"<code>__init__(key_or_value, *args)</code>","text":"<p>Initialize the exception with the invalid value.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __init__(self, key_or_value: Any, *args):\n    \"\"\"Initialize the exception with the invalid value.\"\"\"\n    super().__init__(args)\n    self.key_or_value = key_or_value\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.InvalidValueError.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __str__(self):\n    \"\"\"Print exception string.\"\"\"\n    return f\"invalid value for key/value: {self.key_or_value}\"\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.MissingKeyError","title":"<code>MissingKeyError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Test expected to find a storage key set but key was missing.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>@dataclass(kw_only=True)\nclass MissingKeyError(Exception):\n    \"\"\"Test expected to find a storage key set but key was missing.\"\"\"\n\n    key: int\n\n    def __init__(self, key: int, *args):\n        \"\"\"Initialize the exception with the missing key.\"\"\"\n        super().__init__(args)\n        self.key = key\n\n    def __str__(self):\n        \"\"\"Print exception string.\"\"\"\n        return \"key {0} not found in storage\".format(Hash(self.key))\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.MissingKeyError.__init__","title":"<code>__init__(key, *args)</code>","text":"<p>Initialize the exception with the missing key.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __init__(self, key: int, *args):\n    \"\"\"Initialize the exception with the missing key.\"\"\"\n    super().__init__(args)\n    self.key = key\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.MissingKeyError.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __str__(self):\n    \"\"\"Print exception string.\"\"\"\n    return \"key {0} not found in storage\".format(Hash(self.key))\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.KeyValueMismatchError","title":"<code>KeyValueMismatchError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Test expected a certain value in a storage key but value found was different.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>@dataclass(kw_only=True)\nclass KeyValueMismatchError(Exception):\n    \"\"\"\n    Test expected a certain value in a storage key but value found\n    was different.\n    \"\"\"\n\n    address: Address\n    key: int\n    want: int\n    got: int\n    hint: str\n\n    def __init__(self, address: Address, key: int, want: int, got: int, hint: str = \"\", *args):\n        \"\"\"Initialize the exception with the address, key, wanted and got values.\"\"\"\n        super().__init__(args)\n        self.address = address\n        self.key = key\n        self.want = want\n        self.got = got\n        self.hint = hint\n\n    def __str__(self):\n        \"\"\"Print exception string.\"\"\"\n        label_str = \"\"\n        if self.address.label is not None:\n            label_str = f\" ({self.address.label})\"\n        return (\n            f\"incorrect value in address {self.address}{label_str} for \"\n            + f\"key {Hash(self.key)}{f' ({self.hint})' if self.hint else ''}:\"\n            + f\" want {HexNumber(self.want)} (dec:{int(self.want)}),\"\n            + f\" got {HexNumber(self.got)} (dec:{int(self.got)})\"\n        )\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.KeyValueMismatchError.__init__","title":"<code>__init__(address, key, want, got, hint='', *args)</code>","text":"<p>Initialize the exception with the address, key, wanted and got values.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __init__(self, address: Address, key: int, want: int, got: int, hint: str = \"\", *args):\n    \"\"\"Initialize the exception with the address, key, wanted and got values.\"\"\"\n    super().__init__(args)\n    self.address = address\n    self.key = key\n    self.want = want\n    self.got = got\n    self.hint = hint\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.KeyValueMismatchError.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __str__(self):\n    \"\"\"Print exception string.\"\"\"\n    label_str = \"\"\n    if self.address.label is not None:\n        label_str = f\" ({self.address.label})\"\n    return (\n        f\"incorrect value in address {self.address}{label_str} for \"\n        + f\"key {Hash(self.key)}{f' ({self.hint})' if self.hint else ''}:\"\n        + f\" want {HexNumber(self.want)} (dec:{int(self.want)}),\"\n        + f\" got {HexNumber(self.got)} (dec:{int(self.got)})\"\n    )\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.__contains__","title":"<code>__contains__(key)</code>","text":"<p>Check for an item in the storage.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __contains__(self, key: StorageKeyValueTypeConvertible | StorageKeyValueType) -&gt; bool:\n    \"\"\"Check for an item in the storage.\"\"\"\n    return StorageKeyValueTypeAdapter.validate_python(key) in self.root\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Return an item from the storage.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __getitem__(\n    self, key: StorageKeyValueTypeConvertible | StorageKeyValueType\n) -&gt; StorageKeyValueType:\n    \"\"\"Return an item from the storage.\"\"\"\n    return self.root[StorageKeyValueTypeAdapter.validate_python(key)]\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Set an item in the storage.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __setitem__(\n    self,\n    key: StorageKeyValueTypeConvertible | StorageKeyValueType,\n    value: StorageKeyValueTypeConvertible | StorageKeyValueType,\n):  # noqa: SC200\n    \"\"\"Set an item in the storage.\"\"\"\n    self.root[StorageKeyValueTypeAdapter.validate_python(key)] = (\n        StorageKeyValueTypeAdapter.validate_python(value)\n    )\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.__delitem__","title":"<code>__delitem__(key)</code>","text":"<p>Delete an item from the storage.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __delitem__(self, key: StorageKeyValueTypeConvertible | StorageKeyValueType):\n    \"\"\"Delete an item from the storage.\"\"\"\n    del self.root[StorageKeyValueTypeAdapter.validate_python(key)]\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.__iter__","title":"<code>__iter__()</code>","text":"<p>Return an iterator over the storage.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __iter__(self):\n    \"\"\"Return an iterator over the storage.\"\"\"\n    return iter(self.root)\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Return True if both storages are equal.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __eq__(self, other) -&gt; bool:\n    \"\"\"Return True if both storages are equal.\"\"\"\n    if not isinstance(other, Storage):\n        return False\n    return self.root == other.root\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Return True if both storages are not equal.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __ne__(self, other) -&gt; bool:\n    \"\"\"Return True if both storages are not equal.\"\"\"\n    if not isinstance(other, Storage):\n        return False\n    return self.root != other.root\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.__bool__","title":"<code>__bool__()</code>","text":"<p>Return True if the storage is not empty.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    \"\"\"Return True if the storage is not empty.\"\"\"\n    return any(v for v in self.root.values())\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.__add__","title":"<code>__add__(other)</code>","text":"<p>Return a new storage that is the sum of two storages.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __add__(self, other: \"Storage\") -&gt; \"Storage\":\n    \"\"\"Return a new storage that is the sum of two storages.\"\"\"\n    return Storage({**self.root, **other.root})\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.keys","title":"<code>keys()</code>","text":"<p>Return the keys of the storage.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def keys(self) -&gt; set[StorageKeyValueType]:\n    \"\"\"Return the keys of the storage.\"\"\"\n    return set(self.root.keys())\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.set_next_slot","title":"<code>set_next_slot(slot)</code>","text":"<p>Set the next slot to be used by <code>store_next</code>.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def set_next_slot(self, slot: int) -&gt; \"Storage\":\n    \"\"\"Set the next slot to be used by `store_next`.\"\"\"\n    self._current_slot = slot\n    return self\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.items","title":"<code>items()</code>","text":"<p>Return the items of the storage.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def items(self):\n    \"\"\"Return the items of the storage.\"\"\"\n    return self.root.items()\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.store_next","title":"<code>store_next(value, hint='')</code>","text":"<p>Store a value in the storage and returns the key where the value is stored.</p> <p>Increments the key counter so the next time this function is called, the next key is used.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def store_next(\n    self, value: StorageKeyValueTypeConvertible | StorageKeyValueType | bool, hint: str = \"\"\n) -&gt; StorageKeyValueType:\n    \"\"\"\n    Store a value in the storage and returns the key where the value is stored.\n\n    Increments the key counter so the next time this function is called,\n    the next key is used.\n    \"\"\"\n    slot = StorageKeyValueTypeAdapter.validate_python(self._current_slot)\n    self._current_slot += 1\n    if hint:\n        self._hint_map[slot] = hint\n    self[slot] = StorageKeyValueTypeAdapter.validate_python(value)\n    return slot\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.peek_slot","title":"<code>peek_slot()</code>","text":"<p>Peek the next slot that will be used by <code>store_next</code>.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def peek_slot(self) -&gt; int:\n    \"\"\"Peek the next slot that will be used by `store_next`.\"\"\"\n    return self._current_slot\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.contains","title":"<code>contains(other)</code>","text":"<p>Return True if self contains all keys with equal value as contained by second storage. Used for comparison with test expected post state and alloc returned by the transition tool.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def contains(self, other: \"Storage\") -&gt; bool:\n    \"\"\"\n    Return True if self contains all keys with equal value as\n    contained by second storage.\n    Used for comparison with test expected post state and alloc returned\n    by the transition tool.\n    \"\"\"\n    for key in other.keys():\n        if key not in self:\n            return False\n        if self[key] != other[key]:\n            return False\n    return True\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.must_contain","title":"<code>must_contain(address, other)</code>","text":"<p>Succeeds only if self contains all keys with equal value as contained by second storage. Used for comparison with test expected post state and alloc returned by the transition tool. Raises detailed exception when a difference is found.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def must_contain(self, address: Address, other: \"Storage\"):\n    \"\"\"\n    Succeeds only if self contains all keys with equal value as\n    contained by second storage.\n    Used for comparison with test expected post state and alloc returned\n    by the transition tool.\n    Raises detailed exception when a difference is found.\n    \"\"\"\n    for key in other.keys():\n        if key not in self:\n            # storage[key]==0 is equal to missing storage\n            if other[key] != 0:\n                raise Storage.MissingKeyError(key=key)\n        elif self[key] != other[key]:\n            raise Storage.KeyValueMismatchError(\n                address=address,\n                key=key,\n                want=self[key],\n                got=other[key],\n                hint=self._hint_map.get(key, \"\"),\n            )\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.must_be_equal","title":"<code>must_be_equal(address, other)</code>","text":"<p>Succeed only if \"self\" is equal to \"other\" storage.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def must_be_equal(self, address: Address, other: \"Storage | None\"):\n    \"\"\"Succeed only if \"self\" is equal to \"other\" storage.\"\"\"\n    # Test keys contained in both storage objects\n    if other is None:\n        other = Storage({})\n    for key in self.keys() &amp; other.keys():\n        if self[key] != other[key]:\n            raise Storage.KeyValueMismatchError(\n                address=address,\n                key=key,\n                want=self[key],\n                got=other[key],\n                hint=self._hint_map.get(key, \"\"),\n            )\n\n    # Test keys contained in either one of the storage objects\n    for key in self.keys() ^ other.keys():\n        if key in self:\n            if self[key] != 0:\n                raise Storage.KeyValueMismatchError(\n                    address=address,\n                    key=key,\n                    want=self[key],\n                    got=0,\n                    hint=self._hint_map.get(key, \"\"),\n                )\n\n        elif other[key] != 0:\n            raise Storage.KeyValueMismatchError(\n                address=address,\n                key=key,\n                want=0,\n                got=other[key],\n                hint=self._hint_map.get(key, \"\"),\n            )\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.Storage.canary","title":"<code>canary()</code>","text":"<p>Return a canary storage filled with non-zero values where the current storage expects zero values, to guarantee that the test overwrites the storage.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def canary(self) -&gt; \"Storage\":\n    \"\"\"\n    Return a canary storage filled with non-zero values where the current storage expects\n    zero values, to guarantee that the test overwrites the storage.\n    \"\"\"\n    return Storage({key: HashInt(0xBA5E) for key in self.keys() if self[key] == 0})\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.to_bytes","title":"<code>to_bytes(input_bytes)</code>","text":"<p>Convert multiple types into bytes.</p> Source code in <code>src/ethereum_test_base_types/conversions.py</code> <pre><code>def to_bytes(input_bytes: BytesConvertible) -&gt; bytes:\n    \"\"\"Convert multiple types into bytes.\"\"\"\n    if input_bytes is None:\n        raise Exception(\"Cannot convert `None` input to bytes\")\n\n    if (\n        isinstance(input_bytes, SupportsBytes)\n        or isinstance(input_bytes, bytes)\n        or isinstance(input_bytes, list)\n    ):\n        return bytes(input_bytes)\n\n    if isinstance(input_bytes, str):\n        # We can have a hex representation of bytes with spaces for readability\n        input_bytes = sub(r\"\\s+\", \"\", input_bytes)\n        if input_bytes.startswith(\"0x\"):\n            input_bytes = input_bytes[2:]\n        if len(input_bytes) % 2 == 1:\n            input_bytes = \"0\" + input_bytes\n        return bytes.fromhex(input_bytes)\n\n    raise Exception(\"invalid type for `bytes`\")\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.to_hex","title":"<code>to_hex(input_bytes)</code>","text":"<p>Convert multiple types into a bytes hex string.</p> Source code in <code>src/ethereum_test_base_types/conversions.py</code> <pre><code>def to_hex(input_bytes: BytesConvertible) -&gt; str:\n    \"\"\"Convert multiple types into a bytes hex string.\"\"\"\n    return \"0x\" + to_bytes(input_bytes).hex()\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.to_json","title":"<code>to_json(input_model)</code>","text":"<p>Convert a model to its json data representation.</p> Source code in <code>src/ethereum_test_base_types/json.py</code> <pre><code>def to_json(\n    input_model: (\n        EthereumTestBaseModel\n        | EthereumTestRootModel\n        | AnyStr\n        | List[EthereumTestBaseModel | EthereumTestRootModel | AnyStr]\n    ),\n) -&gt; Any:\n    \"\"\"Convert a model to its json data representation.\"\"\"\n    if isinstance(input_model, list):\n        return [to_json(item) for item in input_model]\n    elif isinstance(input_model, (EthereumTestBaseModel, EthereumTestRootModel)):\n        return input_model.model_dump(mode=\"json\", by_alias=True, exclude_none=True)\n    else:\n        return str(input_model)\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.CamelModel","title":"<code>CamelModel</code>","text":"<p>               Bases: <code>CopyValidateModel</code></p> <p>A base model that converts field names to camel case when serializing.</p> <p>For example, the field name <code>current_timestamp</code> in a Python model will be represented as <code>currentTimestamp</code> when it is serialized to json.</p> Source code in <code>src/ethereum_test_base_types/pydantic.py</code> <pre><code>class CamelModel(CopyValidateModel):\n    \"\"\"\n    A base model that converts field names to camel case when serializing.\n\n    For example, the field name `current_timestamp` in a Python model will be represented\n    as `currentTimestamp` when it is serialized to json.\n    \"\"\"\n\n    model_config = ConfigDict(\n        alias_generator=to_camel,\n        populate_by_name=True,\n        validate_default=True,\n    )\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.EthereumTestBaseModel","title":"<code>EthereumTestBaseModel</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>ModelCustomizationsMixin</code></p> <p>Base model for all models for Ethereum tests.</p> Source code in <code>src/ethereum_test_base_types/pydantic.py</code> <pre><code>class EthereumTestBaseModel(BaseModel, ModelCustomizationsMixin):\n    \"\"\"Base model for all models for Ethereum tests.\"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.EthereumTestRootModel","title":"<code>EthereumTestRootModel</code>","text":"<p>               Bases: <code>RootModel[RootModelRootType]</code>, <code>ModelCustomizationsMixin</code></p> <p>Base model for all models for Ethereum tests.</p> Source code in <code>src/ethereum_test_base_types/pydantic.py</code> <pre><code>class EthereumTestRootModel(RootModel[RootModelRootType], ModelCustomizationsMixin):\n    \"\"\"Base model for all models for Ethereum tests.\"\"\"\n\n    root: Any\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.ReferenceSpec","title":"<code>ReferenceSpec</code>","text":"<p>Reference Specification Description Abstract Class.</p> Source code in <code>src/ethereum_test_base_types/reference_spec/reference_spec.py</code> <pre><code>class ReferenceSpec:\n    \"\"\"Reference Specification Description Abstract Class.\"\"\"\n\n    @abstractmethod\n    def name(self) -&gt; str:\n        \"\"\"Return the name of the spec.\"\"\"\n        pass\n\n    @abstractmethod\n    def has_known_version(self) -&gt; bool:\n        \"\"\"Return true if the reference spec object is hard-coded with a latest known version.\"\"\"\n        pass\n\n    @abstractmethod\n    def known_version(self) -&gt; str:\n        \"\"\"Return the latest known version in the reference.\"\"\"\n        pass\n\n    @abstractmethod\n    def api_url(self) -&gt; str:\n        \"\"\"Return the URL required to poll the version from an API, if needed.\"\"\"\n        pass\n\n    @abstractmethod\n    def latest_version(self) -&gt; str:\n        \"\"\"Return a digest that points to the latest version of the spec.\"\"\"\n        pass\n\n    @abstractmethod\n    def is_outdated(self) -&gt; bool:\n        \"\"\"\n        Check whether the reference specification has been updated since the\n        test was last updated.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def write_info(self, info: Dict[str, Dict[str, Any] | str]):\n        \"\"\"Write info about the reference specification used into the output fixture.\"\"\"\n        pass\n\n    @staticmethod\n    @abstractmethod\n    def parseable_from_module(module_dict: Dict[str, Any]) -&gt; bool:\n        \"\"\"Check whether the module's dict contains required reference spec information.\"\"\"\n        pass\n\n    @staticmethod\n    @abstractmethod\n    def parse_from_module(module_dict: Dict[str, Any]) -&gt; \"ReferenceSpec\":\n        \"\"\"Parse the module's dict into a reference spec.\"\"\"\n        pass\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.ReferenceSpec.name","title":"<code>name()</code>  <code>abstractmethod</code>","text":"<p>Return the name of the spec.</p> Source code in <code>src/ethereum_test_base_types/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef name(self) -&gt; str:\n    \"\"\"Return the name of the spec.\"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.ReferenceSpec.has_known_version","title":"<code>has_known_version()</code>  <code>abstractmethod</code>","text":"<p>Return true if the reference spec object is hard-coded with a latest known version.</p> Source code in <code>src/ethereum_test_base_types/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef has_known_version(self) -&gt; bool:\n    \"\"\"Return true if the reference spec object is hard-coded with a latest known version.\"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.ReferenceSpec.known_version","title":"<code>known_version()</code>  <code>abstractmethod</code>","text":"<p>Return the latest known version in the reference.</p> Source code in <code>src/ethereum_test_base_types/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef known_version(self) -&gt; str:\n    \"\"\"Return the latest known version in the reference.\"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.ReferenceSpec.api_url","title":"<code>api_url()</code>  <code>abstractmethod</code>","text":"<p>Return the URL required to poll the version from an API, if needed.</p> Source code in <code>src/ethereum_test_base_types/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef api_url(self) -&gt; str:\n    \"\"\"Return the URL required to poll the version from an API, if needed.\"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.ReferenceSpec.latest_version","title":"<code>latest_version()</code>  <code>abstractmethod</code>","text":"<p>Return a digest that points to the latest version of the spec.</p> Source code in <code>src/ethereum_test_base_types/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef latest_version(self) -&gt; str:\n    \"\"\"Return a digest that points to the latest version of the spec.\"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.ReferenceSpec.is_outdated","title":"<code>is_outdated()</code>  <code>abstractmethod</code>","text":"<p>Check whether the reference specification has been updated since the test was last updated.</p> Source code in <code>src/ethereum_test_base_types/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef is_outdated(self) -&gt; bool:\n    \"\"\"\n    Check whether the reference specification has been updated since the\n    test was last updated.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.ReferenceSpec.write_info","title":"<code>write_info(info)</code>  <code>abstractmethod</code>","text":"<p>Write info about the reference specification used into the output fixture.</p> Source code in <code>src/ethereum_test_base_types/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef write_info(self, info: Dict[str, Dict[str, Any] | str]):\n    \"\"\"Write info about the reference specification used into the output fixture.\"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.ReferenceSpec.parseable_from_module","title":"<code>parseable_from_module(module_dict)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Check whether the module's dict contains required reference spec information.</p> Source code in <code>src/ethereum_test_base_types/reference_spec/reference_spec.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef parseable_from_module(module_dict: Dict[str, Any]) -&gt; bool:\n    \"\"\"Check whether the module's dict contains required reference spec information.\"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_base_types/#ethereum_test_base_types.ReferenceSpec.parse_from_module","title":"<code>parse_from_module(module_dict)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Parse the module's dict into a reference spec.</p> Source code in <code>src/ethereum_test_base_types/reference_spec/reference_spec.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef parse_from_module(module_dict: Dict[str, Any]) -&gt; \"ReferenceSpec\":\n    \"\"\"Parse the module's dict into a reference spec.\"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_exceptions/","title":"Ethereum Test Exceptions package","text":"<p>Exceptions for invalid execution.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EngineAPIError","title":"<code>EngineAPIError</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>List of Engine API errors.</p> Source code in <code>src/ethereum_test_exceptions/engine_api.py</code> <pre><code>class EngineAPIError(IntEnum):\n    \"\"\"List of Engine API errors.\"\"\"\n\n    ParseError = -32700\n    InvalidRequest = -32600\n    MethodNotFound = -32601\n    InvalidParams = -32602\n    InternalError = -32603\n    ServerError = -32000\n    UnknownPayload = -38001\n    InvalidForkchoiceState = -38002\n    InvalidPayloadAttributes = -38003\n    TooLargeRequest = -38004\n    UnsupportedFork = -38005\n</code></pre>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.ExceptionMapper","title":"<code>ExceptionMapper</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Translate between EEST exceptions and error strings returned by client's t8n or other tools.</p> Source code in <code>src/ethereum_test_exceptions/exception_mapper.py</code> <pre><code>class ExceptionMapper(ABC):\n    \"\"\"\n    Translate between EEST exceptions and error strings returned by client's\n    t8n or other tools.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the exception mapper.\"\"\"\n        # Ensure that the subclass has properly defined _mapping_data before accessing it\n        assert self._mapping_data is not None, \"_mapping_data must be defined in subclass\"\n\n        assert len({entry.exception for entry in self._mapping_data}) == len(self._mapping_data), (\n            \"Duplicate exception in _mapping_data\"\n        )\n        assert len({entry.message for entry in self._mapping_data}) == len(self._mapping_data), (\n            \"Duplicate message in _mapping_data\"\n        )\n        self.exception_to_message_map: frozenbidict = frozenbidict(\n            {entry.exception: entry.message for entry in self._mapping_data}\n        )\n\n    @property\n    @abstractmethod\n    def _mapping_data(self):\n        \"\"\"Should be overridden in the subclass to provide mapping data.\"\"\"\n        pass\n\n    def exception_to_message(self, exception: ExceptionBase) -&gt; str | None:\n        \"\"\"Exception and to formatted string.\"\"\"\n        message = self.exception_to_message_map.get(exception, None)\n        return message\n\n    def message_to_exception(self, exception_string: str) -&gt; ExceptionBase:\n        \"\"\"Match a formatted string to an exception.\"\"\"\n        for entry in self._mapping_data:\n            if entry.message in exception_string:\n                return entry.exception\n        return UndefinedException.UNDEFINED_EXCEPTION\n</code></pre>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.ExceptionMapper.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the exception mapper.</p> Source code in <code>src/ethereum_test_exceptions/exception_mapper.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the exception mapper.\"\"\"\n    # Ensure that the subclass has properly defined _mapping_data before accessing it\n    assert self._mapping_data is not None, \"_mapping_data must be defined in subclass\"\n\n    assert len({entry.exception for entry in self._mapping_data}) == len(self._mapping_data), (\n        \"Duplicate exception in _mapping_data\"\n    )\n    assert len({entry.message for entry in self._mapping_data}) == len(self._mapping_data), (\n        \"Duplicate message in _mapping_data\"\n    )\n    self.exception_to_message_map: frozenbidict = frozenbidict(\n        {entry.exception: entry.message for entry in self._mapping_data}\n    )\n</code></pre>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.ExceptionMapper.exception_to_message","title":"<code>exception_to_message(exception)</code>","text":"<p>Exception and to formatted string.</p> Source code in <code>src/ethereum_test_exceptions/exception_mapper.py</code> <pre><code>def exception_to_message(self, exception: ExceptionBase) -&gt; str | None:\n    \"\"\"Exception and to formatted string.\"\"\"\n    message = self.exception_to_message_map.get(exception, None)\n    return message\n</code></pre>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.ExceptionMapper.message_to_exception","title":"<code>message_to_exception(exception_string)</code>","text":"<p>Match a formatted string to an exception.</p> Source code in <code>src/ethereum_test_exceptions/exception_mapper.py</code> <pre><code>def message_to_exception(self, exception_string: str) -&gt; ExceptionBase:\n    \"\"\"Match a formatted string to an exception.\"\"\"\n    for entry in self._mapping_data:\n        if entry.message in exception_string:\n            return entry.exception\n    return UndefinedException.UNDEFINED_EXCEPTION\n</code></pre>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.ExceptionMessage","title":"<code>ExceptionMessage</code>  <code>dataclass</code>","text":"<p>Defines a mapping between an exception and a message.</p> Source code in <code>src/ethereum_test_exceptions/exception_mapper.py</code> <pre><code>@dataclass\nclass ExceptionMessage:\n    \"\"\"Defines a mapping between an exception and a message.\"\"\"\n\n    exception: ExceptionBase\n    message: str\n</code></pre>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException","title":"<code>BlockException</code>","text":"<p>               Bases: <code>ExceptionBase</code></p> <p>Exception raised when a block is invalid, but not due to a transaction.</p> <p>E.g. all transactions in the block are valid, and can be applied to the state, but the block header contains an invalid field.</p> Source code in <code>src/ethereum_test_exceptions/exceptions.py</code> <pre><code>@unique\nclass BlockException(ExceptionBase):\n    \"\"\"\n    Exception raised when a block is invalid, but not due to a transaction.\n\n    E.g. all transactions in the block are valid, and can be applied to the state, but the\n    block header contains an invalid field.\n    \"\"\"\n\n    TOO_MANY_UNCLES = auto()\n    \"\"\"\n    Block declares too many uncles over the allowed limit.\n    \"\"\"\n    UNCLE_IN_CHAIN = auto()\n    \"\"\"\n    Block declares uncle header that is already imported into chain.\n    \"\"\"\n    UNCLE_IS_ANCESTOR = auto()\n    \"\"\"\n    Block declares uncle header that is directly a parent of this block.\n    \"\"\"\n    UNCLE_IS_BROTHER = auto()\n    \"\"\"\n    Block declares two similar uncle headers.\n    \"\"\"\n    UNCLE_PARENT_INCORRECT = auto()\n    \"\"\"\n    Block declares uncle header that is an outdated block to be an uncle.\n    \"\"\"\n    EXTRA_DATA_TOO_BIG = auto()\n    \"\"\"\n    Block header's extra data &gt;32 bytes.\n    \"\"\"\n    EXTRA_DATA_INVALID_DAO = auto()\n    \"\"\"\n    Block header's extra data after dao fork must be a fixed pre defined hash.\n    \"\"\"\n    UNKNOWN_PARENT = auto()\n    \"\"\"\n    Block header's parent hash does not correspond to any of existing blocks on chain.\n    \"\"\"\n    UNCLE_UNKNOWN_PARENT = auto()\n    \"\"\"\n    Uncle header's parent hash does not correspond to any of existing blocks on chain.\n    \"\"\"\n    UNKNOWN_PARENT_ZERO = auto()\n    \"\"\"\n    Block header's parent hash is zero hash.\n    \"\"\"\n    GASLIMIT_TOO_BIG = auto()\n    \"\"\"\n    Block header's gas limit &gt; 0x7fffffffffffffff.\n    \"\"\"\n    INVALID_BLOCK_NUMBER = auto()\n    \"\"\"\n    Block header's number != parent header's number + 1.\n    \"\"\"\n    INVALID_BLOCK_TIMESTAMP_OLDER_THAN_PARENT = auto()\n    \"\"\"\n    Block header's timestamp &lt;= parent header's timestamp.\n    \"\"\"\n    INVALID_DIFFICULTY = auto()\n    \"\"\"\n    Block header's difficulty does not match the difficulty formula calculated from previous block.\n    \"\"\"\n    INVALID_LOG_BLOOM = auto()\n    \"\"\"\n    Block header's logs bloom hash does not match the actually computed log bloom.\n    \"\"\"\n    INVALID_STATE_ROOT = auto()\n    \"\"\"\n    Block header's state root hash does not match the actually computed hash of the state.\n    \"\"\"\n    INVALID_RECEIPTS_ROOT = auto()\n    \"\"\"\n    Block header's receipts root hash does not match the actually computed hash of receipts.\n    \"\"\"\n    INVALID_TRANSACTIONS_ROOT = auto()\n    \"\"\"\n    Block header's transactions root hash does not match the actually computed hash of tx tree.\n    \"\"\"\n    INVALID_UNCLES_HASH = auto()\n    \"\"\"\n    Block header's uncle hash does not match the actually computed hash of block's uncles.\n    \"\"\"\n    GAS_USED_OVERFLOW = auto()\n    \"\"\"\n    Block transactions consume more gas than block header allow.\n    \"\"\"\n    INVALID_GASLIMIT = auto()\n    \"\"\"\n    Block header's gas limit does not match the gas limit formula calculated from previous block.\n    \"\"\"\n    INVALID_BASEFEE_PER_GAS = auto()\n    \"\"\"\n    Block header's base_fee_per_gas field is calculated incorrect.\n    \"\"\"\n    INVALID_GAS_USED = auto()\n    \"\"\"\n    Block header's actual gas used does not match the provided header's value\n    \"\"\"\n    INVALID_WITHDRAWALS_ROOT = auto()\n    \"\"\"\n    Block header's withdrawals root does not match calculated withdrawals root.\n    \"\"\"\n    INCORRECT_BLOCK_FORMAT = auto()\n    \"\"\"\n    Block's format is incorrect, contains invalid fields, is missing fields, or contains fields of\n    a fork that is not active yet.\n    \"\"\"\n    BLOB_GAS_USED_ABOVE_LIMIT = auto()\n    \"\"\"\n    Block's blob gas used in header is above the limit.\n    \"\"\"\n    INCORRECT_BLOB_GAS_USED = auto()\n    \"\"\"\n    Block's blob gas used in header is incorrect.\n    \"\"\"\n    INCORRECT_EXCESS_BLOB_GAS = auto()\n    \"\"\"\n    Block's excess blob gas in header is incorrect.\n    \"\"\"\n    RLP_STRUCTURES_ENCODING = auto()\n    \"\"\"\n    Block's rlp encoding is valid but ethereum structures in it are invalid.\n    \"\"\"\n    RLP_WITHDRAWALS_NOT_READ = auto()\n    \"\"\"\n    Block's rlp encoding is missing withdrawals.\n    \"\"\"\n    RLP_INVALID_FIELD_OVERFLOW_64 = auto()\n    \"\"\"\n    One of block's fields rlp is overflow 2**64 value.\n    \"\"\"\n    RLP_INVALID_ADDRESS = auto()\n    \"\"\"\n    Block withdrawals address is rlp of invalid address != 20 bytes.\n    \"\"\"\n    INVALID_REQUESTS = auto()\n    \"\"\"\n    Block's requests are invalid.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_LEGACY = auto()\n    \"\"\"\n    Legacy block import is impossible in this chain configuration.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_LEGACY_WRONG_PARENT = auto()\n    \"\"\"\n    Legacy block import is impossible, trying to import on top of a block that is not legacy.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_LONDON_WRONG_PARENT = auto()\n    \"\"\"\n    Trying to import london (basefee) block on top of block that is not 1559.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_PARIS_WRONG_POW = auto()\n    \"\"\"\n    Trying to import paris(merge) block with PoW enabled.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_PARIS_WRONG_POS = auto()\n    \"\"\"\n    Trying to import paris(merge) block with PoS enabled before TTD is reached.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_LONDON_OVER_PARIS = auto()\n    \"\"\"\n    Trying to import london looking block over paris network (POS).\n    \"\"\"\n    IMPORT_IMPOSSIBLE_PARIS_OVER_SHANGHAI = auto()\n    \"\"\"\n    Trying to import paris block on top of shanghai block.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_SHANGHAI = auto()\n    \"\"\"\n    Shanghai block import is impossible in this chain configuration.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_UNCLES_OVER_PARIS = auto()\n    \"\"\"\n    Trying to import a block after paris fork that has not empty uncles hash.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_DIFFICULTY_OVER_PARIS = auto()\n    \"\"\"\n    Trying to import a block after paris fork that has difficulty != 0.\n    \"\"\"\n</code></pre>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.TOO_MANY_UNCLES","title":"<code>TOO_MANY_UNCLES = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block declares too many uncles over the allowed limit.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.UNCLE_IN_CHAIN","title":"<code>UNCLE_IN_CHAIN = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block declares uncle header that is already imported into chain.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.UNCLE_IS_ANCESTOR","title":"<code>UNCLE_IS_ANCESTOR = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block declares uncle header that is directly a parent of this block.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.UNCLE_IS_BROTHER","title":"<code>UNCLE_IS_BROTHER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block declares two similar uncle headers.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.UNCLE_PARENT_INCORRECT","title":"<code>UNCLE_PARENT_INCORRECT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block declares uncle header that is an outdated block to be an uncle.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.EXTRA_DATA_TOO_BIG","title":"<code>EXTRA_DATA_TOO_BIG = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's extra data &gt;32 bytes.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.EXTRA_DATA_INVALID_DAO","title":"<code>EXTRA_DATA_INVALID_DAO = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's extra data after dao fork must be a fixed pre defined hash.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.UNKNOWN_PARENT","title":"<code>UNKNOWN_PARENT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's parent hash does not correspond to any of existing blocks on chain.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.UNCLE_UNKNOWN_PARENT","title":"<code>UNCLE_UNKNOWN_PARENT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Uncle header's parent hash does not correspond to any of existing blocks on chain.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.UNKNOWN_PARENT_ZERO","title":"<code>UNKNOWN_PARENT_ZERO = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's parent hash is zero hash.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.GASLIMIT_TOO_BIG","title":"<code>GASLIMIT_TOO_BIG = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's gas limit &gt; 0x7fffffffffffffff.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.INVALID_BLOCK_NUMBER","title":"<code>INVALID_BLOCK_NUMBER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's number != parent header's number + 1.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.INVALID_BLOCK_TIMESTAMP_OLDER_THAN_PARENT","title":"<code>INVALID_BLOCK_TIMESTAMP_OLDER_THAN_PARENT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's timestamp &lt;= parent header's timestamp.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.INVALID_DIFFICULTY","title":"<code>INVALID_DIFFICULTY = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's difficulty does not match the difficulty formula calculated from previous block.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.INVALID_LOG_BLOOM","title":"<code>INVALID_LOG_BLOOM = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's logs bloom hash does not match the actually computed log bloom.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.INVALID_STATE_ROOT","title":"<code>INVALID_STATE_ROOT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's state root hash does not match the actually computed hash of the state.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.INVALID_RECEIPTS_ROOT","title":"<code>INVALID_RECEIPTS_ROOT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's receipts root hash does not match the actually computed hash of receipts.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.INVALID_TRANSACTIONS_ROOT","title":"<code>INVALID_TRANSACTIONS_ROOT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's transactions root hash does not match the actually computed hash of tx tree.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.INVALID_UNCLES_HASH","title":"<code>INVALID_UNCLES_HASH = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's uncle hash does not match the actually computed hash of block's uncles.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.GAS_USED_OVERFLOW","title":"<code>GAS_USED_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block transactions consume more gas than block header allow.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.INVALID_GASLIMIT","title":"<code>INVALID_GASLIMIT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's gas limit does not match the gas limit formula calculated from previous block.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.INVALID_BASEFEE_PER_GAS","title":"<code>INVALID_BASEFEE_PER_GAS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's base_fee_per_gas field is calculated incorrect.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.INVALID_GAS_USED","title":"<code>INVALID_GAS_USED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's actual gas used does not match the provided header's value</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.INVALID_WITHDRAWALS_ROOT","title":"<code>INVALID_WITHDRAWALS_ROOT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's withdrawals root does not match calculated withdrawals root.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.INCORRECT_BLOCK_FORMAT","title":"<code>INCORRECT_BLOCK_FORMAT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block's format is incorrect, contains invalid fields, is missing fields, or contains fields of a fork that is not active yet.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.BLOB_GAS_USED_ABOVE_LIMIT","title":"<code>BLOB_GAS_USED_ABOVE_LIMIT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block's blob gas used in header is above the limit.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.INCORRECT_BLOB_GAS_USED","title":"<code>INCORRECT_BLOB_GAS_USED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block's blob gas used in header is incorrect.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.INCORRECT_EXCESS_BLOB_GAS","title":"<code>INCORRECT_EXCESS_BLOB_GAS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block's excess blob gas in header is incorrect.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.RLP_STRUCTURES_ENCODING","title":"<code>RLP_STRUCTURES_ENCODING = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block's rlp encoding is valid but ethereum structures in it are invalid.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.RLP_WITHDRAWALS_NOT_READ","title":"<code>RLP_WITHDRAWALS_NOT_READ = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block's rlp encoding is missing withdrawals.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.RLP_INVALID_FIELD_OVERFLOW_64","title":"<code>RLP_INVALID_FIELD_OVERFLOW_64 = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>One of block's fields rlp is overflow 2**64 value.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.RLP_INVALID_ADDRESS","title":"<code>RLP_INVALID_ADDRESS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block withdrawals address is rlp of invalid address != 20 bytes.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.INVALID_REQUESTS","title":"<code>INVALID_REQUESTS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block's requests are invalid.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.IMPORT_IMPOSSIBLE_LEGACY","title":"<code>IMPORT_IMPOSSIBLE_LEGACY = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Legacy block import is impossible in this chain configuration.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.IMPORT_IMPOSSIBLE_LEGACY_WRONG_PARENT","title":"<code>IMPORT_IMPOSSIBLE_LEGACY_WRONG_PARENT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Legacy block import is impossible, trying to import on top of a block that is not legacy.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.IMPORT_IMPOSSIBLE_LONDON_WRONG_PARENT","title":"<code>IMPORT_IMPOSSIBLE_LONDON_WRONG_PARENT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Trying to import london (basefee) block on top of block that is not 1559.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.IMPORT_IMPOSSIBLE_PARIS_WRONG_POW","title":"<code>IMPORT_IMPOSSIBLE_PARIS_WRONG_POW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Trying to import paris(merge) block with PoW enabled.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.IMPORT_IMPOSSIBLE_PARIS_WRONG_POS","title":"<code>IMPORT_IMPOSSIBLE_PARIS_WRONG_POS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Trying to import paris(merge) block with PoS enabled before TTD is reached.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.IMPORT_IMPOSSIBLE_LONDON_OVER_PARIS","title":"<code>IMPORT_IMPOSSIBLE_LONDON_OVER_PARIS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Trying to import london looking block over paris network (POS).</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.IMPORT_IMPOSSIBLE_PARIS_OVER_SHANGHAI","title":"<code>IMPORT_IMPOSSIBLE_PARIS_OVER_SHANGHAI = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Trying to import paris block on top of shanghai block.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.IMPORT_IMPOSSIBLE_SHANGHAI","title":"<code>IMPORT_IMPOSSIBLE_SHANGHAI = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Shanghai block import is impossible in this chain configuration.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.IMPORT_IMPOSSIBLE_UNCLES_OVER_PARIS","title":"<code>IMPORT_IMPOSSIBLE_UNCLES_OVER_PARIS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Trying to import a block after paris fork that has not empty uncles hash.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.BlockException.IMPORT_IMPOSSIBLE_DIFFICULTY_OVER_PARIS","title":"<code>IMPORT_IMPOSSIBLE_DIFFICULTY_OVER_PARIS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Trying to import a block after paris fork that has difficulty != 0.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException","title":"<code>EOFException</code>","text":"<p>               Bases: <code>ExceptionBase</code></p> <p>Exception raised when an EOF container is invalid.</p> Source code in <code>src/ethereum_test_exceptions/exceptions.py</code> <pre><code>@unique\nclass EOFException(ExceptionBase):\n    \"\"\"Exception raised when an EOF container is invalid.\"\"\"\n\n    DEFAULT_EXCEPTION = auto()\n    \"\"\"\n    Expect some exception, not yet known.\n    \"\"\"\n\n    UNDEFINED_EXCEPTION = auto()\n    \"\"\"\n    Indicates that exception string is not mapped to an exception enum.\n    \"\"\"\n\n    UNDEFINED_INSTRUCTION = auto()\n    \"\"\"\n    EOF container has undefined instruction in it's body code.\n    \"\"\"\n\n    UNKNOWN_VERSION = auto()\n    \"\"\"\n    EOF container has an unknown version.\n    \"\"\"\n    INCOMPLETE_MAGIC = auto()\n    \"\"\"\n    EOF container has not enough bytes to read magic.\n    \"\"\"\n    INVALID_MAGIC = auto()\n    \"\"\"\n    EOF container has not allowed magic version byte.\n    \"\"\"\n    INVALID_VERSION = auto()\n    \"\"\"\n    EOF container version bytes mismatch.\n    \"\"\"\n    INVALID_NON_RETURNING_FLAG = auto()\n    \"\"\"\n    EOF container's section has non-returning flag set incorrectly.\n    \"\"\"\n    INVALID_RJUMP_DESTINATION = auto()\n    \"\"\"\n    Code has RJUMP instruction with invalid parameters.\n    \"\"\"\n    MISSING_TYPE_HEADER = auto()\n    \"\"\"\n    EOF container missing types section.\n    \"\"\"\n    INVALID_TYPE_SECTION_SIZE = auto()\n    \"\"\"\n    EOF container types section has wrong size.\n    \"\"\"\n    INVALID_TYPE_BODY = auto()\n    \"\"\"\n    EOF container types body section bytes are wrong.\n    \"\"\"\n    MISSING_CODE_HEADER = auto()\n    \"\"\"\n    EOF container missing code section.\n    \"\"\"\n    INVALID_CODE_SECTION = auto()\n    \"\"\"\n    EOF container code section bytes are incorrect.\n    \"\"\"\n    INCOMPLETE_CODE_HEADER = auto()\n    \"\"\"\n    EOF container code header missing bytes.\n    \"\"\"\n    INCOMPLETE_DATA_HEADER = auto()\n    \"\"\"\n    EOF container data header missing bytes.\n    \"\"\"\n    ZERO_SECTION_SIZE = auto()\n    \"\"\"\n    EOF container data header construction is wrong.\n    \"\"\"\n    MISSING_DATA_SECTION = auto()\n    \"\"\"\n    EOF container missing data section\n    \"\"\"\n    INCOMPLETE_CONTAINER = auto()\n    \"\"\"\n    EOF container bytes are incomplete.\n    \"\"\"\n    INVALID_SECTION_BODIES_SIZE = auto()\n    \"\"\"\n    Sections bodies does not match sections headers.\n    \"\"\"\n    TRAILING_BYTES = auto()\n    \"\"\"\n    EOF container has bytes beyond data section.\n    \"\"\"\n    MISSING_TERMINATOR = auto()\n    \"\"\"\n    EOF container missing terminator bytes between header and body.\n    \"\"\"\n    MISSING_HEADERS_TERMINATOR = auto()\n    \"\"\"\n    Some type of another exception about missing headers terminator.\n    \"\"\"\n    INVALID_FIRST_SECTION_TYPE = auto()\n    \"\"\"\n    EOF container header does not have types section first.\n    \"\"\"\n    INCOMPLETE_SECTION_NUMBER = auto()\n    \"\"\"\n    EOF container header has section that is missing declaration bytes.\n    \"\"\"\n    INCOMPLETE_SECTION_SIZE = auto()\n    \"\"\"\n    EOF container header has section that is defined incorrectly.\n    \"\"\"\n    TOO_MANY_CODE_SECTIONS = auto()\n    \"\"\"\n    EOF container header has too many code sections.\n    \"\"\"\n    MISSING_STOP_OPCODE = auto()\n    \"\"\"\n    EOF container's code missing STOP bytecode at it's end.\n    \"\"\"\n    INPUTS_OUTPUTS_NUM_ABOVE_LIMIT = auto()\n    \"\"\"\n    EOF container code section inputs/outputs number is above the limit\n    \"\"\"\n    UNREACHABLE_INSTRUCTIONS = auto()\n    \"\"\"\n    EOF container's code have instructions that are unreachable.\n    \"\"\"\n    UNREACHABLE_CODE_SECTIONS = auto()\n    \"\"\"\n    EOF container's body have code sections that are unreachable.\n    \"\"\"\n    STACK_UNDERFLOW = auto()\n    \"\"\"\n    EOF container's code produces an stack underflow.\n    \"\"\"\n    STACK_OVERFLOW = auto()\n    \"\"\"\n    EOF container's code produces an stack overflow.\n    \"\"\"\n    STACK_HEIGHT_MISMATCH = auto()\n    \"\"\"\n    EOF container section stack height mismatch.\n    \"\"\"\n    MAX_STACK_HEIGHT_ABOVE_LIMIT = auto()\n    \"\"\"\n    EOF container's specified max stack height is above the limit.\n    \"\"\"\n    STACK_HIGHER_THAN_OUTPUTS = auto()\n    \"\"\"\n    EOF container section stack height is higher than the outputs.\n    when returning\n    \"\"\"\n    JUMPF_DESTINATION_INCOMPATIBLE_OUTPUTS = auto()\n    \"\"\"\n    EOF container section JUMPF's to a destination section with incompatible outputs.\n    \"\"\"\n    INVALID_MAX_STACK_HEIGHT = auto()\n    \"\"\"\n    EOF container section's specified max stack height does not match the actual stack height.\n    \"\"\"\n    INVALID_DATALOADN_INDEX = auto()\n    \"\"\"\n    A DATALOADN instruction has out-of-bounds index for the data section.\n    \"\"\"\n    TRUNCATED_INSTRUCTION = auto()\n    \"\"\"\n    EOF container's code section has truncated instruction.\n    \"\"\"\n    TOPLEVEL_CONTAINER_TRUNCATED = auto()\n    \"\"\"\n    Top-level EOF container has data section truncated\n    \"\"\"\n    ORPHAN_SUBCONTAINER = auto()\n    \"\"\"\n    EOF container has an unreferenced subcontainer.\n    '\"\"\"\n    CONTAINER_SIZE_ABOVE_LIMIT = auto()\n    \"\"\"\n    EOF container is above size limit\n    \"\"\"\n    INVALID_CONTAINER_SECTION_INDEX = auto()\n    \"\"\"\n    Instruction references container section that does not exist.\n    \"\"\"\n    INCOMPATIBLE_CONTAINER_KIND = auto()\n    \"\"\"\n    Incompatible instruction found in a container of a specific kind.\n    \"\"\"\n    AMBIGUOUS_CONTAINER_KIND = auto()\n    \"\"\"\n    The kind of a sub-container cannot be uniquely deduced.\n    \"\"\"\n    TOO_MANY_CONTAINERS = auto()\n    \"\"\"\n    EOF container header has too many sub-containers.\n    \"\"\"\n    INVALID_CODE_SECTION_INDEX = auto()\n    \"\"\"\n    CALLF Operation referes to a non-existent code section\n    \"\"\"\n    UNEXPECTED_HEADER_KIND = auto()\n    \"\"\"\n    Header parsing encounterd a section kind it wasn't expecting\n    \"\"\"\n    CALLF_TO_NON_RETURNING = auto()\n    \"\"\"\n    CALLF instruction targeting a non-returning code section\n    \"\"\"\n    EOFCREATE_WITH_TRUNCATED_CONTAINER = auto()\n    \"\"\"\n    EOFCREATE with truncated container\n    \"\"\"\n</code></pre>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.DEFAULT_EXCEPTION","title":"<code>DEFAULT_EXCEPTION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Expect some exception, not yet known.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.UNDEFINED_EXCEPTION","title":"<code>UNDEFINED_EXCEPTION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Indicates that exception string is not mapped to an exception enum.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.UNDEFINED_INSTRUCTION","title":"<code>UNDEFINED_INSTRUCTION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container has undefined instruction in it's body code.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.UNKNOWN_VERSION","title":"<code>UNKNOWN_VERSION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container has an unknown version.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.INCOMPLETE_MAGIC","title":"<code>INCOMPLETE_MAGIC = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container has not enough bytes to read magic.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.INVALID_MAGIC","title":"<code>INVALID_MAGIC = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container has not allowed magic version byte.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.INVALID_VERSION","title":"<code>INVALID_VERSION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container version bytes mismatch.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.INVALID_NON_RETURNING_FLAG","title":"<code>INVALID_NON_RETURNING_FLAG = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's section has non-returning flag set incorrectly.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.INVALID_RJUMP_DESTINATION","title":"<code>INVALID_RJUMP_DESTINATION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Code has RJUMP instruction with invalid parameters.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.MISSING_TYPE_HEADER","title":"<code>MISSING_TYPE_HEADER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container missing types section.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.INVALID_TYPE_SECTION_SIZE","title":"<code>INVALID_TYPE_SECTION_SIZE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container types section has wrong size.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.INVALID_TYPE_BODY","title":"<code>INVALID_TYPE_BODY = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container types body section bytes are wrong.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.MISSING_CODE_HEADER","title":"<code>MISSING_CODE_HEADER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container missing code section.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.INVALID_CODE_SECTION","title":"<code>INVALID_CODE_SECTION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container code section bytes are incorrect.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.INCOMPLETE_CODE_HEADER","title":"<code>INCOMPLETE_CODE_HEADER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container code header missing bytes.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.INCOMPLETE_DATA_HEADER","title":"<code>INCOMPLETE_DATA_HEADER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container data header missing bytes.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.ZERO_SECTION_SIZE","title":"<code>ZERO_SECTION_SIZE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container data header construction is wrong.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.MISSING_DATA_SECTION","title":"<code>MISSING_DATA_SECTION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container missing data section</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.INCOMPLETE_CONTAINER","title":"<code>INCOMPLETE_CONTAINER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container bytes are incomplete.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.INVALID_SECTION_BODIES_SIZE","title":"<code>INVALID_SECTION_BODIES_SIZE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Sections bodies does not match sections headers.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.TRAILING_BYTES","title":"<code>TRAILING_BYTES = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container has bytes beyond data section.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.MISSING_TERMINATOR","title":"<code>MISSING_TERMINATOR = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container missing terminator bytes between header and body.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.MISSING_HEADERS_TERMINATOR","title":"<code>MISSING_HEADERS_TERMINATOR = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Some type of another exception about missing headers terminator.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.INVALID_FIRST_SECTION_TYPE","title":"<code>INVALID_FIRST_SECTION_TYPE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container header does not have types section first.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.INCOMPLETE_SECTION_NUMBER","title":"<code>INCOMPLETE_SECTION_NUMBER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container header has section that is missing declaration bytes.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.INCOMPLETE_SECTION_SIZE","title":"<code>INCOMPLETE_SECTION_SIZE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container header has section that is defined incorrectly.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.TOO_MANY_CODE_SECTIONS","title":"<code>TOO_MANY_CODE_SECTIONS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container header has too many code sections.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.MISSING_STOP_OPCODE","title":"<code>MISSING_STOP_OPCODE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's code missing STOP bytecode at it's end.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.INPUTS_OUTPUTS_NUM_ABOVE_LIMIT","title":"<code>INPUTS_OUTPUTS_NUM_ABOVE_LIMIT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container code section inputs/outputs number is above the limit</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.UNREACHABLE_INSTRUCTIONS","title":"<code>UNREACHABLE_INSTRUCTIONS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's code have instructions that are unreachable.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.UNREACHABLE_CODE_SECTIONS","title":"<code>UNREACHABLE_CODE_SECTIONS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's body have code sections that are unreachable.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.STACK_UNDERFLOW","title":"<code>STACK_UNDERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's code produces an stack underflow.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.STACK_OVERFLOW","title":"<code>STACK_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's code produces an stack overflow.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.STACK_HEIGHT_MISMATCH","title":"<code>STACK_HEIGHT_MISMATCH = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container section stack height mismatch.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.MAX_STACK_HEIGHT_ABOVE_LIMIT","title":"<code>MAX_STACK_HEIGHT_ABOVE_LIMIT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's specified max stack height is above the limit.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.STACK_HIGHER_THAN_OUTPUTS","title":"<code>STACK_HIGHER_THAN_OUTPUTS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container section stack height is higher than the outputs. when returning</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.JUMPF_DESTINATION_INCOMPATIBLE_OUTPUTS","title":"<code>JUMPF_DESTINATION_INCOMPATIBLE_OUTPUTS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container section JUMPF's to a destination section with incompatible outputs.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.INVALID_MAX_STACK_HEIGHT","title":"<code>INVALID_MAX_STACK_HEIGHT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container section's specified max stack height does not match the actual stack height.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.INVALID_DATALOADN_INDEX","title":"<code>INVALID_DATALOADN_INDEX = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A DATALOADN instruction has out-of-bounds index for the data section.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.TRUNCATED_INSTRUCTION","title":"<code>TRUNCATED_INSTRUCTION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's code section has truncated instruction.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.TOPLEVEL_CONTAINER_TRUNCATED","title":"<code>TOPLEVEL_CONTAINER_TRUNCATED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Top-level EOF container has data section truncated</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.ORPHAN_SUBCONTAINER","title":"<code>ORPHAN_SUBCONTAINER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container has an unreferenced subcontainer. '</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.CONTAINER_SIZE_ABOVE_LIMIT","title":"<code>CONTAINER_SIZE_ABOVE_LIMIT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container is above size limit</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.INVALID_CONTAINER_SECTION_INDEX","title":"<code>INVALID_CONTAINER_SECTION_INDEX = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Instruction references container section that does not exist.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.INCOMPATIBLE_CONTAINER_KIND","title":"<code>INCOMPATIBLE_CONTAINER_KIND = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Incompatible instruction found in a container of a specific kind.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.AMBIGUOUS_CONTAINER_KIND","title":"<code>AMBIGUOUS_CONTAINER_KIND = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The kind of a sub-container cannot be uniquely deduced.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.TOO_MANY_CONTAINERS","title":"<code>TOO_MANY_CONTAINERS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container header has too many sub-containers.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.INVALID_CODE_SECTION_INDEX","title":"<code>INVALID_CODE_SECTION_INDEX = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>CALLF Operation referes to a non-existent code section</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.UNEXPECTED_HEADER_KIND","title":"<code>UNEXPECTED_HEADER_KIND = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Header parsing encounterd a section kind it wasn't expecting</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.CALLF_TO_NON_RETURNING","title":"<code>CALLF_TO_NON_RETURNING = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>CALLF instruction targeting a non-returning code section</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.EOFException.EOFCREATE_WITH_TRUNCATED_CONTAINER","title":"<code>EOFCREATE_WITH_TRUNCATED_CONTAINER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOFCREATE with truncated container</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.ExceptionBase","title":"<code>ExceptionBase</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Base class for exceptions.</p> Source code in <code>src/ethereum_test_exceptions/exceptions.py</code> <pre><code>class ExceptionBase(Enum):\n    \"\"\"Base class for exceptions.\"\"\"\n\n    def __init_subclass__(cls) -&gt; None:\n        \"\"\"Register the exception class.\"\"\"\n        super().__init_subclass__()\n        _exception_classes[cls.__name__] = cls\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source_type: Any, handler: GetCoreSchemaHandler\n    ) -&gt; PlainValidatorFunctionSchema:\n        \"\"\"Call class constructor without info and appends the serialization schema.\"\"\"\n        return no_info_plain_validator_function(\n            cls.from_str,\n            serialization=to_string_ser_schema(),\n        )\n\n    @classmethod\n    def from_str(cls, value: \"str | ExceptionBase\") -&gt; \"ExceptionBase\":\n        \"\"\"Return ContainerKind enum value from a string.\"\"\"\n        if isinstance(value, ExceptionBase):\n            return value\n\n        class_name, enum_name = value.split(\".\")\n\n        if cls == ExceptionBase:\n            # Exception base automatically resolves the class\n            assert class_name in _exception_classes, f\"No such exception class: {class_name}\"\n            exception_class = _exception_classes[class_name]\n        else:\n            # Otherwise, use the class that the method is called on\n            assert cls.__name__ == class_name, (\n                f\"Unexpected exception type: {class_name}, expected {cls.__name__}\"\n            )\n            exception_class = cls\n\n        exception = getattr(exception_class, enum_name, None)\n        if exception is not None:\n            return exception\n        raise ValueError(f\"No such exception in {class_name}: {value}\")\n\n    def __contains__(self, exception) -&gt; bool:\n        \"\"\"Check if provided exception is equal to this.\"\"\"\n        return self == exception\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return string representation of the exception.\"\"\"\n        return f\"{self.__class__.__name__}.{self.name}\"\n</code></pre>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.ExceptionBase.__init_subclass__","title":"<code>__init_subclass__()</code>","text":"<p>Register the exception class.</p> Source code in <code>src/ethereum_test_exceptions/exceptions.py</code> <pre><code>def __init_subclass__(cls) -&gt; None:\n    \"\"\"Register the exception class.\"\"\"\n    super().__init_subclass__()\n    _exception_classes[cls.__name__] = cls\n</code></pre>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.ExceptionBase.__get_pydantic_core_schema__","title":"<code>__get_pydantic_core_schema__(source_type, handler)</code>  <code>classmethod</code>","text":"<p>Call class constructor without info and appends the serialization schema.</p> Source code in <code>src/ethereum_test_exceptions/exceptions.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(\n    cls, source_type: Any, handler: GetCoreSchemaHandler\n) -&gt; PlainValidatorFunctionSchema:\n    \"\"\"Call class constructor without info and appends the serialization schema.\"\"\"\n    return no_info_plain_validator_function(\n        cls.from_str,\n        serialization=to_string_ser_schema(),\n    )\n</code></pre>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.ExceptionBase.from_str","title":"<code>from_str(value)</code>  <code>classmethod</code>","text":"<p>Return ContainerKind enum value from a string.</p> Source code in <code>src/ethereum_test_exceptions/exceptions.py</code> <pre><code>@classmethod\ndef from_str(cls, value: \"str | ExceptionBase\") -&gt; \"ExceptionBase\":\n    \"\"\"Return ContainerKind enum value from a string.\"\"\"\n    if isinstance(value, ExceptionBase):\n        return value\n\n    class_name, enum_name = value.split(\".\")\n\n    if cls == ExceptionBase:\n        # Exception base automatically resolves the class\n        assert class_name in _exception_classes, f\"No such exception class: {class_name}\"\n        exception_class = _exception_classes[class_name]\n    else:\n        # Otherwise, use the class that the method is called on\n        assert cls.__name__ == class_name, (\n            f\"Unexpected exception type: {class_name}, expected {cls.__name__}\"\n        )\n        exception_class = cls\n\n    exception = getattr(exception_class, enum_name, None)\n    if exception is not None:\n        return exception\n    raise ValueError(f\"No such exception in {class_name}: {value}\")\n</code></pre>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.ExceptionBase.__contains__","title":"<code>__contains__(exception)</code>","text":"<p>Check if provided exception is equal to this.</p> Source code in <code>src/ethereum_test_exceptions/exceptions.py</code> <pre><code>def __contains__(self, exception) -&gt; bool:\n    \"\"\"Check if provided exception is equal to this.\"\"\"\n    return self == exception\n</code></pre>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.ExceptionBase.__str__","title":"<code>__str__()</code>","text":"<p>Return string representation of the exception.</p> Source code in <code>src/ethereum_test_exceptions/exceptions.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return string representation of the exception.\"\"\"\n    return f\"{self.__class__.__name__}.{self.name}\"\n</code></pre>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException","title":"<code>TransactionException</code>","text":"<p>               Bases: <code>ExceptionBase</code></p> <p>Exception raised when a transaction is invalid, and thus cannot be executed.</p> <p>If a transaction with any of these exceptions is included in a block, the block is invalid.</p> Source code in <code>src/ethereum_test_exceptions/exceptions.py</code> <pre><code>@unique\nclass TransactionException(ExceptionBase):\n    \"\"\"\n    Exception raised when a transaction is invalid, and thus cannot be executed.\n\n    If a transaction with any of these exceptions is included in a block, the block is invalid.\n    \"\"\"\n\n    TYPE_NOT_SUPPORTED = auto()\n    \"\"\"\n    Transaction type is not supported on this chain configuration.\n    \"\"\"\n    SENDER_NOT_EOA = auto()\n    \"\"\"\n    Transaction is coming from address that is not exist anymore.\n    \"\"\"\n    ADDRESS_TOO_SHORT = auto()\n    \"\"\"\n    Transaction `to` is not allowed to be less than 20 bytes.\n    \"\"\"\n    ADDRESS_TOO_LONG = auto()\n    \"\"\"\n    Transaction `to` is not allowed to be more than 20 bytes.\n    \"\"\"\n    NONCE_MISMATCH_TOO_HIGH = auto()\n    \"\"\"\n    Transaction nonce &gt; sender.nonce.\n    \"\"\"\n    NONCE_MISMATCH_TOO_LOW = auto()\n    \"\"\"\n    Transaction nonce &lt; sender.nonce.\n    \"\"\"\n    NONCE_TOO_BIG = auto()\n    \"\"\"\n    Transaction `nonce` is not allowed to be max_uint64 - 1 (this is probably TransactionTest).\n    \"\"\"\n    NONCE_IS_MAX = auto()\n    \"\"\"\n    Transaction `nonce` is not allowed to be max_uint64 - 1 (this is StateTests).\n    \"\"\"\n    NONCE_OVERFLOW = auto()\n    \"\"\"\n    Transaction `nonce` is not allowed to be more than uint64.\n    \"\"\"\n    GASLIMIT_OVERFLOW = auto()\n    \"\"\"\n    Transaction gaslimit exceeds 2^64-1 maximum value.\n    \"\"\"\n    VALUE_OVERFLOW = auto()\n    \"\"\"\n    Transaction value exceeds 2^256-1 maximum value.\n    \"\"\"\n    GASPRICE_OVERFLOW = auto()\n    \"\"\"\n    Transaction gasPrice exceeds 2^256-1 maximum value.\n    \"\"\"\n    GASLIMIT_PRICE_PRODUCT_OVERFLOW = auto()\n    \"\"\"\n    Transaction gasPrice * gasLimit exceeds 2^256-1 maximum value.\n    \"\"\"\n    INVALID_SIGNATURE_VRS = auto()\n    \"\"\"\n    Invalid transaction v, r, s values.\n    \"\"\"\n    RLP_INVALID_SIGNATURE_R = auto()\n    \"\"\"\n    Error reading transaction signature R value.\n    \"\"\"\n    RLP_INVALID_SIGNATURE_S = auto()\n    \"\"\"\n    Error reading transaction signature S value.\n    \"\"\"\n    RLP_LEADING_ZEROS_GASLIMIT = auto()\n    \"\"\"\n    Error reading transaction gaslimit field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_GASPRICE = auto()\n    \"\"\"\n    Error reading transaction gasprice field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_VALUE = auto()\n    \"\"\"\n    Error reading transaction value field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_NONCE = auto()\n    \"\"\"\n    Error reading transaction nonce field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_R = auto()\n    \"\"\"\n    Error reading transaction signature R field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_S = auto()\n    \"\"\"\n    Error reading transaction signature S field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_V = auto()\n    \"\"\"\n    Error reading transaction signature V field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_BASEFEE = auto()\n    \"\"\"\n    Error reading transaction basefee field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_PRIORITY_FEE = auto()\n    \"\"\"\n    Error reading transaction priority fee field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_DATA_SIZE = auto()\n    \"\"\"\n    Error reading transaction data field RLP, (rlp field length has leading zeros).\n    \"\"\"\n    RLP_LEADING_ZEROS_NONCE_SIZE = auto()\n    \"\"\"\n    Error reading transaction nonce field RLP, (rlp field length has leading zeros).\n    \"\"\"\n    RLP_TOO_FEW_ELEMENTS = auto()\n    \"\"\"\n    Error reading transaction RLP, structure has too few elements than expected.\n    \"\"\"\n    RLP_TOO_MANY_ELEMENTS = auto()\n    \"\"\"\n    Error reading transaction RLP, structure has too many elements than expected.\n    \"\"\"\n    RLP_ERROR_EOF = auto()\n    \"\"\"\n    Error reading transaction RLP, rlp stream unexpectedly finished.\n    \"\"\"\n    RLP_ERROR_SIZE = auto()\n    \"\"\"\n    Error reading transaction RLP, rlp size is invalid.\n    \"\"\"\n    RLP_ERROR_SIZE_LEADING_ZEROS = auto()\n    \"\"\"\n    Error reading transaction RLP, field size has leading zeros.\n    \"\"\"\n    INVALID_CHAINID = auto()\n    \"\"\"\n    Transaction chain id encoding is incorrect.\n    \"\"\"\n    RLP_INVALID_DATA = auto()\n    \"\"\"\n    Transaction data field is invalid rlp.\n    \"\"\"\n    RLP_INVALID_GASLIMIT = auto()\n    \"\"\"\n    Transaction gaslimit field is invalid rlp.\n    \"\"\"\n    RLP_INVALID_NONCE = auto()\n    \"\"\"\n    Transaction nonce field is invalid rlp.\n    \"\"\"\n    RLP_INVALID_TO = auto()\n    \"\"\"\n    Transaction to field is invalid rlp.\n    \"\"\"\n    RLP_INVALID_ACCESS_LIST_ADDRESS_TOO_LONG = auto()\n    \"\"\"\n    Transaction access list address is &gt; 20 bytes.\n    \"\"\"\n    RLP_INVALID_ACCESS_LIST_ADDRESS_TOO_SHORT = auto()\n    \"\"\"\n    Transaction access list address is &lt; 20 bytes.\n    \"\"\"\n    RLP_INVALID_ACCESS_LIST_STORAGE_TOO_LONG = auto()\n    \"\"\"\n    Transaction access list storage hash &gt; 32 bytes.\n    \"\"\"\n    RLP_INVALID_ACCESS_LIST_STORAGE_TOO_SHORT = auto()\n    \"\"\"\n    Transaction access list storage hash &lt; 32 bytes.\n    \"\"\"\n    RLP_INVALID_HEADER = auto()\n    \"\"\"\n    Transaction failed to read from RLP as rlp header is invalid.\n    \"\"\"\n    RLP_INVALID_VALUE = auto()\n    \"\"\"\n    Transaction value field is invalid rlp/structure.\n    \"\"\"\n    EC_RECOVERY_FAIL = auto()\n    \"\"\"\n    Transaction has correct signature, but ec recovery failed.\n    \"\"\"\n    INSUFFICIENT_ACCOUNT_FUNDS = auto()\n    \"\"\"\n    Transaction's sender does not have enough funds to pay for the transaction.\n    \"\"\"\n    INSUFFICIENT_MAX_FEE_PER_GAS = auto()\n    \"\"\"\n    Transaction's max-fee-per-gas is lower than the block base-fee.\n    \"\"\"\n    PRIORITY_OVERFLOW = auto()\n    \"\"\"\n    Transaction's max-priority-fee-per-gas is exceeds 2^256-1 maximum value.\n    \"\"\"\n    PRIORITY_GREATER_THAN_MAX_FEE_PER_GAS = auto()\n    \"\"\"\n    Transaction's max-priority-fee-per-gas is greater than the max-fee-per-gas.\n    \"\"\"\n    PRIORITY_GREATER_THAN_MAX_FEE_PER_GAS_2 = auto()\n    \"\"\"\n    Transaction's max-priority-fee-per-gas is greater than the max-fee-per-gas (TransactionTests).\n    \"\"\"\n    INSUFFICIENT_MAX_FEE_PER_BLOB_GAS = auto()\n    \"\"\"\n    Transaction's max-fee-per-blob-gas is lower than the block's blob-gas price.\n    \"\"\"\n    INTRINSIC_GAS_TOO_LOW = auto()\n    \"\"\"\n    Transaction's gas limit is too low.\n    \"\"\"\n    INITCODE_SIZE_EXCEEDED = auto()\n    \"\"\"\n    Transaction's initcode for a contract-creating transaction is too large.\n    \"\"\"\n    TYPE_3_TX_PRE_FORK = auto()\n    \"\"\"\n    Transaction type 3 included before activation fork.\n    \"\"\"\n    TYPE_3_TX_ZERO_BLOBS_PRE_FORK = auto()\n    \"\"\"\n    Transaction type 3, with zero blobs, included before activation fork.\n    \"\"\"\n    TYPE_3_TX_INVALID_BLOB_VERSIONED_HASH = auto()\n    \"\"\"\n    Transaction contains a blob versioned hash with an invalid version.\n    \"\"\"\n    TYPE_3_TX_WITH_FULL_BLOBS = auto()\n    \"\"\"\n    Transaction contains full blobs (network-version of the transaction).\n    \"\"\"\n    TYPE_3_TX_BLOB_COUNT_EXCEEDED = auto()\n    \"\"\"\n    Transaction contains too many blob versioned hashes.\n    \"\"\"\n    TYPE_3_TX_CONTRACT_CREATION = auto()\n    \"\"\"\n    Transaction is a type 3 transaction and has an empty `to`.\n    \"\"\"\n    TYPE_3_TX_MAX_BLOB_GAS_ALLOWANCE_EXCEEDED = auto()\n    \"\"\"\n    Transaction causes block to go over blob gas limit.\n    \"\"\"\n    GAS_ALLOWANCE_EXCEEDED = auto()\n    \"\"\"\n    Transaction causes block to go over blob gas limit.\n    \"\"\"\n    TYPE_3_TX_ZERO_BLOBS = auto()\n    \"\"\"\n    Transaction is type 3, but has no blobs.\n    \"\"\"\n    TYPE_4_EMPTY_AUTHORIZATION_LIST = auto()\n    \"\"\"\n    Transaction is type 4, but has an empty authorization list.\n    \"\"\"\n    TYPE_4_INVALID_AUTHORITY_SIGNATURE = auto()\n    \"\"\"\n    Transaction authority signature is invalid\n    \"\"\"\n    TYPE_4_INVALID_AUTHORITY_SIGNATURE_S_TOO_HIGH = auto()\n    \"\"\"\n    Transaction authority signature is invalid\n    \"\"\"\n    TYPE_4_TX_CONTRACT_CREATION = auto()\n    \"\"\"\n    Transaction is a type 4 transaction and has an empty `to`.\n    \"\"\"\n    TYPE_4_INVALID_AUTHORIZATION_FORMAT = auto()\n    \"\"\"\n    Transaction is type 4, but contains an authorization that has an invalid format.\n    \"\"\"\n</code></pre>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.TYPE_NOT_SUPPORTED","title":"<code>TYPE_NOT_SUPPORTED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction type is not supported on this chain configuration.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.SENDER_NOT_EOA","title":"<code>SENDER_NOT_EOA = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction is coming from address that is not exist anymore.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.ADDRESS_TOO_SHORT","title":"<code>ADDRESS_TOO_SHORT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction <code>to</code> is not allowed to be less than 20 bytes.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.ADDRESS_TOO_LONG","title":"<code>ADDRESS_TOO_LONG = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction <code>to</code> is not allowed to be more than 20 bytes.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.NONCE_MISMATCH_TOO_HIGH","title":"<code>NONCE_MISMATCH_TOO_HIGH = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction nonce &gt; sender.nonce.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.NONCE_MISMATCH_TOO_LOW","title":"<code>NONCE_MISMATCH_TOO_LOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction nonce &lt; sender.nonce.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.NONCE_TOO_BIG","title":"<code>NONCE_TOO_BIG = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction <code>nonce</code> is not allowed to be max_uint64 - 1 (this is probably TransactionTest).</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.NONCE_IS_MAX","title":"<code>NONCE_IS_MAX = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction <code>nonce</code> is not allowed to be max_uint64 - 1 (this is StateTests).</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.NONCE_OVERFLOW","title":"<code>NONCE_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction <code>nonce</code> is not allowed to be more than uint64.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.GASLIMIT_OVERFLOW","title":"<code>GASLIMIT_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction gaslimit exceeds 2^64-1 maximum value.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.VALUE_OVERFLOW","title":"<code>VALUE_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction value exceeds 2^256-1 maximum value.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.GASPRICE_OVERFLOW","title":"<code>GASPRICE_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction gasPrice exceeds 2^256-1 maximum value.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.GASLIMIT_PRICE_PRODUCT_OVERFLOW","title":"<code>GASLIMIT_PRICE_PRODUCT_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction gasPrice * gasLimit exceeds 2^256-1 maximum value.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.INVALID_SIGNATURE_VRS","title":"<code>INVALID_SIGNATURE_VRS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Invalid transaction v, r, s values.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_SIGNATURE_R","title":"<code>RLP_INVALID_SIGNATURE_R = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction signature R value.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_SIGNATURE_S","title":"<code>RLP_INVALID_SIGNATURE_S = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction signature S value.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_LEADING_ZEROS_GASLIMIT","title":"<code>RLP_LEADING_ZEROS_GASLIMIT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction gaslimit field RLP.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_LEADING_ZEROS_GASPRICE","title":"<code>RLP_LEADING_ZEROS_GASPRICE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction gasprice field RLP.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_LEADING_ZEROS_VALUE","title":"<code>RLP_LEADING_ZEROS_VALUE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction value field RLP.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_LEADING_ZEROS_NONCE","title":"<code>RLP_LEADING_ZEROS_NONCE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction nonce field RLP.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_LEADING_ZEROS_R","title":"<code>RLP_LEADING_ZEROS_R = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction signature R field RLP.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_LEADING_ZEROS_S","title":"<code>RLP_LEADING_ZEROS_S = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction signature S field RLP.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_LEADING_ZEROS_V","title":"<code>RLP_LEADING_ZEROS_V = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction signature V field RLP.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_LEADING_ZEROS_BASEFEE","title":"<code>RLP_LEADING_ZEROS_BASEFEE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction basefee field RLP.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_LEADING_ZEROS_PRIORITY_FEE","title":"<code>RLP_LEADING_ZEROS_PRIORITY_FEE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction priority fee field RLP.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_LEADING_ZEROS_DATA_SIZE","title":"<code>RLP_LEADING_ZEROS_DATA_SIZE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction data field RLP, (rlp field length has leading zeros).</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_LEADING_ZEROS_NONCE_SIZE","title":"<code>RLP_LEADING_ZEROS_NONCE_SIZE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction nonce field RLP, (rlp field length has leading zeros).</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_TOO_FEW_ELEMENTS","title":"<code>RLP_TOO_FEW_ELEMENTS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction RLP, structure has too few elements than expected.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_TOO_MANY_ELEMENTS","title":"<code>RLP_TOO_MANY_ELEMENTS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction RLP, structure has too many elements than expected.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_ERROR_EOF","title":"<code>RLP_ERROR_EOF = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction RLP, rlp stream unexpectedly finished.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_ERROR_SIZE","title":"<code>RLP_ERROR_SIZE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction RLP, rlp size is invalid.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_ERROR_SIZE_LEADING_ZEROS","title":"<code>RLP_ERROR_SIZE_LEADING_ZEROS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction RLP, field size has leading zeros.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.INVALID_CHAINID","title":"<code>INVALID_CHAINID = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction chain id encoding is incorrect.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_DATA","title":"<code>RLP_INVALID_DATA = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction data field is invalid rlp.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_GASLIMIT","title":"<code>RLP_INVALID_GASLIMIT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction gaslimit field is invalid rlp.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_NONCE","title":"<code>RLP_INVALID_NONCE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction nonce field is invalid rlp.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_TO","title":"<code>RLP_INVALID_TO = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction to field is invalid rlp.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_ACCESS_LIST_ADDRESS_TOO_LONG","title":"<code>RLP_INVALID_ACCESS_LIST_ADDRESS_TOO_LONG = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction access list address is &gt; 20 bytes.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_ACCESS_LIST_ADDRESS_TOO_SHORT","title":"<code>RLP_INVALID_ACCESS_LIST_ADDRESS_TOO_SHORT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction access list address is &lt; 20 bytes.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_ACCESS_LIST_STORAGE_TOO_LONG","title":"<code>RLP_INVALID_ACCESS_LIST_STORAGE_TOO_LONG = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction access list storage hash &gt; 32 bytes.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_ACCESS_LIST_STORAGE_TOO_SHORT","title":"<code>RLP_INVALID_ACCESS_LIST_STORAGE_TOO_SHORT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction access list storage hash &lt; 32 bytes.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_HEADER","title":"<code>RLP_INVALID_HEADER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction failed to read from RLP as rlp header is invalid.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.RLP_INVALID_VALUE","title":"<code>RLP_INVALID_VALUE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction value field is invalid rlp/structure.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.EC_RECOVERY_FAIL","title":"<code>EC_RECOVERY_FAIL = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction has correct signature, but ec recovery failed.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.INSUFFICIENT_ACCOUNT_FUNDS","title":"<code>INSUFFICIENT_ACCOUNT_FUNDS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's sender does not have enough funds to pay for the transaction.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.INSUFFICIENT_MAX_FEE_PER_GAS","title":"<code>INSUFFICIENT_MAX_FEE_PER_GAS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's max-fee-per-gas is lower than the block base-fee.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.PRIORITY_OVERFLOW","title":"<code>PRIORITY_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's max-priority-fee-per-gas is exceeds 2^256-1 maximum value.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.PRIORITY_GREATER_THAN_MAX_FEE_PER_GAS","title":"<code>PRIORITY_GREATER_THAN_MAX_FEE_PER_GAS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's max-priority-fee-per-gas is greater than the max-fee-per-gas.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.PRIORITY_GREATER_THAN_MAX_FEE_PER_GAS_2","title":"<code>PRIORITY_GREATER_THAN_MAX_FEE_PER_GAS_2 = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's max-priority-fee-per-gas is greater than the max-fee-per-gas (TransactionTests).</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.INSUFFICIENT_MAX_FEE_PER_BLOB_GAS","title":"<code>INSUFFICIENT_MAX_FEE_PER_BLOB_GAS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's max-fee-per-blob-gas is lower than the block's blob-gas price.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.INTRINSIC_GAS_TOO_LOW","title":"<code>INTRINSIC_GAS_TOO_LOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's gas limit is too low.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.INITCODE_SIZE_EXCEEDED","title":"<code>INITCODE_SIZE_EXCEEDED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's initcode for a contract-creating transaction is too large.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.TYPE_3_TX_PRE_FORK","title":"<code>TYPE_3_TX_PRE_FORK = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction type 3 included before activation fork.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.TYPE_3_TX_ZERO_BLOBS_PRE_FORK","title":"<code>TYPE_3_TX_ZERO_BLOBS_PRE_FORK = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction type 3, with zero blobs, included before activation fork.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.TYPE_3_TX_INVALID_BLOB_VERSIONED_HASH","title":"<code>TYPE_3_TX_INVALID_BLOB_VERSIONED_HASH = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction contains a blob versioned hash with an invalid version.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.TYPE_3_TX_WITH_FULL_BLOBS","title":"<code>TYPE_3_TX_WITH_FULL_BLOBS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction contains full blobs (network-version of the transaction).</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.TYPE_3_TX_BLOB_COUNT_EXCEEDED","title":"<code>TYPE_3_TX_BLOB_COUNT_EXCEEDED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction contains too many blob versioned hashes.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.TYPE_3_TX_CONTRACT_CREATION","title":"<code>TYPE_3_TX_CONTRACT_CREATION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction is a type 3 transaction and has an empty <code>to</code>.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.TYPE_3_TX_MAX_BLOB_GAS_ALLOWANCE_EXCEEDED","title":"<code>TYPE_3_TX_MAX_BLOB_GAS_ALLOWANCE_EXCEEDED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction causes block to go over blob gas limit.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.GAS_ALLOWANCE_EXCEEDED","title":"<code>GAS_ALLOWANCE_EXCEEDED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction causes block to go over blob gas limit.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.TYPE_3_TX_ZERO_BLOBS","title":"<code>TYPE_3_TX_ZERO_BLOBS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction is type 3, but has no blobs.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.TYPE_4_EMPTY_AUTHORIZATION_LIST","title":"<code>TYPE_4_EMPTY_AUTHORIZATION_LIST = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction is type 4, but has an empty authorization list.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.TYPE_4_INVALID_AUTHORITY_SIGNATURE","title":"<code>TYPE_4_INVALID_AUTHORITY_SIGNATURE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction authority signature is invalid</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.TYPE_4_INVALID_AUTHORITY_SIGNATURE_S_TOO_HIGH","title":"<code>TYPE_4_INVALID_AUTHORITY_SIGNATURE_S_TOO_HIGH = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction authority signature is invalid</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.TYPE_4_TX_CONTRACT_CREATION","title":"<code>TYPE_4_TX_CONTRACT_CREATION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction is a type 4 transaction and has an empty <code>to</code>.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.TransactionException.TYPE_4_INVALID_AUTHORIZATION_FORMAT","title":"<code>TYPE_4_INVALID_AUTHORIZATION_FORMAT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction is type 4, but contains an authorization that has an invalid format.</p>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.UndefinedException","title":"<code>UndefinedException</code>","text":"<p>               Bases: <code>ExceptionBase</code></p> <p>Default Exception.</p> Source code in <code>src/ethereum_test_exceptions/exceptions.py</code> <pre><code>@unique\nclass UndefinedException(ExceptionBase):\n    \"\"\"Default Exception.\"\"\"\n\n    UNDEFINED_EXCEPTION = auto()\n    \"\"\"\n    Exception to alert to define a proper exception\n    \"\"\"\n</code></pre>"},{"location":"library/ethereum_test_exceptions/#ethereum_test_exceptions.UndefinedException.UNDEFINED_EXCEPTION","title":"<code>UNDEFINED_EXCEPTION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exception to alert to define a proper exception</p>"},{"location":"library/ethereum_test_fixtures/","title":"Ethereum Test Fixtures package","text":"<p>Ethereum test fixture format definitions.</p>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.BaseFixture","title":"<code>BaseFixture</code>","text":"<p>               Bases: <code>CamelModel</code></p> <p>Represents a base Ethereum test fixture of any type.</p> Source code in <code>src/ethereum_test_fixtures/base.py</code> <pre><code>class BaseFixture(CamelModel):\n    \"\"\"Represents a base Ethereum test fixture of any type.\"\"\"\n\n    # Base Fixture class properties\n    formats: ClassVar[Dict[str, Type[\"BaseFixture\"]]] = {}\n    formats_type_adapter: ClassVar[TypeAdapter]\n\n    info: Dict[str, Dict[str, Any] | str] = Field(default_factory=dict, alias=\"_info\")\n\n    # Fixture format properties\n    format_name: ClassVar[str] = \"\"\n    output_file_extension: ClassVar[str] = \".json\"\n    description: ClassVar[str] = \"Unknown fixture format; it has not been set.\"\n\n    @classmethod\n    def output_base_dir_name(cls) -&gt; str:\n        \"\"\"Return name of the subdirectory where this type of fixture should be dumped to.\"\"\"\n        return cls.format_name.replace(\"test\", \"tests\")\n\n    @classmethod\n    def __pydantic_init_subclass__(cls, **kwargs):\n        \"\"\"\n        Register all subclasses of BaseFixture with a fixture format name set\n        as possible fixture formats.\n        \"\"\"\n        if cls.format_name:\n            # Register the new fixture format\n            BaseFixture.formats[cls.format_name] = cls\n            if len(BaseFixture.formats) &gt; 1:\n                BaseFixture.formats_type_adapter = TypeAdapter(\n                    Annotated[\n                        Union[\n                            tuple(\n                                Annotated[fixture_format, Tag(format_name)]\n                                for (\n                                    format_name,\n                                    fixture_format,\n                                ) in BaseFixture.formats.items()\n                            )\n                        ],\n                        Discriminator(fixture_format_discriminator),\n                    ]\n                )\n            else:\n                BaseFixture.formats_type_adapter = TypeAdapter(cls)\n\n    @model_validator(mode=\"wrap\")\n    @classmethod\n    def _parse_into_subclass(cls, v: Any, handler: ValidatorFunctionWrapHandler) -&gt; \"BaseFixture\":\n        \"\"\"Parse the fixture into the correct subclass.\"\"\"\n        if cls is BaseFixture:\n            return BaseFixture.formats_type_adapter.validate_python(v)\n        return handler(v)\n\n    @cached_property\n    def json_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Returns the JSON representation of the fixture.\"\"\"\n        return self.model_dump(mode=\"json\", by_alias=True, exclude_none=True, exclude={\"info\"})\n\n    @cached_property\n    def hash(self) -&gt; str:\n        \"\"\"Returns the hash of the fixture.\"\"\"\n        json_str = json.dumps(self.json_dict, sort_keys=True, separators=(\",\", \":\"))\n        h = hashlib.sha256(json_str.encode(\"utf-8\")).hexdigest()\n        return f\"0x{h}\"\n\n    def json_dict_with_info(self, hash_only: bool = False) -&gt; Dict[str, Any]:\n        \"\"\"Return JSON representation of the fixture with the info field.\"\"\"\n        dict_with_info = self.json_dict.copy()\n        dict_with_info[\"_info\"] = {\"hash\": self.hash}\n        if not hash_only:\n            dict_with_info[\"_info\"].update(self.info)\n        return dict_with_info\n\n    def fill_info(\n        self,\n        t8n_version: str,\n        test_case_description: str,\n        fixture_source_url: str,\n        ref_spec: ReferenceSpec | None,\n        _info_metadata: Dict[str, Any],\n    ):\n        \"\"\"Fill the info field for this fixture.\"\"\"\n        if \"comment\" not in self.info:\n            self.info[\"comment\"] = \"`execution-spec-tests` generated test\"\n        self.info[\"filling-transition-tool\"] = t8n_version\n        self.info[\"description\"] = test_case_description\n        self.info[\"url\"] = fixture_source_url\n        self.info[\"fixture-format\"] = self.format_name\n        if ref_spec is not None:\n            ref_spec.write_info(self.info)\n        if _info_metadata:\n            self.info.update(_info_metadata)\n\n    def get_fork(self) -&gt; str | None:\n        \"\"\"Return fork of the fixture as a string.\"\"\"\n        raise NotImplementedError\n\n    @classmethod\n    def supports_fork(cls, fork: Fork) -&gt; bool:\n        \"\"\"\n        Return whether the fixture can be generated for the given fork.\n\n        By default, all fixtures support all forks.\n        \"\"\"\n        return True\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.BaseFixture.output_base_dir_name","title":"<code>output_base_dir_name()</code>  <code>classmethod</code>","text":"<p>Return name of the subdirectory where this type of fixture should be dumped to.</p> Source code in <code>src/ethereum_test_fixtures/base.py</code> <pre><code>@classmethod\ndef output_base_dir_name(cls) -&gt; str:\n    \"\"\"Return name of the subdirectory where this type of fixture should be dumped to.\"\"\"\n    return cls.format_name.replace(\"test\", \"tests\")\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.BaseFixture.__pydantic_init_subclass__","title":"<code>__pydantic_init_subclass__(**kwargs)</code>  <code>classmethod</code>","text":"<p>Register all subclasses of BaseFixture with a fixture format name set as possible fixture formats.</p> Source code in <code>src/ethereum_test_fixtures/base.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Register all subclasses of BaseFixture with a fixture format name set\n    as possible fixture formats.\n    \"\"\"\n    if cls.format_name:\n        # Register the new fixture format\n        BaseFixture.formats[cls.format_name] = cls\n        if len(BaseFixture.formats) &gt; 1:\n            BaseFixture.formats_type_adapter = TypeAdapter(\n                Annotated[\n                    Union[\n                        tuple(\n                            Annotated[fixture_format, Tag(format_name)]\n                            for (\n                                format_name,\n                                fixture_format,\n                            ) in BaseFixture.formats.items()\n                        )\n                    ],\n                    Discriminator(fixture_format_discriminator),\n                ]\n            )\n        else:\n            BaseFixture.formats_type_adapter = TypeAdapter(cls)\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.BaseFixture.json_dict","title":"<code>json_dict: Dict[str, Any]</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the JSON representation of the fixture.</p>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.BaseFixture.hash","title":"<code>hash: str</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the hash of the fixture.</p>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.BaseFixture.json_dict_with_info","title":"<code>json_dict_with_info(hash_only=False)</code>","text":"<p>Return JSON representation of the fixture with the info field.</p> Source code in <code>src/ethereum_test_fixtures/base.py</code> <pre><code>def json_dict_with_info(self, hash_only: bool = False) -&gt; Dict[str, Any]:\n    \"\"\"Return JSON representation of the fixture with the info field.\"\"\"\n    dict_with_info = self.json_dict.copy()\n    dict_with_info[\"_info\"] = {\"hash\": self.hash}\n    if not hash_only:\n        dict_with_info[\"_info\"].update(self.info)\n    return dict_with_info\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.BaseFixture.fill_info","title":"<code>fill_info(t8n_version, test_case_description, fixture_source_url, ref_spec, _info_metadata)</code>","text":"<p>Fill the info field for this fixture.</p> Source code in <code>src/ethereum_test_fixtures/base.py</code> <pre><code>def fill_info(\n    self,\n    t8n_version: str,\n    test_case_description: str,\n    fixture_source_url: str,\n    ref_spec: ReferenceSpec | None,\n    _info_metadata: Dict[str, Any],\n):\n    \"\"\"Fill the info field for this fixture.\"\"\"\n    if \"comment\" not in self.info:\n        self.info[\"comment\"] = \"`execution-spec-tests` generated test\"\n    self.info[\"filling-transition-tool\"] = t8n_version\n    self.info[\"description\"] = test_case_description\n    self.info[\"url\"] = fixture_source_url\n    self.info[\"fixture-format\"] = self.format_name\n    if ref_spec is not None:\n        ref_spec.write_info(self.info)\n    if _info_metadata:\n        self.info.update(_info_metadata)\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.BaseFixture.get_fork","title":"<code>get_fork()</code>","text":"<p>Return fork of the fixture as a string.</p> Source code in <code>src/ethereum_test_fixtures/base.py</code> <pre><code>def get_fork(self) -&gt; str | None:\n    \"\"\"Return fork of the fixture as a string.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.BaseFixture.supports_fork","title":"<code>supports_fork(fork)</code>  <code>classmethod</code>","text":"<p>Return whether the fixture can be generated for the given fork.</p> <p>By default, all fixtures support all forks.</p> Source code in <code>src/ethereum_test_fixtures/base.py</code> <pre><code>@classmethod\ndef supports_fork(cls, fork: Fork) -&gt; bool:\n    \"\"\"\n    Return whether the fixture can be generated for the given fork.\n\n    By default, all fixtures support all forks.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.LabeledFixtureFormat","title":"<code>LabeledFixtureFormat</code>","text":"<p>Represents a fixture format with a custom label.</p> <p>This label will be used in the test id and also will be added as a marker to the generated test case when filling the test.</p> Source code in <code>src/ethereum_test_fixtures/base.py</code> <pre><code>class LabeledFixtureFormat:\n    \"\"\"\n    Represents a fixture format with a custom label.\n\n    This label will be used in the test id and also will be added as a marker to the\n    generated test case when filling the test.\n    \"\"\"\n\n    format: Type[BaseFixture]\n    label: str\n    description: str\n\n    registered_labels: ClassVar[Dict[str, \"LabeledFixtureFormat\"]] = {}\n\n    def __init__(\n        self,\n        fixture_format: \"Type[BaseFixture] | LabeledFixtureFormat\",\n        label: str,\n        description: str,\n    ):\n        \"\"\"Initialize the fixture format with a custom label.\"\"\"\n        self.format = (\n            fixture_format.format\n            if isinstance(fixture_format, LabeledFixtureFormat)\n            else fixture_format\n        )\n        self.label = label\n        self.description = description\n        if label not in LabeledFixtureFormat.registered_labels:\n            LabeledFixtureFormat.registered_labels[label] = self\n\n    @property\n    def format_name(self) -&gt; str:\n        \"\"\"Get the execute format name.\"\"\"\n        return self.format.format_name\n\n    def __eq__(self, other: Any) -&gt; bool:\n        \"\"\"\n        Check if two labeled fixture formats are equal.\n\n        If the other object is a FixtureFormat type, the format of the labeled fixture\n        format will be compared with the format of the other object.\n        \"\"\"\n        if isinstance(other, LabeledFixtureFormat):\n            return self.format == other.format\n        if isinstance(other, type) and issubclass(other, BaseFixture):\n            return self.format == other\n        return False\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.LabeledFixtureFormat.__init__","title":"<code>__init__(fixture_format, label, description)</code>","text":"<p>Initialize the fixture format with a custom label.</p> Source code in <code>src/ethereum_test_fixtures/base.py</code> <pre><code>def __init__(\n    self,\n    fixture_format: \"Type[BaseFixture] | LabeledFixtureFormat\",\n    label: str,\n    description: str,\n):\n    \"\"\"Initialize the fixture format with a custom label.\"\"\"\n    self.format = (\n        fixture_format.format\n        if isinstance(fixture_format, LabeledFixtureFormat)\n        else fixture_format\n    )\n    self.label = label\n    self.description = description\n    if label not in LabeledFixtureFormat.registered_labels:\n        LabeledFixtureFormat.registered_labels[label] = self\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.LabeledFixtureFormat.format_name","title":"<code>format_name: str</code>  <code>property</code>","text":"<p>Get the execute format name.</p>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.LabeledFixtureFormat.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check if two labeled fixture formats are equal.</p> <p>If the other object is a FixtureFormat type, the format of the labeled fixture format will be compared with the format of the other object.</p> Source code in <code>src/ethereum_test_fixtures/base.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    \"\"\"\n    Check if two labeled fixture formats are equal.\n\n    If the other object is a FixtureFormat type, the format of the labeled fixture\n    format will be compared with the format of the other object.\n    \"\"\"\n    if isinstance(other, LabeledFixtureFormat):\n        return self.format == other.format\n    if isinstance(other, type) and issubclass(other, BaseFixture):\n        return self.format == other\n    return False\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.BlockchainEngineFixture","title":"<code>BlockchainEngineFixture</code>","text":"<p>               Bases: <code>BlockchainFixtureCommon</code></p> <p>Engine specific test fixture information.</p> Source code in <code>src/ethereum_test_fixtures/blockchain.py</code> <pre><code>class BlockchainEngineFixture(BlockchainFixtureCommon):\n    \"\"\"Engine specific test fixture information.\"\"\"\n\n    format_name: ClassVar[str] = \"blockchain_test_engine\"\n    description: ClassVar[str] = (\n        \"Tests that generate a blockchain test fixture in Engine API format.\"\n    )\n\n    payloads: List[FixtureEngineNewPayload] = Field(..., alias=\"engineNewPayloads\")\n    sync_payload: FixtureEngineNewPayload | None = None\n\n    @classmethod\n    def supports_fork(cls, fork: Fork) -&gt; bool:\n        \"\"\"\n        Return whether the fixture can be generated for the given fork.\n\n        The Engine API is available only on Paris and afterwards.\n        \"\"\"\n        return fork &gt;= Paris\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.BlockchainEngineFixture.supports_fork","title":"<code>supports_fork(fork)</code>  <code>classmethod</code>","text":"<p>Return whether the fixture can be generated for the given fork.</p> <p>The Engine API is available only on Paris and afterwards.</p> Source code in <code>src/ethereum_test_fixtures/blockchain.py</code> <pre><code>@classmethod\ndef supports_fork(cls, fork: Fork) -&gt; bool:\n    \"\"\"\n    Return whether the fixture can be generated for the given fork.\n\n    The Engine API is available only on Paris and afterwards.\n    \"\"\"\n    return fork &gt;= Paris\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.BlockchainFixture","title":"<code>BlockchainFixture</code>","text":"<p>               Bases: <code>BlockchainFixtureCommon</code></p> <p>Cross-client specific blockchain test model use in JSON fixtures.</p> Source code in <code>src/ethereum_test_fixtures/blockchain.py</code> <pre><code>class BlockchainFixture(BlockchainFixtureCommon):\n    \"\"\"Cross-client specific blockchain test model use in JSON fixtures.\"\"\"\n\n    format_name: ClassVar[str] = \"blockchain_test\"\n    description: ClassVar[str] = \"Tests that generate a blockchain test fixture.\"\n\n    genesis_rlp: Bytes = Field(..., alias=\"genesisRLP\")\n    blocks: List[FixtureBlock | InvalidFixtureBlock]\n    seal_engine: Literal[\"NoProof\"] = Field(\"NoProof\")\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.BlockchainFixtureCommon","title":"<code>BlockchainFixtureCommon</code>","text":"<p>               Bases: <code>BaseFixture</code></p> <p>Base blockchain test fixture model.</p> Source code in <code>src/ethereum_test_fixtures/blockchain.py</code> <pre><code>class BlockchainFixtureCommon(BaseFixture):\n    \"\"\"Base blockchain test fixture model.\"\"\"\n\n    fork: str = Field(..., alias=\"network\")\n    genesis: FixtureHeader = Field(..., alias=\"genesisBlockHeader\")\n    pre: Alloc\n    post_state: Alloc | None = Field(None)\n    last_block_hash: Hash = Field(..., alias=\"lastblockhash\")  # FIXME: lastBlockHash\n    config: FixtureConfig\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def config_defaults_for_backwards_compatibility(cls, data: Any) -&gt; Any:\n        \"\"\"\n        Check if the config field is populated, otherwise use the root-level field values for\n        backwards compatibility.\n        \"\"\"\n        if isinstance(data, dict):\n            if \"config\" not in data:\n                data[\"config\"] = {}\n            if isinstance(data[\"config\"], dict):\n                if \"network\" not in data[\"config\"]:\n                    data[\"config\"][\"network\"] = data[\"network\"]\n                if \"chainid\" not in data[\"config\"]:\n                    data[\"config\"][\"chainid\"] = \"0x01\"\n        return data\n\n    def get_fork(self) -&gt; str | None:\n        \"\"\"Return fork of the fixture as a string.\"\"\"\n        return self.fork\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.BlockchainFixtureCommon.config_defaults_for_backwards_compatibility","title":"<code>config_defaults_for_backwards_compatibility(data)</code>  <code>classmethod</code>","text":"<p>Check if the config field is populated, otherwise use the root-level field values for backwards compatibility.</p> Source code in <code>src/ethereum_test_fixtures/blockchain.py</code> <pre><code>@model_validator(mode=\"before\")\n@classmethod\ndef config_defaults_for_backwards_compatibility(cls, data: Any) -&gt; Any:\n    \"\"\"\n    Check if the config field is populated, otherwise use the root-level field values for\n    backwards compatibility.\n    \"\"\"\n    if isinstance(data, dict):\n        if \"config\" not in data:\n            data[\"config\"] = {}\n        if isinstance(data[\"config\"], dict):\n            if \"network\" not in data[\"config\"]:\n                data[\"config\"][\"network\"] = data[\"network\"]\n            if \"chainid\" not in data[\"config\"]:\n                data[\"config\"][\"chainid\"] = \"0x01\"\n    return data\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.BlockchainFixtureCommon.get_fork","title":"<code>get_fork()</code>","text":"<p>Return fork of the fixture as a string.</p> Source code in <code>src/ethereum_test_fixtures/blockchain.py</code> <pre><code>def get_fork(self) -&gt; str | None:\n    \"\"\"Return fork of the fixture as a string.\"\"\"\n    return self.fork\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.FixtureCollector","title":"<code>FixtureCollector</code>  <code>dataclass</code>","text":"<p>Collects all fixtures generated by the test cases.</p> Source code in <code>src/ethereum_test_fixtures/collector.py</code> <pre><code>@dataclass(kw_only=True)\nclass FixtureCollector:\n    \"\"\"Collects all fixtures generated by the test cases.\"\"\"\n\n    output_dir: Path\n    flat_output: bool\n    single_fixture_per_file: bool\n    filler_path: Path\n    base_dump_dir: Optional[Path] = None\n\n    # Internal state\n    all_fixtures: Dict[Path, Fixtures] = field(default_factory=dict)\n    json_path_to_test_item: Dict[Path, TestInfo] = field(default_factory=dict)\n\n    def get_fixture_basename(self, info: TestInfo) -&gt; Path:\n        \"\"\"Return basename of the fixture file for a given test case.\"\"\"\n        if self.flat_output:\n            if self.single_fixture_per_file:\n                return Path(strip_test_prefix(info.get_single_test_name()))\n            return Path(strip_test_prefix(info.original_name))\n        else:\n            relative_fixture_output_dir = Path(info.path).parent / strip_test_prefix(\n                Path(info.path).stem\n            )\n            module_relative_output_dir = get_module_relative_output_dir(\n                relative_fixture_output_dir, self.filler_path\n            )\n\n            if self.single_fixture_per_file:\n                return module_relative_output_dir / strip_test_prefix(info.get_single_test_name())\n            return module_relative_output_dir / strip_test_prefix(info.original_name)\n\n    def add_fixture(self, info: TestInfo, fixture: BaseFixture) -&gt; Path:\n        \"\"\"Add fixture to the list of fixtures of a given test case.\"\"\"\n        fixture_basename = self.get_fixture_basename(info)\n\n        fixture_path = (\n            self.output_dir\n            / fixture.output_base_dir_name()\n            / fixture_basename.with_suffix(fixture.output_file_extension)\n        )\n        if fixture_path not in self.all_fixtures.keys():  # relevant when we group by test function\n            self.all_fixtures[fixture_path] = Fixtures(root={})\n            self.json_path_to_test_item[fixture_path] = info\n\n        self.all_fixtures[fixture_path][info.id] = fixture\n\n        return fixture_path\n\n    def dump_fixtures(self) -&gt; None:\n        \"\"\"Dump all collected fixtures to their respective files.\"\"\"\n        if self.output_dir.name == \"stdout\":\n            combined_fixtures = {\n                k: to_json(v) for fixture in self.all_fixtures.values() for k, v in fixture.items()\n            }\n            json.dump(combined_fixtures, sys.stdout, indent=4)\n            return\n        os.makedirs(self.output_dir, exist_ok=True)\n        for fixture_path, fixtures in self.all_fixtures.items():\n            os.makedirs(fixture_path.parent, exist_ok=True)\n            if len({fixture.__class__ for fixture in fixtures.values()}) != 1:\n                raise TypeError(\"All fixtures in a single file must have the same format.\")\n            fixtures.collect_into_file(fixture_path)\n\n    def verify_fixture_files(self, evm_fixture_verification: FixtureConsumer) -&gt; None:\n        \"\"\"Run `evm [state|block]test` on each fixture.\"\"\"\n        for fixture_path, name_fixture_dict in self.all_fixtures.items():\n            for _fixture_name, fixture in name_fixture_dict.items():\n                if evm_fixture_verification.can_consume(fixture.__class__):\n                    info = self.json_path_to_test_item[fixture_path]\n                    consume_direct_dump_dir = self._get_consume_direct_dump_dir(info)\n                    evm_fixture_verification.consume_fixture(\n                        fixture.__class__,\n                        fixture_path,\n                        fixture_name=None,\n                        debug_output_path=consume_direct_dump_dir,\n                    )\n\n    def _get_consume_direct_dump_dir(\n        self,\n        info: TestInfo,\n    ):\n        \"\"\"\n        Directory to dump the current test function's fixture.json and fixture\n        verification debug output.\n        \"\"\"\n        if not self.base_dump_dir:\n            return None\n        if self.single_fixture_per_file:\n            return info.get_dump_dir_path(\n                self.base_dump_dir, self.filler_path, level=\"test_parameter\"\n            )\n        else:\n            return info.get_dump_dir_path(\n                self.base_dump_dir, self.filler_path, level=\"test_function\"\n            )\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.FixtureCollector.get_fixture_basename","title":"<code>get_fixture_basename(info)</code>","text":"<p>Return basename of the fixture file for a given test case.</p> Source code in <code>src/ethereum_test_fixtures/collector.py</code> <pre><code>def get_fixture_basename(self, info: TestInfo) -&gt; Path:\n    \"\"\"Return basename of the fixture file for a given test case.\"\"\"\n    if self.flat_output:\n        if self.single_fixture_per_file:\n            return Path(strip_test_prefix(info.get_single_test_name()))\n        return Path(strip_test_prefix(info.original_name))\n    else:\n        relative_fixture_output_dir = Path(info.path).parent / strip_test_prefix(\n            Path(info.path).stem\n        )\n        module_relative_output_dir = get_module_relative_output_dir(\n            relative_fixture_output_dir, self.filler_path\n        )\n\n        if self.single_fixture_per_file:\n            return module_relative_output_dir / strip_test_prefix(info.get_single_test_name())\n        return module_relative_output_dir / strip_test_prefix(info.original_name)\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.FixtureCollector.add_fixture","title":"<code>add_fixture(info, fixture)</code>","text":"<p>Add fixture to the list of fixtures of a given test case.</p> Source code in <code>src/ethereum_test_fixtures/collector.py</code> <pre><code>def add_fixture(self, info: TestInfo, fixture: BaseFixture) -&gt; Path:\n    \"\"\"Add fixture to the list of fixtures of a given test case.\"\"\"\n    fixture_basename = self.get_fixture_basename(info)\n\n    fixture_path = (\n        self.output_dir\n        / fixture.output_base_dir_name()\n        / fixture_basename.with_suffix(fixture.output_file_extension)\n    )\n    if fixture_path not in self.all_fixtures.keys():  # relevant when we group by test function\n        self.all_fixtures[fixture_path] = Fixtures(root={})\n        self.json_path_to_test_item[fixture_path] = info\n\n    self.all_fixtures[fixture_path][info.id] = fixture\n\n    return fixture_path\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.FixtureCollector.dump_fixtures","title":"<code>dump_fixtures()</code>","text":"<p>Dump all collected fixtures to their respective files.</p> Source code in <code>src/ethereum_test_fixtures/collector.py</code> <pre><code>def dump_fixtures(self) -&gt; None:\n    \"\"\"Dump all collected fixtures to their respective files.\"\"\"\n    if self.output_dir.name == \"stdout\":\n        combined_fixtures = {\n            k: to_json(v) for fixture in self.all_fixtures.values() for k, v in fixture.items()\n        }\n        json.dump(combined_fixtures, sys.stdout, indent=4)\n        return\n    os.makedirs(self.output_dir, exist_ok=True)\n    for fixture_path, fixtures in self.all_fixtures.items():\n        os.makedirs(fixture_path.parent, exist_ok=True)\n        if len({fixture.__class__ for fixture in fixtures.values()}) != 1:\n            raise TypeError(\"All fixtures in a single file must have the same format.\")\n        fixtures.collect_into_file(fixture_path)\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.FixtureCollector.verify_fixture_files","title":"<code>verify_fixture_files(evm_fixture_verification)</code>","text":"<p>Run <code>evm [state|block]test</code> on each fixture.</p> Source code in <code>src/ethereum_test_fixtures/collector.py</code> <pre><code>def verify_fixture_files(self, evm_fixture_verification: FixtureConsumer) -&gt; None:\n    \"\"\"Run `evm [state|block]test` on each fixture.\"\"\"\n    for fixture_path, name_fixture_dict in self.all_fixtures.items():\n        for _fixture_name, fixture in name_fixture_dict.items():\n            if evm_fixture_verification.can_consume(fixture.__class__):\n                info = self.json_path_to_test_item[fixture_path]\n                consume_direct_dump_dir = self._get_consume_direct_dump_dir(info)\n                evm_fixture_verification.consume_fixture(\n                    fixture.__class__,\n                    fixture_path,\n                    fixture_name=None,\n                    debug_output_path=consume_direct_dump_dir,\n                )\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.TestInfo","title":"<code>TestInfo</code>  <code>dataclass</code>","text":"<p>Contains test information from the current node.</p> Source code in <code>src/ethereum_test_fixtures/collector.py</code> <pre><code>@dataclass(kw_only=True)\nclass TestInfo:\n    \"\"\"Contains test information from the current node.\"\"\"\n\n    name: str  # pytest: Item.name\n    id: str  # pytest: Item.nodeid\n    original_name: str  # pytest: Item.originalname\n    path: Path  # pytest: Item.path\n\n    def get_name_and_parameters(self) -&gt; Tuple[str, str]:\n        \"\"\"\n        Convert test name to a tuple containing the test name and test parameters.\n\n        Example:\n        test_push0_key_sstore[fork_Shanghai] -&gt; test_push0_key_sstore, fork_Shanghai\n\n        \"\"\"\n        test_name, parameters = self.name.split(\"[\")\n        return test_name, re.sub(r\"[\\[\\-]\", \"_\", parameters).replace(\"]\", \"\")\n\n    def get_single_test_name(self) -&gt; str:\n        \"\"\"Convert test name to a single test name.\"\"\"\n        test_name, test_parameters = self.get_name_and_parameters()\n        return f\"{test_name}__{test_parameters}\"\n\n    def get_dump_dir_path(\n        self,\n        base_dump_dir: Optional[Path],\n        filler_path: Path,\n        level: Literal[\"test_module\", \"test_function\", \"test_parameter\"] = \"test_parameter\",\n    ) -&gt; Optional[Path]:\n        \"\"\"Path to dump the debug output as defined by the level to dump at.\"\"\"\n        if not base_dump_dir:\n            return None\n        test_module_relative_dir = get_module_relative_output_dir(self.path, filler_path)\n        if level == \"test_module\":\n            return Path(base_dump_dir) / Path(str(test_module_relative_dir).replace(os.sep, \"__\"))\n        test_name, test_parameter_string = self.get_name_and_parameters()\n        flat_path = f\"{str(test_module_relative_dir).replace(os.sep, '__')}__{test_name}\"\n        if level == \"test_function\":\n            return Path(base_dump_dir) / flat_path\n        elif level == \"test_parameter\":\n            return Path(base_dump_dir) / flat_path / test_parameter_string\n        raise Exception(\"Unexpected level.\")\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.TestInfo.get_name_and_parameters","title":"<code>get_name_and_parameters()</code>","text":"<p>Convert test name to a tuple containing the test name and test parameters.</p> <p>Example: test_push0_key_sstore[fork_Shanghai] -&gt; test_push0_key_sstore, fork_Shanghai</p> Source code in <code>src/ethereum_test_fixtures/collector.py</code> <pre><code>def get_name_and_parameters(self) -&gt; Tuple[str, str]:\n    \"\"\"\n    Convert test name to a tuple containing the test name and test parameters.\n\n    Example:\n    test_push0_key_sstore[fork_Shanghai] -&gt; test_push0_key_sstore, fork_Shanghai\n\n    \"\"\"\n    test_name, parameters = self.name.split(\"[\")\n    return test_name, re.sub(r\"[\\[\\-]\", \"_\", parameters).replace(\"]\", \"\")\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.TestInfo.get_single_test_name","title":"<code>get_single_test_name()</code>","text":"<p>Convert test name to a single test name.</p> Source code in <code>src/ethereum_test_fixtures/collector.py</code> <pre><code>def get_single_test_name(self) -&gt; str:\n    \"\"\"Convert test name to a single test name.\"\"\"\n    test_name, test_parameters = self.get_name_and_parameters()\n    return f\"{test_name}__{test_parameters}\"\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.TestInfo.get_dump_dir_path","title":"<code>get_dump_dir_path(base_dump_dir, filler_path, level='test_parameter')</code>","text":"<p>Path to dump the debug output as defined by the level to dump at.</p> Source code in <code>src/ethereum_test_fixtures/collector.py</code> <pre><code>def get_dump_dir_path(\n    self,\n    base_dump_dir: Optional[Path],\n    filler_path: Path,\n    level: Literal[\"test_module\", \"test_function\", \"test_parameter\"] = \"test_parameter\",\n) -&gt; Optional[Path]:\n    \"\"\"Path to dump the debug output as defined by the level to dump at.\"\"\"\n    if not base_dump_dir:\n        return None\n    test_module_relative_dir = get_module_relative_output_dir(self.path, filler_path)\n    if level == \"test_module\":\n        return Path(base_dump_dir) / Path(str(test_module_relative_dir).replace(os.sep, \"__\"))\n    test_name, test_parameter_string = self.get_name_and_parameters()\n    flat_path = f\"{str(test_module_relative_dir).replace(os.sep, '__')}__{test_name}\"\n    if level == \"test_function\":\n        return Path(base_dump_dir) / flat_path\n    elif level == \"test_parameter\":\n        return Path(base_dump_dir) / flat_path / test_parameter_string\n    raise Exception(\"Unexpected level.\")\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.FixtureConsumer","title":"<code>FixtureConsumer</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class for verifying Ethereum test fixtures.</p> Source code in <code>src/ethereum_test_fixtures/consume.py</code> <pre><code>class FixtureConsumer(ABC):\n    \"\"\"Abstract class for verifying Ethereum test fixtures.\"\"\"\n\n    fixture_formats: List[FixtureFormat]\n\n    def can_consume(\n        self,\n        fixture_format: FixtureFormat,\n    ) -&gt; bool:\n        \"\"\"Return whether the fixture format is consumable by this consumer.\"\"\"\n        return fixture_format in self.fixture_formats\n\n    @abstractmethod\n    def consume_fixture(\n        self,\n        fixture_format: FixtureFormat,\n        fixture_path: Path,\n        fixture_name: str | None = None,\n        debug_output_path: Path | None = None,\n    ):\n        \"\"\"Test the client with the specified fixture using its direct consumer interface.\"\"\"\n        raise NotImplementedError(\n            \"The `consume_fixture()` function is not supported by this tool.\"\n        )\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.FixtureConsumer.can_consume","title":"<code>can_consume(fixture_format)</code>","text":"<p>Return whether the fixture format is consumable by this consumer.</p> Source code in <code>src/ethereum_test_fixtures/consume.py</code> <pre><code>def can_consume(\n    self,\n    fixture_format: FixtureFormat,\n) -&gt; bool:\n    \"\"\"Return whether the fixture format is consumable by this consumer.\"\"\"\n    return fixture_format in self.fixture_formats\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.FixtureConsumer.consume_fixture","title":"<code>consume_fixture(fixture_format, fixture_path, fixture_name=None, debug_output_path=None)</code>  <code>abstractmethod</code>","text":"<p>Test the client with the specified fixture using its direct consumer interface.</p> Source code in <code>src/ethereum_test_fixtures/consume.py</code> <pre><code>@abstractmethod\ndef consume_fixture(\n    self,\n    fixture_format: FixtureFormat,\n    fixture_path: Path,\n    fixture_name: str | None = None,\n    debug_output_path: Path | None = None,\n):\n    \"\"\"Test the client with the specified fixture using its direct consumer interface.\"\"\"\n    raise NotImplementedError(\n        \"The `consume_fixture()` function is not supported by this tool.\"\n    )\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.EOFFixture","title":"<code>EOFFixture</code>","text":"<p>               Bases: <code>BaseFixture</code></p> <p>Fixture for a single EOFTest.</p> Source code in <code>src/ethereum_test_fixtures/eof.py</code> <pre><code>class EOFFixture(BaseFixture):\n    \"\"\"Fixture for a single EOFTest.\"\"\"\n\n    format_name: ClassVar[str] = \"eof_test\"\n    description: ClassVar[str] = \"Tests that generate an EOF test fixture.\"\n\n    vectors: Mapping[Number, Vector]\n\n    def get_fork(self) -&gt; str | None:\n        \"\"\"Return fork of the fixture as a string.\"\"\"\n        return None\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.EOFFixture.get_fork","title":"<code>get_fork()</code>","text":"<p>Return fork of the fixture as a string.</p> Source code in <code>src/ethereum_test_fixtures/eof.py</code> <pre><code>def get_fork(self) -&gt; str | None:\n    \"\"\"Return fork of the fixture as a string.\"\"\"\n    return None\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.StateFixture","title":"<code>StateFixture</code>","text":"<p>               Bases: <code>BaseFixture</code></p> <p>Fixture for a single StateTest.</p> Source code in <code>src/ethereum_test_fixtures/state.py</code> <pre><code>class StateFixture(BaseFixture):\n    \"\"\"Fixture for a single StateTest.\"\"\"\n\n    format_name: ClassVar[str] = \"state_test\"\n    description: ClassVar[str] = \"Tests that generate a state test fixture.\"\n\n    env: FixtureEnvironment\n    pre: Alloc\n    transaction: FixtureTransaction\n    post: Mapping[str, List[FixtureForkPost]]\n    config: FixtureConfig\n\n    def get_fork(self) -&gt; str | None:\n        \"\"\"Return fork of the fixture as a string.\"\"\"\n        forks = list(self.post.keys())\n        assert len(forks) == 1, \"Expected state test fixture with single fork\"\n        return forks[0]\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.StateFixture.get_fork","title":"<code>get_fork()</code>","text":"<p>Return fork of the fixture as a string.</p> Source code in <code>src/ethereum_test_fixtures/state.py</code> <pre><code>def get_fork(self) -&gt; str | None:\n    \"\"\"Return fork of the fixture as a string.\"\"\"\n    forks = list(self.post.keys())\n    assert len(forks) == 1, \"Expected state test fixture with single fork\"\n    return forks[0]\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.TransactionFixture","title":"<code>TransactionFixture</code>","text":"<p>               Bases: <code>BaseFixture</code></p> <p>Fixture for a single TransactionTest.</p> Source code in <code>src/ethereum_test_fixtures/transaction.py</code> <pre><code>class TransactionFixture(BaseFixture):\n    \"\"\"Fixture for a single TransactionTest.\"\"\"\n\n    format_name: ClassVar[str] = \"transaction_test\"\n    description: ClassVar[str] = \"Tests that generate a transaction test fixture.\"\n\n    result: Mapping[str, FixtureResult]\n    transaction: Bytes = Field(..., alias=\"txbytes\")\n\n    def get_fork(self) -&gt; str | None:\n        \"\"\"Return the fork of the fixture as a string.\"\"\"\n        forks = list(self.result.keys())\n        assert len(forks) == 1, \"Expected transaction test fixture with single fork\"\n        return forks[0]\n</code></pre>"},{"location":"library/ethereum_test_fixtures/#ethereum_test_fixtures.TransactionFixture.get_fork","title":"<code>get_fork()</code>","text":"<p>Return the fork of the fixture as a string.</p> Source code in <code>src/ethereum_test_fixtures/transaction.py</code> <pre><code>def get_fork(self) -&gt; str | None:\n    \"\"\"Return the fork of the fixture as a string.\"\"\"\n    forks = list(self.result.keys())\n    assert len(forks) == 1, \"Expected transaction test fixture with single fork\"\n    return forks[0]\n</code></pre>"},{"location":"library/ethereum_test_forks/","title":"Ethereum Test Forks package","text":"<p>Ethereum test fork definitions.</p>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.ForkAttribute","title":"<code>ForkAttribute</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>A protocol to get the attribute of a fork at a given block number and timestamp.</p> Source code in <code>src/ethereum_test_forks/base_fork.py</code> <pre><code>class ForkAttribute(Protocol):\n    \"\"\"A protocol to get the attribute of a fork at a given block number and timestamp.\"\"\"\n\n    def __call__(self, block_number: int = 0, timestamp: int = 0) -&gt; Any:\n        \"\"\"Return value of the attribute at the given block number and timestamp.\"\"\"\n        pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.ForkAttribute.__call__","title":"<code>__call__(block_number=0, timestamp=0)</code>","text":"<p>Return value of the attribute at the given block number and timestamp.</p> Source code in <code>src/ethereum_test_forks/base_fork.py</code> <pre><code>def __call__(self, block_number: int = 0, timestamp: int = 0) -&gt; Any:\n    \"\"\"Return value of the attribute at the given block number and timestamp.\"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.ArrowGlacier","title":"<code>ArrowGlacier</code>","text":"<p>               Bases: <code>London</code></p> <p>Arrow Glacier fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class ArrowGlacier(London, solc_name=\"london\", ignore=True):\n    \"\"\"Arrow Glacier fork.\"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Berlin","title":"<code>Berlin</code>","text":"<p>               Bases: <code>Istanbul</code></p> <p>Berlin fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Berlin(Istanbul):\n    \"\"\"Berlin fork.\"\"\"\n\n    @classmethod\n    def tx_types(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[int]:\n        \"\"\"At Berlin, access list transactions are introduced.\"\"\"\n        return [1] + super(Berlin, cls).tx_types(block_number, timestamp)\n\n    @classmethod\n    def contract_creating_tx_types(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[int]:\n        \"\"\"At Berlin, access list transactions are introduced.\"\"\"\n        return [1] + super(Berlin, cls).contract_creating_tx_types(block_number, timestamp)\n\n    @classmethod\n    def transaction_intrinsic_cost_calculator(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; TransactionIntrinsicCostCalculator:\n        \"\"\"At Berlin, the transaction intrinsic cost needs to take the access list into account.\"\"\"\n        super_fn = super(Berlin, cls).transaction_intrinsic_cost_calculator(\n            block_number, timestamp\n        )\n        gas_costs = cls.gas_costs(block_number, timestamp)\n\n        def fn(\n            *,\n            calldata: BytesConvertible = b\"\",\n            contract_creation: bool = False,\n            access_list: List[AccessList] | None = None,\n            authorization_list_or_count: Sized | int | None = None,\n            return_cost_deducted_prior_execution: bool = False,\n        ) -&gt; int:\n            intrinsic_cost: int = super_fn(\n                calldata=calldata,\n                contract_creation=contract_creation,\n                authorization_list_or_count=authorization_list_or_count,\n            )\n            if access_list is not None:\n                for access in access_list:\n                    intrinsic_cost += gas_costs.G_ACCESS_LIST_ADDRESS\n                    for _ in access.storage_keys:\n                        intrinsic_cost += gas_costs.G_ACCESS_LIST_STORAGE\n            return intrinsic_cost\n\n        return fn\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Berlin.tx_types","title":"<code>tx_types(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Berlin, access list transactions are introduced.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef tx_types(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[int]:\n    \"\"\"At Berlin, access list transactions are introduced.\"\"\"\n    return [1] + super(Berlin, cls).tx_types(block_number, timestamp)\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Berlin.contract_creating_tx_types","title":"<code>contract_creating_tx_types(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Berlin, access list transactions are introduced.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef contract_creating_tx_types(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[int]:\n    \"\"\"At Berlin, access list transactions are introduced.\"\"\"\n    return [1] + super(Berlin, cls).contract_creating_tx_types(block_number, timestamp)\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Berlin.transaction_intrinsic_cost_calculator","title":"<code>transaction_intrinsic_cost_calculator(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Berlin, the transaction intrinsic cost needs to take the access list into account.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef transaction_intrinsic_cost_calculator(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; TransactionIntrinsicCostCalculator:\n    \"\"\"At Berlin, the transaction intrinsic cost needs to take the access list into account.\"\"\"\n    super_fn = super(Berlin, cls).transaction_intrinsic_cost_calculator(\n        block_number, timestamp\n    )\n    gas_costs = cls.gas_costs(block_number, timestamp)\n\n    def fn(\n        *,\n        calldata: BytesConvertible = b\"\",\n        contract_creation: bool = False,\n        access_list: List[AccessList] | None = None,\n        authorization_list_or_count: Sized | int | None = None,\n        return_cost_deducted_prior_execution: bool = False,\n    ) -&gt; int:\n        intrinsic_cost: int = super_fn(\n            calldata=calldata,\n            contract_creation=contract_creation,\n            authorization_list_or_count=authorization_list_or_count,\n        )\n        if access_list is not None:\n            for access in access_list:\n                intrinsic_cost += gas_costs.G_ACCESS_LIST_ADDRESS\n                for _ in access.storage_keys:\n                    intrinsic_cost += gas_costs.G_ACCESS_LIST_STORAGE\n        return intrinsic_cost\n\n    return fn\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Byzantium","title":"<code>Byzantium</code>","text":"<p>               Bases: <code>Homestead</code></p> <p>Byzantium fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Byzantium(Homestead):\n    \"\"\"Byzantium fork.\"\"\"\n\n    @classmethod\n    def get_reward(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n        \"\"\"\n        At Byzantium, the block reward is reduced to\n        3_000_000_000_000_000_000 wei.\n        \"\"\"\n        return 3_000_000_000_000_000_000\n\n    @classmethod\n    def precompiles(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[Address]:\n        \"\"\"\n        At Byzantium, pre-compiles for bigint modular exponentiation, addition and scalar\n        multiplication on elliptic curve alt_bn128, and optimal ate pairing check on\n        elliptic curve alt_bn128 are introduced.\n        \"\"\"\n        return [Address(i) for i in range(5, 9)] + super(Byzantium, cls).precompiles(\n            block_number, timestamp\n        )\n\n    @classmethod\n    def call_opcodes(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; List[Tuple[Opcodes, EVMCodeType]]:\n        \"\"\"At Byzantium, STATICCALL opcode was introduced.\"\"\"\n        return [(Opcodes.STATICCALL, EVMCodeType.LEGACY)] + super(Byzantium, cls).call_opcodes(\n            block_number, timestamp\n        )\n\n    @classmethod\n    def valid_opcodes(\n        cls,\n    ) -&gt; List[Opcodes]:\n        \"\"\"Return list of Opcodes that are valid to work on this fork.\"\"\"\n        return [Opcodes.RETURNDATASIZE, Opcodes.STATICCALL] + super(Byzantium, cls).valid_opcodes()\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Byzantium.get_reward","title":"<code>get_reward(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Byzantium, the block reward is reduced to 3_000_000_000_000_000_000 wei.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef get_reward(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n    \"\"\"\n    At Byzantium, the block reward is reduced to\n    3_000_000_000_000_000_000 wei.\n    \"\"\"\n    return 3_000_000_000_000_000_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Byzantium.precompiles","title":"<code>precompiles(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Byzantium, pre-compiles for bigint modular exponentiation, addition and scalar multiplication on elliptic curve alt_bn128, and optimal ate pairing check on elliptic curve alt_bn128 are introduced.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef precompiles(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[Address]:\n    \"\"\"\n    At Byzantium, pre-compiles for bigint modular exponentiation, addition and scalar\n    multiplication on elliptic curve alt_bn128, and optimal ate pairing check on\n    elliptic curve alt_bn128 are introduced.\n    \"\"\"\n    return [Address(i) for i in range(5, 9)] + super(Byzantium, cls).precompiles(\n        block_number, timestamp\n    )\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Byzantium.call_opcodes","title":"<code>call_opcodes(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Byzantium, STATICCALL opcode was introduced.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef call_opcodes(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; List[Tuple[Opcodes, EVMCodeType]]:\n    \"\"\"At Byzantium, STATICCALL opcode was introduced.\"\"\"\n    return [(Opcodes.STATICCALL, EVMCodeType.LEGACY)] + super(Byzantium, cls).call_opcodes(\n        block_number, timestamp\n    )\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Byzantium.valid_opcodes","title":"<code>valid_opcodes()</code>  <code>classmethod</code>","text":"<p>Return list of Opcodes that are valid to work on this fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef valid_opcodes(\n    cls,\n) -&gt; List[Opcodes]:\n    \"\"\"Return list of Opcodes that are valid to work on this fork.\"\"\"\n    return [Opcodes.RETURNDATASIZE, Opcodes.STATICCALL] + super(Byzantium, cls).valid_opcodes()\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun","title":"<code>Cancun</code>","text":"<p>               Bases: <code>Shanghai</code></p> <p>Cancun fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Cancun(Shanghai):\n    \"\"\"Cancun fork.\"\"\"\n\n    @classmethod\n    def solc_min_version(cls) -&gt; Version:\n        \"\"\"Return minimum version of solc that supports this fork.\"\"\"\n        return Version.parse(\"0.8.24\")\n\n    @classmethod\n    def header_excess_blob_gas_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"Excess blob gas is required starting from Cancun.\"\"\"\n        return True\n\n    @classmethod\n    def header_blob_gas_used_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"Blob gas used is required starting from Cancun.\"\"\"\n        return True\n\n    @classmethod\n    def header_beacon_root_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"Parent beacon block root is required starting from Cancun.\"\"\"\n        return True\n\n    @classmethod\n    def blob_gas_price_calculator(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; BlobGasPriceCalculator:\n        \"\"\"Return a callable that calculates the blob gas price at Cancun.\"\"\"\n        min_base_fee_per_blob_gas = cls.min_base_fee_per_blob_gas(block_number, timestamp)\n        blob_base_fee_update_fraction = cls.blob_base_fee_update_fraction(block_number, timestamp)\n\n        def fn(*, excess_blob_gas) -&gt; int:\n            return fake_exponential(\n                min_base_fee_per_blob_gas,\n                excess_blob_gas,\n                blob_base_fee_update_fraction,\n            )\n\n        return fn\n\n    @classmethod\n    def excess_blob_gas_calculator(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; ExcessBlobGasCalculator:\n        \"\"\"Return a callable that calculates the excess blob gas for a block at Cancun.\"\"\"\n        target_blobs_per_block = cls.target_blobs_per_block(block_number, timestamp)\n        blob_gas_per_blob = cls.blob_gas_per_blob(block_number, timestamp)\n        target_blob_gas_per_block = target_blobs_per_block * blob_gas_per_blob\n\n        def fn(\n            *,\n            parent_excess_blob_gas: int | None = None,\n            parent_excess_blobs: int | None = None,\n            parent_blob_gas_used: int | None = None,\n            parent_blob_count: int | None = None,\n        ) -&gt; int:\n            if parent_excess_blob_gas is None:\n                assert parent_excess_blobs is not None, \"Parent excess blobs are required\"\n                parent_excess_blob_gas = parent_excess_blobs * blob_gas_per_blob\n            if parent_blob_gas_used is None:\n                assert parent_blob_count is not None, \"Parent blob count is required\"\n                parent_blob_gas_used = parent_blob_count * blob_gas_per_blob\n            if parent_excess_blob_gas + parent_blob_gas_used &lt; target_blob_gas_per_block:\n                return 0\n            else:\n                return parent_excess_blob_gas + parent_blob_gas_used - target_blob_gas_per_block\n\n        return fn\n\n    @classmethod\n    def min_base_fee_per_blob_gas(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n        \"\"\"Return the minimum base fee per blob gas for Cancun.\"\"\"\n        return 1\n\n    @classmethod\n    def blob_base_fee_update_fraction(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n        \"\"\"Return the blob base fee update fraction for Cancun.\"\"\"\n        return 3338477\n\n    @classmethod\n    def blob_gas_per_blob(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n        \"\"\"Blobs are enabled starting from Cancun.\"\"\"\n        return 2**17\n\n    @classmethod\n    def supports_blobs(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"At Cancun, blobs support is enabled.\"\"\"\n        return True\n\n    @classmethod\n    def target_blobs_per_block(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n        \"\"\"Blobs are enabled starting from Cancun, with a static target of 3 blobs.\"\"\"\n        return 3\n\n    @classmethod\n    def max_blobs_per_block(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n        \"\"\"Blobs are enabled starting from Cancun, with a static max of 6 blobs.\"\"\"\n        return 6\n\n    @classmethod\n    def blob_schedule(cls, block_number: int = 0, timestamp: int = 0) -&gt; BlobSchedule | None:\n        \"\"\"\n        At Cancun, the fork object runs this routine to get the updated blob\n        schedule.\n        \"\"\"\n        parent_fork = cls.parent()\n        assert parent_fork is not None, \"Parent fork must be defined\"\n        blob_schedule = parent_fork.blob_schedule(block_number, timestamp)\n        if blob_schedule is None:\n            last_blob_schedule = None\n            blob_schedule = BlobSchedule()\n        else:\n            last_blob_schedule = blob_schedule.last()\n        current_blob_schedule = ForkBlobSchedule(\n            target_blobs_per_block=cls.target_blobs_per_block(block_number, timestamp),\n            max_blobs_per_block=cls.max_blobs_per_block(block_number, timestamp),\n            base_fee_update_fraction=cls.blob_base_fee_update_fraction(block_number, timestamp),\n        )\n        if last_blob_schedule is None or last_blob_schedule != current_blob_schedule:\n            blob_schedule.append(fork=cls.__name__, schedule=current_blob_schedule)\n        return blob_schedule\n\n    @classmethod\n    def tx_types(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[int]:\n        \"\"\"At Cancun, blob type transactions are introduced.\"\"\"\n        return [3] + super(Cancun, cls).tx_types(block_number, timestamp)\n\n    @classmethod\n    def precompiles(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[Address]:\n        \"\"\"At Cancun, pre-compile for kzg point evaluation is introduced.\"\"\"\n        return [Address(0xA)] + super(Cancun, cls).precompiles(block_number, timestamp)\n\n    @classmethod\n    def system_contracts(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[Address]:\n        \"\"\"Cancun introduces the system contract for EIP-4788.\"\"\"\n        return [Address(0x000F3DF6D732807EF1319FB7B8BB8522D0BEAC02)]\n\n    @classmethod\n    def pre_allocation_blockchain(cls) -&gt; Mapping:\n        \"\"\"\n        Cancun requires pre-allocation of the beacon root contract for EIP-4788 on blockchain\n        type tests.\n        \"\"\"\n        new_allocation = {\n            0x000F3DF6D732807EF1319FB7B8BB8522D0BEAC02: {\n                \"nonce\": 1,\n                \"code\": \"0x3373fffffffffffffffffffffffffffffffffffffffe14604d57602036146024575f5f\"\n                \"fd5b5f35801560495762001fff810690815414603c575f5ffd5b62001fff01545f5260205ff35b5f\"\n                \"5ffd5b62001fff42064281555f359062001fff015500\",\n            }\n        }\n        return new_allocation | super(Cancun, cls).pre_allocation_blockchain()  # type: ignore\n\n    @classmethod\n    def engine_new_payload_version(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; Optional[int]:\n        \"\"\"From Cancun, new payload calls must use version 3.\"\"\"\n        return 3\n\n    @classmethod\n    def engine_new_payload_blob_hashes(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"From Cancun, payloads must have blob hashes.\"\"\"\n        return True\n\n    @classmethod\n    def engine_new_payload_beacon_root(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"From Cancun, payloads must have a parent beacon block root.\"\"\"\n        return True\n\n    @classmethod\n    def valid_opcodes(\n        cls,\n    ) -&gt; List[Opcodes]:\n        \"\"\"Return list of Opcodes that are valid to work on this fork.\"\"\"\n        return [\n            Opcodes.BLOBHASH,\n            Opcodes.BLOBBASEFEE,\n            Opcodes.TLOAD,\n            Opcodes.TSTORE,\n            Opcodes.MCOPY,\n        ] + super(Cancun, cls).valid_opcodes()\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun.solc_min_version","title":"<code>solc_min_version()</code>  <code>classmethod</code>","text":"<p>Return minimum version of solc that supports this fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef solc_min_version(cls) -&gt; Version:\n    \"\"\"Return minimum version of solc that supports this fork.\"\"\"\n    return Version.parse(\"0.8.24\")\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun.header_excess_blob_gas_required","title":"<code>header_excess_blob_gas_required(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Excess blob gas is required starting from Cancun.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_excess_blob_gas_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"Excess blob gas is required starting from Cancun.\"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun.header_blob_gas_used_required","title":"<code>header_blob_gas_used_required(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Blob gas used is required starting from Cancun.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_blob_gas_used_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"Blob gas used is required starting from Cancun.\"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun.header_beacon_root_required","title":"<code>header_beacon_root_required(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Parent beacon block root is required starting from Cancun.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_beacon_root_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"Parent beacon block root is required starting from Cancun.\"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun.blob_gas_price_calculator","title":"<code>blob_gas_price_calculator(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Return a callable that calculates the blob gas price at Cancun.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef blob_gas_price_calculator(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; BlobGasPriceCalculator:\n    \"\"\"Return a callable that calculates the blob gas price at Cancun.\"\"\"\n    min_base_fee_per_blob_gas = cls.min_base_fee_per_blob_gas(block_number, timestamp)\n    blob_base_fee_update_fraction = cls.blob_base_fee_update_fraction(block_number, timestamp)\n\n    def fn(*, excess_blob_gas) -&gt; int:\n        return fake_exponential(\n            min_base_fee_per_blob_gas,\n            excess_blob_gas,\n            blob_base_fee_update_fraction,\n        )\n\n    return fn\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun.excess_blob_gas_calculator","title":"<code>excess_blob_gas_calculator(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Return a callable that calculates the excess blob gas for a block at Cancun.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef excess_blob_gas_calculator(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; ExcessBlobGasCalculator:\n    \"\"\"Return a callable that calculates the excess blob gas for a block at Cancun.\"\"\"\n    target_blobs_per_block = cls.target_blobs_per_block(block_number, timestamp)\n    blob_gas_per_blob = cls.blob_gas_per_blob(block_number, timestamp)\n    target_blob_gas_per_block = target_blobs_per_block * blob_gas_per_blob\n\n    def fn(\n        *,\n        parent_excess_blob_gas: int | None = None,\n        parent_excess_blobs: int | None = None,\n        parent_blob_gas_used: int | None = None,\n        parent_blob_count: int | None = None,\n    ) -&gt; int:\n        if parent_excess_blob_gas is None:\n            assert parent_excess_blobs is not None, \"Parent excess blobs are required\"\n            parent_excess_blob_gas = parent_excess_blobs * blob_gas_per_blob\n        if parent_blob_gas_used is None:\n            assert parent_blob_count is not None, \"Parent blob count is required\"\n            parent_blob_gas_used = parent_blob_count * blob_gas_per_blob\n        if parent_excess_blob_gas + parent_blob_gas_used &lt; target_blob_gas_per_block:\n            return 0\n        else:\n            return parent_excess_blob_gas + parent_blob_gas_used - target_blob_gas_per_block\n\n    return fn\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun.min_base_fee_per_blob_gas","title":"<code>min_base_fee_per_blob_gas(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Return the minimum base fee per blob gas for Cancun.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef min_base_fee_per_blob_gas(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n    \"\"\"Return the minimum base fee per blob gas for Cancun.\"\"\"\n    return 1\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun.blob_base_fee_update_fraction","title":"<code>blob_base_fee_update_fraction(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Return the blob base fee update fraction for Cancun.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef blob_base_fee_update_fraction(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n    \"\"\"Return the blob base fee update fraction for Cancun.\"\"\"\n    return 3338477\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun.blob_gas_per_blob","title":"<code>blob_gas_per_blob(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Blobs are enabled starting from Cancun.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef blob_gas_per_blob(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n    \"\"\"Blobs are enabled starting from Cancun.\"\"\"\n    return 2**17\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun.supports_blobs","title":"<code>supports_blobs(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Cancun, blobs support is enabled.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef supports_blobs(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"At Cancun, blobs support is enabled.\"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun.target_blobs_per_block","title":"<code>target_blobs_per_block(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Blobs are enabled starting from Cancun, with a static target of 3 blobs.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef target_blobs_per_block(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n    \"\"\"Blobs are enabled starting from Cancun, with a static target of 3 blobs.\"\"\"\n    return 3\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun.max_blobs_per_block","title":"<code>max_blobs_per_block(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Blobs are enabled starting from Cancun, with a static max of 6 blobs.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef max_blobs_per_block(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n    \"\"\"Blobs are enabled starting from Cancun, with a static max of 6 blobs.\"\"\"\n    return 6\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun.blob_schedule","title":"<code>blob_schedule(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Cancun, the fork object runs this routine to get the updated blob schedule.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef blob_schedule(cls, block_number: int = 0, timestamp: int = 0) -&gt; BlobSchedule | None:\n    \"\"\"\n    At Cancun, the fork object runs this routine to get the updated blob\n    schedule.\n    \"\"\"\n    parent_fork = cls.parent()\n    assert parent_fork is not None, \"Parent fork must be defined\"\n    blob_schedule = parent_fork.blob_schedule(block_number, timestamp)\n    if blob_schedule is None:\n        last_blob_schedule = None\n        blob_schedule = BlobSchedule()\n    else:\n        last_blob_schedule = blob_schedule.last()\n    current_blob_schedule = ForkBlobSchedule(\n        target_blobs_per_block=cls.target_blobs_per_block(block_number, timestamp),\n        max_blobs_per_block=cls.max_blobs_per_block(block_number, timestamp),\n        base_fee_update_fraction=cls.blob_base_fee_update_fraction(block_number, timestamp),\n    )\n    if last_blob_schedule is None or last_blob_schedule != current_blob_schedule:\n        blob_schedule.append(fork=cls.__name__, schedule=current_blob_schedule)\n    return blob_schedule\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun.tx_types","title":"<code>tx_types(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Cancun, blob type transactions are introduced.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef tx_types(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[int]:\n    \"\"\"At Cancun, blob type transactions are introduced.\"\"\"\n    return [3] + super(Cancun, cls).tx_types(block_number, timestamp)\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun.precompiles","title":"<code>precompiles(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Cancun, pre-compile for kzg point evaluation is introduced.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef precompiles(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[Address]:\n    \"\"\"At Cancun, pre-compile for kzg point evaluation is introduced.\"\"\"\n    return [Address(0xA)] + super(Cancun, cls).precompiles(block_number, timestamp)\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun.system_contracts","title":"<code>system_contracts(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Cancun introduces the system contract for EIP-4788.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef system_contracts(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[Address]:\n    \"\"\"Cancun introduces the system contract for EIP-4788.\"\"\"\n    return [Address(0x000F3DF6D732807EF1319FB7B8BB8522D0BEAC02)]\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun.pre_allocation_blockchain","title":"<code>pre_allocation_blockchain()</code>  <code>classmethod</code>","text":"<p>Cancun requires pre-allocation of the beacon root contract for EIP-4788 on blockchain type tests.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef pre_allocation_blockchain(cls) -&gt; Mapping:\n    \"\"\"\n    Cancun requires pre-allocation of the beacon root contract for EIP-4788 on blockchain\n    type tests.\n    \"\"\"\n    new_allocation = {\n        0x000F3DF6D732807EF1319FB7B8BB8522D0BEAC02: {\n            \"nonce\": 1,\n            \"code\": \"0x3373fffffffffffffffffffffffffffffffffffffffe14604d57602036146024575f5f\"\n            \"fd5b5f35801560495762001fff810690815414603c575f5ffd5b62001fff01545f5260205ff35b5f\"\n            \"5ffd5b62001fff42064281555f359062001fff015500\",\n        }\n    }\n    return new_allocation | super(Cancun, cls).pre_allocation_blockchain()  # type: ignore\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun.engine_new_payload_version","title":"<code>engine_new_payload_version(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>From Cancun, new payload calls must use version 3.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef engine_new_payload_version(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; Optional[int]:\n    \"\"\"From Cancun, new payload calls must use version 3.\"\"\"\n    return 3\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun.engine_new_payload_blob_hashes","title":"<code>engine_new_payload_blob_hashes(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>From Cancun, payloads must have blob hashes.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef engine_new_payload_blob_hashes(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"From Cancun, payloads must have blob hashes.\"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun.engine_new_payload_beacon_root","title":"<code>engine_new_payload_beacon_root(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>From Cancun, payloads must have a parent beacon block root.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef engine_new_payload_beacon_root(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"From Cancun, payloads must have a parent beacon block root.\"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun.valid_opcodes","title":"<code>valid_opcodes()</code>  <code>classmethod</code>","text":"<p>Return list of Opcodes that are valid to work on this fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef valid_opcodes(\n    cls,\n) -&gt; List[Opcodes]:\n    \"\"\"Return list of Opcodes that are valid to work on this fork.\"\"\"\n    return [\n        Opcodes.BLOBHASH,\n        Opcodes.BLOBBASEFEE,\n        Opcodes.TLOAD,\n        Opcodes.TSTORE,\n        Opcodes.MCOPY,\n    ] + super(Cancun, cls).valid_opcodes()\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Constantinople","title":"<code>Constantinople</code>","text":"<p>               Bases: <code>Byzantium</code></p> <p>Constantinople fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Constantinople(Byzantium):\n    \"\"\"Constantinople fork.\"\"\"\n\n    @classmethod\n    def get_reward(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n        \"\"\"\n        At Constantinople, the block reward is reduced to\n        2_000_000_000_000_000_000 wei.\n        \"\"\"\n        return 2_000_000_000_000_000_000\n\n    @classmethod\n    def create_opcodes(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; List[Tuple[Opcodes, EVMCodeType]]:\n        \"\"\"At Constantinople, `CREATE2` opcode is added.\"\"\"\n        return [(Opcodes.CREATE2, EVMCodeType.LEGACY)] + super(Constantinople, cls).create_opcodes(\n            block_number, timestamp\n        )\n\n    @classmethod\n    def valid_opcodes(\n        cls,\n    ) -&gt; List[Opcodes]:\n        \"\"\"Return list of Opcodes that are valid to work on this fork.\"\"\"\n        return [\n            Opcodes.SHL,\n            Opcodes.SHR,\n            Opcodes.SAR,\n            Opcodes.EXTCODEHASH,\n            Opcodes.CREATE2,\n        ] + super(Constantinople, cls).valid_opcodes()\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Constantinople.get_reward","title":"<code>get_reward(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Constantinople, the block reward is reduced to 2_000_000_000_000_000_000 wei.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef get_reward(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n    \"\"\"\n    At Constantinople, the block reward is reduced to\n    2_000_000_000_000_000_000 wei.\n    \"\"\"\n    return 2_000_000_000_000_000_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Constantinople.create_opcodes","title":"<code>create_opcodes(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Constantinople, <code>CREATE2</code> opcode is added.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef create_opcodes(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; List[Tuple[Opcodes, EVMCodeType]]:\n    \"\"\"At Constantinople, `CREATE2` opcode is added.\"\"\"\n    return [(Opcodes.CREATE2, EVMCodeType.LEGACY)] + super(Constantinople, cls).create_opcodes(\n        block_number, timestamp\n    )\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Constantinople.valid_opcodes","title":"<code>valid_opcodes()</code>  <code>classmethod</code>","text":"<p>Return list of Opcodes that are valid to work on this fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef valid_opcodes(\n    cls,\n) -&gt; List[Opcodes]:\n    \"\"\"Return list of Opcodes that are valid to work on this fork.\"\"\"\n    return [\n        Opcodes.SHL,\n        Opcodes.SHR,\n        Opcodes.SAR,\n        Opcodes.EXTCODEHASH,\n        Opcodes.CREATE2,\n    ] + super(Constantinople, cls).valid_opcodes()\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.ConstantinopleFix","title":"<code>ConstantinopleFix</code>","text":"<p>               Bases: <code>Constantinople</code></p> <p>Constantinople Fix fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class ConstantinopleFix(Constantinople, solc_name=\"constantinople\"):\n    \"\"\"Constantinople Fix fork.\"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier","title":"<code>Frontier</code>","text":"<p>               Bases: <code>BaseFork</code></p> <p>Frontier fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Frontier(BaseFork, solc_name=\"homestead\"):\n    \"\"\"Frontier fork.\"\"\"\n\n    @classmethod\n    def transition_tool_name(cls, block_number: int = 0, timestamp: int = 0) -&gt; str:\n        \"\"\"Return fork name as it's meant to be passed to the transition tool for execution.\"\"\"\n        if cls._transition_tool_name is not None:\n            return cls._transition_tool_name\n        return cls.name()\n\n    @classmethod\n    def solc_name(cls) -&gt; str:\n        \"\"\"Return fork name as it's meant to be passed to the solc compiler.\"\"\"\n        if cls._solc_name is not None:\n            return cls._solc_name\n        return cls.name().lower()\n\n    @classmethod\n    def solc_min_version(cls) -&gt; Version:\n        \"\"\"Return minimum version of solc that supports this fork.\"\"\"\n        return Version.parse(\"0.8.20\")\n\n    @classmethod\n    def header_base_fee_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"At genesis, header must not contain base fee.\"\"\"\n        return False\n\n    @classmethod\n    def header_prev_randao_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"At genesis, header must not contain Prev Randao value.\"\"\"\n        return False\n\n    @classmethod\n    def header_zero_difficulty_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"At genesis, header must not have difficulty zero.\"\"\"\n        return False\n\n    @classmethod\n    def header_withdrawals_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"At genesis, header must not contain withdrawals.\"\"\"\n        return False\n\n    @classmethod\n    def header_excess_blob_gas_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"At genesis, header must not contain excess blob gas.\"\"\"\n        return False\n\n    @classmethod\n    def header_blob_gas_used_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"At genesis, header must not contain blob gas used.\"\"\"\n        return False\n\n    @classmethod\n    def gas_costs(cls, block_number: int = 0, timestamp: int = 0) -&gt; GasCosts:\n        \"\"\"Return dataclass with the defined gas costs constants for genesis.\"\"\"\n        return GasCosts(\n            G_JUMPDEST=1,\n            G_BASE=2,\n            G_VERY_LOW=3,\n            G_LOW=5,\n            G_MID=8,\n            G_HIGH=10,\n            G_WARM_ACCOUNT_ACCESS=100,\n            G_COLD_ACCOUNT_ACCESS=2_600,\n            G_ACCESS_LIST_ADDRESS=2_400,\n            G_ACCESS_LIST_STORAGE=1_900,\n            G_WARM_SLOAD=100,\n            G_COLD_SLOAD=2_100,\n            G_STORAGE_SET=20_000,\n            G_STORAGE_RESET=2_900,\n            R_STORAGE_CLEAR=4_800,\n            G_SELF_DESTRUCT=5_000,\n            G_CREATE=32_000,\n            G_CODE_DEPOSIT_BYTE=200,\n            G_INITCODE_WORD=2,\n            G_CALL_VALUE=9_000,\n            G_CALL_STIPEND=2_300,\n            G_NEW_ACCOUNT=25_000,\n            G_EXP=10,\n            G_EXP_BYTE=50,\n            G_MEMORY=3,\n            G_TX_DATA_ZERO=4,\n            G_TX_DATA_NON_ZERO=68,\n            G_TX_DATA_STANDARD_TOKEN_COST=0,\n            G_TX_DATA_FLOOR_TOKEN_COST=0,\n            G_TRANSACTION=21_000,\n            G_TRANSACTION_CREATE=32_000,\n            G_LOG=375,\n            G_LOG_DATA=8,\n            G_LOG_TOPIC=375,\n            G_KECCAK_256=30,\n            G_KECCAK_256_WORD=6,\n            G_COPY=3,\n            G_BLOCKHASH=20,\n            G_AUTHORIZATION=0,\n            R_AUTHORIZATION_EXISTING_AUTHORITY=0,\n        )\n\n    @classmethod\n    def memory_expansion_gas_calculator(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; MemoryExpansionGasCalculator:\n        \"\"\"Return callable that calculates the gas cost of memory expansion for the fork.\"\"\"\n        gas_costs = cls.gas_costs(block_number, timestamp)\n\n        def fn(*, new_bytes: int, previous_bytes: int = 0) -&gt; int:\n            if new_bytes &lt;= previous_bytes:\n                return 0\n            new_words = ceiling_division(new_bytes, 32)\n            previous_words = ceiling_division(previous_bytes, 32)\n\n            def c(w: int) -&gt; int:\n                return (gas_costs.G_MEMORY * w) + ((w * w) // 512)\n\n            return c(new_words) - c(previous_words)\n\n        return fn\n\n    @classmethod\n    def calldata_gas_calculator(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; CalldataGasCalculator:\n        \"\"\"\n        Return callable that calculates the transaction gas cost for its calldata\n        depending on its contents.\n        \"\"\"\n        gas_costs = cls.gas_costs(block_number, timestamp)\n\n        def fn(*, data: BytesConvertible, floor: bool = False) -&gt; int:\n            cost = 0\n            for b in Bytes(data):\n                if b == 0:\n                    cost += gas_costs.G_TX_DATA_ZERO\n                else:\n                    cost += gas_costs.G_TX_DATA_NON_ZERO\n            return cost\n\n        return fn\n\n    @classmethod\n    def transaction_data_floor_cost_calculator(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; TransactionDataFloorCostCalculator:\n        \"\"\"At frontier, the transaction data floor cost is a constant zero.\"\"\"\n\n        def fn(*, data: BytesConvertible) -&gt; int:\n            return 0\n\n        return fn\n\n    @classmethod\n    def transaction_intrinsic_cost_calculator(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; TransactionIntrinsicCostCalculator:\n        \"\"\"Return callable that calculates the intrinsic gas cost of a transaction for the fork.\"\"\"\n        gas_costs = cls.gas_costs(block_number, timestamp)\n        calldata_gas_calculator = cls.calldata_gas_calculator(block_number, timestamp)\n\n        def fn(\n            *,\n            calldata: BytesConvertible = b\"\",\n            contract_creation: bool = False,\n            access_list: List[AccessList] | None = None,\n            authorization_list_or_count: Sized | int | None = None,\n            return_cost_deducted_prior_execution: bool = False,\n        ) -&gt; int:\n            assert access_list is None, f\"Access list is not supported in {cls.name()}\"\n            assert authorization_list_or_count is None, (\n                f\"Authorizations are not supported in {cls.name()}\"\n            )\n            intrinsic_cost: int = gas_costs.G_TRANSACTION\n\n            if contract_creation:\n                intrinsic_cost += gas_costs.G_INITCODE_WORD * ceiling_division(\n                    len(Bytes(calldata)), 32\n                )\n\n            return intrinsic_cost + calldata_gas_calculator(data=calldata)\n\n        return fn\n\n    @classmethod\n    def blob_gas_price_calculator(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; BlobGasPriceCalculator:\n        \"\"\"Return a callable that calculates the blob gas price at a given fork.\"\"\"\n        raise NotImplementedError(f\"Blob gas price calculator is not supported in {cls.name()}\")\n\n    @classmethod\n    def excess_blob_gas_calculator(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; ExcessBlobGasCalculator:\n        \"\"\"Return a callable that calculates the excess blob gas for a block at a given fork.\"\"\"\n        raise NotImplementedError(f\"Excess blob gas calculator is not supported in {cls.name()}\")\n\n    @classmethod\n    def min_base_fee_per_blob_gas(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n        \"\"\"Return the amount of blob gas used per blob at a given fork.\"\"\"\n        raise NotImplementedError(f\"Base fee per blob gas is not supported in {cls.name()}\")\n\n    @classmethod\n    def blob_base_fee_update_fraction(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n        \"\"\"Return the blob base fee update fraction at a given fork.\"\"\"\n        raise NotImplementedError(\n            f\"Blob base fee update fraction is not supported in {cls.name()}\"\n        )\n\n    @classmethod\n    def blob_gas_per_blob(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n        \"\"\"Return the amount of blob gas used per blob at a given fork.\"\"\"\n        return 0\n\n    @classmethod\n    def supports_blobs(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"Blobs are not supported at Frontier.\"\"\"\n        return False\n\n    @classmethod\n    def target_blobs_per_block(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n        \"\"\"Return the target number of blobs per block at a given fork.\"\"\"\n        raise NotImplementedError(f\"Target blobs per block is not supported in {cls.name()}\")\n\n    @classmethod\n    def max_blobs_per_block(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n        \"\"\"Return the max number of blobs per block at a given fork.\"\"\"\n        raise NotImplementedError(f\"Max blobs per block is not supported in {cls.name()}\")\n\n    @classmethod\n    def blob_schedule(cls, block_number: int = 0, timestamp: int = 0) -&gt; BlobSchedule | None:\n        \"\"\"At genesis, no blob schedule is used.\"\"\"\n        return None\n\n    @classmethod\n    def header_requests_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"At genesis, header must not contain beacon chain requests.\"\"\"\n        return False\n\n    @classmethod\n    def engine_new_payload_version(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; Optional[int]:\n        \"\"\"At genesis, payloads cannot be sent through the engine API.\"\"\"\n        return None\n\n    @classmethod\n    def header_beacon_root_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"At genesis, header must not contain parent beacon block root.\"\"\"\n        return False\n\n    @classmethod\n    def engine_new_payload_blob_hashes(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"At genesis, payloads do not have blob hashes.\"\"\"\n        return False\n\n    @classmethod\n    def engine_new_payload_beacon_root(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"At genesis, payloads do not have a parent beacon block root.\"\"\"\n        return False\n\n    @classmethod\n    def engine_new_payload_requests(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"At genesis, payloads do not have requests.\"\"\"\n        return False\n\n    @classmethod\n    def engine_new_payload_target_blobs_per_block(\n        cls,\n        block_number: int = 0,\n        timestamp: int = 0,\n    ) -&gt; bool:\n        \"\"\"At genesis, payloads do not have target blobs per block.\"\"\"\n        return False\n\n    @classmethod\n    def engine_payload_attribute_target_blobs_per_block(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; bool:\n        \"\"\"At genesis, payload attributes do not include the target blobs per block.\"\"\"\n        return False\n\n    @classmethod\n    def engine_payload_attribute_max_blobs_per_block(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; bool:\n        \"\"\"At genesis, payload attributes do not include the max blobs per block.\"\"\"\n        return False\n\n    @classmethod\n    def engine_forkchoice_updated_version(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; Optional[int]:\n        \"\"\"At genesis, forkchoice updates cannot be sent through the engine API.\"\"\"\n        return cls.engine_new_payload_version(block_number, timestamp)\n\n    @classmethod\n    def engine_get_payload_version(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; Optional[int]:\n        \"\"\"At genesis, payloads cannot be retrieved through the engine API.\"\"\"\n        return cls.engine_new_payload_version(block_number, timestamp)\n\n    @classmethod\n    def get_reward(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n        \"\"\"\n        At Genesis the expected reward amount in wei is\n        5_000_000_000_000_000_000.\n        \"\"\"\n        return 5_000_000_000_000_000_000\n\n    @classmethod\n    def tx_types(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[int]:\n        \"\"\"At Genesis, only legacy transactions are allowed.\"\"\"\n        return [0]\n\n    @classmethod\n    def contract_creating_tx_types(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[int]:\n        \"\"\"At Genesis, only legacy transactions are allowed.\"\"\"\n        return [0]\n\n    @classmethod\n    def precompiles(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[Address]:\n        \"\"\"At Genesis, no pre-compiles are present.\"\"\"\n        return []\n\n    @classmethod\n    def system_contracts(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[Address]:\n        \"\"\"At Genesis, no system-contracts are present.\"\"\"\n        return []\n\n    @classmethod\n    def evm_code_types(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[EVMCodeType]:\n        \"\"\"At Genesis, only legacy EVM code is supported.\"\"\"\n        return [EVMCodeType.LEGACY]\n\n    @classmethod\n    def call_opcodes(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; List[Tuple[Opcodes, EVMCodeType]]:\n        \"\"\"Return list of call opcodes supported by the fork.\"\"\"\n        return [\n            (Opcodes.CALL, EVMCodeType.LEGACY),\n            (Opcodes.CALLCODE, EVMCodeType.LEGACY),\n        ]\n\n    @classmethod\n    def valid_opcodes(\n        cls,\n    ) -&gt; List[Opcodes]:\n        \"\"\"Return list of Opcodes that are valid to work on this fork.\"\"\"\n        return [\n            Opcodes.STOP,\n            Opcodes.ADD,\n            Opcodes.MUL,\n            Opcodes.SUB,\n            Opcodes.DIV,\n            Opcodes.SDIV,\n            Opcodes.MOD,\n            Opcodes.SMOD,\n            Opcodes.ADDMOD,\n            Opcodes.MULMOD,\n            Opcodes.EXP,\n            Opcodes.SIGNEXTEND,\n            Opcodes.LT,\n            Opcodes.GT,\n            Opcodes.SLT,\n            Opcodes.SGT,\n            Opcodes.EQ,\n            Opcodes.ISZERO,\n            Opcodes.AND,\n            Opcodes.OR,\n            Opcodes.XOR,\n            Opcodes.NOT,\n            Opcodes.BYTE,\n            Opcodes.SHA3,\n            Opcodes.ADDRESS,\n            Opcodes.BALANCE,\n            Opcodes.ORIGIN,\n            Opcodes.CALLER,\n            Opcodes.CALLVALUE,\n            Opcodes.CALLDATALOAD,\n            Opcodes.CALLDATASIZE,\n            Opcodes.CALLDATACOPY,\n            Opcodes.CODESIZE,\n            Opcodes.CODECOPY,\n            Opcodes.GASPRICE,\n            Opcodes.EXTCODESIZE,\n            Opcodes.EXTCODECOPY,\n            Opcodes.BLOCKHASH,\n            Opcodes.COINBASE,\n            Opcodes.TIMESTAMP,\n            Opcodes.NUMBER,\n            Opcodes.PREVRANDAO,\n            Opcodes.GASLIMIT,\n            Opcodes.POP,\n            Opcodes.MLOAD,\n            Opcodes.MSTORE,\n            Opcodes.MSTORE8,\n            Opcodes.SLOAD,\n            Opcodes.SSTORE,\n            Opcodes.PC,\n            Opcodes.MSIZE,\n            Opcodes.GAS,\n            Opcodes.JUMP,\n            Opcodes.JUMPI,\n            Opcodes.JUMPDEST,\n            Opcodes.PUSH1,\n            Opcodes.PUSH2,\n            Opcodes.PUSH3,\n            Opcodes.PUSH4,\n            Opcodes.PUSH5,\n            Opcodes.PUSH6,\n            Opcodes.PUSH7,\n            Opcodes.PUSH8,\n            Opcodes.PUSH9,\n            Opcodes.PUSH10,\n            Opcodes.PUSH11,\n            Opcodes.PUSH12,\n            Opcodes.PUSH13,\n            Opcodes.PUSH14,\n            Opcodes.PUSH15,\n            Opcodes.PUSH16,\n            Opcodes.PUSH17,\n            Opcodes.PUSH18,\n            Opcodes.PUSH19,\n            Opcodes.PUSH20,\n            Opcodes.PUSH21,\n            Opcodes.PUSH22,\n            Opcodes.PUSH23,\n            Opcodes.PUSH24,\n            Opcodes.PUSH25,\n            Opcodes.PUSH26,\n            Opcodes.PUSH27,\n            Opcodes.PUSH28,\n            Opcodes.PUSH29,\n            Opcodes.PUSH30,\n            Opcodes.PUSH31,\n            Opcodes.PUSH32,\n            Opcodes.DUP1,\n            Opcodes.DUP2,\n            Opcodes.DUP3,\n            Opcodes.DUP4,\n            Opcodes.DUP5,\n            Opcodes.DUP6,\n            Opcodes.DUP7,\n            Opcodes.DUP8,\n            Opcodes.DUP9,\n            Opcodes.DUP10,\n            Opcodes.DUP11,\n            Opcodes.DUP12,\n            Opcodes.DUP13,\n            Opcodes.DUP14,\n            Opcodes.DUP15,\n            Opcodes.DUP16,\n            Opcodes.SWAP1,\n            Opcodes.SWAP2,\n            Opcodes.SWAP3,\n            Opcodes.SWAP4,\n            Opcodes.SWAP5,\n            Opcodes.SWAP6,\n            Opcodes.SWAP7,\n            Opcodes.SWAP8,\n            Opcodes.SWAP9,\n            Opcodes.SWAP10,\n            Opcodes.SWAP11,\n            Opcodes.SWAP12,\n            Opcodes.SWAP13,\n            Opcodes.SWAP14,\n            Opcodes.SWAP15,\n            Opcodes.SWAP16,\n            Opcodes.LOG0,\n            Opcodes.LOG1,\n            Opcodes.LOG2,\n            Opcodes.LOG3,\n            Opcodes.LOG4,\n            Opcodes.CREATE,\n            Opcodes.CALL,\n            Opcodes.CALLCODE,\n            Opcodes.RETURN,\n            Opcodes.SELFDESTRUCT,\n        ]\n\n    @classmethod\n    def create_opcodes(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; List[Tuple[Opcodes, EVMCodeType]]:\n        \"\"\"At Genesis, only `CREATE` opcode is supported.\"\"\"\n        return [\n            (Opcodes.CREATE, EVMCodeType.LEGACY),\n        ]\n\n    @classmethod\n    def max_request_type(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n        \"\"\"At genesis, no request type is supported, signaled by -1.\"\"\"\n        return -1\n\n    @classmethod\n    def pre_allocation(cls) -&gt; Mapping:\n        \"\"\"\n        Return whether the fork expects pre-allocation of accounts.\n\n        Frontier does not require pre-allocated accounts\n        \"\"\"\n        return {}\n\n    @classmethod\n    def pre_allocation_blockchain(cls) -&gt; Mapping:\n        \"\"\"\n        Return whether the fork expects pre-allocation of accounts.\n\n        Frontier does not require pre-allocated accounts\n        \"\"\"\n        return {}\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.transition_tool_name","title":"<code>transition_tool_name(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Return fork name as it's meant to be passed to the transition tool for execution.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef transition_tool_name(cls, block_number: int = 0, timestamp: int = 0) -&gt; str:\n    \"\"\"Return fork name as it's meant to be passed to the transition tool for execution.\"\"\"\n    if cls._transition_tool_name is not None:\n        return cls._transition_tool_name\n    return cls.name()\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.solc_name","title":"<code>solc_name()</code>  <code>classmethod</code>","text":"<p>Return fork name as it's meant to be passed to the solc compiler.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef solc_name(cls) -&gt; str:\n    \"\"\"Return fork name as it's meant to be passed to the solc compiler.\"\"\"\n    if cls._solc_name is not None:\n        return cls._solc_name\n    return cls.name().lower()\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.solc_min_version","title":"<code>solc_min_version()</code>  <code>classmethod</code>","text":"<p>Return minimum version of solc that supports this fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef solc_min_version(cls) -&gt; Version:\n    \"\"\"Return minimum version of solc that supports this fork.\"\"\"\n    return Version.parse(\"0.8.20\")\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.header_base_fee_required","title":"<code>header_base_fee_required(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At genesis, header must not contain base fee.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_base_fee_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"At genesis, header must not contain base fee.\"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.header_prev_randao_required","title":"<code>header_prev_randao_required(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At genesis, header must not contain Prev Randao value.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_prev_randao_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"At genesis, header must not contain Prev Randao value.\"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.header_zero_difficulty_required","title":"<code>header_zero_difficulty_required(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At genesis, header must not have difficulty zero.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_zero_difficulty_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"At genesis, header must not have difficulty zero.\"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.header_withdrawals_required","title":"<code>header_withdrawals_required(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At genesis, header must not contain withdrawals.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_withdrawals_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"At genesis, header must not contain withdrawals.\"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.header_excess_blob_gas_required","title":"<code>header_excess_blob_gas_required(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At genesis, header must not contain excess blob gas.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_excess_blob_gas_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"At genesis, header must not contain excess blob gas.\"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.header_blob_gas_used_required","title":"<code>header_blob_gas_used_required(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At genesis, header must not contain blob gas used.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_blob_gas_used_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"At genesis, header must not contain blob gas used.\"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.gas_costs","title":"<code>gas_costs(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Return dataclass with the defined gas costs constants for genesis.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef gas_costs(cls, block_number: int = 0, timestamp: int = 0) -&gt; GasCosts:\n    \"\"\"Return dataclass with the defined gas costs constants for genesis.\"\"\"\n    return GasCosts(\n        G_JUMPDEST=1,\n        G_BASE=2,\n        G_VERY_LOW=3,\n        G_LOW=5,\n        G_MID=8,\n        G_HIGH=10,\n        G_WARM_ACCOUNT_ACCESS=100,\n        G_COLD_ACCOUNT_ACCESS=2_600,\n        G_ACCESS_LIST_ADDRESS=2_400,\n        G_ACCESS_LIST_STORAGE=1_900,\n        G_WARM_SLOAD=100,\n        G_COLD_SLOAD=2_100,\n        G_STORAGE_SET=20_000,\n        G_STORAGE_RESET=2_900,\n        R_STORAGE_CLEAR=4_800,\n        G_SELF_DESTRUCT=5_000,\n        G_CREATE=32_000,\n        G_CODE_DEPOSIT_BYTE=200,\n        G_INITCODE_WORD=2,\n        G_CALL_VALUE=9_000,\n        G_CALL_STIPEND=2_300,\n        G_NEW_ACCOUNT=25_000,\n        G_EXP=10,\n        G_EXP_BYTE=50,\n        G_MEMORY=3,\n        G_TX_DATA_ZERO=4,\n        G_TX_DATA_NON_ZERO=68,\n        G_TX_DATA_STANDARD_TOKEN_COST=0,\n        G_TX_DATA_FLOOR_TOKEN_COST=0,\n        G_TRANSACTION=21_000,\n        G_TRANSACTION_CREATE=32_000,\n        G_LOG=375,\n        G_LOG_DATA=8,\n        G_LOG_TOPIC=375,\n        G_KECCAK_256=30,\n        G_KECCAK_256_WORD=6,\n        G_COPY=3,\n        G_BLOCKHASH=20,\n        G_AUTHORIZATION=0,\n        R_AUTHORIZATION_EXISTING_AUTHORITY=0,\n    )\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.memory_expansion_gas_calculator","title":"<code>memory_expansion_gas_calculator(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Return callable that calculates the gas cost of memory expansion for the fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef memory_expansion_gas_calculator(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; MemoryExpansionGasCalculator:\n    \"\"\"Return callable that calculates the gas cost of memory expansion for the fork.\"\"\"\n    gas_costs = cls.gas_costs(block_number, timestamp)\n\n    def fn(*, new_bytes: int, previous_bytes: int = 0) -&gt; int:\n        if new_bytes &lt;= previous_bytes:\n            return 0\n        new_words = ceiling_division(new_bytes, 32)\n        previous_words = ceiling_division(previous_bytes, 32)\n\n        def c(w: int) -&gt; int:\n            return (gas_costs.G_MEMORY * w) + ((w * w) // 512)\n\n        return c(new_words) - c(previous_words)\n\n    return fn\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.calldata_gas_calculator","title":"<code>calldata_gas_calculator(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Return callable that calculates the transaction gas cost for its calldata depending on its contents.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef calldata_gas_calculator(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; CalldataGasCalculator:\n    \"\"\"\n    Return callable that calculates the transaction gas cost for its calldata\n    depending on its contents.\n    \"\"\"\n    gas_costs = cls.gas_costs(block_number, timestamp)\n\n    def fn(*, data: BytesConvertible, floor: bool = False) -&gt; int:\n        cost = 0\n        for b in Bytes(data):\n            if b == 0:\n                cost += gas_costs.G_TX_DATA_ZERO\n            else:\n                cost += gas_costs.G_TX_DATA_NON_ZERO\n        return cost\n\n    return fn\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.transaction_data_floor_cost_calculator","title":"<code>transaction_data_floor_cost_calculator(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At frontier, the transaction data floor cost is a constant zero.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef transaction_data_floor_cost_calculator(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; TransactionDataFloorCostCalculator:\n    \"\"\"At frontier, the transaction data floor cost is a constant zero.\"\"\"\n\n    def fn(*, data: BytesConvertible) -&gt; int:\n        return 0\n\n    return fn\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.transaction_intrinsic_cost_calculator","title":"<code>transaction_intrinsic_cost_calculator(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Return callable that calculates the intrinsic gas cost of a transaction for the fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef transaction_intrinsic_cost_calculator(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; TransactionIntrinsicCostCalculator:\n    \"\"\"Return callable that calculates the intrinsic gas cost of a transaction for the fork.\"\"\"\n    gas_costs = cls.gas_costs(block_number, timestamp)\n    calldata_gas_calculator = cls.calldata_gas_calculator(block_number, timestamp)\n\n    def fn(\n        *,\n        calldata: BytesConvertible = b\"\",\n        contract_creation: bool = False,\n        access_list: List[AccessList] | None = None,\n        authorization_list_or_count: Sized | int | None = None,\n        return_cost_deducted_prior_execution: bool = False,\n    ) -&gt; int:\n        assert access_list is None, f\"Access list is not supported in {cls.name()}\"\n        assert authorization_list_or_count is None, (\n            f\"Authorizations are not supported in {cls.name()}\"\n        )\n        intrinsic_cost: int = gas_costs.G_TRANSACTION\n\n        if contract_creation:\n            intrinsic_cost += gas_costs.G_INITCODE_WORD * ceiling_division(\n                len(Bytes(calldata)), 32\n            )\n\n        return intrinsic_cost + calldata_gas_calculator(data=calldata)\n\n    return fn\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.blob_gas_price_calculator","title":"<code>blob_gas_price_calculator(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Return a callable that calculates the blob gas price at a given fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef blob_gas_price_calculator(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; BlobGasPriceCalculator:\n    \"\"\"Return a callable that calculates the blob gas price at a given fork.\"\"\"\n    raise NotImplementedError(f\"Blob gas price calculator is not supported in {cls.name()}\")\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.excess_blob_gas_calculator","title":"<code>excess_blob_gas_calculator(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Return a callable that calculates the excess blob gas for a block at a given fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef excess_blob_gas_calculator(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; ExcessBlobGasCalculator:\n    \"\"\"Return a callable that calculates the excess blob gas for a block at a given fork.\"\"\"\n    raise NotImplementedError(f\"Excess blob gas calculator is not supported in {cls.name()}\")\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.min_base_fee_per_blob_gas","title":"<code>min_base_fee_per_blob_gas(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Return the amount of blob gas used per blob at a given fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef min_base_fee_per_blob_gas(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n    \"\"\"Return the amount of blob gas used per blob at a given fork.\"\"\"\n    raise NotImplementedError(f\"Base fee per blob gas is not supported in {cls.name()}\")\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.blob_base_fee_update_fraction","title":"<code>blob_base_fee_update_fraction(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Return the blob base fee update fraction at a given fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef blob_base_fee_update_fraction(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n    \"\"\"Return the blob base fee update fraction at a given fork.\"\"\"\n    raise NotImplementedError(\n        f\"Blob base fee update fraction is not supported in {cls.name()}\"\n    )\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.blob_gas_per_blob","title":"<code>blob_gas_per_blob(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Return the amount of blob gas used per blob at a given fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef blob_gas_per_blob(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n    \"\"\"Return the amount of blob gas used per blob at a given fork.\"\"\"\n    return 0\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.supports_blobs","title":"<code>supports_blobs(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Blobs are not supported at Frontier.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef supports_blobs(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"Blobs are not supported at Frontier.\"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.target_blobs_per_block","title":"<code>target_blobs_per_block(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Return the target number of blobs per block at a given fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef target_blobs_per_block(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n    \"\"\"Return the target number of blobs per block at a given fork.\"\"\"\n    raise NotImplementedError(f\"Target blobs per block is not supported in {cls.name()}\")\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.max_blobs_per_block","title":"<code>max_blobs_per_block(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Return the max number of blobs per block at a given fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef max_blobs_per_block(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n    \"\"\"Return the max number of blobs per block at a given fork.\"\"\"\n    raise NotImplementedError(f\"Max blobs per block is not supported in {cls.name()}\")\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.blob_schedule","title":"<code>blob_schedule(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At genesis, no blob schedule is used.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef blob_schedule(cls, block_number: int = 0, timestamp: int = 0) -&gt; BlobSchedule | None:\n    \"\"\"At genesis, no blob schedule is used.\"\"\"\n    return None\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.header_requests_required","title":"<code>header_requests_required(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At genesis, header must not contain beacon chain requests.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_requests_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"At genesis, header must not contain beacon chain requests.\"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.engine_new_payload_version","title":"<code>engine_new_payload_version(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At genesis, payloads cannot be sent through the engine API.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef engine_new_payload_version(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; Optional[int]:\n    \"\"\"At genesis, payloads cannot be sent through the engine API.\"\"\"\n    return None\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.header_beacon_root_required","title":"<code>header_beacon_root_required(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At genesis, header must not contain parent beacon block root.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_beacon_root_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"At genesis, header must not contain parent beacon block root.\"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.engine_new_payload_blob_hashes","title":"<code>engine_new_payload_blob_hashes(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At genesis, payloads do not have blob hashes.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef engine_new_payload_blob_hashes(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"At genesis, payloads do not have blob hashes.\"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.engine_new_payload_beacon_root","title":"<code>engine_new_payload_beacon_root(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At genesis, payloads do not have a parent beacon block root.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef engine_new_payload_beacon_root(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"At genesis, payloads do not have a parent beacon block root.\"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.engine_new_payload_requests","title":"<code>engine_new_payload_requests(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At genesis, payloads do not have requests.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef engine_new_payload_requests(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"At genesis, payloads do not have requests.\"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.engine_new_payload_target_blobs_per_block","title":"<code>engine_new_payload_target_blobs_per_block(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At genesis, payloads do not have target blobs per block.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef engine_new_payload_target_blobs_per_block(\n    cls,\n    block_number: int = 0,\n    timestamp: int = 0,\n) -&gt; bool:\n    \"\"\"At genesis, payloads do not have target blobs per block.\"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.engine_payload_attribute_target_blobs_per_block","title":"<code>engine_payload_attribute_target_blobs_per_block(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At genesis, payload attributes do not include the target blobs per block.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef engine_payload_attribute_target_blobs_per_block(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; bool:\n    \"\"\"At genesis, payload attributes do not include the target blobs per block.\"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.engine_payload_attribute_max_blobs_per_block","title":"<code>engine_payload_attribute_max_blobs_per_block(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At genesis, payload attributes do not include the max blobs per block.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef engine_payload_attribute_max_blobs_per_block(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; bool:\n    \"\"\"At genesis, payload attributes do not include the max blobs per block.\"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.engine_forkchoice_updated_version","title":"<code>engine_forkchoice_updated_version(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At genesis, forkchoice updates cannot be sent through the engine API.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef engine_forkchoice_updated_version(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; Optional[int]:\n    \"\"\"At genesis, forkchoice updates cannot be sent through the engine API.\"\"\"\n    return cls.engine_new_payload_version(block_number, timestamp)\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.engine_get_payload_version","title":"<code>engine_get_payload_version(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At genesis, payloads cannot be retrieved through the engine API.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef engine_get_payload_version(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; Optional[int]:\n    \"\"\"At genesis, payloads cannot be retrieved through the engine API.\"\"\"\n    return cls.engine_new_payload_version(block_number, timestamp)\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.get_reward","title":"<code>get_reward(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Genesis the expected reward amount in wei is 5_000_000_000_000_000_000.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef get_reward(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n    \"\"\"\n    At Genesis the expected reward amount in wei is\n    5_000_000_000_000_000_000.\n    \"\"\"\n    return 5_000_000_000_000_000_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.tx_types","title":"<code>tx_types(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Genesis, only legacy transactions are allowed.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef tx_types(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[int]:\n    \"\"\"At Genesis, only legacy transactions are allowed.\"\"\"\n    return [0]\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.contract_creating_tx_types","title":"<code>contract_creating_tx_types(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Genesis, only legacy transactions are allowed.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef contract_creating_tx_types(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[int]:\n    \"\"\"At Genesis, only legacy transactions are allowed.\"\"\"\n    return [0]\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.precompiles","title":"<code>precompiles(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Genesis, no pre-compiles are present.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef precompiles(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[Address]:\n    \"\"\"At Genesis, no pre-compiles are present.\"\"\"\n    return []\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.system_contracts","title":"<code>system_contracts(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Genesis, no system-contracts are present.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef system_contracts(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[Address]:\n    \"\"\"At Genesis, no system-contracts are present.\"\"\"\n    return []\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.evm_code_types","title":"<code>evm_code_types(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Genesis, only legacy EVM code is supported.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef evm_code_types(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[EVMCodeType]:\n    \"\"\"At Genesis, only legacy EVM code is supported.\"\"\"\n    return [EVMCodeType.LEGACY]\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.call_opcodes","title":"<code>call_opcodes(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Return list of call opcodes supported by the fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef call_opcodes(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; List[Tuple[Opcodes, EVMCodeType]]:\n    \"\"\"Return list of call opcodes supported by the fork.\"\"\"\n    return [\n        (Opcodes.CALL, EVMCodeType.LEGACY),\n        (Opcodes.CALLCODE, EVMCodeType.LEGACY),\n    ]\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.valid_opcodes","title":"<code>valid_opcodes()</code>  <code>classmethod</code>","text":"<p>Return list of Opcodes that are valid to work on this fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef valid_opcodes(\n    cls,\n) -&gt; List[Opcodes]:\n    \"\"\"Return list of Opcodes that are valid to work on this fork.\"\"\"\n    return [\n        Opcodes.STOP,\n        Opcodes.ADD,\n        Opcodes.MUL,\n        Opcodes.SUB,\n        Opcodes.DIV,\n        Opcodes.SDIV,\n        Opcodes.MOD,\n        Opcodes.SMOD,\n        Opcodes.ADDMOD,\n        Opcodes.MULMOD,\n        Opcodes.EXP,\n        Opcodes.SIGNEXTEND,\n        Opcodes.LT,\n        Opcodes.GT,\n        Opcodes.SLT,\n        Opcodes.SGT,\n        Opcodes.EQ,\n        Opcodes.ISZERO,\n        Opcodes.AND,\n        Opcodes.OR,\n        Opcodes.XOR,\n        Opcodes.NOT,\n        Opcodes.BYTE,\n        Opcodes.SHA3,\n        Opcodes.ADDRESS,\n        Opcodes.BALANCE,\n        Opcodes.ORIGIN,\n        Opcodes.CALLER,\n        Opcodes.CALLVALUE,\n        Opcodes.CALLDATALOAD,\n        Opcodes.CALLDATASIZE,\n        Opcodes.CALLDATACOPY,\n        Opcodes.CODESIZE,\n        Opcodes.CODECOPY,\n        Opcodes.GASPRICE,\n        Opcodes.EXTCODESIZE,\n        Opcodes.EXTCODECOPY,\n        Opcodes.BLOCKHASH,\n        Opcodes.COINBASE,\n        Opcodes.TIMESTAMP,\n        Opcodes.NUMBER,\n        Opcodes.PREVRANDAO,\n        Opcodes.GASLIMIT,\n        Opcodes.POP,\n        Opcodes.MLOAD,\n        Opcodes.MSTORE,\n        Opcodes.MSTORE8,\n        Opcodes.SLOAD,\n        Opcodes.SSTORE,\n        Opcodes.PC,\n        Opcodes.MSIZE,\n        Opcodes.GAS,\n        Opcodes.JUMP,\n        Opcodes.JUMPI,\n        Opcodes.JUMPDEST,\n        Opcodes.PUSH1,\n        Opcodes.PUSH2,\n        Opcodes.PUSH3,\n        Opcodes.PUSH4,\n        Opcodes.PUSH5,\n        Opcodes.PUSH6,\n        Opcodes.PUSH7,\n        Opcodes.PUSH8,\n        Opcodes.PUSH9,\n        Opcodes.PUSH10,\n        Opcodes.PUSH11,\n        Opcodes.PUSH12,\n        Opcodes.PUSH13,\n        Opcodes.PUSH14,\n        Opcodes.PUSH15,\n        Opcodes.PUSH16,\n        Opcodes.PUSH17,\n        Opcodes.PUSH18,\n        Opcodes.PUSH19,\n        Opcodes.PUSH20,\n        Opcodes.PUSH21,\n        Opcodes.PUSH22,\n        Opcodes.PUSH23,\n        Opcodes.PUSH24,\n        Opcodes.PUSH25,\n        Opcodes.PUSH26,\n        Opcodes.PUSH27,\n        Opcodes.PUSH28,\n        Opcodes.PUSH29,\n        Opcodes.PUSH30,\n        Opcodes.PUSH31,\n        Opcodes.PUSH32,\n        Opcodes.DUP1,\n        Opcodes.DUP2,\n        Opcodes.DUP3,\n        Opcodes.DUP4,\n        Opcodes.DUP5,\n        Opcodes.DUP6,\n        Opcodes.DUP7,\n        Opcodes.DUP8,\n        Opcodes.DUP9,\n        Opcodes.DUP10,\n        Opcodes.DUP11,\n        Opcodes.DUP12,\n        Opcodes.DUP13,\n        Opcodes.DUP14,\n        Opcodes.DUP15,\n        Opcodes.DUP16,\n        Opcodes.SWAP1,\n        Opcodes.SWAP2,\n        Opcodes.SWAP3,\n        Opcodes.SWAP4,\n        Opcodes.SWAP5,\n        Opcodes.SWAP6,\n        Opcodes.SWAP7,\n        Opcodes.SWAP8,\n        Opcodes.SWAP9,\n        Opcodes.SWAP10,\n        Opcodes.SWAP11,\n        Opcodes.SWAP12,\n        Opcodes.SWAP13,\n        Opcodes.SWAP14,\n        Opcodes.SWAP15,\n        Opcodes.SWAP16,\n        Opcodes.LOG0,\n        Opcodes.LOG1,\n        Opcodes.LOG2,\n        Opcodes.LOG3,\n        Opcodes.LOG4,\n        Opcodes.CREATE,\n        Opcodes.CALL,\n        Opcodes.CALLCODE,\n        Opcodes.RETURN,\n        Opcodes.SELFDESTRUCT,\n    ]\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.create_opcodes","title":"<code>create_opcodes(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Genesis, only <code>CREATE</code> opcode is supported.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef create_opcodes(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; List[Tuple[Opcodes, EVMCodeType]]:\n    \"\"\"At Genesis, only `CREATE` opcode is supported.\"\"\"\n    return [\n        (Opcodes.CREATE, EVMCodeType.LEGACY),\n    ]\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.max_request_type","title":"<code>max_request_type(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At genesis, no request type is supported, signaled by -1.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef max_request_type(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n    \"\"\"At genesis, no request type is supported, signaled by -1.\"\"\"\n    return -1\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.pre_allocation","title":"<code>pre_allocation()</code>  <code>classmethod</code>","text":"<p>Return whether the fork expects pre-allocation of accounts.</p> <p>Frontier does not require pre-allocated accounts</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef pre_allocation(cls) -&gt; Mapping:\n    \"\"\"\n    Return whether the fork expects pre-allocation of accounts.\n\n    Frontier does not require pre-allocated accounts\n    \"\"\"\n    return {}\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier.pre_allocation_blockchain","title":"<code>pre_allocation_blockchain()</code>  <code>classmethod</code>","text":"<p>Return whether the fork expects pre-allocation of accounts.</p> <p>Frontier does not require pre-allocated accounts</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef pre_allocation_blockchain(cls) -&gt; Mapping:\n    \"\"\"\n    Return whether the fork expects pre-allocation of accounts.\n\n    Frontier does not require pre-allocated accounts\n    \"\"\"\n    return {}\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.GrayGlacier","title":"<code>GrayGlacier</code>","text":"<p>               Bases: <code>ArrowGlacier</code></p> <p>Gray Glacier fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class GrayGlacier(ArrowGlacier, solc_name=\"london\", ignore=True):\n    \"\"\"Gray Glacier fork.\"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Homestead","title":"<code>Homestead</code>","text":"<p>               Bases: <code>Frontier</code></p> <p>Homestead fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Homestead(Frontier):\n    \"\"\"Homestead fork.\"\"\"\n\n    @classmethod\n    def precompiles(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[Address]:\n        \"\"\"\n        At Homestead, EC-recover, SHA256, RIPEMD160, and Identity pre-compiles\n        are introduced.\n        \"\"\"\n        return [Address(i) for i in range(1, 5)] + super(Homestead, cls).precompiles(\n            block_number, timestamp\n        )\n\n    @classmethod\n    def call_opcodes(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; List[Tuple[Opcodes, EVMCodeType]]:\n        \"\"\"At Homestead, DELEGATECALL opcode was introduced.\"\"\"\n        return [(Opcodes.DELEGATECALL, EVMCodeType.LEGACY)] + super(Homestead, cls).call_opcodes(\n            block_number, timestamp\n        )\n\n    @classmethod\n    def valid_opcodes(\n        cls,\n    ) -&gt; List[Opcodes]:\n        \"\"\"Return the list of Opcodes that are valid to work on this fork.\"\"\"\n        return [Opcodes.DELEGATECALL] + super(Homestead, cls).valid_opcodes()\n\n    @classmethod\n    def transaction_intrinsic_cost_calculator(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; TransactionIntrinsicCostCalculator:\n        \"\"\"\n        At Homestead, the transaction intrinsic cost needs to take contract\n        creation into account.\n        \"\"\"\n        super_fn = super(Homestead, cls).transaction_intrinsic_cost_calculator(\n            block_number, timestamp\n        )\n        gas_costs = cls.gas_costs(block_number, timestamp)\n\n        def fn(\n            *,\n            calldata: BytesConvertible = b\"\",\n            contract_creation: bool = False,\n            access_list: List[AccessList] | None = None,\n            authorization_list_or_count: Sized | int | None = None,\n            return_cost_deducted_prior_execution: bool = False,\n        ) -&gt; int:\n            intrinsic_cost: int = super_fn(\n                calldata=calldata,\n                contract_creation=contract_creation,\n                access_list=access_list,\n                authorization_list_or_count=authorization_list_or_count,\n            )\n            if contract_creation:\n                intrinsic_cost += gas_costs.G_TRANSACTION_CREATE\n            return intrinsic_cost\n\n        return fn\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Homestead.precompiles","title":"<code>precompiles(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Homestead, EC-recover, SHA256, RIPEMD160, and Identity pre-compiles are introduced.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef precompiles(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[Address]:\n    \"\"\"\n    At Homestead, EC-recover, SHA256, RIPEMD160, and Identity pre-compiles\n    are introduced.\n    \"\"\"\n    return [Address(i) for i in range(1, 5)] + super(Homestead, cls).precompiles(\n        block_number, timestamp\n    )\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Homestead.call_opcodes","title":"<code>call_opcodes(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Homestead, DELEGATECALL opcode was introduced.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef call_opcodes(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; List[Tuple[Opcodes, EVMCodeType]]:\n    \"\"\"At Homestead, DELEGATECALL opcode was introduced.\"\"\"\n    return [(Opcodes.DELEGATECALL, EVMCodeType.LEGACY)] + super(Homestead, cls).call_opcodes(\n        block_number, timestamp\n    )\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Homestead.valid_opcodes","title":"<code>valid_opcodes()</code>  <code>classmethod</code>","text":"<p>Return the list of Opcodes that are valid to work on this fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef valid_opcodes(\n    cls,\n) -&gt; List[Opcodes]:\n    \"\"\"Return the list of Opcodes that are valid to work on this fork.\"\"\"\n    return [Opcodes.DELEGATECALL] + super(Homestead, cls).valid_opcodes()\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Homestead.transaction_intrinsic_cost_calculator","title":"<code>transaction_intrinsic_cost_calculator(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Homestead, the transaction intrinsic cost needs to take contract creation into account.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef transaction_intrinsic_cost_calculator(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; TransactionIntrinsicCostCalculator:\n    \"\"\"\n    At Homestead, the transaction intrinsic cost needs to take contract\n    creation into account.\n    \"\"\"\n    super_fn = super(Homestead, cls).transaction_intrinsic_cost_calculator(\n        block_number, timestamp\n    )\n    gas_costs = cls.gas_costs(block_number, timestamp)\n\n    def fn(\n        *,\n        calldata: BytesConvertible = b\"\",\n        contract_creation: bool = False,\n        access_list: List[AccessList] | None = None,\n        authorization_list_or_count: Sized | int | None = None,\n        return_cost_deducted_prior_execution: bool = False,\n    ) -&gt; int:\n        intrinsic_cost: int = super_fn(\n            calldata=calldata,\n            contract_creation=contract_creation,\n            access_list=access_list,\n            authorization_list_or_count=authorization_list_or_count,\n        )\n        if contract_creation:\n            intrinsic_cost += gas_costs.G_TRANSACTION_CREATE\n        return intrinsic_cost\n\n    return fn\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Istanbul","title":"<code>Istanbul</code>","text":"<p>               Bases: <code>ConstantinopleFix</code></p> <p>Istanbul fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Istanbul(ConstantinopleFix):\n    \"\"\"Istanbul fork.\"\"\"\n\n    @classmethod\n    def precompiles(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[Address]:\n        \"\"\"At Istanbul, pre-compile for blake2 compression is introduced.\"\"\"\n        return [Address(9)] + super(Istanbul, cls).precompiles(block_number, timestamp)\n\n    @classmethod\n    def valid_opcodes(\n        cls,\n    ) -&gt; List[Opcodes]:\n        \"\"\"Return list of Opcodes that are valid to work on this fork.\"\"\"\n        return [Opcodes.CHAINID, Opcodes.SELFBALANCE] + super(Istanbul, cls).valid_opcodes()\n\n    @classmethod\n    def gas_costs(cls, block_number: int = 0, timestamp: int = 0) -&gt; GasCosts:\n        \"\"\"\n        On Istanbul, the non-zero transaction data byte cost is reduced to 16 due to\n        EIP-2028.\n        \"\"\"\n        return replace(\n            super(Istanbul, cls).gas_costs(block_number, timestamp),\n            G_TX_DATA_NON_ZERO=16,  # https://eips.ethereum.org/EIPS/eip-2028\n        )\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Istanbul.precompiles","title":"<code>precompiles(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Istanbul, pre-compile for blake2 compression is introduced.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef precompiles(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[Address]:\n    \"\"\"At Istanbul, pre-compile for blake2 compression is introduced.\"\"\"\n    return [Address(9)] + super(Istanbul, cls).precompiles(block_number, timestamp)\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Istanbul.valid_opcodes","title":"<code>valid_opcodes()</code>  <code>classmethod</code>","text":"<p>Return list of Opcodes that are valid to work on this fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef valid_opcodes(\n    cls,\n) -&gt; List[Opcodes]:\n    \"\"\"Return list of Opcodes that are valid to work on this fork.\"\"\"\n    return [Opcodes.CHAINID, Opcodes.SELFBALANCE] + super(Istanbul, cls).valid_opcodes()\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Istanbul.gas_costs","title":"<code>gas_costs(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>On Istanbul, the non-zero transaction data byte cost is reduced to 16 due to EIP-2028.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef gas_costs(cls, block_number: int = 0, timestamp: int = 0) -&gt; GasCosts:\n    \"\"\"\n    On Istanbul, the non-zero transaction data byte cost is reduced to 16 due to\n    EIP-2028.\n    \"\"\"\n    return replace(\n        super(Istanbul, cls).gas_costs(block_number, timestamp),\n        G_TX_DATA_NON_ZERO=16,  # https://eips.ethereum.org/EIPS/eip-2028\n    )\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.London","title":"<code>London</code>","text":"<p>               Bases: <code>Berlin</code></p> <p>London fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class London(Berlin):\n    \"\"\"London fork.\"\"\"\n\n    @classmethod\n    def header_base_fee_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"Header must contain the Base Fee starting from London.\"\"\"\n        return True\n\n    @classmethod\n    def tx_types(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[int]:\n        \"\"\"At London, dynamic fee transactions are introduced.\"\"\"\n        return [2] + super(London, cls).tx_types(block_number, timestamp)\n\n    @classmethod\n    def contract_creating_tx_types(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[int]:\n        \"\"\"At London, dynamic fee transactions are introduced.\"\"\"\n        return [2] + super(London, cls).contract_creating_tx_types(block_number, timestamp)\n\n    @classmethod\n    def valid_opcodes(\n        cls,\n    ) -&gt; List[Opcodes]:\n        \"\"\"Return list of Opcodes that are valid to work on this fork.\"\"\"\n        return [Opcodes.BASEFEE] + super(London, cls).valid_opcodes()\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.London.header_base_fee_required","title":"<code>header_base_fee_required(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Header must contain the Base Fee starting from London.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_base_fee_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"Header must contain the Base Fee starting from London.\"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.London.tx_types","title":"<code>tx_types(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At London, dynamic fee transactions are introduced.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef tx_types(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[int]:\n    \"\"\"At London, dynamic fee transactions are introduced.\"\"\"\n    return [2] + super(London, cls).tx_types(block_number, timestamp)\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.London.contract_creating_tx_types","title":"<code>contract_creating_tx_types(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At London, dynamic fee transactions are introduced.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef contract_creating_tx_types(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[int]:\n    \"\"\"At London, dynamic fee transactions are introduced.\"\"\"\n    return [2] + super(London, cls).contract_creating_tx_types(block_number, timestamp)\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.London.valid_opcodes","title":"<code>valid_opcodes()</code>  <code>classmethod</code>","text":"<p>Return list of Opcodes that are valid to work on this fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef valid_opcodes(\n    cls,\n) -&gt; List[Opcodes]:\n    \"\"\"Return list of Opcodes that are valid to work on this fork.\"\"\"\n    return [Opcodes.BASEFEE] + super(London, cls).valid_opcodes()\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.MuirGlacier","title":"<code>MuirGlacier</code>","text":"<p>               Bases: <code>Istanbul</code></p> <p>Muir Glacier fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class MuirGlacier(Istanbul, solc_name=\"istanbul\", ignore=True):\n    \"\"\"Muir Glacier fork.\"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Osaka","title":"<code>Osaka</code>","text":"<p>               Bases: <code>Prague</code></p> <p>Osaka fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Osaka(Prague, solc_name=\"cancun\"):\n    \"\"\"Osaka fork.\"\"\"\n\n    @classmethod\n    def evm_code_types(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[EVMCodeType]:\n        \"\"\"EOF V1 is supported starting from Osaka.\"\"\"\n        return super(Osaka, cls).evm_code_types(\n            block_number,\n            timestamp,\n        ) + [EVMCodeType.EOF_V1]\n\n    @classmethod\n    def call_opcodes(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; List[Tuple[Opcodes, EVMCodeType]]:\n        \"\"\"EOF V1 introduces EXTCALL, EXTSTATICCALL, EXTDELEGATECALL.\"\"\"\n        return [\n            (Opcodes.EXTCALL, EVMCodeType.EOF_V1),\n            (Opcodes.EXTSTATICCALL, EVMCodeType.EOF_V1),\n            (Opcodes.EXTDELEGATECALL, EVMCodeType.EOF_V1),\n        ] + super(Osaka, cls).call_opcodes(block_number, timestamp)\n\n    @classmethod\n    def is_deployed(cls) -&gt; bool:\n        \"\"\"\n        Flag that the fork has not been deployed to mainnet; it is under active\n        development.\n        \"\"\"\n        return False\n\n    @classmethod\n    def solc_min_version(cls) -&gt; Version:\n        \"\"\"Return minimum version of solc that supports this fork.\"\"\"\n        return Version.parse(\"1.0.0\")  # set a high version; currently unknown\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Osaka.evm_code_types","title":"<code>evm_code_types(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>EOF V1 is supported starting from Osaka.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef evm_code_types(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[EVMCodeType]:\n    \"\"\"EOF V1 is supported starting from Osaka.\"\"\"\n    return super(Osaka, cls).evm_code_types(\n        block_number,\n        timestamp,\n    ) + [EVMCodeType.EOF_V1]\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Osaka.call_opcodes","title":"<code>call_opcodes(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>EOF V1 introduces EXTCALL, EXTSTATICCALL, EXTDELEGATECALL.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef call_opcodes(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; List[Tuple[Opcodes, EVMCodeType]]:\n    \"\"\"EOF V1 introduces EXTCALL, EXTSTATICCALL, EXTDELEGATECALL.\"\"\"\n    return [\n        (Opcodes.EXTCALL, EVMCodeType.EOF_V1),\n        (Opcodes.EXTSTATICCALL, EVMCodeType.EOF_V1),\n        (Opcodes.EXTDELEGATECALL, EVMCodeType.EOF_V1),\n    ] + super(Osaka, cls).call_opcodes(block_number, timestamp)\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Osaka.is_deployed","title":"<code>is_deployed()</code>  <code>classmethod</code>","text":"<p>Flag that the fork has not been deployed to mainnet; it is under active development.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef is_deployed(cls) -&gt; bool:\n    \"\"\"\n    Flag that the fork has not been deployed to mainnet; it is under active\n    development.\n    \"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Osaka.solc_min_version","title":"<code>solc_min_version()</code>  <code>classmethod</code>","text":"<p>Return minimum version of solc that supports this fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef solc_min_version(cls) -&gt; Version:\n    \"\"\"Return minimum version of solc that supports this fork.\"\"\"\n    return Version.parse(\"1.0.0\")  # set a high version; currently unknown\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Paris","title":"<code>Paris</code>","text":"<p>               Bases: <code>London</code></p> <p>Paris (Merge) fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Paris(\n    London,\n    transition_tool_name=\"Merge\",\n    blockchain_test_network_name=\"Paris\",\n):\n    \"\"\"Paris (Merge) fork.\"\"\"\n\n    @classmethod\n    def header_prev_randao_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"Prev Randao is required starting from Paris.\"\"\"\n        return True\n\n    @classmethod\n    def header_zero_difficulty_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"Zero difficulty is required starting from Paris.\"\"\"\n        return True\n\n    @classmethod\n    def get_reward(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n        \"\"\"Paris updates the reward to 0.\"\"\"\n        return 0\n\n    @classmethod\n    def engine_new_payload_version(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; Optional[int]:\n        \"\"\"From Paris, payloads can be sent through the engine API.\"\"\"\n        return 1\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Paris.header_prev_randao_required","title":"<code>header_prev_randao_required(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Prev Randao is required starting from Paris.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_prev_randao_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"Prev Randao is required starting from Paris.\"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Paris.header_zero_difficulty_required","title":"<code>header_zero_difficulty_required(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Zero difficulty is required starting from Paris.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_zero_difficulty_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"Zero difficulty is required starting from Paris.\"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Paris.get_reward","title":"<code>get_reward(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Paris updates the reward to 0.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef get_reward(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n    \"\"\"Paris updates the reward to 0.\"\"\"\n    return 0\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Paris.engine_new_payload_version","title":"<code>engine_new_payload_version(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>From Paris, payloads can be sent through the engine API.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef engine_new_payload_version(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; Optional[int]:\n    \"\"\"From Paris, payloads can be sent through the engine API.\"\"\"\n    return 1\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Prague","title":"<code>Prague</code>","text":"<p>               Bases: <code>Cancun</code></p> <p>Prague fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Prague(Cancun):\n    \"\"\"Prague fork.\"\"\"\n\n    @classmethod\n    def is_deployed(cls) -&gt; bool:\n        \"\"\"\n        Flag that the fork has not been deployed to mainnet; it is under active\n        development.\n        \"\"\"\n        return False\n\n    @classmethod\n    def solc_min_version(cls) -&gt; Version:\n        \"\"\"Return minimum version of solc that supports this fork.\"\"\"\n        return Version.parse(\"1.0.0\")  # set a high version; currently unknown\n\n    @classmethod\n    def precompiles(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[Address]:\n        \"\"\"\n        At Prague, pre-compile for BLS operations are added.\n\n        G1ADD = 0x0B\n        G1MSM = 0x0C\n        G2ADD = 0x0D\n        G2MSM = 0x0E\n        PAIRING = 0x0F\n        MAP_FP_TO_G1 = 0x10\n        MAP_FP2_TO_G2 = 0x11\n        \"\"\"\n        return [Address(i) for i in range(0xB, 0x11 + 1)] + super(Prague, cls).precompiles(\n            block_number, timestamp\n        )\n\n    @classmethod\n    def gas_costs(cls, block_number: int = 0, timestamp: int = 0) -&gt; GasCosts:\n        \"\"\"\n        On Prague, the standard token cost and the floor token costs are introduced due to\n        EIP-7623.\n        \"\"\"\n        return replace(\n            super(Prague, cls).gas_costs(block_number, timestamp),\n            G_TX_DATA_STANDARD_TOKEN_COST=4,  # https://eips.ethereum.org/EIPS/eip-7623\n            G_TX_DATA_FLOOR_TOKEN_COST=10,\n            G_AUTHORIZATION=25_000,\n            R_AUTHORIZATION_EXISTING_AUTHORITY=12_500,\n        )\n\n    @classmethod\n    def system_contracts(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[Address]:\n        \"\"\"Prague introduces the system contracts for EIP-6110, EIP-7002, EIP-7251 and EIP-2935.\"\"\"\n        return [\n            Address(0x00000000219AB540356CBB839CBE05303D7705FA),\n            Address(0x00000961EF480EB55E80D19AD83579A64C007002),\n            Address(0x0000BBDDC7CE488642FB579F8B00F3A590007251),\n            Address(0x0000F90827F1C53A10CB7A02335B175320002935),\n        ] + super(Prague, cls).system_contracts(block_number, timestamp)\n\n    @classmethod\n    def max_request_type(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n        \"\"\"At Prague, three request types are introduced, hence the max request type is 2.\"\"\"\n        return 2\n\n    @classmethod\n    def calldata_gas_calculator(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; CalldataGasCalculator:\n        \"\"\"\n        Return a callable that calculates the transaction gas cost for its calldata\n        depending on its contents.\n        \"\"\"\n        gas_costs = cls.gas_costs(block_number, timestamp)\n\n        def fn(*, data: BytesConvertible, floor: bool = False) -&gt; int:\n            tokens = 0\n            for b in Bytes(data):\n                if b == 0:\n                    tokens += 1\n                else:\n                    tokens += 4\n            if floor:\n                return tokens * gas_costs.G_TX_DATA_FLOOR_TOKEN_COST\n            return tokens * gas_costs.G_TX_DATA_STANDARD_TOKEN_COST\n\n        return fn\n\n    @classmethod\n    def transaction_data_floor_cost_calculator(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; TransactionDataFloorCostCalculator:\n        \"\"\"On Prague, due to EIP-7623, the transaction data floor cost is introduced.\"\"\"\n        calldata_gas_calculator = cls.calldata_gas_calculator(block_number, timestamp)\n        gas_costs = cls.gas_costs(block_number, timestamp)\n\n        def fn(*, data: BytesConvertible) -&gt; int:\n            return calldata_gas_calculator(data=data, floor=True) + gas_costs.G_TRANSACTION\n\n        return fn\n\n    @classmethod\n    def transaction_intrinsic_cost_calculator(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; TransactionIntrinsicCostCalculator:\n        \"\"\"\n        At Prague, the transaction intrinsic cost needs to take the\n        authorizations into account.\n        \"\"\"\n        super_fn = super(Prague, cls).transaction_intrinsic_cost_calculator(\n            block_number, timestamp\n        )\n        gas_costs = cls.gas_costs(block_number, timestamp)\n        transaction_data_floor_cost_calculator = cls.transaction_data_floor_cost_calculator(\n            block_number, timestamp\n        )\n\n        def fn(\n            *,\n            calldata: BytesConvertible = b\"\",\n            contract_creation: bool = False,\n            access_list: List[AccessList] | None = None,\n            authorization_list_or_count: Sized | int | None = None,\n            return_cost_deducted_prior_execution: bool = False,\n        ) -&gt; int:\n            intrinsic_cost: int = super_fn(\n                calldata=calldata,\n                contract_creation=contract_creation,\n                access_list=access_list,\n                return_cost_deducted_prior_execution=False,\n            )\n            if authorization_list_or_count is not None:\n                if isinstance(authorization_list_or_count, Sized):\n                    authorization_list_or_count = len(authorization_list_or_count)\n                intrinsic_cost += authorization_list_or_count * gas_costs.G_AUTHORIZATION\n\n            if return_cost_deducted_prior_execution:\n                return intrinsic_cost\n\n            transaction_floor_data_cost = transaction_data_floor_cost_calculator(data=calldata)\n            return max(intrinsic_cost, transaction_floor_data_cost)\n\n        return fn\n\n    @classmethod\n    def blob_base_fee_update_fraction(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n        \"\"\"Return the blob base fee update fraction for Prague.\"\"\"\n        return 5007716\n\n    @classmethod\n    def target_blobs_per_block(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n        \"\"\"Target blob count of 6 for Prague.\"\"\"\n        return 6\n\n    @classmethod\n    def max_blobs_per_block(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n        \"\"\"Max blob count of 9 for Prague.\"\"\"\n        return 9\n\n    @classmethod\n    def pre_allocation_blockchain(cls) -&gt; Mapping:\n        \"\"\"\n        Prague requires pre-allocation of the beacon chain deposit contract for EIP-6110,\n        the exits contract for EIP-7002, and the history storage contract for EIP-2935.\n        \"\"\"\n        new_allocation = {}\n\n        # Add the beacon chain deposit contract\n        deposit_contract_tree_depth = 32\n        storage = {}\n        next_hash = sha256(b\"\\x00\" * 64).digest()\n        for i in range(deposit_contract_tree_depth + 2, deposit_contract_tree_depth * 2 + 1):\n            storage[i] = next_hash\n            next_hash = sha256(next_hash + next_hash).digest()\n\n        with open(CURRENT_FOLDER / \"contracts\" / \"deposit_contract.bin\", mode=\"rb\") as f:\n            new_allocation.update(\n                {\n                    0x00000000219AB540356CBB839CBE05303D7705FA: {\n                        \"nonce\": 1,\n                        \"code\": f.read(),\n                        \"storage\": storage,\n                    }\n                }\n            )\n\n        # EIP-7002: Add the withdrawal request contract\n        with open(CURRENT_FOLDER / \"contracts\" / \"withdrawal_request.bin\", mode=\"rb\") as f:\n            new_allocation.update(\n                {\n                    0x00000961EF480EB55E80D19AD83579A64C007002: {\n                        \"nonce\": 1,\n                        \"code\": f.read(),\n                    },\n                }\n            )\n\n        # EIP-7251: Add the consolidation request contract\n        with open(CURRENT_FOLDER / \"contracts\" / \"consolidation_request.bin\", mode=\"rb\") as f:\n            new_allocation.update(\n                {\n                    0x0000BBDDC7CE488642FB579F8B00F3A590007251: {\n                        \"nonce\": 1,\n                        \"code\": f.read(),\n                    },\n                }\n            )\n\n        # EIP-2935: Add the history storage contract\n        with open(CURRENT_FOLDER / \"contracts\" / \"history_contract.bin\", mode=\"rb\") as f:\n            new_allocation.update(\n                {\n                    0x0000F90827F1C53A10CB7A02335B175320002935: {\n                        \"nonce\": 1,\n                        \"code\": f.read(),\n                    }\n                }\n            )\n\n        return new_allocation | super(Prague, cls).pre_allocation_blockchain()  # type: ignore\n\n    @classmethod\n    def header_requests_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"\n        Prague requires that the execution layer header contains the beacon\n        chain requests hash.\n        \"\"\"\n        return True\n\n    @classmethod\n    def engine_new_payload_requests(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"From Prague, new payloads include the requests hash as a parameter.\"\"\"\n        return True\n\n    @classmethod\n    def engine_new_payload_version(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; Optional[int]:\n        \"\"\"From Prague, new payload calls must use version 4.\"\"\"\n        return 4\n\n    @classmethod\n    def engine_forkchoice_updated_version(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; Optional[int]:\n        \"\"\"At Prague, version number of NewPayload and ForkchoiceUpdated diverge.\"\"\"\n        return 3\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Prague.is_deployed","title":"<code>is_deployed()</code>  <code>classmethod</code>","text":"<p>Flag that the fork has not been deployed to mainnet; it is under active development.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef is_deployed(cls) -&gt; bool:\n    \"\"\"\n    Flag that the fork has not been deployed to mainnet; it is under active\n    development.\n    \"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Prague.solc_min_version","title":"<code>solc_min_version()</code>  <code>classmethod</code>","text":"<p>Return minimum version of solc that supports this fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef solc_min_version(cls) -&gt; Version:\n    \"\"\"Return minimum version of solc that supports this fork.\"\"\"\n    return Version.parse(\"1.0.0\")  # set a high version; currently unknown\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Prague.precompiles","title":"<code>precompiles(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Prague, pre-compile for BLS operations are added.</p> <p>G1ADD = 0x0B G1MSM = 0x0C G2ADD = 0x0D G2MSM = 0x0E PAIRING = 0x0F MAP_FP_TO_G1 = 0x10 MAP_FP2_TO_G2 = 0x11</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef precompiles(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[Address]:\n    \"\"\"\n    At Prague, pre-compile for BLS operations are added.\n\n    G1ADD = 0x0B\n    G1MSM = 0x0C\n    G2ADD = 0x0D\n    G2MSM = 0x0E\n    PAIRING = 0x0F\n    MAP_FP_TO_G1 = 0x10\n    MAP_FP2_TO_G2 = 0x11\n    \"\"\"\n    return [Address(i) for i in range(0xB, 0x11 + 1)] + super(Prague, cls).precompiles(\n        block_number, timestamp\n    )\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Prague.gas_costs","title":"<code>gas_costs(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>On Prague, the standard token cost and the floor token costs are introduced due to EIP-7623.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef gas_costs(cls, block_number: int = 0, timestamp: int = 0) -&gt; GasCosts:\n    \"\"\"\n    On Prague, the standard token cost and the floor token costs are introduced due to\n    EIP-7623.\n    \"\"\"\n    return replace(\n        super(Prague, cls).gas_costs(block_number, timestamp),\n        G_TX_DATA_STANDARD_TOKEN_COST=4,  # https://eips.ethereum.org/EIPS/eip-7623\n        G_TX_DATA_FLOOR_TOKEN_COST=10,\n        G_AUTHORIZATION=25_000,\n        R_AUTHORIZATION_EXISTING_AUTHORITY=12_500,\n    )\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Prague.system_contracts","title":"<code>system_contracts(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Prague introduces the system contracts for EIP-6110, EIP-7002, EIP-7251 and EIP-2935.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef system_contracts(cls, block_number: int = 0, timestamp: int = 0) -&gt; List[Address]:\n    \"\"\"Prague introduces the system contracts for EIP-6110, EIP-7002, EIP-7251 and EIP-2935.\"\"\"\n    return [\n        Address(0x00000000219AB540356CBB839CBE05303D7705FA),\n        Address(0x00000961EF480EB55E80D19AD83579A64C007002),\n        Address(0x0000BBDDC7CE488642FB579F8B00F3A590007251),\n        Address(0x0000F90827F1C53A10CB7A02335B175320002935),\n    ] + super(Prague, cls).system_contracts(block_number, timestamp)\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Prague.max_request_type","title":"<code>max_request_type(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Prague, three request types are introduced, hence the max request type is 2.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef max_request_type(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n    \"\"\"At Prague, three request types are introduced, hence the max request type is 2.\"\"\"\n    return 2\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Prague.calldata_gas_calculator","title":"<code>calldata_gas_calculator(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Return a callable that calculates the transaction gas cost for its calldata depending on its contents.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef calldata_gas_calculator(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; CalldataGasCalculator:\n    \"\"\"\n    Return a callable that calculates the transaction gas cost for its calldata\n    depending on its contents.\n    \"\"\"\n    gas_costs = cls.gas_costs(block_number, timestamp)\n\n    def fn(*, data: BytesConvertible, floor: bool = False) -&gt; int:\n        tokens = 0\n        for b in Bytes(data):\n            if b == 0:\n                tokens += 1\n            else:\n                tokens += 4\n        if floor:\n            return tokens * gas_costs.G_TX_DATA_FLOOR_TOKEN_COST\n        return tokens * gas_costs.G_TX_DATA_STANDARD_TOKEN_COST\n\n    return fn\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Prague.transaction_data_floor_cost_calculator","title":"<code>transaction_data_floor_cost_calculator(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>On Prague, due to EIP-7623, the transaction data floor cost is introduced.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef transaction_data_floor_cost_calculator(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; TransactionDataFloorCostCalculator:\n    \"\"\"On Prague, due to EIP-7623, the transaction data floor cost is introduced.\"\"\"\n    calldata_gas_calculator = cls.calldata_gas_calculator(block_number, timestamp)\n    gas_costs = cls.gas_costs(block_number, timestamp)\n\n    def fn(*, data: BytesConvertible) -&gt; int:\n        return calldata_gas_calculator(data=data, floor=True) + gas_costs.G_TRANSACTION\n\n    return fn\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Prague.transaction_intrinsic_cost_calculator","title":"<code>transaction_intrinsic_cost_calculator(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Prague, the transaction intrinsic cost needs to take the authorizations into account.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef transaction_intrinsic_cost_calculator(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; TransactionIntrinsicCostCalculator:\n    \"\"\"\n    At Prague, the transaction intrinsic cost needs to take the\n    authorizations into account.\n    \"\"\"\n    super_fn = super(Prague, cls).transaction_intrinsic_cost_calculator(\n        block_number, timestamp\n    )\n    gas_costs = cls.gas_costs(block_number, timestamp)\n    transaction_data_floor_cost_calculator = cls.transaction_data_floor_cost_calculator(\n        block_number, timestamp\n    )\n\n    def fn(\n        *,\n        calldata: BytesConvertible = b\"\",\n        contract_creation: bool = False,\n        access_list: List[AccessList] | None = None,\n        authorization_list_or_count: Sized | int | None = None,\n        return_cost_deducted_prior_execution: bool = False,\n    ) -&gt; int:\n        intrinsic_cost: int = super_fn(\n            calldata=calldata,\n            contract_creation=contract_creation,\n            access_list=access_list,\n            return_cost_deducted_prior_execution=False,\n        )\n        if authorization_list_or_count is not None:\n            if isinstance(authorization_list_or_count, Sized):\n                authorization_list_or_count = len(authorization_list_or_count)\n            intrinsic_cost += authorization_list_or_count * gas_costs.G_AUTHORIZATION\n\n        if return_cost_deducted_prior_execution:\n            return intrinsic_cost\n\n        transaction_floor_data_cost = transaction_data_floor_cost_calculator(data=calldata)\n        return max(intrinsic_cost, transaction_floor_data_cost)\n\n    return fn\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Prague.blob_base_fee_update_fraction","title":"<code>blob_base_fee_update_fraction(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Return the blob base fee update fraction for Prague.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef blob_base_fee_update_fraction(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n    \"\"\"Return the blob base fee update fraction for Prague.\"\"\"\n    return 5007716\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Prague.target_blobs_per_block","title":"<code>target_blobs_per_block(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Target blob count of 6 for Prague.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef target_blobs_per_block(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n    \"\"\"Target blob count of 6 for Prague.\"\"\"\n    return 6\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Prague.max_blobs_per_block","title":"<code>max_blobs_per_block(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Max blob count of 9 for Prague.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef max_blobs_per_block(cls, block_number: int = 0, timestamp: int = 0) -&gt; int:\n    \"\"\"Max blob count of 9 for Prague.\"\"\"\n    return 9\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Prague.pre_allocation_blockchain","title":"<code>pre_allocation_blockchain()</code>  <code>classmethod</code>","text":"<p>Prague requires pre-allocation of the beacon chain deposit contract for EIP-6110, the exits contract for EIP-7002, and the history storage contract for EIP-2935.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef pre_allocation_blockchain(cls) -&gt; Mapping:\n    \"\"\"\n    Prague requires pre-allocation of the beacon chain deposit contract for EIP-6110,\n    the exits contract for EIP-7002, and the history storage contract for EIP-2935.\n    \"\"\"\n    new_allocation = {}\n\n    # Add the beacon chain deposit contract\n    deposit_contract_tree_depth = 32\n    storage = {}\n    next_hash = sha256(b\"\\x00\" * 64).digest()\n    for i in range(deposit_contract_tree_depth + 2, deposit_contract_tree_depth * 2 + 1):\n        storage[i] = next_hash\n        next_hash = sha256(next_hash + next_hash).digest()\n\n    with open(CURRENT_FOLDER / \"contracts\" / \"deposit_contract.bin\", mode=\"rb\") as f:\n        new_allocation.update(\n            {\n                0x00000000219AB540356CBB839CBE05303D7705FA: {\n                    \"nonce\": 1,\n                    \"code\": f.read(),\n                    \"storage\": storage,\n                }\n            }\n        )\n\n    # EIP-7002: Add the withdrawal request contract\n    with open(CURRENT_FOLDER / \"contracts\" / \"withdrawal_request.bin\", mode=\"rb\") as f:\n        new_allocation.update(\n            {\n                0x00000961EF480EB55E80D19AD83579A64C007002: {\n                    \"nonce\": 1,\n                    \"code\": f.read(),\n                },\n            }\n        )\n\n    # EIP-7251: Add the consolidation request contract\n    with open(CURRENT_FOLDER / \"contracts\" / \"consolidation_request.bin\", mode=\"rb\") as f:\n        new_allocation.update(\n            {\n                0x0000BBDDC7CE488642FB579F8B00F3A590007251: {\n                    \"nonce\": 1,\n                    \"code\": f.read(),\n                },\n            }\n        )\n\n    # EIP-2935: Add the history storage contract\n    with open(CURRENT_FOLDER / \"contracts\" / \"history_contract.bin\", mode=\"rb\") as f:\n        new_allocation.update(\n            {\n                0x0000F90827F1C53A10CB7A02335B175320002935: {\n                    \"nonce\": 1,\n                    \"code\": f.read(),\n                }\n            }\n        )\n\n    return new_allocation | super(Prague, cls).pre_allocation_blockchain()  # type: ignore\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Prague.header_requests_required","title":"<code>header_requests_required(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Prague requires that the execution layer header contains the beacon chain requests hash.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_requests_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"\n    Prague requires that the execution layer header contains the beacon\n    chain requests hash.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Prague.engine_new_payload_requests","title":"<code>engine_new_payload_requests(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>From Prague, new payloads include the requests hash as a parameter.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef engine_new_payload_requests(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"From Prague, new payloads include the requests hash as a parameter.\"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Prague.engine_new_payload_version","title":"<code>engine_new_payload_version(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>From Prague, new payload calls must use version 4.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef engine_new_payload_version(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; Optional[int]:\n    \"\"\"From Prague, new payload calls must use version 4.\"\"\"\n    return 4\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Prague.engine_forkchoice_updated_version","title":"<code>engine_forkchoice_updated_version(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>At Prague, version number of NewPayload and ForkchoiceUpdated diverge.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef engine_forkchoice_updated_version(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; Optional[int]:\n    \"\"\"At Prague, version number of NewPayload and ForkchoiceUpdated diverge.\"\"\"\n    return 3\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Shanghai","title":"<code>Shanghai</code>","text":"<p>               Bases: <code>Paris</code></p> <p>Shanghai fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Shanghai(Paris):\n    \"\"\"Shanghai fork.\"\"\"\n\n    @classmethod\n    def header_withdrawals_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n        \"\"\"Withdrawals are required starting from Shanghai.\"\"\"\n        return True\n\n    @classmethod\n    def engine_new_payload_version(\n        cls, block_number: int = 0, timestamp: int = 0\n    ) -&gt; Optional[int]:\n        \"\"\"From Shanghai, new payload calls must use version 2.\"\"\"\n        return 2\n\n    @classmethod\n    def valid_opcodes(\n        cls,\n    ) -&gt; List[Opcodes]:\n        \"\"\"Return list of Opcodes that are valid to work on this fork.\"\"\"\n        return [Opcodes.PUSH0] + super(Shanghai, cls).valid_opcodes()\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Shanghai.header_withdrawals_required","title":"<code>header_withdrawals_required(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>Withdrawals are required starting from Shanghai.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_withdrawals_required(cls, block_number: int = 0, timestamp: int = 0) -&gt; bool:\n    \"\"\"Withdrawals are required starting from Shanghai.\"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Shanghai.engine_new_payload_version","title":"<code>engine_new_payload_version(block_number=0, timestamp=0)</code>  <code>classmethod</code>","text":"<p>From Shanghai, new payload calls must use version 2.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef engine_new_payload_version(\n    cls, block_number: int = 0, timestamp: int = 0\n) -&gt; Optional[int]:\n    \"\"\"From Shanghai, new payload calls must use version 2.\"\"\"\n    return 2\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Shanghai.valid_opcodes","title":"<code>valid_opcodes()</code>  <code>classmethod</code>","text":"<p>Return list of Opcodes that are valid to work on this fork.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef valid_opcodes(\n    cls,\n) -&gt; List[Opcodes]:\n    \"\"\"Return list of Opcodes that are valid to work on this fork.\"\"\"\n    return [Opcodes.PUSH0] + super(Shanghai, cls).valid_opcodes()\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.BerlinToLondonAt5","title":"<code>BerlinToLondonAt5</code>","text":"<p>               Bases: <code>Berlin</code></p> <p>Berlin to London transition at Block 5.</p> Source code in <code>src/ethereum_test_forks/forks/transition.py</code> <pre><code>@transition_fork(to_fork=London, at_block=5)\nclass BerlinToLondonAt5(Berlin):\n    \"\"\"Berlin to London transition at Block 5.\"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.CancunToPragueAtTime15k","title":"<code>CancunToPragueAtTime15k</code>","text":"<p>               Bases: <code>Cancun</code></p> <p>Cancun to Prague transition at Timestamp 15k.</p> Source code in <code>src/ethereum_test_forks/forks/transition.py</code> <pre><code>@transition_fork(to_fork=Prague, at_timestamp=15_000)\nclass CancunToPragueAtTime15k(Cancun):\n    \"\"\"Cancun to Prague transition at Timestamp 15k.\"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.ParisToShanghaiAtTime15k","title":"<code>ParisToShanghaiAtTime15k</code>","text":"<p>               Bases: <code>Paris</code></p> <p>Paris to Shanghai transition at Timestamp 15k.</p> Source code in <code>src/ethereum_test_forks/forks/transition.py</code> <pre><code>@transition_fork(to_fork=Shanghai, at_timestamp=15_000)\nclass ParisToShanghaiAtTime15k(Paris, blockchain_test_network_name=\"ParisToShanghaiAtTime15k\"):\n    \"\"\"Paris to Shanghai transition at Timestamp 15k.\"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.ShanghaiToCancunAtTime15k","title":"<code>ShanghaiToCancunAtTime15k</code>","text":"<p>               Bases: <code>Shanghai</code></p> <p>Shanghai to Cancun transition at Timestamp 15k.</p> Source code in <code>src/ethereum_test_forks/forks/transition.py</code> <pre><code>@transition_fork(to_fork=Cancun, at_timestamp=15_000)\nclass ShanghaiToCancunAtTime15k(Shanghai):\n    \"\"\"Shanghai to Cancun transition at Timestamp 15k.\"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.GasCosts","title":"<code>GasCosts</code>  <code>dataclass</code>","text":"<p>Class that contains the gas cost constants for any fork.</p> Source code in <code>src/ethereum_test_forks/gas_costs.py</code> <pre><code>@dataclass(kw_only=True, frozen=True)\nclass GasCosts:\n    \"\"\"Class that contains the gas cost constants for any fork.\"\"\"\n\n    G_JUMPDEST: int\n    G_BASE: int\n    G_VERY_LOW: int\n    G_LOW: int\n    G_MID: int\n    G_HIGH: int\n    G_WARM_ACCOUNT_ACCESS: int\n    G_COLD_ACCOUNT_ACCESS: int\n    G_ACCESS_LIST_ADDRESS: int\n    G_ACCESS_LIST_STORAGE: int\n    G_WARM_SLOAD: int\n    G_COLD_SLOAD: int\n    G_STORAGE_SET: int\n    G_STORAGE_RESET: int\n\n    R_STORAGE_CLEAR: int\n\n    G_SELF_DESTRUCT: int\n    G_CREATE: int\n\n    G_CODE_DEPOSIT_BYTE: int\n    G_INITCODE_WORD: int\n\n    G_CALL_VALUE: int\n    G_CALL_STIPEND: int\n    G_NEW_ACCOUNT: int\n\n    G_EXP: int\n    G_EXP_BYTE: int\n\n    G_MEMORY: int\n\n    G_TX_DATA_ZERO: int\n    G_TX_DATA_NON_ZERO: int\n    G_TX_DATA_STANDARD_TOKEN_COST: int\n    G_TX_DATA_FLOOR_TOKEN_COST: int\n\n    G_TRANSACTION: int\n    G_TRANSACTION_CREATE: int\n\n    G_LOG: int\n    G_LOG_DATA: int\n    G_LOG_TOPIC: int\n\n    G_KECCAK_256: int\n    G_KECCAK_256_WORD: int\n\n    G_COPY: int\n    G_BLOCKHASH: int\n\n    G_AUTHORIZATION: int\n\n    R_AUTHORIZATION_EXISTING_AUTHORITY: int\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.InvalidForkError","title":"<code>InvalidForkError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Invalid fork error raised when the fork specified is not found or incompatible.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>class InvalidForkError(Exception):\n    \"\"\"Invalid fork error raised when the fork specified is not found or incompatible.\"\"\"\n\n    def __init__(self, message):\n        \"\"\"Initialize the InvalidForkError exception.\"\"\"\n        super().__init__(message)\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.InvalidForkError.__init__","title":"<code>__init__(message)</code>","text":"<p>Initialize the InvalidForkError exception.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def __init__(self, message):\n    \"\"\"Initialize the InvalidForkError exception.\"\"\"\n    super().__init__(message)\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks_from","title":"<code>forks_from(fork, deployed_only=True)</code>","text":"<p>Return specified fork and all forks after it.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def forks_from(fork: Fork, deployed_only: bool = True) -&gt; List[Fork]:\n    \"\"\"Return specified fork and all forks after it.\"\"\"\n    if deployed_only:\n        latest_fork = get_deployed_forks()[-1]\n    else:\n        latest_fork = get_forks()[-1]\n    return forks_from_until(fork, latest_fork)\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks_from_until","title":"<code>forks_from_until(fork_from, fork_until)</code>","text":"<p>Return specified fork and all forks after it until and including the second specified fork.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def forks_from_until(fork_from: Fork, fork_until: Fork) -&gt; List[Fork]:\n    \"\"\"\n    Return specified fork and all forks after it until and including the\n    second specified fork.\n    \"\"\"\n    prev_fork = fork_until\n\n    forks: List[Fork] = []\n\n    while prev_fork != BaseFork and prev_fork != fork_from:\n        forks.insert(0, prev_fork)\n\n        prev_fork = get_parent_fork(prev_fork)\n\n    if prev_fork == BaseFork:\n        return []\n\n    forks.insert(0, fork_from)\n\n    return forks\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.get_closest_fork_with_solc_support","title":"<code>get_closest_fork_with_solc_support(fork, solc_version)</code>","text":"<p>Return closest fork, potentially the provided fork itself, that has solc support.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def get_closest_fork_with_solc_support(fork: Fork, solc_version: Version) -&gt; Optional[Fork]:\n    \"\"\"\n    Return closest fork, potentially the provided fork itself, that has\n    solc support.\n    \"\"\"\n    if fork is BaseFork:\n        return None\n    return (\n        fork\n        if solc_version &gt;= fork.solc_min_version()\n        else get_closest_fork_with_solc_support(get_parent_fork(fork), solc_version)\n    )\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.get_deployed_forks","title":"<code>get_deployed_forks()</code>","text":"<p>Return list of all the fork classes implemented by <code>ethereum_test_forks</code> that have been deployed to mainnet, chronologically ordered by deployment.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def get_deployed_forks() -&gt; List[Fork]:\n    \"\"\"\n    Return list of all the fork classes implemented by `ethereum_test_forks`\n    that have been deployed to mainnet, chronologically ordered by deployment.\n    \"\"\"\n    return [fork for fork in get_forks() if fork.is_deployed()]\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.get_development_forks","title":"<code>get_development_forks()</code>","text":"<p>Return list of all the fork classes implemented by <code>ethereum_test_forks</code> that have been not yet deployed to mainnet and are currently under development. The list is ordered by their planned deployment date.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def get_development_forks() -&gt; List[Fork]:\n    \"\"\"\n    Return list of all the fork classes implemented by `ethereum_test_forks`\n    that have been not yet deployed to mainnet and are currently under\n    development. The list is ordered by their planned deployment date.\n    \"\"\"\n    return [fork for fork in get_forks() if not fork.is_deployed()]\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.get_forks","title":"<code>get_forks()</code>","text":"<p>Return list of all the fork classes implemented by <code>ethereum_test_forks</code> ordered chronologically by deployment.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def get_forks() -&gt; List[Fork]:\n    \"\"\"\n    Return list of all the fork classes implemented by\n    `ethereum_test_forks` ordered chronologically by deployment.\n    \"\"\"\n    all_forks: List[Fork] = []\n    for fork_name in forks.__dict__:\n        fork = forks.__dict__[fork_name]\n        if not isinstance(fork, type):\n            continue\n        if issubclass(fork, BaseFork) and fork is not BaseFork:\n            all_forks.append(fork)\n    return all_forks\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.get_forks_with_no_descendants","title":"<code>get_forks_with_no_descendants(forks)</code>","text":"<p>Get forks with no descendants in the inheritance hierarchy.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def get_forks_with_no_descendants(forks: Set[Fork]) -&gt; Set[Fork]:\n    \"\"\"Get forks with no descendants in the inheritance hierarchy.\"\"\"\n    resulting_forks: Set[Fork] = set()\n    for fork in forks:\n        descendants = False\n        for next_fork in forks - {fork}:\n            if next_fork &gt; fork:\n                descendants = True\n                break\n        if not descendants:\n            resulting_forks = resulting_forks | {fork}\n    return resulting_forks\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.get_forks_with_no_parents","title":"<code>get_forks_with_no_parents(forks)</code>","text":"<p>Get forks with no parents in the inheritance hierarchy.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def get_forks_with_no_parents(forks: Set[Fork]) -&gt; Set[Fork]:\n    \"\"\"Get forks with no parents in the inheritance hierarchy.\"\"\"\n    resulting_forks: Set[Fork] = set()\n    for fork in forks:\n        parents = False\n        for next_fork in forks - {fork}:\n            if next_fork &lt; fork:\n                parents = True\n                break\n        if not parents:\n            resulting_forks = resulting_forks | {fork}\n    return resulting_forks\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.get_forks_with_solc_support","title":"<code>get_forks_with_solc_support(solc_version)</code>","text":"<p>Return list of all fork classes that are supported by solc.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def get_forks_with_solc_support(solc_version: Version) -&gt; List[Fork]:\n    \"\"\"Return list of all fork classes that are supported by solc.\"\"\"\n    return [fork for fork in get_forks() if solc_version &gt;= fork.solc_min_version()]\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.get_forks_without_solc_support","title":"<code>get_forks_without_solc_support(solc_version)</code>","text":"<p>Return list of all fork classes that aren't supported by solc.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def get_forks_without_solc_support(solc_version: Version) -&gt; List[Fork]:\n    \"\"\"Return list of all fork classes that aren't supported by solc.\"\"\"\n    return [fork for fork in get_forks() if solc_version &lt; fork.solc_min_version()]\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.get_from_until_fork_set","title":"<code>get_from_until_fork_set(forks, forks_from, forks_until)</code>","text":"<p>Get fork range from forks_from to forks_until.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def get_from_until_fork_set(\n    forks: Set[Fork], forks_from: Set[Fork], forks_until: Set[Fork]\n) -&gt; Set[Fork]:\n    \"\"\"Get fork range from forks_from to forks_until.\"\"\"\n    resulting_set = set()\n    for fork_from in forks_from:\n        for fork_until in forks_until:\n            for fork in forks:\n                if fork &lt;= fork_until and fork &gt;= fork_from:\n                    resulting_set.add(fork)\n    return resulting_set\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.get_last_descendants","title":"<code>get_last_descendants(forks, forks_from)</code>","text":"<p>Get last descendant of a class in the inheritance hierarchy.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def get_last_descendants(forks: Set[Fork], forks_from: Set[Fork]) -&gt; Set[Fork]:\n    \"\"\"Get last descendant of a class in the inheritance hierarchy.\"\"\"\n    resulting_forks: Set[Fork] = set()\n    forks = get_forks_with_no_descendants(forks)\n    for fork_from in forks_from:\n        for fork in forks:\n            if fork &gt;= fork_from:\n                resulting_forks = resulting_forks | {fork}\n    return resulting_forks\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.get_relative_fork_markers","title":"<code>get_relative_fork_markers(fork_identifier, strict_mode=True)</code>","text":"<p>Return a list of marker names for a given fork.</p> <p>For a base fork (e.g. <code>Shanghai</code>), return [ <code>Shanghai</code> ]. For a transition fork (e.g. <code>ShanghaiToCancunAtTime15k</code> which transitions to <code>Cancun</code>), return [ <code>ShanghaiToCancunAtTime15k</code>, <code>Cancun</code> ].</p> <p>If <code>strict_mode</code> is set to <code>True</code>, raise an <code>InvalidForkError</code> if the fork is not found, otherwise, simply return the provided (str) <code>fork_identifier</code> (this is required to run <code>consume</code> with forks that are unknown to EEST).</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def get_relative_fork_markers(fork_identifier: Fork | str, strict_mode: bool = True) -&gt; list[str]:\n    \"\"\"\n    Return a list of marker names for a given fork.\n\n    For a base fork (e.g. `Shanghai`), return [ `Shanghai` ].\n    For a transition fork (e.g. `ShanghaiToCancunAtTime15k` which transitions to `Cancun`),\n    return [ `ShanghaiToCancunAtTime15k`, `Cancun` ].\n\n    If `strict_mode` is set to `True`, raise an `InvalidForkError` if the fork is not found,\n    otherwise, simply return the provided (str) `fork_identifier` (this is required to run\n    `consume` with forks that are unknown to EEST).\n    \"\"\"\n    all_forks = set(get_forks()) | set(get_transition_forks())\n    if isinstance(fork_identifier, str):\n        fork_class = None\n        for candidate in all_forks:\n            if candidate.name() == fork_identifier:\n                fork_class = candidate\n                break\n        if strict_mode and fork_class is None:\n            raise InvalidForkError(f\"Unknown fork: {fork_identifier}\")\n        return [fork_identifier]\n    else:\n        fork_class = fork_identifier\n\n    if issubclass(fork_class, TransitionBaseClass):\n        return [fork_class.name(), fork_class.transitions_to().name()]\n    else:\n        return [fork_class.name()]\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.get_transition_fork_predecessor","title":"<code>get_transition_fork_predecessor(transition_fork)</code>","text":"<p>Return the fork from which the transition fork transitions.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def get_transition_fork_predecessor(transition_fork: Fork) -&gt; Fork:\n    \"\"\"Return the fork from which the transition fork transitions.\"\"\"\n    if not issubclass(transition_fork, TransitionBaseClass):\n        raise InvalidForkError(f\"{transition_fork} is not a transition fork.\")\n    return transition_fork.transitions_from()\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.get_transition_fork_successor","title":"<code>get_transition_fork_successor(transition_fork)</code>","text":"<p>Return the fork to which the transition fork transitions.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def get_transition_fork_successor(transition_fork: Fork) -&gt; Fork:\n    \"\"\"Return the fork to which the transition fork transitions.\"\"\"\n    if not issubclass(transition_fork, TransitionBaseClass):\n        raise InvalidForkError(f\"{transition_fork} is not a transition fork.\")\n    return transition_fork.transitions_to()\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.get_transition_forks","title":"<code>get_transition_forks()</code>","text":"<p>Return all the transition forks.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def get_transition_forks() -&gt; Set[Fork]:\n    \"\"\"Return all the transition forks.\"\"\"\n    transition_forks: Set[Fork] = set()\n\n    for fork_name in transition.__dict__:\n        fork = transition.__dict__[fork_name]\n        if not isinstance(fork, type):\n            continue\n        if issubclass(fork, TransitionBaseClass) and issubclass(fork, BaseFork):\n            transition_forks.add(fork)\n\n    return transition_forks\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.transition_fork_from_to","title":"<code>transition_fork_from_to(fork_from, fork_to)</code>","text":"<p>Return transition fork that transitions to and from the specified forks.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def transition_fork_from_to(fork_from: Fork, fork_to: Fork) -&gt; Fork | None:\n    \"\"\"\n    Return transition fork that transitions to and from the specified\n    forks.\n    \"\"\"\n    for transition_fork in get_transition_forks():\n        if not issubclass(transition_fork, TransitionBaseClass):\n            continue\n        if (\n            transition_fork.transitions_to() == fork_to\n            and transition_fork.transitions_from() == fork_from\n        ):\n            return transition_fork\n\n    return None\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.transition_fork_to","title":"<code>transition_fork_to(fork_to)</code>","text":"<p>Return transition fork that transitions to the specified fork.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def transition_fork_to(fork_to: Fork) -&gt; Set[Fork]:\n    \"\"\"Return transition fork that transitions to the specified fork.\"\"\"\n    transition_forks: Set[Fork] = set()\n    for transition_fork in get_transition_forks():\n        if not issubclass(transition_fork, TransitionBaseClass):\n            continue\n        if transition_fork.transitions_to() == fork_to:\n            transition_forks.add(transition_fork)\n\n    return transition_forks\n</code></pre>"},{"location":"library/ethereum_test_specs/","title":"Ethereum Test Specs package","text":"<p>Test spec definitions and utilities.</p>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.BaseTest","title":"<code>BaseTest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a base Ethereum test which must return a single test fixture.</p> Source code in <code>src/ethereum_test_specs/base.py</code> <pre><code>class BaseTest(BaseModel):\n    \"\"\"Represents a base Ethereum test which must return a single test fixture.\"\"\"\n\n    tag: str = \"\"\n\n    # Transition tool specific fields\n    t8n_dump_dir: Path | None = Field(None, exclude=True)\n    _t8n_call_counter: Iterator[int] = count(0)\n\n    supported_fixture_formats: ClassVar[Sequence[FixtureFormat | LabeledFixtureFormat]] = []\n    supported_execute_formats: ClassVar[Sequence[ExecuteFormat | LabeledExecuteFormat]] = []\n\n    supported_markers: ClassVar[Dict[str, str]] = {}\n\n    @classmethod\n    def discard_fixture_format_by_marks(\n        cls,\n        fixture_format: FixtureFormat,\n        fork: Fork,\n        markers: List[pytest.Mark],\n    ) -&gt; bool:\n        \"\"\"Discard a fixture format from filling if the appropriate marker is used.\"\"\"\n        return False\n\n    @classmethod\n    def discard_execute_format_by_marks(\n        cls,\n        execute_format: ExecuteFormat,\n        fork: Fork,\n        markers: List[pytest.Mark],\n    ) -&gt; bool:\n        \"\"\"Discard an execute format from executing if the appropriate marker is used.\"\"\"\n        return False\n\n    @abstractmethod\n    def generate(\n        self,\n        *,\n        request: pytest.FixtureRequest,\n        t8n: TransitionTool,\n        fork: Fork,\n        fixture_format: FixtureFormat,\n        eips: Optional[List[int]] = None,\n    ) -&gt; BaseFixture:\n        \"\"\"Generate the list of test fixtures.\"\"\"\n        pass\n\n    def execute(\n        self,\n        *,\n        fork: Fork,\n        execute_format: ExecuteFormat,\n        eips: Optional[List[int]] = None,\n    ) -&gt; BaseExecute:\n        \"\"\"Generate the list of test fixtures.\"\"\"\n        raise Exception(f\"Unsupported execute format: {execute_format}\")\n\n    @classmethod\n    def pytest_parameter_name(cls) -&gt; str:\n        \"\"\"\n        Must return the name of the parameter used in pytest to select this\n        spec type as filler for the test.\n\n        By default, it returns the underscore separated name of the class.\n        \"\"\"\n        return reduce(lambda x, y: x + (\"_\" if y.isupper() else \"\") + y, cls.__name__).lower()\n\n    def get_next_transition_tool_output_path(self) -&gt; str:\n        \"\"\"Return path to the next transition tool output file.\"\"\"\n        if not self.t8n_dump_dir:\n            return \"\"\n        return path.join(\n            self.t8n_dump_dir,\n            str(next(self._t8n_call_counter)),\n        )\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.BaseTest.discard_fixture_format_by_marks","title":"<code>discard_fixture_format_by_marks(fixture_format, fork, markers)</code>  <code>classmethod</code>","text":"<p>Discard a fixture format from filling if the appropriate marker is used.</p> Source code in <code>src/ethereum_test_specs/base.py</code> <pre><code>@classmethod\ndef discard_fixture_format_by_marks(\n    cls,\n    fixture_format: FixtureFormat,\n    fork: Fork,\n    markers: List[pytest.Mark],\n) -&gt; bool:\n    \"\"\"Discard a fixture format from filling if the appropriate marker is used.\"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.BaseTest.discard_execute_format_by_marks","title":"<code>discard_execute_format_by_marks(execute_format, fork, markers)</code>  <code>classmethod</code>","text":"<p>Discard an execute format from executing if the appropriate marker is used.</p> Source code in <code>src/ethereum_test_specs/base.py</code> <pre><code>@classmethod\ndef discard_execute_format_by_marks(\n    cls,\n    execute_format: ExecuteFormat,\n    fork: Fork,\n    markers: List[pytest.Mark],\n) -&gt; bool:\n    \"\"\"Discard an execute format from executing if the appropriate marker is used.\"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.BaseTest.generate","title":"<code>generate(*, request, t8n, fork, fixture_format, eips=None)</code>  <code>abstractmethod</code>","text":"<p>Generate the list of test fixtures.</p> Source code in <code>src/ethereum_test_specs/base.py</code> <pre><code>@abstractmethod\ndef generate(\n    self,\n    *,\n    request: pytest.FixtureRequest,\n    t8n: TransitionTool,\n    fork: Fork,\n    fixture_format: FixtureFormat,\n    eips: Optional[List[int]] = None,\n) -&gt; BaseFixture:\n    \"\"\"Generate the list of test fixtures.\"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.BaseTest.execute","title":"<code>execute(*, fork, execute_format, eips=None)</code>","text":"<p>Generate the list of test fixtures.</p> Source code in <code>src/ethereum_test_specs/base.py</code> <pre><code>def execute(\n    self,\n    *,\n    fork: Fork,\n    execute_format: ExecuteFormat,\n    eips: Optional[List[int]] = None,\n) -&gt; BaseExecute:\n    \"\"\"Generate the list of test fixtures.\"\"\"\n    raise Exception(f\"Unsupported execute format: {execute_format}\")\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.BaseTest.pytest_parameter_name","title":"<code>pytest_parameter_name()</code>  <code>classmethod</code>","text":"<p>Must return the name of the parameter used in pytest to select this spec type as filler for the test.</p> <p>By default, it returns the underscore separated name of the class.</p> Source code in <code>src/ethereum_test_specs/base.py</code> <pre><code>@classmethod\ndef pytest_parameter_name(cls) -&gt; str:\n    \"\"\"\n    Must return the name of the parameter used in pytest to select this\n    spec type as filler for the test.\n\n    By default, it returns the underscore separated name of the class.\n    \"\"\"\n    return reduce(lambda x, y: x + (\"_\" if y.isupper() else \"\") + y, cls.__name__).lower()\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.BaseTest.get_next_transition_tool_output_path","title":"<code>get_next_transition_tool_output_path()</code>","text":"<p>Return path to the next transition tool output file.</p> Source code in <code>src/ethereum_test_specs/base.py</code> <pre><code>def get_next_transition_tool_output_path(self) -&gt; str:\n    \"\"\"Return path to the next transition tool output file.\"\"\"\n    if not self.t8n_dump_dir:\n        return \"\"\n    return path.join(\n        self.t8n_dump_dir,\n        str(next(self._t8n_call_counter)),\n    )\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.BlockchainTest","title":"<code>BlockchainTest</code>","text":"<p>               Bases: <code>BaseTest</code></p> <p>Filler type that tests multiple blocks (valid or invalid) in a chain.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>class BlockchainTest(BaseTest):\n    \"\"\"Filler type that tests multiple blocks (valid or invalid) in a chain.\"\"\"\n\n    pre: Alloc\n    post: Alloc\n    blocks: List[Block]\n    genesis_environment: Environment = Field(default_factory=Environment)\n    verify_sync: bool = False\n    chain_id: int = 1\n\n    supported_fixture_formats: ClassVar[Sequence[FixtureFormat | LabeledFixtureFormat]] = [\n        BlockchainFixture,\n        BlockchainEngineFixture,\n    ]\n    supported_execute_formats: ClassVar[Sequence[ExecuteFormat | LabeledExecuteFormat]] = [\n        TransactionPost,\n    ]\n\n    supported_markers: ClassVar[Dict[str, str]] = {\n        \"blockchain_test_engine_only\": \"Only generate a blockchain test engine fixture\",\n        \"blockchain_test_only\": \"Only generate a blockchain test fixture\",\n    }\n\n    @classmethod\n    def discard_fixture_format_by_marks(\n        cls,\n        fixture_format: FixtureFormat,\n        fork: Fork,\n        markers: List[pytest.Mark],\n    ) -&gt; bool:\n        \"\"\"Discard a fixture format from filling if the appropriate marker is used.\"\"\"\n        if \"blockchain_test_only\" in [m.name for m in markers]:\n            return fixture_format != BlockchainFixture\n        if \"blockchain_test_engine_only\" in [m.name for m in markers]:\n            return fixture_format != BlockchainEngineFixture\n        return False\n\n    @staticmethod\n    def make_genesis(\n        genesis_environment: Environment,\n        pre: Alloc,\n        fork: Fork,\n    ) -&gt; Tuple[Alloc, FixtureBlock]:\n        \"\"\"Create a genesis block from the blockchain test definition.\"\"\"\n        env = genesis_environment.set_fork_requirements(fork)\n        assert env.withdrawals is None or len(env.withdrawals) == 0, (\n            \"withdrawals must be empty at genesis\"\n        )\n        assert env.parent_beacon_block_root is None or env.parent_beacon_block_root == Hash(0), (\n            \"parent_beacon_block_root must be empty at genesis\"\n        )\n\n        pre_alloc = Alloc.merge(\n            Alloc.model_validate(fork.pre_allocation_blockchain()),\n            pre,\n        )\n        if empty_accounts := pre_alloc.empty_accounts():\n            raise Exception(f\"Empty accounts in pre state: {empty_accounts}\")\n        state_root = pre_alloc.state_root()\n        genesis = FixtureHeader(\n            parent_hash=0,\n            ommers_hash=EmptyOmmersRoot,\n            fee_recipient=0,\n            state_root=state_root,\n            transactions_trie=EmptyTrieRoot,\n            receipts_root=EmptyTrieRoot,\n            logs_bloom=0,\n            difficulty=0x20000 if env.difficulty is None else env.difficulty,\n            number=0,\n            gas_limit=env.gas_limit,\n            gas_used=0,\n            timestamp=0,\n            extra_data=b\"\\x00\",\n            prev_randao=0,\n            nonce=0,\n            base_fee_per_gas=env.base_fee_per_gas,\n            blob_gas_used=env.blob_gas_used,\n            excess_blob_gas=env.excess_blob_gas,\n            withdrawals_root=(\n                Withdrawal.list_root(env.withdrawals) if env.withdrawals is not None else None\n            ),\n            parent_beacon_block_root=env.parent_beacon_block_root,\n            requests_hash=Requests() if fork.header_requests_required(0, 0) else None,\n            fork=fork,\n        )\n\n        return (\n            pre_alloc,\n            FixtureBlockBase(\n                header=genesis,\n                withdrawals=None if env.withdrawals is None else [],\n            ).with_rlp(txs=[]),\n        )\n\n    def generate_block_data(\n        self,\n        t8n: TransitionTool,\n        fork: Fork,\n        block: Block,\n        previous_env: Environment,\n        previous_alloc: Alloc,\n        eips: Optional[List[int]] = None,\n        slow: bool = False,\n    ) -&gt; Tuple[FixtureHeader, List[Transaction], List[Bytes] | None, Alloc, Environment]:\n        \"\"\"Generate common block data for both make_fixture and make_hive_fixture.\"\"\"\n        if block.rlp and block.exception is not None:\n            raise Exception(\n                \"test correctness: post-state cannot be verified if the \"\n                + \"block's rlp is supplied and the block is not supposed \"\n                + \"to produce an exception\"\n            )\n\n        env = block.set_environment(previous_env)\n        env = env.set_fork_requirements(fork)\n\n        txs = [tx.with_signature_and_sender() for tx in block.txs]\n\n        if failing_tx_count := len([tx for tx in txs if tx.error]) &gt; 0:\n            if failing_tx_count &gt; 1:\n                raise Exception(\n                    \"test correctness: only one transaction can produce an exception in a block\"\n                )\n            if not txs[-1].error:\n                raise Exception(\n                    \"test correctness: the transaction that produces an exception \"\n                    + \"must be the last transaction in the block\"\n                )\n\n        transition_tool_output = t8n.evaluate(\n            alloc=previous_alloc,\n            txs=txs,\n            env=env,\n            fork=fork,\n            chain_id=self.chain_id,\n            reward=fork.get_reward(env.number, env.timestamp),\n            blob_schedule=fork.blob_schedule(),\n            eips=eips,\n            debug_output_path=self.get_next_transition_tool_output_path(),\n            slow_request=slow,\n        )\n\n        try:\n            rejected_txs = verify_transactions(\n                txs=txs,\n                exception_mapper=t8n.exception_mapper,\n                result=transition_tool_output.result,\n            )\n            verify_result(transition_tool_output.result, env)\n        except Exception as e:\n            print_traces(t8n.get_traces())\n            pprint(transition_tool_output.result)\n            pprint(previous_alloc)\n            pprint(transition_tool_output.alloc)\n            raise e\n\n        if len(rejected_txs) &gt; 0 and block.exception is None:\n            print_traces(t8n.get_traces())\n            raise Exception(\n                \"one or more transactions in `BlockchainTest` are \"\n                + \"intrinsically invalid, but the block was not expected \"\n                + \"to be invalid. Please verify whether the transaction \"\n                + \"was indeed expected to fail and add the proper \"\n                + \"`block.exception`\"\n            )\n\n        # One special case of the invalid transactions is the blob gas used, since this value\n        # is not included in the transition tool result, but it is included in the block header,\n        # and some clients check it before executing the block by simply counting the type-3 txs,\n        # we need to set the correct value by default.\n        blob_gas_used: int | None = None\n        if (blob_gas_per_blob := fork.blob_gas_per_blob(env.number, env.timestamp)) &gt; 0:\n            blob_gas_used = blob_gas_per_blob * count_blobs(txs)\n\n        header = FixtureHeader(\n            **(\n                transition_tool_output.result.model_dump(\n                    exclude_none=True, exclude={\"blob_gas_used\", \"transactions_trie\"}\n                )\n                | env.model_dump(exclude_none=True, exclude={\"blob_gas_used\"})\n            ),\n            blob_gas_used=blob_gas_used,\n            transactions_trie=Transaction.list_root(txs),\n            extra_data=block.extra_data if block.extra_data is not None else b\"\",\n            fork=fork,\n        )\n\n        if block.header_verify is not None:\n            # Verify the header after transition tool processing.\n            block.header_verify.verify(header)\n\n        requests_list: List[Bytes] | None = None\n        if fork.header_requests_required(header.number, header.timestamp):\n            assert transition_tool_output.result.requests is not None, (\n                \"Requests are required for this block\"\n            )\n            requests = Requests(requests_lists=list(transition_tool_output.result.requests))\n\n            if Hash(requests) != header.requests_hash:\n                raise Exception(\n                    \"Requests root in header does not match the requests root in the transition \"\n                    \"tool output: \"\n                    f\"{header.requests_hash} != {Hash(requests)}\"\n                )\n\n            requests_list = requests.requests_list\n\n        if block.requests is not None:\n            header.requests_hash = Hash(Requests(requests_lists=list(block.requests)))\n            requests_list = block.requests\n\n        if block.rlp_modifier is not None:\n            # Modify any parameter specified in the `rlp_modifier` after\n            # transition tool processing.\n            header = block.rlp_modifier.apply(header)\n            header.fork = fork  # Deleted during `apply` because `exclude=True`\n\n        return (\n            header,\n            txs,\n            requests_list,\n            transition_tool_output.alloc,\n            env,\n        )\n\n    @staticmethod\n    def network_info(fork: Fork, eips: Optional[List[int]] = None):\n        \"\"\"Return fixture network information for the fork &amp; EIP/s.\"\"\"\n        return (\n            \"+\".join([fork.blockchain_test_network_name()] + [str(eip) for eip in eips])\n            if eips\n            else fork.blockchain_test_network_name()\n        )\n\n    def verify_post_state(self, t8n, t8n_state: Alloc, expected_state: Alloc | None = None):\n        \"\"\"Verify post alloc after all block/s or payload/s are generated.\"\"\"\n        try:\n            if expected_state:\n                expected_state.verify_post_alloc(t8n_state)\n            else:\n                self.post.verify_post_alloc(t8n_state)\n        except Exception as e:\n            print_traces(t8n.get_traces())\n            raise e\n\n    def make_fixture(\n        self,\n        t8n: TransitionTool,\n        fork: Fork,\n        eips: Optional[List[int]] = None,\n        slow: bool = False,\n    ) -&gt; BlockchainFixture:\n        \"\"\"Create a fixture from the blockchain test definition.\"\"\"\n        fixture_blocks: List[FixtureBlock | InvalidFixtureBlock] = []\n\n        pre, genesis = BlockchainTest.make_genesis(self.genesis_environment, self.pre, fork)\n\n        alloc = pre\n        env = environment_from_parent_header(genesis.header)\n        head = genesis.header.block_hash\n\n        for block in self.blocks:\n            if block.rlp is None:\n                # This is the most common case, the RLP needs to be constructed\n                # based on the transactions to be included in the block.\n                # Set the environment according to the block to execute.\n                header, txs, _, new_alloc, new_env = self.generate_block_data(\n                    t8n=t8n,\n                    fork=fork,\n                    block=block,\n                    previous_env=env,\n                    previous_alloc=alloc,\n                    eips=eips,\n                    slow=slow,\n                )\n                fixture_block = FixtureBlockBase(\n                    header=header,\n                    txs=[FixtureTransaction.from_transaction(tx) for tx in txs],\n                    ommers=[],\n                    withdrawals=(\n                        [FixtureWithdrawal.from_withdrawal(w) for w in new_env.withdrawals]\n                        if new_env.withdrawals is not None\n                        else None\n                    ),\n                    fork=fork,\n                ).with_rlp(txs=txs)\n                if block.exception is None:\n                    fixture_blocks.append(fixture_block)\n                    # Update env, alloc and last block hash for the next block.\n                    alloc = new_alloc\n                    env = apply_new_parent(new_env, header)\n                    head = header.block_hash\n                else:\n                    fixture_blocks.append(\n                        InvalidFixtureBlock(\n                            rlp=fixture_block.rlp,\n                            expect_exception=block.exception,\n                            rlp_decoded=(\n                                None\n                                if BlockException.RLP_STRUCTURES_ENCODING in block.exception\n                                else fixture_block.without_rlp()\n                            ),\n                        ),\n                    )\n            else:\n                assert block.exception is not None, (\n                    \"test correctness: if the block's rlp is hard-coded, \"\n                    + \"the block is expected to produce an exception\"\n                )\n                fixture_blocks.append(\n                    InvalidFixtureBlock(\n                        rlp=block.rlp,\n                        expect_exception=block.exception,\n                    ),\n                )\n\n            if block.expected_post_state:\n                self.verify_post_state(\n                    t8n, t8n_state=alloc, expected_state=block.expected_post_state\n                )\n\n        self.verify_post_state(t8n, t8n_state=alloc)\n        network_info = BlockchainTest.network_info(fork, eips)\n        return BlockchainFixture(\n            fork=network_info,\n            genesis=genesis.header,\n            genesis_rlp=genesis.rlp,\n            blocks=fixture_blocks,\n            last_block_hash=head,\n            pre=pre,\n            post_state=alloc,\n            config=FixtureConfig(\n                fork=network_info,\n                blob_schedule=FixtureBlobSchedule.from_blob_schedule(fork.blob_schedule()),\n                chain_id=self.chain_id,\n            ),\n        )\n\n    def make_hive_fixture(\n        self,\n        t8n: TransitionTool,\n        fork: Fork,\n        eips: Optional[List[int]] = None,\n        slow: bool = False,\n    ) -&gt; BlockchainEngineFixture:\n        \"\"\"Create a hive fixture from the blocktest definition.\"\"\"\n        fixture_payloads: List[FixtureEngineNewPayload] = []\n\n        pre, genesis = BlockchainTest.make_genesis(self.genesis_environment, self.pre, fork)\n        alloc = pre\n        env = environment_from_parent_header(genesis.header)\n        head_hash = genesis.header.block_hash\n\n        for block in self.blocks:\n            header, txs, requests, new_alloc, new_env = self.generate_block_data(\n                t8n=t8n,\n                fork=fork,\n                block=block,\n                previous_env=env,\n                previous_alloc=alloc,\n                eips=eips,\n                slow=slow,\n            )\n            if block.rlp is None:\n                fixture_payloads.append(\n                    FixtureEngineNewPayload.from_fixture_header(\n                        fork=fork,\n                        header=header,\n                        transactions=txs,\n                        withdrawals=new_env.withdrawals,\n                        requests=requests,\n                        validation_error=block.exception,\n                        error_code=block.engine_api_error_code,\n                    )\n                )\n                if block.exception is None:\n                    alloc = new_alloc\n                    env = apply_new_parent(env, header)\n                    head_hash = header.block_hash\n\n            if block.expected_post_state:\n                self.verify_post_state(\n                    t8n, t8n_state=alloc, expected_state=block.expected_post_state\n                )\n\n        fcu_version = fork.engine_forkchoice_updated_version(header.number, header.timestamp)\n        assert fcu_version is not None, (\n            \"A hive fixture was requested but no forkchoice update is defined.\"\n            \" The framework should never try to execute this test case.\"\n        )\n\n        self.verify_post_state(t8n, t8n_state=alloc)\n\n        sync_payload: Optional[FixtureEngineNewPayload] = None\n        if self.verify_sync:\n            # Test is marked for syncing verification.\n            assert genesis.header.block_hash != head_hash, (\n                \"Invalid payload tests negative test via sync is not supported yet.\"\n            )\n\n            # Most clients require the header to start the sync process, so we create an empty\n            # block on top of the last block of the test to send it as new payload and trigger the\n            # sync process.\n            sync_header, _, requests, _, _ = self.generate_block_data(\n                t8n=t8n,\n                fork=fork,\n                block=Block(),\n                previous_env=env,\n                previous_alloc=alloc,\n                eips=eips,\n            )\n            sync_payload = FixtureEngineNewPayload.from_fixture_header(\n                fork=fork,\n                header=sync_header,\n                transactions=[],\n                withdrawals=[],\n                requests=requests,\n                validation_error=None,\n                error_code=None,\n            )\n\n        network_info = BlockchainTest.network_info(fork, eips)\n        return BlockchainEngineFixture(\n            fork=network_info,\n            genesis=genesis.header,\n            payloads=fixture_payloads,\n            fcu_version=fcu_version,\n            pre=pre,\n            post_state=alloc,\n            sync_payload=sync_payload,\n            last_block_hash=head_hash,\n            config=FixtureConfig(\n                fork=network_info,\n                chain_id=self.chain_id,\n                blob_schedule=FixtureBlobSchedule.from_blob_schedule(fork.blob_schedule()),\n            ),\n        )\n\n    def generate(\n        self,\n        request: pytest.FixtureRequest,\n        t8n: TransitionTool,\n        fork: Fork,\n        fixture_format: FixtureFormat,\n        eips: Optional[List[int]] = None,\n    ) -&gt; BaseFixture:\n        \"\"\"Generate the BlockchainTest fixture.\"\"\"\n        t8n.reset_traces()\n        if fixture_format == BlockchainEngineFixture:\n            return self.make_hive_fixture(t8n, fork, eips, slow=is_slow_test(request))\n        elif fixture_format == BlockchainFixture:\n            return self.make_fixture(t8n, fork, eips, slow=is_slow_test(request))\n\n        raise Exception(f\"Unknown fixture format: {fixture_format}\")\n\n    def execute(\n        self,\n        *,\n        fork: Fork,\n        execute_format: ExecuteFormat,\n        eips: Optional[List[int]] = None,\n    ) -&gt; BaseExecute:\n        \"\"\"Generate the list of test fixtures.\"\"\"\n        if execute_format == TransactionPost:\n            txs: List[Transaction] = []\n            for block in self.blocks:\n                txs += block.txs\n            return TransactionPost(\n                transactions=txs,\n                post=self.post,\n            )\n        raise Exception(f\"Unsupported execute format: {execute_format}\")\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.BlockchainTest.discard_fixture_format_by_marks","title":"<code>discard_fixture_format_by_marks(fixture_format, fork, markers)</code>  <code>classmethod</code>","text":"<p>Discard a fixture format from filling if the appropriate marker is used.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>@classmethod\ndef discard_fixture_format_by_marks(\n    cls,\n    fixture_format: FixtureFormat,\n    fork: Fork,\n    markers: List[pytest.Mark],\n) -&gt; bool:\n    \"\"\"Discard a fixture format from filling if the appropriate marker is used.\"\"\"\n    if \"blockchain_test_only\" in [m.name for m in markers]:\n        return fixture_format != BlockchainFixture\n    if \"blockchain_test_engine_only\" in [m.name for m in markers]:\n        return fixture_format != BlockchainEngineFixture\n    return False\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.BlockchainTest.make_genesis","title":"<code>make_genesis(genesis_environment, pre, fork)</code>  <code>staticmethod</code>","text":"<p>Create a genesis block from the blockchain test definition.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>@staticmethod\ndef make_genesis(\n    genesis_environment: Environment,\n    pre: Alloc,\n    fork: Fork,\n) -&gt; Tuple[Alloc, FixtureBlock]:\n    \"\"\"Create a genesis block from the blockchain test definition.\"\"\"\n    env = genesis_environment.set_fork_requirements(fork)\n    assert env.withdrawals is None or len(env.withdrawals) == 0, (\n        \"withdrawals must be empty at genesis\"\n    )\n    assert env.parent_beacon_block_root is None or env.parent_beacon_block_root == Hash(0), (\n        \"parent_beacon_block_root must be empty at genesis\"\n    )\n\n    pre_alloc = Alloc.merge(\n        Alloc.model_validate(fork.pre_allocation_blockchain()),\n        pre,\n    )\n    if empty_accounts := pre_alloc.empty_accounts():\n        raise Exception(f\"Empty accounts in pre state: {empty_accounts}\")\n    state_root = pre_alloc.state_root()\n    genesis = FixtureHeader(\n        parent_hash=0,\n        ommers_hash=EmptyOmmersRoot,\n        fee_recipient=0,\n        state_root=state_root,\n        transactions_trie=EmptyTrieRoot,\n        receipts_root=EmptyTrieRoot,\n        logs_bloom=0,\n        difficulty=0x20000 if env.difficulty is None else env.difficulty,\n        number=0,\n        gas_limit=env.gas_limit,\n        gas_used=0,\n        timestamp=0,\n        extra_data=b\"\\x00\",\n        prev_randao=0,\n        nonce=0,\n        base_fee_per_gas=env.base_fee_per_gas,\n        blob_gas_used=env.blob_gas_used,\n        excess_blob_gas=env.excess_blob_gas,\n        withdrawals_root=(\n            Withdrawal.list_root(env.withdrawals) if env.withdrawals is not None else None\n        ),\n        parent_beacon_block_root=env.parent_beacon_block_root,\n        requests_hash=Requests() if fork.header_requests_required(0, 0) else None,\n        fork=fork,\n    )\n\n    return (\n        pre_alloc,\n        FixtureBlockBase(\n            header=genesis,\n            withdrawals=None if env.withdrawals is None else [],\n        ).with_rlp(txs=[]),\n    )\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.BlockchainTest.generate_block_data","title":"<code>generate_block_data(t8n, fork, block, previous_env, previous_alloc, eips=None, slow=False)</code>","text":"<p>Generate common block data for both make_fixture and make_hive_fixture.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>def generate_block_data(\n    self,\n    t8n: TransitionTool,\n    fork: Fork,\n    block: Block,\n    previous_env: Environment,\n    previous_alloc: Alloc,\n    eips: Optional[List[int]] = None,\n    slow: bool = False,\n) -&gt; Tuple[FixtureHeader, List[Transaction], List[Bytes] | None, Alloc, Environment]:\n    \"\"\"Generate common block data for both make_fixture and make_hive_fixture.\"\"\"\n    if block.rlp and block.exception is not None:\n        raise Exception(\n            \"test correctness: post-state cannot be verified if the \"\n            + \"block's rlp is supplied and the block is not supposed \"\n            + \"to produce an exception\"\n        )\n\n    env = block.set_environment(previous_env)\n    env = env.set_fork_requirements(fork)\n\n    txs = [tx.with_signature_and_sender() for tx in block.txs]\n\n    if failing_tx_count := len([tx for tx in txs if tx.error]) &gt; 0:\n        if failing_tx_count &gt; 1:\n            raise Exception(\n                \"test correctness: only one transaction can produce an exception in a block\"\n            )\n        if not txs[-1].error:\n            raise Exception(\n                \"test correctness: the transaction that produces an exception \"\n                + \"must be the last transaction in the block\"\n            )\n\n    transition_tool_output = t8n.evaluate(\n        alloc=previous_alloc,\n        txs=txs,\n        env=env,\n        fork=fork,\n        chain_id=self.chain_id,\n        reward=fork.get_reward(env.number, env.timestamp),\n        blob_schedule=fork.blob_schedule(),\n        eips=eips,\n        debug_output_path=self.get_next_transition_tool_output_path(),\n        slow_request=slow,\n    )\n\n    try:\n        rejected_txs = verify_transactions(\n            txs=txs,\n            exception_mapper=t8n.exception_mapper,\n            result=transition_tool_output.result,\n        )\n        verify_result(transition_tool_output.result, env)\n    except Exception as e:\n        print_traces(t8n.get_traces())\n        pprint(transition_tool_output.result)\n        pprint(previous_alloc)\n        pprint(transition_tool_output.alloc)\n        raise e\n\n    if len(rejected_txs) &gt; 0 and block.exception is None:\n        print_traces(t8n.get_traces())\n        raise Exception(\n            \"one or more transactions in `BlockchainTest` are \"\n            + \"intrinsically invalid, but the block was not expected \"\n            + \"to be invalid. Please verify whether the transaction \"\n            + \"was indeed expected to fail and add the proper \"\n            + \"`block.exception`\"\n        )\n\n    # One special case of the invalid transactions is the blob gas used, since this value\n    # is not included in the transition tool result, but it is included in the block header,\n    # and some clients check it before executing the block by simply counting the type-3 txs,\n    # we need to set the correct value by default.\n    blob_gas_used: int | None = None\n    if (blob_gas_per_blob := fork.blob_gas_per_blob(env.number, env.timestamp)) &gt; 0:\n        blob_gas_used = blob_gas_per_blob * count_blobs(txs)\n\n    header = FixtureHeader(\n        **(\n            transition_tool_output.result.model_dump(\n                exclude_none=True, exclude={\"blob_gas_used\", \"transactions_trie\"}\n            )\n            | env.model_dump(exclude_none=True, exclude={\"blob_gas_used\"})\n        ),\n        blob_gas_used=blob_gas_used,\n        transactions_trie=Transaction.list_root(txs),\n        extra_data=block.extra_data if block.extra_data is not None else b\"\",\n        fork=fork,\n    )\n\n    if block.header_verify is not None:\n        # Verify the header after transition tool processing.\n        block.header_verify.verify(header)\n\n    requests_list: List[Bytes] | None = None\n    if fork.header_requests_required(header.number, header.timestamp):\n        assert transition_tool_output.result.requests is not None, (\n            \"Requests are required for this block\"\n        )\n        requests = Requests(requests_lists=list(transition_tool_output.result.requests))\n\n        if Hash(requests) != header.requests_hash:\n            raise Exception(\n                \"Requests root in header does not match the requests root in the transition \"\n                \"tool output: \"\n                f\"{header.requests_hash} != {Hash(requests)}\"\n            )\n\n        requests_list = requests.requests_list\n\n    if block.requests is not None:\n        header.requests_hash = Hash(Requests(requests_lists=list(block.requests)))\n        requests_list = block.requests\n\n    if block.rlp_modifier is not None:\n        # Modify any parameter specified in the `rlp_modifier` after\n        # transition tool processing.\n        header = block.rlp_modifier.apply(header)\n        header.fork = fork  # Deleted during `apply` because `exclude=True`\n\n    return (\n        header,\n        txs,\n        requests_list,\n        transition_tool_output.alloc,\n        env,\n    )\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.BlockchainTest.network_info","title":"<code>network_info(fork, eips=None)</code>  <code>staticmethod</code>","text":"<p>Return fixture network information for the fork &amp; EIP/s.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>@staticmethod\ndef network_info(fork: Fork, eips: Optional[List[int]] = None):\n    \"\"\"Return fixture network information for the fork &amp; EIP/s.\"\"\"\n    return (\n        \"+\".join([fork.blockchain_test_network_name()] + [str(eip) for eip in eips])\n        if eips\n        else fork.blockchain_test_network_name()\n    )\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.BlockchainTest.verify_post_state","title":"<code>verify_post_state(t8n, t8n_state, expected_state=None)</code>","text":"<p>Verify post alloc after all block/s or payload/s are generated.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>def verify_post_state(self, t8n, t8n_state: Alloc, expected_state: Alloc | None = None):\n    \"\"\"Verify post alloc after all block/s or payload/s are generated.\"\"\"\n    try:\n        if expected_state:\n            expected_state.verify_post_alloc(t8n_state)\n        else:\n            self.post.verify_post_alloc(t8n_state)\n    except Exception as e:\n        print_traces(t8n.get_traces())\n        raise e\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.BlockchainTest.make_fixture","title":"<code>make_fixture(t8n, fork, eips=None, slow=False)</code>","text":"<p>Create a fixture from the blockchain test definition.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>def make_fixture(\n    self,\n    t8n: TransitionTool,\n    fork: Fork,\n    eips: Optional[List[int]] = None,\n    slow: bool = False,\n) -&gt; BlockchainFixture:\n    \"\"\"Create a fixture from the blockchain test definition.\"\"\"\n    fixture_blocks: List[FixtureBlock | InvalidFixtureBlock] = []\n\n    pre, genesis = BlockchainTest.make_genesis(self.genesis_environment, self.pre, fork)\n\n    alloc = pre\n    env = environment_from_parent_header(genesis.header)\n    head = genesis.header.block_hash\n\n    for block in self.blocks:\n        if block.rlp is None:\n            # This is the most common case, the RLP needs to be constructed\n            # based on the transactions to be included in the block.\n            # Set the environment according to the block to execute.\n            header, txs, _, new_alloc, new_env = self.generate_block_data(\n                t8n=t8n,\n                fork=fork,\n                block=block,\n                previous_env=env,\n                previous_alloc=alloc,\n                eips=eips,\n                slow=slow,\n            )\n            fixture_block = FixtureBlockBase(\n                header=header,\n                txs=[FixtureTransaction.from_transaction(tx) for tx in txs],\n                ommers=[],\n                withdrawals=(\n                    [FixtureWithdrawal.from_withdrawal(w) for w in new_env.withdrawals]\n                    if new_env.withdrawals is not None\n                    else None\n                ),\n                fork=fork,\n            ).with_rlp(txs=txs)\n            if block.exception is None:\n                fixture_blocks.append(fixture_block)\n                # Update env, alloc and last block hash for the next block.\n                alloc = new_alloc\n                env = apply_new_parent(new_env, header)\n                head = header.block_hash\n            else:\n                fixture_blocks.append(\n                    InvalidFixtureBlock(\n                        rlp=fixture_block.rlp,\n                        expect_exception=block.exception,\n                        rlp_decoded=(\n                            None\n                            if BlockException.RLP_STRUCTURES_ENCODING in block.exception\n                            else fixture_block.without_rlp()\n                        ),\n                    ),\n                )\n        else:\n            assert block.exception is not None, (\n                \"test correctness: if the block's rlp is hard-coded, \"\n                + \"the block is expected to produce an exception\"\n            )\n            fixture_blocks.append(\n                InvalidFixtureBlock(\n                    rlp=block.rlp,\n                    expect_exception=block.exception,\n                ),\n            )\n\n        if block.expected_post_state:\n            self.verify_post_state(\n                t8n, t8n_state=alloc, expected_state=block.expected_post_state\n            )\n\n    self.verify_post_state(t8n, t8n_state=alloc)\n    network_info = BlockchainTest.network_info(fork, eips)\n    return BlockchainFixture(\n        fork=network_info,\n        genesis=genesis.header,\n        genesis_rlp=genesis.rlp,\n        blocks=fixture_blocks,\n        last_block_hash=head,\n        pre=pre,\n        post_state=alloc,\n        config=FixtureConfig(\n            fork=network_info,\n            blob_schedule=FixtureBlobSchedule.from_blob_schedule(fork.blob_schedule()),\n            chain_id=self.chain_id,\n        ),\n    )\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.BlockchainTest.make_hive_fixture","title":"<code>make_hive_fixture(t8n, fork, eips=None, slow=False)</code>","text":"<p>Create a hive fixture from the blocktest definition.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>def make_hive_fixture(\n    self,\n    t8n: TransitionTool,\n    fork: Fork,\n    eips: Optional[List[int]] = None,\n    slow: bool = False,\n) -&gt; BlockchainEngineFixture:\n    \"\"\"Create a hive fixture from the blocktest definition.\"\"\"\n    fixture_payloads: List[FixtureEngineNewPayload] = []\n\n    pre, genesis = BlockchainTest.make_genesis(self.genesis_environment, self.pre, fork)\n    alloc = pre\n    env = environment_from_parent_header(genesis.header)\n    head_hash = genesis.header.block_hash\n\n    for block in self.blocks:\n        header, txs, requests, new_alloc, new_env = self.generate_block_data(\n            t8n=t8n,\n            fork=fork,\n            block=block,\n            previous_env=env,\n            previous_alloc=alloc,\n            eips=eips,\n            slow=slow,\n        )\n        if block.rlp is None:\n            fixture_payloads.append(\n                FixtureEngineNewPayload.from_fixture_header(\n                    fork=fork,\n                    header=header,\n                    transactions=txs,\n                    withdrawals=new_env.withdrawals,\n                    requests=requests,\n                    validation_error=block.exception,\n                    error_code=block.engine_api_error_code,\n                )\n            )\n            if block.exception is None:\n                alloc = new_alloc\n                env = apply_new_parent(env, header)\n                head_hash = header.block_hash\n\n        if block.expected_post_state:\n            self.verify_post_state(\n                t8n, t8n_state=alloc, expected_state=block.expected_post_state\n            )\n\n    fcu_version = fork.engine_forkchoice_updated_version(header.number, header.timestamp)\n    assert fcu_version is not None, (\n        \"A hive fixture was requested but no forkchoice update is defined.\"\n        \" The framework should never try to execute this test case.\"\n    )\n\n    self.verify_post_state(t8n, t8n_state=alloc)\n\n    sync_payload: Optional[FixtureEngineNewPayload] = None\n    if self.verify_sync:\n        # Test is marked for syncing verification.\n        assert genesis.header.block_hash != head_hash, (\n            \"Invalid payload tests negative test via sync is not supported yet.\"\n        )\n\n        # Most clients require the header to start the sync process, so we create an empty\n        # block on top of the last block of the test to send it as new payload and trigger the\n        # sync process.\n        sync_header, _, requests, _, _ = self.generate_block_data(\n            t8n=t8n,\n            fork=fork,\n            block=Block(),\n            previous_env=env,\n            previous_alloc=alloc,\n            eips=eips,\n        )\n        sync_payload = FixtureEngineNewPayload.from_fixture_header(\n            fork=fork,\n            header=sync_header,\n            transactions=[],\n            withdrawals=[],\n            requests=requests,\n            validation_error=None,\n            error_code=None,\n        )\n\n    network_info = BlockchainTest.network_info(fork, eips)\n    return BlockchainEngineFixture(\n        fork=network_info,\n        genesis=genesis.header,\n        payloads=fixture_payloads,\n        fcu_version=fcu_version,\n        pre=pre,\n        post_state=alloc,\n        sync_payload=sync_payload,\n        last_block_hash=head_hash,\n        config=FixtureConfig(\n            fork=network_info,\n            chain_id=self.chain_id,\n            blob_schedule=FixtureBlobSchedule.from_blob_schedule(fork.blob_schedule()),\n        ),\n    )\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.BlockchainTest.generate","title":"<code>generate(request, t8n, fork, fixture_format, eips=None)</code>","text":"<p>Generate the BlockchainTest fixture.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>def generate(\n    self,\n    request: pytest.FixtureRequest,\n    t8n: TransitionTool,\n    fork: Fork,\n    fixture_format: FixtureFormat,\n    eips: Optional[List[int]] = None,\n) -&gt; BaseFixture:\n    \"\"\"Generate the BlockchainTest fixture.\"\"\"\n    t8n.reset_traces()\n    if fixture_format == BlockchainEngineFixture:\n        return self.make_hive_fixture(t8n, fork, eips, slow=is_slow_test(request))\n    elif fixture_format == BlockchainFixture:\n        return self.make_fixture(t8n, fork, eips, slow=is_slow_test(request))\n\n    raise Exception(f\"Unknown fixture format: {fixture_format}\")\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.BlockchainTest.execute","title":"<code>execute(*, fork, execute_format, eips=None)</code>","text":"<p>Generate the list of test fixtures.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>def execute(\n    self,\n    *,\n    fork: Fork,\n    execute_format: ExecuteFormat,\n    eips: Optional[List[int]] = None,\n) -&gt; BaseExecute:\n    \"\"\"Generate the list of test fixtures.\"\"\"\n    if execute_format == TransactionPost:\n        txs: List[Transaction] = []\n        for block in self.blocks:\n            txs += block.txs\n        return TransactionPost(\n            transactions=txs,\n            post=self.post,\n        )\n    raise Exception(f\"Unsupported execute format: {execute_format}\")\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFStateTest","title":"<code>EOFStateTest</code>","text":"<p>               Bases: <code>EOFTest</code>, <code>Transaction</code></p> <p>Filler type that generates an EOF test for container validation, and also tests the container during runtime using a state test (and blockchain test).</p> <p>In the state or blockchain test, the container is first deployed to the pre-allocation and then a transaction is sent to the deployed container.</p> <p>Container deployment/validation is not tested like in the <code>EOFTest</code> unless the container under test is an initcode container.</p> <p>All fields from <code>ethereum_test_types.Transaction</code> are available for use in the test.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>class EOFStateTest(EOFTest, Transaction):\n    \"\"\"\n    Filler type that generates an EOF test for container validation, and also tests the container\n    during runtime using a state test (and blockchain test).\n\n    In the state or blockchain test, the container is first deployed to the pre-allocation and\n    then a transaction is sent to the deployed container.\n\n    Container deployment/validation is **not** tested like in the `EOFTest` unless the container\n    under test is an initcode container.\n\n    All fields from `ethereum_test_types.Transaction` are available for use in the test.\n    \"\"\"\n\n    gas_limit: HexNumber = Field(HexNumber(10_000_000), serialization_alias=\"gas\")\n    \"\"\"\n    Gas limit for the transaction that deploys the container.\n    \"\"\"\n    tx_sender_funding_amount: int = 1_000_000_000_000_000_000_000\n    \"\"\"\n    Amount of funds to send to the sender EOA before the transaction.\n    \"\"\"\n    env: Environment = Field(default_factory=Environment)\n    \"\"\"\n    Environment object that is used during State Test generation.\n    \"\"\"\n    container_post: Account = Field(default_factory=Account)\n    \"\"\"\n    Account object used to verify the container post state.\n    \"\"\"\n\n    supported_fixture_formats: ClassVar[Sequence[FixtureFormat | LabeledFixtureFormat]] = [\n        EOFFixture\n    ] + [\n        LabeledFixtureFormat(\n            fixture_format,\n            f\"eof_{fixture_format.format_name}\",\n            f\"Tests that generate an EOF {fixture_format.format_name}.\",\n        )\n        for fixture_format in StateTest.supported_fixture_formats\n    ]\n\n    supported_execute_formats: ClassVar[Sequence[ExecuteFormat | LabeledExecuteFormat]] = [\n        LabeledExecuteFormat(\n            execute_format,\n            f\"eof_{execute_format.format_name}\",\n            f\"Tests that generate an EOF {execute_format.format_name}.\",\n        )\n        for execute_format in StateTest.supported_execute_formats\n    ]\n\n    @classmethod\n    def pytest_parameter_name(cls) -&gt; str:\n        \"\"\"Workaround for pytest parameter name.\"\"\"\n        return \"eof_state_test\"\n\n    def model_post_init(self, __context):\n        \"\"\"Prepare the transaction parameters required to fill the test.\"\"\"\n        assert self.pre is not None, \"pre must be set to generate a StateTest.\"\n\n        EOFTest.model_post_init(self, __context)\n\n        self.sender = self.pre.fund_eoa(amount=self.tx_sender_funding_amount)\n        if self.post is None:\n            self.post = Alloc()\n\n        if self.expect_exception is not None:  # Invalid EOF\n            self.to = None  # Make EIP-7698 create transaction\n            self.data = Bytes(\n                bytes(self.container) + self.data\n            )  # by concatenating container and tx data.\n\n            # Run transaction model validation\n            Transaction.model_post_init(self, __context)\n\n            self.post[self.created_contract] = None  # Expect failure.\n        elif self.container_kind == ContainerKind.INITCODE:\n            self.to = None  # Make EIP-7698 create transaction\n            self.data = Bytes(\n                bytes(self.container) + self.data\n            )  # by concatenating container and tx data.\n\n            # Run transaction model validation\n            Transaction.model_post_init(self, __context)\n\n            self.post[self.created_contract] = self.container_post  # Successful.\n        else:\n            self.to = self.pre.deploy_contract(code=self.container)\n\n            # Run transaction model validation\n            Transaction.model_post_init(self, __context)\n\n            self.post[self.to] = self.container_post\n\n    def generate_state_test(self, fork: Fork) -&gt; StateTest:\n        \"\"\"Generate the StateTest filler.\"\"\"\n        assert self.pre is not None, \"pre must be set to generate a StateTest.\"\n        assert self.post is not None, \"post must be set to generate a StateTest.\"\n\n        return StateTest(\n            pre=self.pre,\n            tx=self,\n            env=self.env,\n            post=self.post,\n            t8n_dump_dir=self.t8n_dump_dir,\n        )\n\n    def generate(\n        self,\n        *,\n        request: pytest.FixtureRequest,\n        t8n: TransitionTool,\n        fork: Fork,\n        eips: Optional[List[int]] = None,\n        fixture_format: FixtureFormat,\n        **_,\n    ) -&gt; BaseFixture:\n        \"\"\"Generate the BlockchainTest fixture.\"\"\"\n        if fixture_format == EOFFixture:\n            if Bytes(self.container) in existing_tests:\n                # Gracefully skip duplicate tests because one EOFStateTest can generate multiple\n                # state fixtures with the same data.\n                pytest.skip(f\"Duplicate EOF container on EOFStateTest: {request.node.nodeid}\")\n            return self.make_eof_test_fixture(request=request, fork=fork, eips=eips)\n        elif fixture_format in StateTest.supported_fixture_formats:\n            return self.generate_state_test(fork).generate(\n                request=request, t8n=t8n, fork=fork, fixture_format=fixture_format, eips=eips\n            )\n\n        raise Exception(f\"Unknown fixture format: {fixture_format}\")\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFStateTest.gas_limit","title":"<code>gas_limit: HexNumber = Field(HexNumber(10000000), serialization_alias='gas')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Gas limit for the transaction that deploys the container.</p>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFStateTest.tx_sender_funding_amount","title":"<code>tx_sender_funding_amount: int = 1000000000000000000000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Amount of funds to send to the sender EOA before the transaction.</p>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFStateTest.env","title":"<code>env: Environment = Field(default_factory=Environment)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Environment object that is used during State Test generation.</p>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFStateTest.container_post","title":"<code>container_post: Account = Field(default_factory=Account)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Account object used to verify the container post state.</p>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFStateTest.pytest_parameter_name","title":"<code>pytest_parameter_name()</code>  <code>classmethod</code>","text":"<p>Workaround for pytest parameter name.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>@classmethod\ndef pytest_parameter_name(cls) -&gt; str:\n    \"\"\"Workaround for pytest parameter name.\"\"\"\n    return \"eof_state_test\"\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFStateTest.model_post_init","title":"<code>model_post_init(__context)</code>","text":"<p>Prepare the transaction parameters required to fill the test.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>def model_post_init(self, __context):\n    \"\"\"Prepare the transaction parameters required to fill the test.\"\"\"\n    assert self.pre is not None, \"pre must be set to generate a StateTest.\"\n\n    EOFTest.model_post_init(self, __context)\n\n    self.sender = self.pre.fund_eoa(amount=self.tx_sender_funding_amount)\n    if self.post is None:\n        self.post = Alloc()\n\n    if self.expect_exception is not None:  # Invalid EOF\n        self.to = None  # Make EIP-7698 create transaction\n        self.data = Bytes(\n            bytes(self.container) + self.data\n        )  # by concatenating container and tx data.\n\n        # Run transaction model validation\n        Transaction.model_post_init(self, __context)\n\n        self.post[self.created_contract] = None  # Expect failure.\n    elif self.container_kind == ContainerKind.INITCODE:\n        self.to = None  # Make EIP-7698 create transaction\n        self.data = Bytes(\n            bytes(self.container) + self.data\n        )  # by concatenating container and tx data.\n\n        # Run transaction model validation\n        Transaction.model_post_init(self, __context)\n\n        self.post[self.created_contract] = self.container_post  # Successful.\n    else:\n        self.to = self.pre.deploy_contract(code=self.container)\n\n        # Run transaction model validation\n        Transaction.model_post_init(self, __context)\n\n        self.post[self.to] = self.container_post\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFStateTest.generate_state_test","title":"<code>generate_state_test(fork)</code>","text":"<p>Generate the StateTest filler.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>def generate_state_test(self, fork: Fork) -&gt; StateTest:\n    \"\"\"Generate the StateTest filler.\"\"\"\n    assert self.pre is not None, \"pre must be set to generate a StateTest.\"\n    assert self.post is not None, \"post must be set to generate a StateTest.\"\n\n    return StateTest(\n        pre=self.pre,\n        tx=self,\n        env=self.env,\n        post=self.post,\n        t8n_dump_dir=self.t8n_dump_dir,\n    )\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFStateTest.generate","title":"<code>generate(*, request, t8n, fork, eips=None, fixture_format, **_)</code>","text":"<p>Generate the BlockchainTest fixture.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>def generate(\n    self,\n    *,\n    request: pytest.FixtureRequest,\n    t8n: TransitionTool,\n    fork: Fork,\n    eips: Optional[List[int]] = None,\n    fixture_format: FixtureFormat,\n    **_,\n) -&gt; BaseFixture:\n    \"\"\"Generate the BlockchainTest fixture.\"\"\"\n    if fixture_format == EOFFixture:\n        if Bytes(self.container) in existing_tests:\n            # Gracefully skip duplicate tests because one EOFStateTest can generate multiple\n            # state fixtures with the same data.\n            pytest.skip(f\"Duplicate EOF container on EOFStateTest: {request.node.nodeid}\")\n        return self.make_eof_test_fixture(request=request, fork=fork, eips=eips)\n    elif fixture_format in StateTest.supported_fixture_formats:\n        return self.generate_state_test(fork).generate(\n            request=request, t8n=t8n, fork=fork, fixture_format=fixture_format, eips=eips\n        )\n\n    raise Exception(f\"Unknown fixture format: {fixture_format}\")\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFTest","title":"<code>EOFTest</code>","text":"<p>               Bases: <code>BaseTest</code></p> <p>Filler type that generates a test for EOF container validation.</p> <p>A state test is also automatically generated where the container is wrapped in a contract-creating transaction to test deployment/validation on the instantiated blockchain.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>class EOFTest(BaseTest):\n    \"\"\"\n    Filler type that generates a test for EOF container validation.\n\n    A state test is also automatically generated where the container is wrapped in a\n    contract-creating transaction to test deployment/validation on the instantiated blockchain.\n    \"\"\"\n\n    container: Container\n    \"\"\"\n    EOF container that will be tested for validity.\n\n    The only supported type at the moment is `ethereum_test_types.eof.v1.Container`.\n\n    If an invalid container needs to be tested, and it cannot be generated using the\n    Container class features, the `raw_bytes` field can be used to provide the raw\n    container bytes.\n    \"\"\"\n    expect_exception: EOFExceptionInstanceOrList | None = None\n    \"\"\"\n    Expected exception that the container should raise when parsed by an EOF parser.\n\n    Can be a single exception or a list of exceptions that the container is expected to raise,\n    in which case the test will pass if any of the exceptions are raised.\n\n    The list of supported exceptions can be found in the `ethereum_test_exceptions.EOFException`\n    class.\n    \"\"\"\n    container_kind: ContainerKind = ContainerKind.RUNTIME\n    \"\"\"\n    Container kind type that the container should be treated as.\n\n    The container kind can be one of the following:\n    - `ContainerKind.INITCODE`: The container is an initcode container.\n    - `ContainerKind.RUNTIME`: The container is a runtime container.\n\n    The default value is `ContainerKind.RUNTIME`.\n    \"\"\"\n    deployed_container: Container | None = None\n    \"\"\"\n    To be used when the container is an initcode container and the expected deployed container is\n    known.\n\n    The value is only used when a State Test is generated from this EOF test to set the expected\n    deployed container that should be found in the post state.\n\n    If this field is not set, and the container is valid:\n      - If the container kind is `ContainerKind.RUNTIME`, the deployed container is assumed to be\n        the container itself, and an initcode container that wraps the container is generated\n        automatically.\n      - If the container kind is `ContainerKind.INITCODE`, `model_post_init` will attempt to infer\n        the deployed container from the sections of the init-container, and the first\n        container-type section will be used. An error will be raised if the deployed container\n        cannot be inferred.\n\n    If the value is set to `None`, it is assumed that the container is invalid and the test will\n    expect that no contract is created.\n\n    It is considered an error if:\n      - The `deployed_container` field is set and the `container_kind` field is not set to\n        `ContainerKind.INITCODE`.\n      - The `deployed_container` field is set and the `expect_exception` is not `None`.\n\n    The deployed container is **not** executed at any point during the EOF validation test nor\n    the generated State Test. For container runtime testing use the `EOFStateTest` class.\n    \"\"\"\n    pre: Alloc | None = None\n    \"\"\"\n    Pre alloc object that is used during State Test generation.\n\n    This field is automatically set by the test filler when generating a State Test from this EOF\n    test and should otherwise be left unset.\n    \"\"\"\n    post: Alloc | None = None\n    \"\"\"\n    Post alloc object that is used during State Test generation.\n\n    This field is automatically set by the test filler when generating a State Test from this EOF\n    test and is normally not set by the user.\n    \"\"\"\n    sender: EOA | None = None\n    \"\"\"\n    Sender EOA object that is used during State Test generation.\n\n    This field is automatically set by the `model_post_init` method and should otherwise be left\n    unset.\n    \"\"\"\n\n    supported_fixture_formats: ClassVar[Sequence[FixtureFormat | LabeledFixtureFormat]] = [\n        EOFFixture\n    ] + [\n        LabeledFixtureFormat(\n            fixture_format,\n            f\"{fixture_format.format_name}_from_eof_test\",\n            f\"A {fixture_format.format_name} generated from an eof_test.\",\n        )\n        for fixture_format in StateTest.supported_fixture_formats\n    ]\n\n    supported_execute_formats: ClassVar[Sequence[ExecuteFormat | LabeledExecuteFormat]] = [\n        LabeledExecuteFormat(\n            execute_format,\n            f\"{execute_format.format_name}_from_eof_test\",\n            f\"A {execute_format.format_name} generated from an eof_test.\",\n        )\n        for execute_format in StateTest.supported_execute_formats\n    ]\n\n    supported_markers: ClassVar[Dict[str, str]] = {\n        \"eof_test_only\": \"Only generate an EOF test fixture\",\n    }\n\n    @classmethod\n    def discard_fixture_format_by_marks(\n        cls,\n        fixture_format: FixtureFormat,\n        fork: Fork,\n        markers: List[pytest.Mark],\n    ) -&gt; bool:\n        \"\"\"Discard a fixture format from filling if the appropriate marker is used.\"\"\"\n        if \"eof_test_only\" in [m.name for m in markers]:\n            return fixture_format != EOFFixture\n        return False\n\n    @classmethod\n    def pytest_parameter_name(cls) -&gt; str:\n        \"\"\"Workaround for pytest parameter name.\"\"\"\n        return \"eof_test\"\n\n    def model_post_init(self, __context):\n        \"\"\"Prepare the test exception based on the container.\"\"\"\n        if self.container.validity_error is not None:\n            if self.expect_exception is not None:\n                assert self.expect_exception == self.container.validity_error, (\n                    f\"Container validity error {self.container.validity_error} \"\n                    f\"does not match expected exception {self.expect_exception}.\"\n                )\n            self.expect_exception = self.container.validity_error\n            assert self.deployed_container is None, (\n                \"deployed_container must be None for invalid containers.\"\n            )\n        if \"kind\" in self.container.model_fields_set or \"container_kind\" in self.model_fields_set:\n            if (\n                \"kind\" in self.container.model_fields_set\n                and \"container_kind\" in self.model_fields_set\n            ):\n                assert self.container.kind == self.container_kind, (\n                    f\"Container kind type {str(self.container.kind)} \"\n                    f\"does not match test {self.container_kind}.\"\n                )\n            elif \"kind\" in self.container.model_fields_set:\n                self.container_kind = self.container.kind\n            elif \"container_kind\" in self.model_fields_set:\n                self.container.kind = self.container_kind\n\n        assert self.pre is not None, \"pre must be set to generate a StateTest.\"\n        self.sender = self.pre.fund_eoa()\n        if self.post is None:\n            self.post = Alloc()\n\n    def make_eof_test_fixture(\n        self,\n        *,\n        request: pytest.FixtureRequest,\n        fork: Fork,\n        eips: Optional[List[int]],\n    ) -&gt; EOFFixture:\n        \"\"\"Generate the EOF test fixture.\"\"\"\n        container_bytes = Bytes(self.container)\n        if container_bytes in existing_tests:\n            pytest.fail(\n                f\"Duplicate EOF test: {container_bytes}, \"\n                f\"existing test: {existing_tests[container_bytes]}\"\n            )\n        existing_tests[container_bytes] = request.node.nodeid\n        vectors = [\n            Vector(\n                code=container_bytes,\n                container_kind=self.container_kind,\n                results={\n                    fork.blockchain_test_network_name(): Result(\n                        exception=self.expect_exception,\n                        valid=self.expect_exception is None,\n                    ),\n                },\n            )\n        ]\n        fixture = EOFFixture(vectors=dict(enumerate(vectors)))\n        try:\n            eof_parse = EOFParse()\n        except FileNotFoundError as e:\n            warnings.warn(\n                f\"{e} Skipping EOF fixture verification. Fixtures may be invalid!\", stacklevel=2\n            )\n            return fixture\n\n        for _, vector in fixture.vectors.items():\n            expected_result = vector.results.get(fork.blockchain_test_network_name())\n            if expected_result is None:\n                raise Exception(f\"EOF Fixture missing vector result for fork: {fork}\")\n            args = []\n            if vector.container_kind == ContainerKind.INITCODE:\n                args.append(\"--initcode\")\n            result = eof_parse.run(*args, input_value=str(vector.code))\n            self.verify_result(result, expected_result, vector.code)\n\n        return fixture\n\n    def verify_result(self, result: CompletedProcess, expected_result: Result, code: Bytes):\n        \"\"\"Check that the reported exception string matches the expected error.\"\"\"\n        parser = EvmoneExceptionMapper()\n        actual_message = result.stdout.strip()\n        actual_exception = parser.message_to_exception(actual_message)\n\n        if expected_result.exception is None:\n            if \"OK\" in actual_message:\n                return\n            else:\n                raise UnexpectedEOFExceptionError(\n                    code=code, got=f\"{actual_exception} ({actual_message})\"\n                )\n        else:\n            expected_string = to_pipe_str(expected_result.exception)\n            print(expected_string)\n            print(actual_exception)\n            if \"OK\" in actual_message:\n                raise ExpectedEOFExceptionError(\n                    code=code,\n                    expected=f\"{expected_string}\",\n                )\n            elif actual_exception in expected_result.exception:\n                return\n            else:\n                raise EOFExceptionMismatchError(\n                    code=code,\n                    expected=f\"{expected_string}\",\n                    got=f\"{actual_exception} ({actual_message})\",\n                )\n\n    def generate_eof_contract_create_transaction(self) -&gt; Transaction:\n        \"\"\"Generate a transaction that creates a contract.\"\"\"\n        assert self.sender is not None, \"sender must be set to generate a StateTest.\"\n        assert self.post is not None, \"post must be set to generate a StateTest.\"\n\n        initcode: Container\n        deployed_container: Container | Bytes | None = None\n        if self.container_kind == ContainerKind.INITCODE:\n            initcode = self.container\n            if \"deployed_container\" in self.model_fields_set:\n                # In the case of an initcontainer where we know the deployed container,\n                # we can use the initcontainer as-is.\n                deployed_container = self.deployed_container\n            elif self.expect_exception is None:\n                # We have a valid init-container, but we don't know the deployed container.\n                # Try to infer the deployed container from the sections of the init-container.\n                assert self.container.raw_bytes is None, (\n                    \"deployed_container must be set for initcode containers with raw_bytes.\"\n                )\n                for section in self.container.sections:\n                    if section.kind == SectionKind.CONTAINER:\n                        deployed_container = section.data\n                        break\n\n                assert deployed_container is not None, (\n                    \"Unable to infer deployed container for init-container. \"\n                    \"Use field `deployed_container` to set the expected deployed container.\"\n                )\n        else:\n            assert self.deployed_container is None, (\n                \"deployed_container must be None for runtime containers.\"\n            )\n            initcode = Container(\n                sections=[\n                    Section.Code(Op.RETURNCODE[0](0, 0)),\n                    Section.Container(self.container),\n                ]\n            )\n            deployed_container = self.container\n\n        tx = Transaction(\n            sender=self.sender,\n            to=None,\n            gas_limit=10_000_000,\n            data=initcode,\n        )\n\n        if self.expect_exception is not None or deployed_container is None:\n            self.post[tx.created_contract] = None\n        else:\n            self.post[tx.created_contract] = Account(\n                code=deployed_container,\n            )\n        return tx\n\n    def generate_state_test(self, fork: Fork) -&gt; StateTest:\n        \"\"\"Generate the StateTest filler.\"\"\"\n        return StateTest(\n            pre=self.pre,\n            tx=self.generate_eof_contract_create_transaction(),\n            env=Environment(),\n            post=self.post,\n            t8n_dump_dir=self.t8n_dump_dir,\n        )\n\n    def generate(\n        self,\n        *,\n        request: pytest.FixtureRequest,\n        t8n: TransitionTool,\n        fork: Fork,\n        eips: Optional[List[int]] = None,\n        fixture_format: FixtureFormat,\n        **_,\n    ) -&gt; BaseFixture:\n        \"\"\"Generate the BlockchainTest fixture.\"\"\"\n        if fixture_format == EOFFixture:\n            return self.make_eof_test_fixture(request=request, fork=fork, eips=eips)\n        elif fixture_format in StateTest.supported_fixture_formats:\n            return self.generate_state_test(fork).generate(\n                request=request, t8n=t8n, fork=fork, fixture_format=fixture_format, eips=eips\n            )\n        raise Exception(f\"Unknown fixture format: {fixture_format}\")\n\n    def execute(\n        self,\n        *,\n        fork: Fork,\n        execute_format: ExecuteFormat,\n        eips: Optional[List[int]] = None,\n    ) -&gt; BaseExecute:\n        \"\"\"Generate the list of test fixtures.\"\"\"\n        if execute_format == TransactionPost:\n            return self.generate_state_test(fork).execute(\n                fork=fork, execute_format=execute_format, eips=eips\n            )\n        raise Exception(f\"Unsupported execute format: {execute_format}\")\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFTest.container","title":"<code>container: Container</code>  <code>instance-attribute</code>","text":"<p>EOF container that will be tested for validity.</p> <p>The only supported type at the moment is <code>ethereum_test_types.eof.v1.Container</code>.</p> <p>If an invalid container needs to be tested, and it cannot be generated using the Container class features, the <code>raw_bytes</code> field can be used to provide the raw container bytes.</p>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFTest.expect_exception","title":"<code>expect_exception: EOFExceptionInstanceOrList | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Expected exception that the container should raise when parsed by an EOF parser.</p> <p>Can be a single exception or a list of exceptions that the container is expected to raise, in which case the test will pass if any of the exceptions are raised.</p> <p>The list of supported exceptions can be found in the <code>ethereum_test_exceptions.EOFException</code> class.</p>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFTest.container_kind","title":"<code>container_kind: ContainerKind = ContainerKind.RUNTIME</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Container kind type that the container should be treated as.</p> <p>The container kind can be one of the following: - <code>ContainerKind.INITCODE</code>: The container is an initcode container. - <code>ContainerKind.RUNTIME</code>: The container is a runtime container.</p> <p>The default value is <code>ContainerKind.RUNTIME</code>.</p>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFTest.deployed_container","title":"<code>deployed_container: Container | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>To be used when the container is an initcode container and the expected deployed container is known.</p> <p>The value is only used when a State Test is generated from this EOF test to set the expected deployed container that should be found in the post state.</p> <p>If this field is not set, and the container is valid:   - If the container kind is <code>ContainerKind.RUNTIME</code>, the deployed container is assumed to be     the container itself, and an initcode container that wraps the container is generated     automatically.   - If the container kind is <code>ContainerKind.INITCODE</code>, <code>model_post_init</code> will attempt to infer     the deployed container from the sections of the init-container, and the first     container-type section will be used. An error will be raised if the deployed container     cannot be inferred.</p> <p>If the value is set to <code>None</code>, it is assumed that the container is invalid and the test will expect that no contract is created.</p> It is considered an error if <ul> <li>The <code>deployed_container</code> field is set and the <code>container_kind</code> field is not set to   <code>ContainerKind.INITCODE</code>.</li> <li>The <code>deployed_container</code> field is set and the <code>expect_exception</code> is not <code>None</code>.</li> </ul> <p>The deployed container is not executed at any point during the EOF validation test nor the generated State Test. For container runtime testing use the <code>EOFStateTest</code> class.</p>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFTest.pre","title":"<code>pre: Alloc | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Pre alloc object that is used during State Test generation.</p> <p>This field is automatically set by the test filler when generating a State Test from this EOF test and should otherwise be left unset.</p>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFTest.post","title":"<code>post: Alloc | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Post alloc object that is used during State Test generation.</p> <p>This field is automatically set by the test filler when generating a State Test from this EOF test and is normally not set by the user.</p>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFTest.sender","title":"<code>sender: EOA | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Sender EOA object that is used during State Test generation.</p> <p>This field is automatically set by the <code>model_post_init</code> method and should otherwise be left unset.</p>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFTest.discard_fixture_format_by_marks","title":"<code>discard_fixture_format_by_marks(fixture_format, fork, markers)</code>  <code>classmethod</code>","text":"<p>Discard a fixture format from filling if the appropriate marker is used.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>@classmethod\ndef discard_fixture_format_by_marks(\n    cls,\n    fixture_format: FixtureFormat,\n    fork: Fork,\n    markers: List[pytest.Mark],\n) -&gt; bool:\n    \"\"\"Discard a fixture format from filling if the appropriate marker is used.\"\"\"\n    if \"eof_test_only\" in [m.name for m in markers]:\n        return fixture_format != EOFFixture\n    return False\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFTest.pytest_parameter_name","title":"<code>pytest_parameter_name()</code>  <code>classmethod</code>","text":"<p>Workaround for pytest parameter name.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>@classmethod\ndef pytest_parameter_name(cls) -&gt; str:\n    \"\"\"Workaround for pytest parameter name.\"\"\"\n    return \"eof_test\"\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFTest.model_post_init","title":"<code>model_post_init(__context)</code>","text":"<p>Prepare the test exception based on the container.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>def model_post_init(self, __context):\n    \"\"\"Prepare the test exception based on the container.\"\"\"\n    if self.container.validity_error is not None:\n        if self.expect_exception is not None:\n            assert self.expect_exception == self.container.validity_error, (\n                f\"Container validity error {self.container.validity_error} \"\n                f\"does not match expected exception {self.expect_exception}.\"\n            )\n        self.expect_exception = self.container.validity_error\n        assert self.deployed_container is None, (\n            \"deployed_container must be None for invalid containers.\"\n        )\n    if \"kind\" in self.container.model_fields_set or \"container_kind\" in self.model_fields_set:\n        if (\n            \"kind\" in self.container.model_fields_set\n            and \"container_kind\" in self.model_fields_set\n        ):\n            assert self.container.kind == self.container_kind, (\n                f\"Container kind type {str(self.container.kind)} \"\n                f\"does not match test {self.container_kind}.\"\n            )\n        elif \"kind\" in self.container.model_fields_set:\n            self.container_kind = self.container.kind\n        elif \"container_kind\" in self.model_fields_set:\n            self.container.kind = self.container_kind\n\n    assert self.pre is not None, \"pre must be set to generate a StateTest.\"\n    self.sender = self.pre.fund_eoa()\n    if self.post is None:\n        self.post = Alloc()\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFTest.make_eof_test_fixture","title":"<code>make_eof_test_fixture(*, request, fork, eips)</code>","text":"<p>Generate the EOF test fixture.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>def make_eof_test_fixture(\n    self,\n    *,\n    request: pytest.FixtureRequest,\n    fork: Fork,\n    eips: Optional[List[int]],\n) -&gt; EOFFixture:\n    \"\"\"Generate the EOF test fixture.\"\"\"\n    container_bytes = Bytes(self.container)\n    if container_bytes in existing_tests:\n        pytest.fail(\n            f\"Duplicate EOF test: {container_bytes}, \"\n            f\"existing test: {existing_tests[container_bytes]}\"\n        )\n    existing_tests[container_bytes] = request.node.nodeid\n    vectors = [\n        Vector(\n            code=container_bytes,\n            container_kind=self.container_kind,\n            results={\n                fork.blockchain_test_network_name(): Result(\n                    exception=self.expect_exception,\n                    valid=self.expect_exception is None,\n                ),\n            },\n        )\n    ]\n    fixture = EOFFixture(vectors=dict(enumerate(vectors)))\n    try:\n        eof_parse = EOFParse()\n    except FileNotFoundError as e:\n        warnings.warn(\n            f\"{e} Skipping EOF fixture verification. Fixtures may be invalid!\", stacklevel=2\n        )\n        return fixture\n\n    for _, vector in fixture.vectors.items():\n        expected_result = vector.results.get(fork.blockchain_test_network_name())\n        if expected_result is None:\n            raise Exception(f\"EOF Fixture missing vector result for fork: {fork}\")\n        args = []\n        if vector.container_kind == ContainerKind.INITCODE:\n            args.append(\"--initcode\")\n        result = eof_parse.run(*args, input_value=str(vector.code))\n        self.verify_result(result, expected_result, vector.code)\n\n    return fixture\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFTest.verify_result","title":"<code>verify_result(result, expected_result, code)</code>","text":"<p>Check that the reported exception string matches the expected error.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>def verify_result(self, result: CompletedProcess, expected_result: Result, code: Bytes):\n    \"\"\"Check that the reported exception string matches the expected error.\"\"\"\n    parser = EvmoneExceptionMapper()\n    actual_message = result.stdout.strip()\n    actual_exception = parser.message_to_exception(actual_message)\n\n    if expected_result.exception is None:\n        if \"OK\" in actual_message:\n            return\n        else:\n            raise UnexpectedEOFExceptionError(\n                code=code, got=f\"{actual_exception} ({actual_message})\"\n            )\n    else:\n        expected_string = to_pipe_str(expected_result.exception)\n        print(expected_string)\n        print(actual_exception)\n        if \"OK\" in actual_message:\n            raise ExpectedEOFExceptionError(\n                code=code,\n                expected=f\"{expected_string}\",\n            )\n        elif actual_exception in expected_result.exception:\n            return\n        else:\n            raise EOFExceptionMismatchError(\n                code=code,\n                expected=f\"{expected_string}\",\n                got=f\"{actual_exception} ({actual_message})\",\n            )\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFTest.generate_eof_contract_create_transaction","title":"<code>generate_eof_contract_create_transaction()</code>","text":"<p>Generate a transaction that creates a contract.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>def generate_eof_contract_create_transaction(self) -&gt; Transaction:\n    \"\"\"Generate a transaction that creates a contract.\"\"\"\n    assert self.sender is not None, \"sender must be set to generate a StateTest.\"\n    assert self.post is not None, \"post must be set to generate a StateTest.\"\n\n    initcode: Container\n    deployed_container: Container | Bytes | None = None\n    if self.container_kind == ContainerKind.INITCODE:\n        initcode = self.container\n        if \"deployed_container\" in self.model_fields_set:\n            # In the case of an initcontainer where we know the deployed container,\n            # we can use the initcontainer as-is.\n            deployed_container = self.deployed_container\n        elif self.expect_exception is None:\n            # We have a valid init-container, but we don't know the deployed container.\n            # Try to infer the deployed container from the sections of the init-container.\n            assert self.container.raw_bytes is None, (\n                \"deployed_container must be set for initcode containers with raw_bytes.\"\n            )\n            for section in self.container.sections:\n                if section.kind == SectionKind.CONTAINER:\n                    deployed_container = section.data\n                    break\n\n            assert deployed_container is not None, (\n                \"Unable to infer deployed container for init-container. \"\n                \"Use field `deployed_container` to set the expected deployed container.\"\n            )\n    else:\n        assert self.deployed_container is None, (\n            \"deployed_container must be None for runtime containers.\"\n        )\n        initcode = Container(\n            sections=[\n                Section.Code(Op.RETURNCODE[0](0, 0)),\n                Section.Container(self.container),\n            ]\n        )\n        deployed_container = self.container\n\n    tx = Transaction(\n        sender=self.sender,\n        to=None,\n        gas_limit=10_000_000,\n        data=initcode,\n    )\n\n    if self.expect_exception is not None or deployed_container is None:\n        self.post[tx.created_contract] = None\n    else:\n        self.post[tx.created_contract] = Account(\n            code=deployed_container,\n        )\n    return tx\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFTest.generate_state_test","title":"<code>generate_state_test(fork)</code>","text":"<p>Generate the StateTest filler.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>def generate_state_test(self, fork: Fork) -&gt; StateTest:\n    \"\"\"Generate the StateTest filler.\"\"\"\n    return StateTest(\n        pre=self.pre,\n        tx=self.generate_eof_contract_create_transaction(),\n        env=Environment(),\n        post=self.post,\n        t8n_dump_dir=self.t8n_dump_dir,\n    )\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFTest.generate","title":"<code>generate(*, request, t8n, fork, eips=None, fixture_format, **_)</code>","text":"<p>Generate the BlockchainTest fixture.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>def generate(\n    self,\n    *,\n    request: pytest.FixtureRequest,\n    t8n: TransitionTool,\n    fork: Fork,\n    eips: Optional[List[int]] = None,\n    fixture_format: FixtureFormat,\n    **_,\n) -&gt; BaseFixture:\n    \"\"\"Generate the BlockchainTest fixture.\"\"\"\n    if fixture_format == EOFFixture:\n        return self.make_eof_test_fixture(request=request, fork=fork, eips=eips)\n    elif fixture_format in StateTest.supported_fixture_formats:\n        return self.generate_state_test(fork).generate(\n            request=request, t8n=t8n, fork=fork, fixture_format=fixture_format, eips=eips\n        )\n    raise Exception(f\"Unknown fixture format: {fixture_format}\")\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.EOFTest.execute","title":"<code>execute(*, fork, execute_format, eips=None)</code>","text":"<p>Generate the list of test fixtures.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>def execute(\n    self,\n    *,\n    fork: Fork,\n    execute_format: ExecuteFormat,\n    eips: Optional[List[int]] = None,\n) -&gt; BaseExecute:\n    \"\"\"Generate the list of test fixtures.\"\"\"\n    if execute_format == TransactionPost:\n        return self.generate_state_test(fork).execute(\n            fork=fork, execute_format=execute_format, eips=eips\n        )\n    raise Exception(f\"Unsupported execute format: {execute_format}\")\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.StateTest","title":"<code>StateTest</code>","text":"<p>               Bases: <code>BaseTest</code></p> <p>Filler type that tests transactions over the period of a single block.</p> Source code in <code>src/ethereum_test_specs/state.py</code> <pre><code>class StateTest(BaseTest):\n    \"\"\"Filler type that tests transactions over the period of a single block.\"\"\"\n\n    env: Environment = Field(default_factory=Environment)\n    pre: Alloc\n    post: Alloc\n    tx: Transaction\n    engine_api_error_code: Optional[EngineAPIError] = None\n    blockchain_test_header_verify: Optional[Header] = None\n    blockchain_test_rlp_modifier: Optional[Header] = None\n    chain_id: int = 1\n\n    supported_fixture_formats: ClassVar[Sequence[FixtureFormat | LabeledFixtureFormat]] = [\n        StateFixture,\n    ] + [\n        LabeledFixtureFormat(\n            fixture_format,\n            f\"{fixture_format.format_name}_from_state_test\",\n            f\"A {fixture_format.format_name} generated from a state_test\",\n        )\n        for fixture_format in BlockchainTest.supported_fixture_formats\n    ]\n    supported_execute_formats: ClassVar[Sequence[ExecuteFormat | LabeledExecuteFormat]] = [\n        TransactionPost,\n    ]\n\n    supported_markers: ClassVar[Dict[str, str]] = {\n        \"state_test_only\": \"Only generate a state test fixture\",\n    }\n\n    @classmethod\n    def discard_fixture_format_by_marks(\n        cls,\n        fixture_format: FixtureFormat,\n        fork: Fork,\n        markers: List[pytest.Mark],\n    ) -&gt; bool:\n        \"\"\"Discard a fixture format from filling if the appropriate marker is used.\"\"\"\n        if \"state_test_only\" in [m.name for m in markers]:\n            return fixture_format != StateFixture\n        return False\n\n    def _generate_blockchain_genesis_environment(self, *, fork: Fork) -&gt; Environment:\n        \"\"\"Generate the genesis environment for the BlockchainTest formatted test.\"\"\"\n        assert self.env.number &gt;= 1, (\n            \"genesis block number cannot be negative, set state test env.number to 1\"\n        )\n\n        # Modify values to the proper values for the genesis block\n        # TODO: All of this can be moved to a new method in `Fork`\n        updated_values: Dict[str, Any] = {\n            \"withdrawals\": None,\n            \"parent_beacon_block_root\": None,\n            \"number\": self.env.number - 1,\n        }\n        if self.env.excess_blob_gas:\n            # The excess blob gas environment value means the value of the context (block header)\n            # where the transaction is executed. In a blockchain test, we need to indirectly\n            # set the excess blob gas by setting the excess blob gas of the genesis block\n            # to the expected value plus the TARGET_BLOB_GAS_PER_BLOCK, which is the value\n            # that will be subtracted from the excess blob gas when the first block is mined.\n            updated_values[\"excess_blob_gas\"] = self.env.excess_blob_gas + (\n                fork.target_blobs_per_block() * fork.blob_gas_per_blob()\n            )\n\n        return self.env.copy(**updated_values)\n\n    def _generate_blockchain_blocks(self) -&gt; List[Block]:\n        \"\"\"Generate the single block that represents this state test in a BlockchainTest format.\"\"\"\n        return [\n            Block(\n                number=self.env.number,\n                timestamp=self.env.timestamp,\n                fee_recipient=self.env.fee_recipient,\n                difficulty=self.env.difficulty,\n                gas_limit=self.env.gas_limit,\n                extra_data=self.env.extra_data,\n                withdrawals=self.env.withdrawals,\n                parent_beacon_block_root=self.env.parent_beacon_block_root,\n                txs=[self.tx],\n                ommers=[],\n                exception=self.tx.error,\n                header_verify=self.blockchain_test_header_verify,\n                rlp_modifier=self.blockchain_test_rlp_modifier,\n            )\n        ]\n\n    def generate_blockchain_test(self, *, fork: Fork) -&gt; BlockchainTest:\n        \"\"\"Generate a BlockchainTest fixture from this StateTest fixture.\"\"\"\n        return BlockchainTest(\n            genesis_environment=self._generate_blockchain_genesis_environment(fork=fork),\n            pre=self.pre,\n            post=self.post,\n            blocks=self._generate_blockchain_blocks(),\n            t8n_dump_dir=self.t8n_dump_dir,\n        )\n\n    def make_state_test_fixture(\n        self,\n        t8n: TransitionTool,\n        fork: Fork,\n        eips: Optional[List[int]] = None,\n        slow: bool = False,\n    ) -&gt; StateFixture:\n        \"\"\"Create a fixture from the state test definition.\"\"\"\n        # We can't generate a state test fixture that names a transition fork,\n        # so we get the fork at the block number and timestamp of the state test\n        fork = fork.fork_at(self.env.number, self.env.timestamp)\n\n        env = self.env.set_fork_requirements(fork)\n        tx = self.tx.with_signature_and_sender(keep_secret_key=True)\n        pre_alloc = Alloc.merge(\n            Alloc.model_validate(fork.pre_allocation()),\n            self.pre,\n        )\n        if empty_accounts := pre_alloc.empty_accounts():\n            raise Exception(f\"Empty accounts in pre state: {empty_accounts}\")\n\n        transition_tool_output = t8n.evaluate(\n            alloc=pre_alloc,\n            txs=[tx],\n            env=env,\n            fork=fork,\n            chain_id=self.chain_id,\n            reward=0,  # Reward on state tests is always zero\n            blob_schedule=fork.blob_schedule(),\n            eips=eips,\n            debug_output_path=self.get_next_transition_tool_output_path(),\n            state_test=True,\n            slow_request=slow,\n        )\n\n        try:\n            self.post.verify_post_alloc(transition_tool_output.alloc)\n        except Exception as e:\n            print_traces(t8n.get_traces())\n            raise e\n\n        try:\n            verify_transactions(\n                txs=[tx],\n                exception_mapper=t8n.exception_mapper,\n                result=transition_tool_output.result,\n            )\n        except Exception as e:\n            print_traces(t8n.get_traces())\n            pprint(transition_tool_output.result)\n            pprint(transition_tool_output.alloc)\n            raise e\n\n        return StateFixture(\n            env=FixtureEnvironment(**env.model_dump(exclude_none=True)),\n            pre=pre_alloc,\n            post={\n                fork.blockchain_test_network_name(): [\n                    FixtureForkPost(\n                        state_root=transition_tool_output.result.state_root,\n                        logs_hash=transition_tool_output.result.logs_hash,\n                        tx_bytes=tx.rlp,\n                        expect_exception=tx.error,\n                        state=transition_tool_output.alloc,\n                    )\n                ]\n            },\n            transaction=FixtureTransaction.from_transaction(tx),\n            config=FixtureConfig(\n                blob_schedule=FixtureBlobSchedule.from_blob_schedule(fork.blob_schedule()),\n                chain_id=self.chain_id,\n            ),\n        )\n\n    def generate(\n        self,\n        request: pytest.FixtureRequest,\n        t8n: TransitionTool,\n        fork: Fork,\n        fixture_format: FixtureFormat,\n        eips: Optional[List[int]] = None,\n    ) -&gt; BaseFixture:\n        \"\"\"Generate the BlockchainTest fixture.\"\"\"\n        if fixture_format in BlockchainTest.supported_fixture_formats:\n            return self.generate_blockchain_test(fork=fork).generate(\n                request=request, t8n=t8n, fork=fork, fixture_format=fixture_format, eips=eips\n            )\n        elif fixture_format == StateFixture:\n            return self.make_state_test_fixture(t8n, fork, eips, slow=is_slow_test(request))\n\n        raise Exception(f\"Unknown fixture format: {fixture_format}\")\n\n    def execute(\n        self,\n        *,\n        fork: Fork,\n        execute_format: ExecuteFormat,\n        eips: Optional[List[int]] = None,\n    ) -&gt; BaseExecute:\n        \"\"\"Generate the list of test fixtures.\"\"\"\n        if execute_format == TransactionPost:\n            return TransactionPost(\n                transactions=[self.tx],\n                post=self.post,\n            )\n        raise Exception(f\"Unsupported execute format: {execute_format}\")\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.StateTest.discard_fixture_format_by_marks","title":"<code>discard_fixture_format_by_marks(fixture_format, fork, markers)</code>  <code>classmethod</code>","text":"<p>Discard a fixture format from filling if the appropriate marker is used.</p> Source code in <code>src/ethereum_test_specs/state.py</code> <pre><code>@classmethod\ndef discard_fixture_format_by_marks(\n    cls,\n    fixture_format: FixtureFormat,\n    fork: Fork,\n    markers: List[pytest.Mark],\n) -&gt; bool:\n    \"\"\"Discard a fixture format from filling if the appropriate marker is used.\"\"\"\n    if \"state_test_only\" in [m.name for m in markers]:\n        return fixture_format != StateFixture\n    return False\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.StateTest.generate_blockchain_test","title":"<code>generate_blockchain_test(*, fork)</code>","text":"<p>Generate a BlockchainTest fixture from this StateTest fixture.</p> Source code in <code>src/ethereum_test_specs/state.py</code> <pre><code>def generate_blockchain_test(self, *, fork: Fork) -&gt; BlockchainTest:\n    \"\"\"Generate a BlockchainTest fixture from this StateTest fixture.\"\"\"\n    return BlockchainTest(\n        genesis_environment=self._generate_blockchain_genesis_environment(fork=fork),\n        pre=self.pre,\n        post=self.post,\n        blocks=self._generate_blockchain_blocks(),\n        t8n_dump_dir=self.t8n_dump_dir,\n    )\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.StateTest.make_state_test_fixture","title":"<code>make_state_test_fixture(t8n, fork, eips=None, slow=False)</code>","text":"<p>Create a fixture from the state test definition.</p> Source code in <code>src/ethereum_test_specs/state.py</code> <pre><code>def make_state_test_fixture(\n    self,\n    t8n: TransitionTool,\n    fork: Fork,\n    eips: Optional[List[int]] = None,\n    slow: bool = False,\n) -&gt; StateFixture:\n    \"\"\"Create a fixture from the state test definition.\"\"\"\n    # We can't generate a state test fixture that names a transition fork,\n    # so we get the fork at the block number and timestamp of the state test\n    fork = fork.fork_at(self.env.number, self.env.timestamp)\n\n    env = self.env.set_fork_requirements(fork)\n    tx = self.tx.with_signature_and_sender(keep_secret_key=True)\n    pre_alloc = Alloc.merge(\n        Alloc.model_validate(fork.pre_allocation()),\n        self.pre,\n    )\n    if empty_accounts := pre_alloc.empty_accounts():\n        raise Exception(f\"Empty accounts in pre state: {empty_accounts}\")\n\n    transition_tool_output = t8n.evaluate(\n        alloc=pre_alloc,\n        txs=[tx],\n        env=env,\n        fork=fork,\n        chain_id=self.chain_id,\n        reward=0,  # Reward on state tests is always zero\n        blob_schedule=fork.blob_schedule(),\n        eips=eips,\n        debug_output_path=self.get_next_transition_tool_output_path(),\n        state_test=True,\n        slow_request=slow,\n    )\n\n    try:\n        self.post.verify_post_alloc(transition_tool_output.alloc)\n    except Exception as e:\n        print_traces(t8n.get_traces())\n        raise e\n\n    try:\n        verify_transactions(\n            txs=[tx],\n            exception_mapper=t8n.exception_mapper,\n            result=transition_tool_output.result,\n        )\n    except Exception as e:\n        print_traces(t8n.get_traces())\n        pprint(transition_tool_output.result)\n        pprint(transition_tool_output.alloc)\n        raise e\n\n    return StateFixture(\n        env=FixtureEnvironment(**env.model_dump(exclude_none=True)),\n        pre=pre_alloc,\n        post={\n            fork.blockchain_test_network_name(): [\n                FixtureForkPost(\n                    state_root=transition_tool_output.result.state_root,\n                    logs_hash=transition_tool_output.result.logs_hash,\n                    tx_bytes=tx.rlp,\n                    expect_exception=tx.error,\n                    state=transition_tool_output.alloc,\n                )\n            ]\n        },\n        transaction=FixtureTransaction.from_transaction(tx),\n        config=FixtureConfig(\n            blob_schedule=FixtureBlobSchedule.from_blob_schedule(fork.blob_schedule()),\n            chain_id=self.chain_id,\n        ),\n    )\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.StateTest.generate","title":"<code>generate(request, t8n, fork, fixture_format, eips=None)</code>","text":"<p>Generate the BlockchainTest fixture.</p> Source code in <code>src/ethereum_test_specs/state.py</code> <pre><code>def generate(\n    self,\n    request: pytest.FixtureRequest,\n    t8n: TransitionTool,\n    fork: Fork,\n    fixture_format: FixtureFormat,\n    eips: Optional[List[int]] = None,\n) -&gt; BaseFixture:\n    \"\"\"Generate the BlockchainTest fixture.\"\"\"\n    if fixture_format in BlockchainTest.supported_fixture_formats:\n        return self.generate_blockchain_test(fork=fork).generate(\n            request=request, t8n=t8n, fork=fork, fixture_format=fixture_format, eips=eips\n        )\n    elif fixture_format == StateFixture:\n        return self.make_state_test_fixture(t8n, fork, eips, slow=is_slow_test(request))\n\n    raise Exception(f\"Unknown fixture format: {fixture_format}\")\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.StateTest.execute","title":"<code>execute(*, fork, execute_format, eips=None)</code>","text":"<p>Generate the list of test fixtures.</p> Source code in <code>src/ethereum_test_specs/state.py</code> <pre><code>def execute(\n    self,\n    *,\n    fork: Fork,\n    execute_format: ExecuteFormat,\n    eips: Optional[List[int]] = None,\n) -&gt; BaseExecute:\n    \"\"\"Generate the list of test fixtures.\"\"\"\n    if execute_format == TransactionPost:\n        return TransactionPost(\n            transactions=[self.tx],\n            post=self.post,\n        )\n    raise Exception(f\"Unsupported execute format: {execute_format}\")\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.TransactionTest","title":"<code>TransactionTest</code>","text":"<p>               Bases: <code>BaseTest</code></p> <p>Filler type that tests the transaction over the period of a single block.</p> Source code in <code>src/ethereum_test_specs/transaction.py</code> <pre><code>class TransactionTest(BaseTest):\n    \"\"\"Filler type that tests the transaction over the period of a single block.\"\"\"\n\n    tx: Transaction\n    pre: Alloc | None = None\n\n    supported_fixture_formats: ClassVar[Sequence[FixtureFormat | LabeledFixtureFormat]] = [\n        TransactionFixture,\n    ]\n    supported_execute_formats: ClassVar[Sequence[ExecuteFormat | LabeledExecuteFormat]] = [\n        TransactionPost,\n    ]\n\n    def make_transaction_test_fixture(\n        self,\n        fork: Fork,\n        eips: Optional[List[int]] = None,\n    ) -&gt; TransactionFixture:\n        \"\"\"Create a fixture from the transaction test definition.\"\"\"\n        if self.tx.error is not None:\n            result = FixtureResult(\n                exception=self.tx.error,\n                hash=None,\n                intrinsic_gas=0,\n                sender=None,\n            )\n        else:\n            intrinsic_gas_cost_calculator = fork.transaction_intrinsic_cost_calculator()\n            intrinsic_gas = intrinsic_gas_cost_calculator(\n                calldata=self.tx.data,\n                contract_creation=self.tx.to is None,\n                access_list=self.tx.access_list,\n                authorization_list_or_count=self.tx.authorization_list,\n            )\n            result = FixtureResult(\n                exception=None,\n                hash=self.tx.hash,\n                intrinsic_gas=intrinsic_gas,\n                sender=self.tx.sender,\n            )\n\n        return TransactionFixture(\n            result={\n                fork.blockchain_test_network_name(): result,\n            },\n            transaction=self.tx.with_signature_and_sender().rlp,\n        )\n\n    def generate(\n        self,\n        request: pytest.FixtureRequest,\n        t8n: TransitionTool,\n        fork: Fork,\n        fixture_format: FixtureFormat,\n        eips: Optional[List[int]] = None,\n    ) -&gt; BaseFixture:\n        \"\"\"Generate the TransactionTest fixture.\"\"\"\n        if fixture_format == TransactionFixture:\n            return self.make_transaction_test_fixture(fork, eips)\n\n        raise Exception(f\"Unknown fixture format: {fixture_format}\")\n\n    def execute(\n        self,\n        *,\n        fork: Fork,\n        execute_format: ExecuteFormat,\n        eips: Optional[List[int]] = None,\n    ) -&gt; BaseExecute:\n        \"\"\"Execute the transaction test by sending it to the live network.\"\"\"\n        if execute_format == TransactionPost:\n            return TransactionPost(\n                transactions=[self.tx],\n                post={},\n            )\n        raise Exception(f\"Unsupported execute format: {execute_format}\")\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.TransactionTest.make_transaction_test_fixture","title":"<code>make_transaction_test_fixture(fork, eips=None)</code>","text":"<p>Create a fixture from the transaction test definition.</p> Source code in <code>src/ethereum_test_specs/transaction.py</code> <pre><code>def make_transaction_test_fixture(\n    self,\n    fork: Fork,\n    eips: Optional[List[int]] = None,\n) -&gt; TransactionFixture:\n    \"\"\"Create a fixture from the transaction test definition.\"\"\"\n    if self.tx.error is not None:\n        result = FixtureResult(\n            exception=self.tx.error,\n            hash=None,\n            intrinsic_gas=0,\n            sender=None,\n        )\n    else:\n        intrinsic_gas_cost_calculator = fork.transaction_intrinsic_cost_calculator()\n        intrinsic_gas = intrinsic_gas_cost_calculator(\n            calldata=self.tx.data,\n            contract_creation=self.tx.to is None,\n            access_list=self.tx.access_list,\n            authorization_list_or_count=self.tx.authorization_list,\n        )\n        result = FixtureResult(\n            exception=None,\n            hash=self.tx.hash,\n            intrinsic_gas=intrinsic_gas,\n            sender=self.tx.sender,\n        )\n\n    return TransactionFixture(\n        result={\n            fork.blockchain_test_network_name(): result,\n        },\n        transaction=self.tx.with_signature_and_sender().rlp,\n    )\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.TransactionTest.generate","title":"<code>generate(request, t8n, fork, fixture_format, eips=None)</code>","text":"<p>Generate the TransactionTest fixture.</p> Source code in <code>src/ethereum_test_specs/transaction.py</code> <pre><code>def generate(\n    self,\n    request: pytest.FixtureRequest,\n    t8n: TransitionTool,\n    fork: Fork,\n    fixture_format: FixtureFormat,\n    eips: Optional[List[int]] = None,\n) -&gt; BaseFixture:\n    \"\"\"Generate the TransactionTest fixture.\"\"\"\n    if fixture_format == TransactionFixture:\n        return self.make_transaction_test_fixture(fork, eips)\n\n    raise Exception(f\"Unknown fixture format: {fixture_format}\")\n</code></pre>"},{"location":"library/ethereum_test_specs/#ethereum_test_specs.TransactionTest.execute","title":"<code>execute(*, fork, execute_format, eips=None)</code>","text":"<p>Execute the transaction test by sending it to the live network.</p> Source code in <code>src/ethereum_test_specs/transaction.py</code> <pre><code>def execute(\n    self,\n    *,\n    fork: Fork,\n    execute_format: ExecuteFormat,\n    eips: Optional[List[int]] = None,\n) -&gt; BaseExecute:\n    \"\"\"Execute the transaction test by sending it to the live network.\"\"\"\n    if execute_format == TransactionPost:\n        return TransactionPost(\n            transactions=[self.tx],\n            post={},\n        )\n    raise Exception(f\"Unsupported execute format: {execute_format}\")\n</code></pre>"},{"location":"library/ethereum_test_tools/","title":"Ethereum Test Tools Package","text":"<p>Module containing tools for generating cross-client Ethereum execution layer tests.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.AccessList","title":"<code>AccessList</code>","text":"<p>               Bases: <code>CamelModel</code></p> <p>Access List for transactions.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>class AccessList(CamelModel):\n    \"\"\"Access List for transactions.\"\"\"\n\n    address: Address\n    storage_keys: List[Hash]\n\n    def to_list(self) -&gt; List[Address | List[Hash]]:\n        \"\"\"Return access list as a list of serializable elements.\"\"\"\n        return [self.address, self.storage_keys]\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.AccessList.to_list","title":"<code>to_list()</code>","text":"<p>Return access list as a list of serializable elements.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def to_list(self) -&gt; List[Address | List[Hash]]:\n    \"\"\"Return access list as a list of serializable elements.\"\"\"\n    return [self.address, self.storage_keys]\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Account","title":"<code>Account</code>","text":"<p>               Bases: <code>CamelModel</code></p> <p>State associated with an address.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>class Account(CamelModel):\n    \"\"\"State associated with an address.\"\"\"\n\n    nonce: ZeroPaddedHexNumber = ZeroPaddedHexNumber(0)\n    \"\"\"\n    The scalar value equal to a) the number of transactions sent by\n    an Externally Owned Account, b) the amount of contracts created by a\n    contract.\n    \"\"\"\n    balance: ZeroPaddedHexNumber = ZeroPaddedHexNumber(0)\n    \"\"\"\n    The amount of Wei (10&lt;sup&gt;-18&lt;/sup&gt; Eth) the account has.\n    \"\"\"\n    code: Bytes = Bytes(b\"\")\n    \"\"\"\n    Bytecode contained by the account.\n    \"\"\"\n    storage: Storage = Field(default_factory=Storage)\n    \"\"\"\n    Storage within a contract.\n    \"\"\"\n\n    NONEXISTENT: ClassVar[None] = None\n    \"\"\"\n    Sentinel object used to specify when an account should not exist in the\n    state.\n    \"\"\"\n\n    @dataclass(kw_only=True)\n    class NonceMismatchError(Exception):\n        \"\"\"\n        Test expected a certain nonce value for an account but a different\n        value was found.\n        \"\"\"\n\n        address: Address\n        want: int | None\n        got: int | None\n\n        def __init__(self, address: Address, want: int | None, got: int | None, *args):\n            \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n            super().__init__(args)\n            self.address = address\n            self.want = want\n            self.got = got\n\n        def __str__(self):\n            \"\"\"Print exception string.\"\"\"\n            label_str = \"\"\n            if self.address.label is not None:\n                label_str = f\" ({self.address.label})\"\n            return (\n                f\"unexpected nonce for account {self.address}{label_str}: \"\n                + f\"want {self.want}, got {self.got}\"\n            )\n\n    @dataclass(kw_only=True)\n    class BalanceMismatchError(Exception):\n        \"\"\"\n        Test expected a certain balance for an account but a different\n        value was found.\n        \"\"\"\n\n        address: Address\n        want: int | None\n        got: int | None\n\n        def __init__(self, address: Address, want: int | None, got: int | None, *args):\n            \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n            super().__init__(args)\n            self.address = address\n            self.want = want\n            self.got = got\n\n        def __str__(self):\n            \"\"\"Print exception string.\"\"\"\n            label_str = \"\"\n            if self.address.label is not None:\n                label_str = f\" ({self.address.label})\"\n            return (\n                f\"unexpected balance for account {self.address}{label_str}: \"\n                + f\"want {self.want}, got {self.got}\"\n            )\n\n    @dataclass(kw_only=True)\n    class CodeMismatchError(Exception):\n        \"\"\"\n        Test expected a certain bytecode for an account but a different\n        one was found.\n        \"\"\"\n\n        address: Address\n        want: bytes | None\n        got: bytes | None\n\n        def __init__(self, address: Address, want: bytes | None, got: bytes | None, *args):\n            \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n            super().__init__(args)\n            self.address = address\n            self.want = want\n            self.got = got\n\n        def __str__(self):\n            \"\"\"Print exception string.\"\"\"\n            label_str = \"\"\n            if self.address.label is not None:\n                label_str = f\" ({self.address.label})\"\n            return (\n                f\"unexpected code for account {self.address}{label_str}: \"\n                + f\"want {self.want}, got {self.got}\"\n            )\n\n    def check_alloc(self: \"Account\", address: Address, account: \"Account\"):\n        \"\"\"\n        Check the returned alloc against an expected account in post state.\n        Raises exception on failure.\n        \"\"\"\n        if \"nonce\" in self.model_fields_set:\n            if self.nonce != account.nonce:\n                raise Account.NonceMismatchError(\n                    address=address,\n                    want=self.nonce,\n                    got=account.nonce,\n                )\n\n        if \"balance\" in self.model_fields_set:\n            if self.balance != account.balance:\n                raise Account.BalanceMismatchError(\n                    address=address,\n                    want=self.balance,\n                    got=account.balance,\n                )\n\n        if \"code\" in self.model_fields_set:\n            if self.code != account.code:\n                raise Account.CodeMismatchError(\n                    address=address,\n                    want=self.code,\n                    got=account.code,\n                )\n\n        if \"storage\" in self.model_fields_set:\n            self.storage.must_be_equal(address=address, other=account.storage)\n\n    def __bool__(self: \"Account\") -&gt; bool:\n        \"\"\"Return True on a non-empty account.\"\"\"\n        return any((self.nonce, self.balance, self.code, self.storage))\n\n    @classmethod\n    def with_code(cls: Type, code: BytesConvertible) -&gt; \"Account\":\n        \"\"\"Create account with provided `code` and nonce of `1`.\"\"\"\n        return Account(nonce=HexNumber(1), code=Bytes(code))\n\n    @classmethod\n    def merge(\n        cls: Type, account_1: \"Dict | Account | None\", account_2: \"Dict | Account | None\"\n    ) -&gt; \"Account\":\n        \"\"\"Create a merged account from two sources.\"\"\"\n\n        def to_kwargs_dict(account: \"Dict | Account | None\") -&gt; Dict:\n            if account is None:\n                return {}\n            if isinstance(account, dict):\n                return account\n            elif isinstance(account, cls):\n                return account.model_dump(exclude_unset=True)\n            raise TypeError(f\"Unexpected type for account merge: {type(account)}\")\n\n        kwargs = to_kwargs_dict(account_1)\n        kwargs.update(to_kwargs_dict(account_2))\n\n        return cls(**kwargs)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Account.nonce","title":"<code>nonce: ZeroPaddedHexNumber = ZeroPaddedHexNumber(0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The scalar value equal to a) the number of transactions sent by an Externally Owned Account, b) the amount of contracts created by a contract.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Account.balance","title":"<code>balance: ZeroPaddedHexNumber = ZeroPaddedHexNumber(0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The amount of Wei (10<sup>-18</sup> Eth) the account has.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Account.code","title":"<code>code: Bytes = Bytes(b'')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Bytecode contained by the account.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Account.storage","title":"<code>storage: Storage = Field(default_factory=Storage)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Storage within a contract.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Account.NONEXISTENT","title":"<code>NONEXISTENT: None = None</code>  <code>class-attribute</code>","text":"<p>Sentinel object used to specify when an account should not exist in the state.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Account.NonceMismatchError","title":"<code>NonceMismatchError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Test expected a certain nonce value for an account but a different value was found.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>@dataclass(kw_only=True)\nclass NonceMismatchError(Exception):\n    \"\"\"\n    Test expected a certain nonce value for an account but a different\n    value was found.\n    \"\"\"\n\n    address: Address\n    want: int | None\n    got: int | None\n\n    def __init__(self, address: Address, want: int | None, got: int | None, *args):\n        \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n        super().__init__(args)\n        self.address = address\n        self.want = want\n        self.got = got\n\n    def __str__(self):\n        \"\"\"Print exception string.\"\"\"\n        label_str = \"\"\n        if self.address.label is not None:\n            label_str = f\" ({self.address.label})\"\n        return (\n            f\"unexpected nonce for account {self.address}{label_str}: \"\n            + f\"want {self.want}, got {self.got}\"\n        )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Account.NonceMismatchError.__init__","title":"<code>__init__(address, want, got, *args)</code>","text":"<p>Initialize the exception with the address, wanted and got values.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __init__(self, address: Address, want: int | None, got: int | None, *args):\n    \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n    super().__init__(args)\n    self.address = address\n    self.want = want\n    self.got = got\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Account.NonceMismatchError.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __str__(self):\n    \"\"\"Print exception string.\"\"\"\n    label_str = \"\"\n    if self.address.label is not None:\n        label_str = f\" ({self.address.label})\"\n    return (\n        f\"unexpected nonce for account {self.address}{label_str}: \"\n        + f\"want {self.want}, got {self.got}\"\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Account.BalanceMismatchError","title":"<code>BalanceMismatchError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Test expected a certain balance for an account but a different value was found.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>@dataclass(kw_only=True)\nclass BalanceMismatchError(Exception):\n    \"\"\"\n    Test expected a certain balance for an account but a different\n    value was found.\n    \"\"\"\n\n    address: Address\n    want: int | None\n    got: int | None\n\n    def __init__(self, address: Address, want: int | None, got: int | None, *args):\n        \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n        super().__init__(args)\n        self.address = address\n        self.want = want\n        self.got = got\n\n    def __str__(self):\n        \"\"\"Print exception string.\"\"\"\n        label_str = \"\"\n        if self.address.label is not None:\n            label_str = f\" ({self.address.label})\"\n        return (\n            f\"unexpected balance for account {self.address}{label_str}: \"\n            + f\"want {self.want}, got {self.got}\"\n        )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Account.BalanceMismatchError.__init__","title":"<code>__init__(address, want, got, *args)</code>","text":"<p>Initialize the exception with the address, wanted and got values.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __init__(self, address: Address, want: int | None, got: int | None, *args):\n    \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n    super().__init__(args)\n    self.address = address\n    self.want = want\n    self.got = got\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Account.BalanceMismatchError.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __str__(self):\n    \"\"\"Print exception string.\"\"\"\n    label_str = \"\"\n    if self.address.label is not None:\n        label_str = f\" ({self.address.label})\"\n    return (\n        f\"unexpected balance for account {self.address}{label_str}: \"\n        + f\"want {self.want}, got {self.got}\"\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Account.CodeMismatchError","title":"<code>CodeMismatchError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Test expected a certain bytecode for an account but a different one was found.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>@dataclass(kw_only=True)\nclass CodeMismatchError(Exception):\n    \"\"\"\n    Test expected a certain bytecode for an account but a different\n    one was found.\n    \"\"\"\n\n    address: Address\n    want: bytes | None\n    got: bytes | None\n\n    def __init__(self, address: Address, want: bytes | None, got: bytes | None, *args):\n        \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n        super().__init__(args)\n        self.address = address\n        self.want = want\n        self.got = got\n\n    def __str__(self):\n        \"\"\"Print exception string.\"\"\"\n        label_str = \"\"\n        if self.address.label is not None:\n            label_str = f\" ({self.address.label})\"\n        return (\n            f\"unexpected code for account {self.address}{label_str}: \"\n            + f\"want {self.want}, got {self.got}\"\n        )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Account.CodeMismatchError.__init__","title":"<code>__init__(address, want, got, *args)</code>","text":"<p>Initialize the exception with the address, wanted and got values.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __init__(self, address: Address, want: bytes | None, got: bytes | None, *args):\n    \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n    super().__init__(args)\n    self.address = address\n    self.want = want\n    self.got = got\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Account.CodeMismatchError.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __str__(self):\n    \"\"\"Print exception string.\"\"\"\n    label_str = \"\"\n    if self.address.label is not None:\n        label_str = f\" ({self.address.label})\"\n    return (\n        f\"unexpected code for account {self.address}{label_str}: \"\n        + f\"want {self.want}, got {self.got}\"\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Account.check_alloc","title":"<code>check_alloc(address, account)</code>","text":"<p>Check the returned alloc against an expected account in post state. Raises exception on failure.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def check_alloc(self: \"Account\", address: Address, account: \"Account\"):\n    \"\"\"\n    Check the returned alloc against an expected account in post state.\n    Raises exception on failure.\n    \"\"\"\n    if \"nonce\" in self.model_fields_set:\n        if self.nonce != account.nonce:\n            raise Account.NonceMismatchError(\n                address=address,\n                want=self.nonce,\n                got=account.nonce,\n            )\n\n    if \"balance\" in self.model_fields_set:\n        if self.balance != account.balance:\n            raise Account.BalanceMismatchError(\n                address=address,\n                want=self.balance,\n                got=account.balance,\n            )\n\n    if \"code\" in self.model_fields_set:\n        if self.code != account.code:\n            raise Account.CodeMismatchError(\n                address=address,\n                want=self.code,\n                got=account.code,\n            )\n\n    if \"storage\" in self.model_fields_set:\n        self.storage.must_be_equal(address=address, other=account.storage)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Account.__bool__","title":"<code>__bool__()</code>","text":"<p>Return True on a non-empty account.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __bool__(self: \"Account\") -&gt; bool:\n    \"\"\"Return True on a non-empty account.\"\"\"\n    return any((self.nonce, self.balance, self.code, self.storage))\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Account.with_code","title":"<code>with_code(code)</code>  <code>classmethod</code>","text":"<p>Create account with provided <code>code</code> and nonce of <code>1</code>.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>@classmethod\ndef with_code(cls: Type, code: BytesConvertible) -&gt; \"Account\":\n    \"\"\"Create account with provided `code` and nonce of `1`.\"\"\"\n    return Account(nonce=HexNumber(1), code=Bytes(code))\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Account.merge","title":"<code>merge(account_1, account_2)</code>  <code>classmethod</code>","text":"<p>Create a merged account from two sources.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>@classmethod\ndef merge(\n    cls: Type, account_1: \"Dict | Account | None\", account_2: \"Dict | Account | None\"\n) -&gt; \"Account\":\n    \"\"\"Create a merged account from two sources.\"\"\"\n\n    def to_kwargs_dict(account: \"Dict | Account | None\") -&gt; Dict:\n        if account is None:\n            return {}\n        if isinstance(account, dict):\n            return account\n        elif isinstance(account, cls):\n            return account.model_dump(exclude_unset=True)\n        raise TypeError(f\"Unexpected type for account merge: {type(account)}\")\n\n    kwargs = to_kwargs_dict(account_1)\n    kwargs.update(to_kwargs_dict(account_2))\n\n    return cls(**kwargs)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Address","title":"<code>Address</code>","text":"<p>               Bases: <code>FixedSizeBytes[20]</code></p> <p>Class that helps represent Ethereum addresses in tests.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>class Address(FixedSizeBytes[20]):  # type: ignore\n    \"\"\"Class that helps represent Ethereum addresses in tests.\"\"\"\n\n    label: str | None = None\n\n    def __new__(\n        cls,\n        input_bytes: \"FixedSizeBytesConvertible | Address\",\n        *args,\n        label: str | None = None,\n        **kwargs,\n    ):\n        \"\"\"Create a new Address object with an optional label.\"\"\"\n        instance = super(Address, cls).__new__(cls, input_bytes, *args, **kwargs)\n        if isinstance(input_bytes, Address) and label is None:\n            instance.label = input_bytes.label\n        else:\n            instance.label = label\n        return instance\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Address.__new__","title":"<code>__new__(input_bytes, *args, label=None, **kwargs)</code>","text":"<p>Create a new Address object with an optional label.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def __new__(\n    cls,\n    input_bytes: \"FixedSizeBytesConvertible | Address\",\n    *args,\n    label: str | None = None,\n    **kwargs,\n):\n    \"\"\"Create a new Address object with an optional label.\"\"\"\n    instance = super(Address, cls).__new__(cls, input_bytes, *args, **kwargs)\n    if isinstance(input_bytes, Address) and label is None:\n        instance.label = input_bytes.label\n    else:\n        instance.label = label\n    return instance\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Bytes","title":"<code>Bytes</code>","text":"<p>               Bases: <code>bytes</code>, <code>ToStringSchema</code></p> <p>Class that helps represent bytes of variable length in tests.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>class Bytes(bytes, ToStringSchema):\n    \"\"\"Class that helps represent bytes of variable length in tests.\"\"\"\n\n    def __new__(cls, input_bytes: BytesConvertible = b\"\"):\n        \"\"\"Create a new Bytes object.\"\"\"\n        if type(input_bytes) is cls:\n            return input_bytes\n        return super(Bytes, cls).__new__(cls, to_bytes(input_bytes))\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return the hash of the bytes.\"\"\"\n        return super(Bytes, self).__hash__()\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the hexadecimal representation of the bytes.\"\"\"\n        return self.hex()\n\n    def hex(self, *args, **kwargs) -&gt; str:\n        \"\"\"Return the hexadecimal representation of the bytes.\"\"\"\n        return \"0x\" + super().hex(*args, **kwargs)\n\n    @classmethod\n    def or_none(cls, input_bytes: \"Bytes | BytesConvertible | None\") -&gt; \"Bytes | None\":\n        \"\"\"Convert the input to a Bytes while accepting None.\"\"\"\n        if input_bytes is None:\n            return input_bytes\n        return cls(input_bytes)\n\n    def keccak256(self) -&gt; \"Hash\":\n        \"\"\"Return the keccak256 hash of the opcode byte representation.\"\"\"\n        k = keccak.new(digest_bits=256)\n        return Hash(k.update(bytes(self)).digest())\n\n    def sha256(self) -&gt; \"Hash\":\n        \"\"\"Return the sha256 hash of the opcode byte representation.\"\"\"\n        return Hash(sha256(self).digest())\n\n    @staticmethod\n    def __get_pydantic_core_schema__(\n        source_type: Any, handler: GetCoreSchemaHandler\n    ) -&gt; PlainValidatorFunctionSchema:\n        \"\"\"Call the class constructor without info and appends the serialization schema.\"\"\"\n        return no_info_plain_validator_function(\n            source_type,\n            serialization=to_string_ser_schema(),\n            json_schema_input_schema=handler(\n                Annotated[str, StringConstraints(pattern=r\"^0x([0-9a-fA-F]{2})*$\")]\n            ),\n        )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Bytes.__new__","title":"<code>__new__(input_bytes=b'')</code>","text":"<p>Create a new Bytes object.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def __new__(cls, input_bytes: BytesConvertible = b\"\"):\n    \"\"\"Create a new Bytes object.\"\"\"\n    if type(input_bytes) is cls:\n        return input_bytes\n    return super(Bytes, cls).__new__(cls, to_bytes(input_bytes))\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Bytes.__hash__","title":"<code>__hash__()</code>","text":"<p>Return the hash of the bytes.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return the hash of the bytes.\"\"\"\n    return super(Bytes, self).__hash__()\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Bytes.__str__","title":"<code>__str__()</code>","text":"<p>Return the hexadecimal representation of the bytes.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the hexadecimal representation of the bytes.\"\"\"\n    return self.hex()\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Bytes.hex","title":"<code>hex(*args, **kwargs)</code>","text":"<p>Return the hexadecimal representation of the bytes.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def hex(self, *args, **kwargs) -&gt; str:\n    \"\"\"Return the hexadecimal representation of the bytes.\"\"\"\n    return \"0x\" + super().hex(*args, **kwargs)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Bytes.or_none","title":"<code>or_none(input_bytes)</code>  <code>classmethod</code>","text":"<p>Convert the input to a Bytes while accepting None.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>@classmethod\ndef or_none(cls, input_bytes: \"Bytes | BytesConvertible | None\") -&gt; \"Bytes | None\":\n    \"\"\"Convert the input to a Bytes while accepting None.\"\"\"\n    if input_bytes is None:\n        return input_bytes\n    return cls(input_bytes)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Bytes.keccak256","title":"<code>keccak256()</code>","text":"<p>Return the keccak256 hash of the opcode byte representation.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def keccak256(self) -&gt; \"Hash\":\n    \"\"\"Return the keccak256 hash of the opcode byte representation.\"\"\"\n    k = keccak.new(digest_bits=256)\n    return Hash(k.update(bytes(self)).digest())\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Bytes.sha256","title":"<code>sha256()</code>","text":"<p>Return the sha256 hash of the opcode byte representation.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>def sha256(self) -&gt; \"Hash\":\n    \"\"\"Return the sha256 hash of the opcode byte representation.\"\"\"\n    return Hash(sha256(self).digest())\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Bytes.__get_pydantic_core_schema__","title":"<code>__get_pydantic_core_schema__(source_type, handler)</code>  <code>staticmethod</code>","text":"<p>Call the class constructor without info and appends the serialization schema.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>@staticmethod\ndef __get_pydantic_core_schema__(\n    source_type: Any, handler: GetCoreSchemaHandler\n) -&gt; PlainValidatorFunctionSchema:\n    \"\"\"Call the class constructor without info and appends the serialization schema.\"\"\"\n    return no_info_plain_validator_function(\n        source_type,\n        serialization=to_string_ser_schema(),\n        json_schema_input_schema=handler(\n            Annotated[str, StringConstraints(pattern=r\"^0x([0-9a-fA-F]{2})*$\")]\n        ),\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Hash","title":"<code>Hash</code>","text":"<p>               Bases: <code>FixedSizeBytes[32]</code></p> <p>Class that helps represent hashes in tests.</p> Source code in <code>src/ethereum_test_base_types/base_types.py</code> <pre><code>class Hash(FixedSizeBytes[32]):  # type: ignore\n    \"\"\"Class that helps represent hashes in tests.\"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.ReferenceSpec","title":"<code>ReferenceSpec</code>","text":"<p>Reference Specification Description Abstract Class.</p> Source code in <code>src/ethereum_test_base_types/reference_spec/reference_spec.py</code> <pre><code>class ReferenceSpec:\n    \"\"\"Reference Specification Description Abstract Class.\"\"\"\n\n    @abstractmethod\n    def name(self) -&gt; str:\n        \"\"\"Return the name of the spec.\"\"\"\n        pass\n\n    @abstractmethod\n    def has_known_version(self) -&gt; bool:\n        \"\"\"Return true if the reference spec object is hard-coded with a latest known version.\"\"\"\n        pass\n\n    @abstractmethod\n    def known_version(self) -&gt; str:\n        \"\"\"Return the latest known version in the reference.\"\"\"\n        pass\n\n    @abstractmethod\n    def api_url(self) -&gt; str:\n        \"\"\"Return the URL required to poll the version from an API, if needed.\"\"\"\n        pass\n\n    @abstractmethod\n    def latest_version(self) -&gt; str:\n        \"\"\"Return a digest that points to the latest version of the spec.\"\"\"\n        pass\n\n    @abstractmethod\n    def is_outdated(self) -&gt; bool:\n        \"\"\"\n        Check whether the reference specification has been updated since the\n        test was last updated.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def write_info(self, info: Dict[str, Dict[str, Any] | str]):\n        \"\"\"Write info about the reference specification used into the output fixture.\"\"\"\n        pass\n\n    @staticmethod\n    @abstractmethod\n    def parseable_from_module(module_dict: Dict[str, Any]) -&gt; bool:\n        \"\"\"Check whether the module's dict contains required reference spec information.\"\"\"\n        pass\n\n    @staticmethod\n    @abstractmethod\n    def parse_from_module(module_dict: Dict[str, Any]) -&gt; \"ReferenceSpec\":\n        \"\"\"Parse the module's dict into a reference spec.\"\"\"\n        pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.ReferenceSpec.name","title":"<code>name()</code>  <code>abstractmethod</code>","text":"<p>Return the name of the spec.</p> Source code in <code>src/ethereum_test_base_types/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef name(self) -&gt; str:\n    \"\"\"Return the name of the spec.\"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.ReferenceSpec.has_known_version","title":"<code>has_known_version()</code>  <code>abstractmethod</code>","text":"<p>Return true if the reference spec object is hard-coded with a latest known version.</p> Source code in <code>src/ethereum_test_base_types/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef has_known_version(self) -&gt; bool:\n    \"\"\"Return true if the reference spec object is hard-coded with a latest known version.\"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.ReferenceSpec.known_version","title":"<code>known_version()</code>  <code>abstractmethod</code>","text":"<p>Return the latest known version in the reference.</p> Source code in <code>src/ethereum_test_base_types/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef known_version(self) -&gt; str:\n    \"\"\"Return the latest known version in the reference.\"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.ReferenceSpec.api_url","title":"<code>api_url()</code>  <code>abstractmethod</code>","text":"<p>Return the URL required to poll the version from an API, if needed.</p> Source code in <code>src/ethereum_test_base_types/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef api_url(self) -&gt; str:\n    \"\"\"Return the URL required to poll the version from an API, if needed.\"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.ReferenceSpec.latest_version","title":"<code>latest_version()</code>  <code>abstractmethod</code>","text":"<p>Return a digest that points to the latest version of the spec.</p> Source code in <code>src/ethereum_test_base_types/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef latest_version(self) -&gt; str:\n    \"\"\"Return a digest that points to the latest version of the spec.\"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.ReferenceSpec.is_outdated","title":"<code>is_outdated()</code>  <code>abstractmethod</code>","text":"<p>Check whether the reference specification has been updated since the test was last updated.</p> Source code in <code>src/ethereum_test_base_types/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef is_outdated(self) -&gt; bool:\n    \"\"\"\n    Check whether the reference specification has been updated since the\n    test was last updated.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.ReferenceSpec.write_info","title":"<code>write_info(info)</code>  <code>abstractmethod</code>","text":"<p>Write info about the reference specification used into the output fixture.</p> Source code in <code>src/ethereum_test_base_types/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef write_info(self, info: Dict[str, Dict[str, Any] | str]):\n    \"\"\"Write info about the reference specification used into the output fixture.\"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.ReferenceSpec.parseable_from_module","title":"<code>parseable_from_module(module_dict)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Check whether the module's dict contains required reference spec information.</p> Source code in <code>src/ethereum_test_base_types/reference_spec/reference_spec.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef parseable_from_module(module_dict: Dict[str, Any]) -&gt; bool:\n    \"\"\"Check whether the module's dict contains required reference spec information.\"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.ReferenceSpec.parse_from_module","title":"<code>parse_from_module(module_dict)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Parse the module's dict into a reference spec.</p> Source code in <code>src/ethereum_test_base_types/reference_spec/reference_spec.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef parse_from_module(module_dict: Dict[str, Any]) -&gt; \"ReferenceSpec\":\n    \"\"\"Parse the module's dict into a reference spec.\"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException","title":"<code>BlockException</code>","text":"<p>               Bases: <code>ExceptionBase</code></p> <p>Exception raised when a block is invalid, but not due to a transaction.</p> <p>E.g. all transactions in the block are valid, and can be applied to the state, but the block header contains an invalid field.</p> Source code in <code>src/ethereum_test_exceptions/exceptions.py</code> <pre><code>@unique\nclass BlockException(ExceptionBase):\n    \"\"\"\n    Exception raised when a block is invalid, but not due to a transaction.\n\n    E.g. all transactions in the block are valid, and can be applied to the state, but the\n    block header contains an invalid field.\n    \"\"\"\n\n    TOO_MANY_UNCLES = auto()\n    \"\"\"\n    Block declares too many uncles over the allowed limit.\n    \"\"\"\n    UNCLE_IN_CHAIN = auto()\n    \"\"\"\n    Block declares uncle header that is already imported into chain.\n    \"\"\"\n    UNCLE_IS_ANCESTOR = auto()\n    \"\"\"\n    Block declares uncle header that is directly a parent of this block.\n    \"\"\"\n    UNCLE_IS_BROTHER = auto()\n    \"\"\"\n    Block declares two similar uncle headers.\n    \"\"\"\n    UNCLE_PARENT_INCORRECT = auto()\n    \"\"\"\n    Block declares uncle header that is an outdated block to be an uncle.\n    \"\"\"\n    EXTRA_DATA_TOO_BIG = auto()\n    \"\"\"\n    Block header's extra data &gt;32 bytes.\n    \"\"\"\n    EXTRA_DATA_INVALID_DAO = auto()\n    \"\"\"\n    Block header's extra data after dao fork must be a fixed pre defined hash.\n    \"\"\"\n    UNKNOWN_PARENT = auto()\n    \"\"\"\n    Block header's parent hash does not correspond to any of existing blocks on chain.\n    \"\"\"\n    UNCLE_UNKNOWN_PARENT = auto()\n    \"\"\"\n    Uncle header's parent hash does not correspond to any of existing blocks on chain.\n    \"\"\"\n    UNKNOWN_PARENT_ZERO = auto()\n    \"\"\"\n    Block header's parent hash is zero hash.\n    \"\"\"\n    GASLIMIT_TOO_BIG = auto()\n    \"\"\"\n    Block header's gas limit &gt; 0x7fffffffffffffff.\n    \"\"\"\n    INVALID_BLOCK_NUMBER = auto()\n    \"\"\"\n    Block header's number != parent header's number + 1.\n    \"\"\"\n    INVALID_BLOCK_TIMESTAMP_OLDER_THAN_PARENT = auto()\n    \"\"\"\n    Block header's timestamp &lt;= parent header's timestamp.\n    \"\"\"\n    INVALID_DIFFICULTY = auto()\n    \"\"\"\n    Block header's difficulty does not match the difficulty formula calculated from previous block.\n    \"\"\"\n    INVALID_LOG_BLOOM = auto()\n    \"\"\"\n    Block header's logs bloom hash does not match the actually computed log bloom.\n    \"\"\"\n    INVALID_STATE_ROOT = auto()\n    \"\"\"\n    Block header's state root hash does not match the actually computed hash of the state.\n    \"\"\"\n    INVALID_RECEIPTS_ROOT = auto()\n    \"\"\"\n    Block header's receipts root hash does not match the actually computed hash of receipts.\n    \"\"\"\n    INVALID_TRANSACTIONS_ROOT = auto()\n    \"\"\"\n    Block header's transactions root hash does not match the actually computed hash of tx tree.\n    \"\"\"\n    INVALID_UNCLES_HASH = auto()\n    \"\"\"\n    Block header's uncle hash does not match the actually computed hash of block's uncles.\n    \"\"\"\n    GAS_USED_OVERFLOW = auto()\n    \"\"\"\n    Block transactions consume more gas than block header allow.\n    \"\"\"\n    INVALID_GASLIMIT = auto()\n    \"\"\"\n    Block header's gas limit does not match the gas limit formula calculated from previous block.\n    \"\"\"\n    INVALID_BASEFEE_PER_GAS = auto()\n    \"\"\"\n    Block header's base_fee_per_gas field is calculated incorrect.\n    \"\"\"\n    INVALID_GAS_USED = auto()\n    \"\"\"\n    Block header's actual gas used does not match the provided header's value\n    \"\"\"\n    INVALID_WITHDRAWALS_ROOT = auto()\n    \"\"\"\n    Block header's withdrawals root does not match calculated withdrawals root.\n    \"\"\"\n    INCORRECT_BLOCK_FORMAT = auto()\n    \"\"\"\n    Block's format is incorrect, contains invalid fields, is missing fields, or contains fields of\n    a fork that is not active yet.\n    \"\"\"\n    BLOB_GAS_USED_ABOVE_LIMIT = auto()\n    \"\"\"\n    Block's blob gas used in header is above the limit.\n    \"\"\"\n    INCORRECT_BLOB_GAS_USED = auto()\n    \"\"\"\n    Block's blob gas used in header is incorrect.\n    \"\"\"\n    INCORRECT_EXCESS_BLOB_GAS = auto()\n    \"\"\"\n    Block's excess blob gas in header is incorrect.\n    \"\"\"\n    RLP_STRUCTURES_ENCODING = auto()\n    \"\"\"\n    Block's rlp encoding is valid but ethereum structures in it are invalid.\n    \"\"\"\n    RLP_WITHDRAWALS_NOT_READ = auto()\n    \"\"\"\n    Block's rlp encoding is missing withdrawals.\n    \"\"\"\n    RLP_INVALID_FIELD_OVERFLOW_64 = auto()\n    \"\"\"\n    One of block's fields rlp is overflow 2**64 value.\n    \"\"\"\n    RLP_INVALID_ADDRESS = auto()\n    \"\"\"\n    Block withdrawals address is rlp of invalid address != 20 bytes.\n    \"\"\"\n    INVALID_REQUESTS = auto()\n    \"\"\"\n    Block's requests are invalid.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_LEGACY = auto()\n    \"\"\"\n    Legacy block import is impossible in this chain configuration.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_LEGACY_WRONG_PARENT = auto()\n    \"\"\"\n    Legacy block import is impossible, trying to import on top of a block that is not legacy.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_LONDON_WRONG_PARENT = auto()\n    \"\"\"\n    Trying to import london (basefee) block on top of block that is not 1559.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_PARIS_WRONG_POW = auto()\n    \"\"\"\n    Trying to import paris(merge) block with PoW enabled.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_PARIS_WRONG_POS = auto()\n    \"\"\"\n    Trying to import paris(merge) block with PoS enabled before TTD is reached.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_LONDON_OVER_PARIS = auto()\n    \"\"\"\n    Trying to import london looking block over paris network (POS).\n    \"\"\"\n    IMPORT_IMPOSSIBLE_PARIS_OVER_SHANGHAI = auto()\n    \"\"\"\n    Trying to import paris block on top of shanghai block.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_SHANGHAI = auto()\n    \"\"\"\n    Shanghai block import is impossible in this chain configuration.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_UNCLES_OVER_PARIS = auto()\n    \"\"\"\n    Trying to import a block after paris fork that has not empty uncles hash.\n    \"\"\"\n    IMPORT_IMPOSSIBLE_DIFFICULTY_OVER_PARIS = auto()\n    \"\"\"\n    Trying to import a block after paris fork that has difficulty != 0.\n    \"\"\"\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.TOO_MANY_UNCLES","title":"<code>TOO_MANY_UNCLES = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block declares too many uncles over the allowed limit.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.UNCLE_IN_CHAIN","title":"<code>UNCLE_IN_CHAIN = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block declares uncle header that is already imported into chain.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.UNCLE_IS_ANCESTOR","title":"<code>UNCLE_IS_ANCESTOR = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block declares uncle header that is directly a parent of this block.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.UNCLE_IS_BROTHER","title":"<code>UNCLE_IS_BROTHER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block declares two similar uncle headers.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.UNCLE_PARENT_INCORRECT","title":"<code>UNCLE_PARENT_INCORRECT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block declares uncle header that is an outdated block to be an uncle.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.EXTRA_DATA_TOO_BIG","title":"<code>EXTRA_DATA_TOO_BIG = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's extra data &gt;32 bytes.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.EXTRA_DATA_INVALID_DAO","title":"<code>EXTRA_DATA_INVALID_DAO = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's extra data after dao fork must be a fixed pre defined hash.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.UNKNOWN_PARENT","title":"<code>UNKNOWN_PARENT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's parent hash does not correspond to any of existing blocks on chain.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.UNCLE_UNKNOWN_PARENT","title":"<code>UNCLE_UNKNOWN_PARENT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Uncle header's parent hash does not correspond to any of existing blocks on chain.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.UNKNOWN_PARENT_ZERO","title":"<code>UNKNOWN_PARENT_ZERO = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's parent hash is zero hash.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.GASLIMIT_TOO_BIG","title":"<code>GASLIMIT_TOO_BIG = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's gas limit &gt; 0x7fffffffffffffff.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.INVALID_BLOCK_NUMBER","title":"<code>INVALID_BLOCK_NUMBER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's number != parent header's number + 1.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.INVALID_BLOCK_TIMESTAMP_OLDER_THAN_PARENT","title":"<code>INVALID_BLOCK_TIMESTAMP_OLDER_THAN_PARENT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's timestamp &lt;= parent header's timestamp.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.INVALID_DIFFICULTY","title":"<code>INVALID_DIFFICULTY = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's difficulty does not match the difficulty formula calculated from previous block.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.INVALID_LOG_BLOOM","title":"<code>INVALID_LOG_BLOOM = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's logs bloom hash does not match the actually computed log bloom.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.INVALID_STATE_ROOT","title":"<code>INVALID_STATE_ROOT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's state root hash does not match the actually computed hash of the state.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.INVALID_RECEIPTS_ROOT","title":"<code>INVALID_RECEIPTS_ROOT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's receipts root hash does not match the actually computed hash of receipts.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.INVALID_TRANSACTIONS_ROOT","title":"<code>INVALID_TRANSACTIONS_ROOT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's transactions root hash does not match the actually computed hash of tx tree.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.INVALID_UNCLES_HASH","title":"<code>INVALID_UNCLES_HASH = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's uncle hash does not match the actually computed hash of block's uncles.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.GAS_USED_OVERFLOW","title":"<code>GAS_USED_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block transactions consume more gas than block header allow.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.INVALID_GASLIMIT","title":"<code>INVALID_GASLIMIT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's gas limit does not match the gas limit formula calculated from previous block.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.INVALID_BASEFEE_PER_GAS","title":"<code>INVALID_BASEFEE_PER_GAS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's base_fee_per_gas field is calculated incorrect.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.INVALID_GAS_USED","title":"<code>INVALID_GAS_USED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's actual gas used does not match the provided header's value</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.INVALID_WITHDRAWALS_ROOT","title":"<code>INVALID_WITHDRAWALS_ROOT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block header's withdrawals root does not match calculated withdrawals root.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.INCORRECT_BLOCK_FORMAT","title":"<code>INCORRECT_BLOCK_FORMAT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block's format is incorrect, contains invalid fields, is missing fields, or contains fields of a fork that is not active yet.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.BLOB_GAS_USED_ABOVE_LIMIT","title":"<code>BLOB_GAS_USED_ABOVE_LIMIT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block's blob gas used in header is above the limit.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.INCORRECT_BLOB_GAS_USED","title":"<code>INCORRECT_BLOB_GAS_USED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block's blob gas used in header is incorrect.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.INCORRECT_EXCESS_BLOB_GAS","title":"<code>INCORRECT_EXCESS_BLOB_GAS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block's excess blob gas in header is incorrect.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.RLP_STRUCTURES_ENCODING","title":"<code>RLP_STRUCTURES_ENCODING = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block's rlp encoding is valid but ethereum structures in it are invalid.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.RLP_WITHDRAWALS_NOT_READ","title":"<code>RLP_WITHDRAWALS_NOT_READ = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block's rlp encoding is missing withdrawals.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.RLP_INVALID_FIELD_OVERFLOW_64","title":"<code>RLP_INVALID_FIELD_OVERFLOW_64 = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>One of block's fields rlp is overflow 2**64 value.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.RLP_INVALID_ADDRESS","title":"<code>RLP_INVALID_ADDRESS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block withdrawals address is rlp of invalid address != 20 bytes.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.INVALID_REQUESTS","title":"<code>INVALID_REQUESTS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Block's requests are invalid.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.IMPORT_IMPOSSIBLE_LEGACY","title":"<code>IMPORT_IMPOSSIBLE_LEGACY = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Legacy block import is impossible in this chain configuration.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.IMPORT_IMPOSSIBLE_LEGACY_WRONG_PARENT","title":"<code>IMPORT_IMPOSSIBLE_LEGACY_WRONG_PARENT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Legacy block import is impossible, trying to import on top of a block that is not legacy.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.IMPORT_IMPOSSIBLE_LONDON_WRONG_PARENT","title":"<code>IMPORT_IMPOSSIBLE_LONDON_WRONG_PARENT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Trying to import london (basefee) block on top of block that is not 1559.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.IMPORT_IMPOSSIBLE_PARIS_WRONG_POW","title":"<code>IMPORT_IMPOSSIBLE_PARIS_WRONG_POW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Trying to import paris(merge) block with PoW enabled.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.IMPORT_IMPOSSIBLE_PARIS_WRONG_POS","title":"<code>IMPORT_IMPOSSIBLE_PARIS_WRONG_POS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Trying to import paris(merge) block with PoS enabled before TTD is reached.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.IMPORT_IMPOSSIBLE_LONDON_OVER_PARIS","title":"<code>IMPORT_IMPOSSIBLE_LONDON_OVER_PARIS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Trying to import london looking block over paris network (POS).</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.IMPORT_IMPOSSIBLE_PARIS_OVER_SHANGHAI","title":"<code>IMPORT_IMPOSSIBLE_PARIS_OVER_SHANGHAI = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Trying to import paris block on top of shanghai block.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.IMPORT_IMPOSSIBLE_SHANGHAI","title":"<code>IMPORT_IMPOSSIBLE_SHANGHAI = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Shanghai block import is impossible in this chain configuration.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.IMPORT_IMPOSSIBLE_UNCLES_OVER_PARIS","title":"<code>IMPORT_IMPOSSIBLE_UNCLES_OVER_PARIS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Trying to import a block after paris fork that has not empty uncles hash.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockException.IMPORT_IMPOSSIBLE_DIFFICULTY_OVER_PARIS","title":"<code>IMPORT_IMPOSSIBLE_DIFFICULTY_OVER_PARIS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Trying to import a block after paris fork that has difficulty != 0.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EngineAPIError","title":"<code>EngineAPIError</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>List of Engine API errors.</p> Source code in <code>src/ethereum_test_exceptions/engine_api.py</code> <pre><code>class EngineAPIError(IntEnum):\n    \"\"\"List of Engine API errors.\"\"\"\n\n    ParseError = -32700\n    InvalidRequest = -32600\n    MethodNotFound = -32601\n    InvalidParams = -32602\n    InternalError = -32603\n    ServerError = -32000\n    UnknownPayload = -38001\n    InvalidForkchoiceState = -38002\n    InvalidPayloadAttributes = -38003\n    TooLargeRequest = -38004\n    UnsupportedFork = -38005\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException","title":"<code>EOFException</code>","text":"<p>               Bases: <code>ExceptionBase</code></p> <p>Exception raised when an EOF container is invalid.</p> Source code in <code>src/ethereum_test_exceptions/exceptions.py</code> <pre><code>@unique\nclass EOFException(ExceptionBase):\n    \"\"\"Exception raised when an EOF container is invalid.\"\"\"\n\n    DEFAULT_EXCEPTION = auto()\n    \"\"\"\n    Expect some exception, not yet known.\n    \"\"\"\n\n    UNDEFINED_EXCEPTION = auto()\n    \"\"\"\n    Indicates that exception string is not mapped to an exception enum.\n    \"\"\"\n\n    UNDEFINED_INSTRUCTION = auto()\n    \"\"\"\n    EOF container has undefined instruction in it's body code.\n    \"\"\"\n\n    UNKNOWN_VERSION = auto()\n    \"\"\"\n    EOF container has an unknown version.\n    \"\"\"\n    INCOMPLETE_MAGIC = auto()\n    \"\"\"\n    EOF container has not enough bytes to read magic.\n    \"\"\"\n    INVALID_MAGIC = auto()\n    \"\"\"\n    EOF container has not allowed magic version byte.\n    \"\"\"\n    INVALID_VERSION = auto()\n    \"\"\"\n    EOF container version bytes mismatch.\n    \"\"\"\n    INVALID_NON_RETURNING_FLAG = auto()\n    \"\"\"\n    EOF container's section has non-returning flag set incorrectly.\n    \"\"\"\n    INVALID_RJUMP_DESTINATION = auto()\n    \"\"\"\n    Code has RJUMP instruction with invalid parameters.\n    \"\"\"\n    MISSING_TYPE_HEADER = auto()\n    \"\"\"\n    EOF container missing types section.\n    \"\"\"\n    INVALID_TYPE_SECTION_SIZE = auto()\n    \"\"\"\n    EOF container types section has wrong size.\n    \"\"\"\n    INVALID_TYPE_BODY = auto()\n    \"\"\"\n    EOF container types body section bytes are wrong.\n    \"\"\"\n    MISSING_CODE_HEADER = auto()\n    \"\"\"\n    EOF container missing code section.\n    \"\"\"\n    INVALID_CODE_SECTION = auto()\n    \"\"\"\n    EOF container code section bytes are incorrect.\n    \"\"\"\n    INCOMPLETE_CODE_HEADER = auto()\n    \"\"\"\n    EOF container code header missing bytes.\n    \"\"\"\n    INCOMPLETE_DATA_HEADER = auto()\n    \"\"\"\n    EOF container data header missing bytes.\n    \"\"\"\n    ZERO_SECTION_SIZE = auto()\n    \"\"\"\n    EOF container data header construction is wrong.\n    \"\"\"\n    MISSING_DATA_SECTION = auto()\n    \"\"\"\n    EOF container missing data section\n    \"\"\"\n    INCOMPLETE_CONTAINER = auto()\n    \"\"\"\n    EOF container bytes are incomplete.\n    \"\"\"\n    INVALID_SECTION_BODIES_SIZE = auto()\n    \"\"\"\n    Sections bodies does not match sections headers.\n    \"\"\"\n    TRAILING_BYTES = auto()\n    \"\"\"\n    EOF container has bytes beyond data section.\n    \"\"\"\n    MISSING_TERMINATOR = auto()\n    \"\"\"\n    EOF container missing terminator bytes between header and body.\n    \"\"\"\n    MISSING_HEADERS_TERMINATOR = auto()\n    \"\"\"\n    Some type of another exception about missing headers terminator.\n    \"\"\"\n    INVALID_FIRST_SECTION_TYPE = auto()\n    \"\"\"\n    EOF container header does not have types section first.\n    \"\"\"\n    INCOMPLETE_SECTION_NUMBER = auto()\n    \"\"\"\n    EOF container header has section that is missing declaration bytes.\n    \"\"\"\n    INCOMPLETE_SECTION_SIZE = auto()\n    \"\"\"\n    EOF container header has section that is defined incorrectly.\n    \"\"\"\n    TOO_MANY_CODE_SECTIONS = auto()\n    \"\"\"\n    EOF container header has too many code sections.\n    \"\"\"\n    MISSING_STOP_OPCODE = auto()\n    \"\"\"\n    EOF container's code missing STOP bytecode at it's end.\n    \"\"\"\n    INPUTS_OUTPUTS_NUM_ABOVE_LIMIT = auto()\n    \"\"\"\n    EOF container code section inputs/outputs number is above the limit\n    \"\"\"\n    UNREACHABLE_INSTRUCTIONS = auto()\n    \"\"\"\n    EOF container's code have instructions that are unreachable.\n    \"\"\"\n    UNREACHABLE_CODE_SECTIONS = auto()\n    \"\"\"\n    EOF container's body have code sections that are unreachable.\n    \"\"\"\n    STACK_UNDERFLOW = auto()\n    \"\"\"\n    EOF container's code produces an stack underflow.\n    \"\"\"\n    STACK_OVERFLOW = auto()\n    \"\"\"\n    EOF container's code produces an stack overflow.\n    \"\"\"\n    STACK_HEIGHT_MISMATCH = auto()\n    \"\"\"\n    EOF container section stack height mismatch.\n    \"\"\"\n    MAX_STACK_HEIGHT_ABOVE_LIMIT = auto()\n    \"\"\"\n    EOF container's specified max stack height is above the limit.\n    \"\"\"\n    STACK_HIGHER_THAN_OUTPUTS = auto()\n    \"\"\"\n    EOF container section stack height is higher than the outputs.\n    when returning\n    \"\"\"\n    JUMPF_DESTINATION_INCOMPATIBLE_OUTPUTS = auto()\n    \"\"\"\n    EOF container section JUMPF's to a destination section with incompatible outputs.\n    \"\"\"\n    INVALID_MAX_STACK_HEIGHT = auto()\n    \"\"\"\n    EOF container section's specified max stack height does not match the actual stack height.\n    \"\"\"\n    INVALID_DATALOADN_INDEX = auto()\n    \"\"\"\n    A DATALOADN instruction has out-of-bounds index for the data section.\n    \"\"\"\n    TRUNCATED_INSTRUCTION = auto()\n    \"\"\"\n    EOF container's code section has truncated instruction.\n    \"\"\"\n    TOPLEVEL_CONTAINER_TRUNCATED = auto()\n    \"\"\"\n    Top-level EOF container has data section truncated\n    \"\"\"\n    ORPHAN_SUBCONTAINER = auto()\n    \"\"\"\n    EOF container has an unreferenced subcontainer.\n    '\"\"\"\n    CONTAINER_SIZE_ABOVE_LIMIT = auto()\n    \"\"\"\n    EOF container is above size limit\n    \"\"\"\n    INVALID_CONTAINER_SECTION_INDEX = auto()\n    \"\"\"\n    Instruction references container section that does not exist.\n    \"\"\"\n    INCOMPATIBLE_CONTAINER_KIND = auto()\n    \"\"\"\n    Incompatible instruction found in a container of a specific kind.\n    \"\"\"\n    AMBIGUOUS_CONTAINER_KIND = auto()\n    \"\"\"\n    The kind of a sub-container cannot be uniquely deduced.\n    \"\"\"\n    TOO_MANY_CONTAINERS = auto()\n    \"\"\"\n    EOF container header has too many sub-containers.\n    \"\"\"\n    INVALID_CODE_SECTION_INDEX = auto()\n    \"\"\"\n    CALLF Operation referes to a non-existent code section\n    \"\"\"\n    UNEXPECTED_HEADER_KIND = auto()\n    \"\"\"\n    Header parsing encounterd a section kind it wasn't expecting\n    \"\"\"\n    CALLF_TO_NON_RETURNING = auto()\n    \"\"\"\n    CALLF instruction targeting a non-returning code section\n    \"\"\"\n    EOFCREATE_WITH_TRUNCATED_CONTAINER = auto()\n    \"\"\"\n    EOFCREATE with truncated container\n    \"\"\"\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.DEFAULT_EXCEPTION","title":"<code>DEFAULT_EXCEPTION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Expect some exception, not yet known.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.UNDEFINED_EXCEPTION","title":"<code>UNDEFINED_EXCEPTION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Indicates that exception string is not mapped to an exception enum.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.UNDEFINED_INSTRUCTION","title":"<code>UNDEFINED_INSTRUCTION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container has undefined instruction in it's body code.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.UNKNOWN_VERSION","title":"<code>UNKNOWN_VERSION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container has an unknown version.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.INCOMPLETE_MAGIC","title":"<code>INCOMPLETE_MAGIC = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container has not enough bytes to read magic.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.INVALID_MAGIC","title":"<code>INVALID_MAGIC = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container has not allowed magic version byte.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.INVALID_VERSION","title":"<code>INVALID_VERSION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container version bytes mismatch.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.INVALID_NON_RETURNING_FLAG","title":"<code>INVALID_NON_RETURNING_FLAG = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's section has non-returning flag set incorrectly.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.INVALID_RJUMP_DESTINATION","title":"<code>INVALID_RJUMP_DESTINATION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Code has RJUMP instruction with invalid parameters.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.MISSING_TYPE_HEADER","title":"<code>MISSING_TYPE_HEADER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container missing types section.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.INVALID_TYPE_SECTION_SIZE","title":"<code>INVALID_TYPE_SECTION_SIZE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container types section has wrong size.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.INVALID_TYPE_BODY","title":"<code>INVALID_TYPE_BODY = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container types body section bytes are wrong.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.MISSING_CODE_HEADER","title":"<code>MISSING_CODE_HEADER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container missing code section.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.INVALID_CODE_SECTION","title":"<code>INVALID_CODE_SECTION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container code section bytes are incorrect.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.INCOMPLETE_CODE_HEADER","title":"<code>INCOMPLETE_CODE_HEADER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container code header missing bytes.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.INCOMPLETE_DATA_HEADER","title":"<code>INCOMPLETE_DATA_HEADER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container data header missing bytes.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.ZERO_SECTION_SIZE","title":"<code>ZERO_SECTION_SIZE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container data header construction is wrong.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.MISSING_DATA_SECTION","title":"<code>MISSING_DATA_SECTION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container missing data section</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.INCOMPLETE_CONTAINER","title":"<code>INCOMPLETE_CONTAINER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container bytes are incomplete.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.INVALID_SECTION_BODIES_SIZE","title":"<code>INVALID_SECTION_BODIES_SIZE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Sections bodies does not match sections headers.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.TRAILING_BYTES","title":"<code>TRAILING_BYTES = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container has bytes beyond data section.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.MISSING_TERMINATOR","title":"<code>MISSING_TERMINATOR = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container missing terminator bytes between header and body.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.MISSING_HEADERS_TERMINATOR","title":"<code>MISSING_HEADERS_TERMINATOR = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Some type of another exception about missing headers terminator.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.INVALID_FIRST_SECTION_TYPE","title":"<code>INVALID_FIRST_SECTION_TYPE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container header does not have types section first.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.INCOMPLETE_SECTION_NUMBER","title":"<code>INCOMPLETE_SECTION_NUMBER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container header has section that is missing declaration bytes.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.INCOMPLETE_SECTION_SIZE","title":"<code>INCOMPLETE_SECTION_SIZE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container header has section that is defined incorrectly.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.TOO_MANY_CODE_SECTIONS","title":"<code>TOO_MANY_CODE_SECTIONS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container header has too many code sections.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.MISSING_STOP_OPCODE","title":"<code>MISSING_STOP_OPCODE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's code missing STOP bytecode at it's end.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.INPUTS_OUTPUTS_NUM_ABOVE_LIMIT","title":"<code>INPUTS_OUTPUTS_NUM_ABOVE_LIMIT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container code section inputs/outputs number is above the limit</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.UNREACHABLE_INSTRUCTIONS","title":"<code>UNREACHABLE_INSTRUCTIONS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's code have instructions that are unreachable.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.UNREACHABLE_CODE_SECTIONS","title":"<code>UNREACHABLE_CODE_SECTIONS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's body have code sections that are unreachable.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.STACK_UNDERFLOW","title":"<code>STACK_UNDERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's code produces an stack underflow.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.STACK_OVERFLOW","title":"<code>STACK_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's code produces an stack overflow.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.STACK_HEIGHT_MISMATCH","title":"<code>STACK_HEIGHT_MISMATCH = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container section stack height mismatch.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.MAX_STACK_HEIGHT_ABOVE_LIMIT","title":"<code>MAX_STACK_HEIGHT_ABOVE_LIMIT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's specified max stack height is above the limit.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.STACK_HIGHER_THAN_OUTPUTS","title":"<code>STACK_HIGHER_THAN_OUTPUTS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container section stack height is higher than the outputs. when returning</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.JUMPF_DESTINATION_INCOMPATIBLE_OUTPUTS","title":"<code>JUMPF_DESTINATION_INCOMPATIBLE_OUTPUTS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container section JUMPF's to a destination section with incompatible outputs.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.INVALID_MAX_STACK_HEIGHT","title":"<code>INVALID_MAX_STACK_HEIGHT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container section's specified max stack height does not match the actual stack height.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.INVALID_DATALOADN_INDEX","title":"<code>INVALID_DATALOADN_INDEX = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A DATALOADN instruction has out-of-bounds index for the data section.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.TRUNCATED_INSTRUCTION","title":"<code>TRUNCATED_INSTRUCTION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container's code section has truncated instruction.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.TOPLEVEL_CONTAINER_TRUNCATED","title":"<code>TOPLEVEL_CONTAINER_TRUNCATED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Top-level EOF container has data section truncated</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.ORPHAN_SUBCONTAINER","title":"<code>ORPHAN_SUBCONTAINER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container has an unreferenced subcontainer. '</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.CONTAINER_SIZE_ABOVE_LIMIT","title":"<code>CONTAINER_SIZE_ABOVE_LIMIT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container is above size limit</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.INVALID_CONTAINER_SECTION_INDEX","title":"<code>INVALID_CONTAINER_SECTION_INDEX = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Instruction references container section that does not exist.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.INCOMPATIBLE_CONTAINER_KIND","title":"<code>INCOMPATIBLE_CONTAINER_KIND = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Incompatible instruction found in a container of a specific kind.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.AMBIGUOUS_CONTAINER_KIND","title":"<code>AMBIGUOUS_CONTAINER_KIND = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The kind of a sub-container cannot be uniquely deduced.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.TOO_MANY_CONTAINERS","title":"<code>TOO_MANY_CONTAINERS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOF container header has too many sub-containers.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.INVALID_CODE_SECTION_INDEX","title":"<code>INVALID_CODE_SECTION_INDEX = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>CALLF Operation referes to a non-existent code section</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.UNEXPECTED_HEADER_KIND","title":"<code>UNEXPECTED_HEADER_KIND = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Header parsing encounterd a section kind it wasn't expecting</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.CALLF_TO_NON_RETURNING","title":"<code>CALLF_TO_NON_RETURNING = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>CALLF instruction targeting a non-returning code section</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFException.EOFCREATE_WITH_TRUNCATED_CONTAINER","title":"<code>EOFCREATE_WITH_TRUNCATED_CONTAINER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EOFCREATE with truncated container</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException","title":"<code>TransactionException</code>","text":"<p>               Bases: <code>ExceptionBase</code></p> <p>Exception raised when a transaction is invalid, and thus cannot be executed.</p> <p>If a transaction with any of these exceptions is included in a block, the block is invalid.</p> Source code in <code>src/ethereum_test_exceptions/exceptions.py</code> <pre><code>@unique\nclass TransactionException(ExceptionBase):\n    \"\"\"\n    Exception raised when a transaction is invalid, and thus cannot be executed.\n\n    If a transaction with any of these exceptions is included in a block, the block is invalid.\n    \"\"\"\n\n    TYPE_NOT_SUPPORTED = auto()\n    \"\"\"\n    Transaction type is not supported on this chain configuration.\n    \"\"\"\n    SENDER_NOT_EOA = auto()\n    \"\"\"\n    Transaction is coming from address that is not exist anymore.\n    \"\"\"\n    ADDRESS_TOO_SHORT = auto()\n    \"\"\"\n    Transaction `to` is not allowed to be less than 20 bytes.\n    \"\"\"\n    ADDRESS_TOO_LONG = auto()\n    \"\"\"\n    Transaction `to` is not allowed to be more than 20 bytes.\n    \"\"\"\n    NONCE_MISMATCH_TOO_HIGH = auto()\n    \"\"\"\n    Transaction nonce &gt; sender.nonce.\n    \"\"\"\n    NONCE_MISMATCH_TOO_LOW = auto()\n    \"\"\"\n    Transaction nonce &lt; sender.nonce.\n    \"\"\"\n    NONCE_TOO_BIG = auto()\n    \"\"\"\n    Transaction `nonce` is not allowed to be max_uint64 - 1 (this is probably TransactionTest).\n    \"\"\"\n    NONCE_IS_MAX = auto()\n    \"\"\"\n    Transaction `nonce` is not allowed to be max_uint64 - 1 (this is StateTests).\n    \"\"\"\n    NONCE_OVERFLOW = auto()\n    \"\"\"\n    Transaction `nonce` is not allowed to be more than uint64.\n    \"\"\"\n    GASLIMIT_OVERFLOW = auto()\n    \"\"\"\n    Transaction gaslimit exceeds 2^64-1 maximum value.\n    \"\"\"\n    VALUE_OVERFLOW = auto()\n    \"\"\"\n    Transaction value exceeds 2^256-1 maximum value.\n    \"\"\"\n    GASPRICE_OVERFLOW = auto()\n    \"\"\"\n    Transaction gasPrice exceeds 2^256-1 maximum value.\n    \"\"\"\n    GASLIMIT_PRICE_PRODUCT_OVERFLOW = auto()\n    \"\"\"\n    Transaction gasPrice * gasLimit exceeds 2^256-1 maximum value.\n    \"\"\"\n    INVALID_SIGNATURE_VRS = auto()\n    \"\"\"\n    Invalid transaction v, r, s values.\n    \"\"\"\n    RLP_INVALID_SIGNATURE_R = auto()\n    \"\"\"\n    Error reading transaction signature R value.\n    \"\"\"\n    RLP_INVALID_SIGNATURE_S = auto()\n    \"\"\"\n    Error reading transaction signature S value.\n    \"\"\"\n    RLP_LEADING_ZEROS_GASLIMIT = auto()\n    \"\"\"\n    Error reading transaction gaslimit field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_GASPRICE = auto()\n    \"\"\"\n    Error reading transaction gasprice field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_VALUE = auto()\n    \"\"\"\n    Error reading transaction value field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_NONCE = auto()\n    \"\"\"\n    Error reading transaction nonce field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_R = auto()\n    \"\"\"\n    Error reading transaction signature R field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_S = auto()\n    \"\"\"\n    Error reading transaction signature S field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_V = auto()\n    \"\"\"\n    Error reading transaction signature V field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_BASEFEE = auto()\n    \"\"\"\n    Error reading transaction basefee field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_PRIORITY_FEE = auto()\n    \"\"\"\n    Error reading transaction priority fee field RLP.\n    \"\"\"\n    RLP_LEADING_ZEROS_DATA_SIZE = auto()\n    \"\"\"\n    Error reading transaction data field RLP, (rlp field length has leading zeros).\n    \"\"\"\n    RLP_LEADING_ZEROS_NONCE_SIZE = auto()\n    \"\"\"\n    Error reading transaction nonce field RLP, (rlp field length has leading zeros).\n    \"\"\"\n    RLP_TOO_FEW_ELEMENTS = auto()\n    \"\"\"\n    Error reading transaction RLP, structure has too few elements than expected.\n    \"\"\"\n    RLP_TOO_MANY_ELEMENTS = auto()\n    \"\"\"\n    Error reading transaction RLP, structure has too many elements than expected.\n    \"\"\"\n    RLP_ERROR_EOF = auto()\n    \"\"\"\n    Error reading transaction RLP, rlp stream unexpectedly finished.\n    \"\"\"\n    RLP_ERROR_SIZE = auto()\n    \"\"\"\n    Error reading transaction RLP, rlp size is invalid.\n    \"\"\"\n    RLP_ERROR_SIZE_LEADING_ZEROS = auto()\n    \"\"\"\n    Error reading transaction RLP, field size has leading zeros.\n    \"\"\"\n    INVALID_CHAINID = auto()\n    \"\"\"\n    Transaction chain id encoding is incorrect.\n    \"\"\"\n    RLP_INVALID_DATA = auto()\n    \"\"\"\n    Transaction data field is invalid rlp.\n    \"\"\"\n    RLP_INVALID_GASLIMIT = auto()\n    \"\"\"\n    Transaction gaslimit field is invalid rlp.\n    \"\"\"\n    RLP_INVALID_NONCE = auto()\n    \"\"\"\n    Transaction nonce field is invalid rlp.\n    \"\"\"\n    RLP_INVALID_TO = auto()\n    \"\"\"\n    Transaction to field is invalid rlp.\n    \"\"\"\n    RLP_INVALID_ACCESS_LIST_ADDRESS_TOO_LONG = auto()\n    \"\"\"\n    Transaction access list address is &gt; 20 bytes.\n    \"\"\"\n    RLP_INVALID_ACCESS_LIST_ADDRESS_TOO_SHORT = auto()\n    \"\"\"\n    Transaction access list address is &lt; 20 bytes.\n    \"\"\"\n    RLP_INVALID_ACCESS_LIST_STORAGE_TOO_LONG = auto()\n    \"\"\"\n    Transaction access list storage hash &gt; 32 bytes.\n    \"\"\"\n    RLP_INVALID_ACCESS_LIST_STORAGE_TOO_SHORT = auto()\n    \"\"\"\n    Transaction access list storage hash &lt; 32 bytes.\n    \"\"\"\n    RLP_INVALID_HEADER = auto()\n    \"\"\"\n    Transaction failed to read from RLP as rlp header is invalid.\n    \"\"\"\n    RLP_INVALID_VALUE = auto()\n    \"\"\"\n    Transaction value field is invalid rlp/structure.\n    \"\"\"\n    EC_RECOVERY_FAIL = auto()\n    \"\"\"\n    Transaction has correct signature, but ec recovery failed.\n    \"\"\"\n    INSUFFICIENT_ACCOUNT_FUNDS = auto()\n    \"\"\"\n    Transaction's sender does not have enough funds to pay for the transaction.\n    \"\"\"\n    INSUFFICIENT_MAX_FEE_PER_GAS = auto()\n    \"\"\"\n    Transaction's max-fee-per-gas is lower than the block base-fee.\n    \"\"\"\n    PRIORITY_OVERFLOW = auto()\n    \"\"\"\n    Transaction's max-priority-fee-per-gas is exceeds 2^256-1 maximum value.\n    \"\"\"\n    PRIORITY_GREATER_THAN_MAX_FEE_PER_GAS = auto()\n    \"\"\"\n    Transaction's max-priority-fee-per-gas is greater than the max-fee-per-gas.\n    \"\"\"\n    PRIORITY_GREATER_THAN_MAX_FEE_PER_GAS_2 = auto()\n    \"\"\"\n    Transaction's max-priority-fee-per-gas is greater than the max-fee-per-gas (TransactionTests).\n    \"\"\"\n    INSUFFICIENT_MAX_FEE_PER_BLOB_GAS = auto()\n    \"\"\"\n    Transaction's max-fee-per-blob-gas is lower than the block's blob-gas price.\n    \"\"\"\n    INTRINSIC_GAS_TOO_LOW = auto()\n    \"\"\"\n    Transaction's gas limit is too low.\n    \"\"\"\n    INITCODE_SIZE_EXCEEDED = auto()\n    \"\"\"\n    Transaction's initcode for a contract-creating transaction is too large.\n    \"\"\"\n    TYPE_3_TX_PRE_FORK = auto()\n    \"\"\"\n    Transaction type 3 included before activation fork.\n    \"\"\"\n    TYPE_3_TX_ZERO_BLOBS_PRE_FORK = auto()\n    \"\"\"\n    Transaction type 3, with zero blobs, included before activation fork.\n    \"\"\"\n    TYPE_3_TX_INVALID_BLOB_VERSIONED_HASH = auto()\n    \"\"\"\n    Transaction contains a blob versioned hash with an invalid version.\n    \"\"\"\n    TYPE_3_TX_WITH_FULL_BLOBS = auto()\n    \"\"\"\n    Transaction contains full blobs (network-version of the transaction).\n    \"\"\"\n    TYPE_3_TX_BLOB_COUNT_EXCEEDED = auto()\n    \"\"\"\n    Transaction contains too many blob versioned hashes.\n    \"\"\"\n    TYPE_3_TX_CONTRACT_CREATION = auto()\n    \"\"\"\n    Transaction is a type 3 transaction and has an empty `to`.\n    \"\"\"\n    TYPE_3_TX_MAX_BLOB_GAS_ALLOWANCE_EXCEEDED = auto()\n    \"\"\"\n    Transaction causes block to go over blob gas limit.\n    \"\"\"\n    GAS_ALLOWANCE_EXCEEDED = auto()\n    \"\"\"\n    Transaction causes block to go over blob gas limit.\n    \"\"\"\n    TYPE_3_TX_ZERO_BLOBS = auto()\n    \"\"\"\n    Transaction is type 3, but has no blobs.\n    \"\"\"\n    TYPE_4_EMPTY_AUTHORIZATION_LIST = auto()\n    \"\"\"\n    Transaction is type 4, but has an empty authorization list.\n    \"\"\"\n    TYPE_4_INVALID_AUTHORITY_SIGNATURE = auto()\n    \"\"\"\n    Transaction authority signature is invalid\n    \"\"\"\n    TYPE_4_INVALID_AUTHORITY_SIGNATURE_S_TOO_HIGH = auto()\n    \"\"\"\n    Transaction authority signature is invalid\n    \"\"\"\n    TYPE_4_TX_CONTRACT_CREATION = auto()\n    \"\"\"\n    Transaction is a type 4 transaction and has an empty `to`.\n    \"\"\"\n    TYPE_4_INVALID_AUTHORIZATION_FORMAT = auto()\n    \"\"\"\n    Transaction is type 4, but contains an authorization that has an invalid format.\n    \"\"\"\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.TYPE_NOT_SUPPORTED","title":"<code>TYPE_NOT_SUPPORTED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction type is not supported on this chain configuration.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.SENDER_NOT_EOA","title":"<code>SENDER_NOT_EOA = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction is coming from address that is not exist anymore.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.ADDRESS_TOO_SHORT","title":"<code>ADDRESS_TOO_SHORT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction <code>to</code> is not allowed to be less than 20 bytes.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.ADDRESS_TOO_LONG","title":"<code>ADDRESS_TOO_LONG = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction <code>to</code> is not allowed to be more than 20 bytes.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.NONCE_MISMATCH_TOO_HIGH","title":"<code>NONCE_MISMATCH_TOO_HIGH = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction nonce &gt; sender.nonce.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.NONCE_MISMATCH_TOO_LOW","title":"<code>NONCE_MISMATCH_TOO_LOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction nonce &lt; sender.nonce.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.NONCE_TOO_BIG","title":"<code>NONCE_TOO_BIG = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction <code>nonce</code> is not allowed to be max_uint64 - 1 (this is probably TransactionTest).</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.NONCE_IS_MAX","title":"<code>NONCE_IS_MAX = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction <code>nonce</code> is not allowed to be max_uint64 - 1 (this is StateTests).</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.NONCE_OVERFLOW","title":"<code>NONCE_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction <code>nonce</code> is not allowed to be more than uint64.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.GASLIMIT_OVERFLOW","title":"<code>GASLIMIT_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction gaslimit exceeds 2^64-1 maximum value.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.VALUE_OVERFLOW","title":"<code>VALUE_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction value exceeds 2^256-1 maximum value.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.GASPRICE_OVERFLOW","title":"<code>GASPRICE_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction gasPrice exceeds 2^256-1 maximum value.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.GASLIMIT_PRICE_PRODUCT_OVERFLOW","title":"<code>GASLIMIT_PRICE_PRODUCT_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction gasPrice * gasLimit exceeds 2^256-1 maximum value.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.INVALID_SIGNATURE_VRS","title":"<code>INVALID_SIGNATURE_VRS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Invalid transaction v, r, s values.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_INVALID_SIGNATURE_R","title":"<code>RLP_INVALID_SIGNATURE_R = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction signature R value.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_INVALID_SIGNATURE_S","title":"<code>RLP_INVALID_SIGNATURE_S = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction signature S value.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_LEADING_ZEROS_GASLIMIT","title":"<code>RLP_LEADING_ZEROS_GASLIMIT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction gaslimit field RLP.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_LEADING_ZEROS_GASPRICE","title":"<code>RLP_LEADING_ZEROS_GASPRICE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction gasprice field RLP.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_LEADING_ZEROS_VALUE","title":"<code>RLP_LEADING_ZEROS_VALUE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction value field RLP.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_LEADING_ZEROS_NONCE","title":"<code>RLP_LEADING_ZEROS_NONCE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction nonce field RLP.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_LEADING_ZEROS_R","title":"<code>RLP_LEADING_ZEROS_R = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction signature R field RLP.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_LEADING_ZEROS_S","title":"<code>RLP_LEADING_ZEROS_S = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction signature S field RLP.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_LEADING_ZEROS_V","title":"<code>RLP_LEADING_ZEROS_V = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction signature V field RLP.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_LEADING_ZEROS_BASEFEE","title":"<code>RLP_LEADING_ZEROS_BASEFEE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction basefee field RLP.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_LEADING_ZEROS_PRIORITY_FEE","title":"<code>RLP_LEADING_ZEROS_PRIORITY_FEE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction priority fee field RLP.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_LEADING_ZEROS_DATA_SIZE","title":"<code>RLP_LEADING_ZEROS_DATA_SIZE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction data field RLP, (rlp field length has leading zeros).</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_LEADING_ZEROS_NONCE_SIZE","title":"<code>RLP_LEADING_ZEROS_NONCE_SIZE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction nonce field RLP, (rlp field length has leading zeros).</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_TOO_FEW_ELEMENTS","title":"<code>RLP_TOO_FEW_ELEMENTS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction RLP, structure has too few elements than expected.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_TOO_MANY_ELEMENTS","title":"<code>RLP_TOO_MANY_ELEMENTS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction RLP, structure has too many elements than expected.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_ERROR_EOF","title":"<code>RLP_ERROR_EOF = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction RLP, rlp stream unexpectedly finished.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_ERROR_SIZE","title":"<code>RLP_ERROR_SIZE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction RLP, rlp size is invalid.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_ERROR_SIZE_LEADING_ZEROS","title":"<code>RLP_ERROR_SIZE_LEADING_ZEROS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reading transaction RLP, field size has leading zeros.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.INVALID_CHAINID","title":"<code>INVALID_CHAINID = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction chain id encoding is incorrect.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_INVALID_DATA","title":"<code>RLP_INVALID_DATA = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction data field is invalid rlp.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_INVALID_GASLIMIT","title":"<code>RLP_INVALID_GASLIMIT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction gaslimit field is invalid rlp.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_INVALID_NONCE","title":"<code>RLP_INVALID_NONCE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction nonce field is invalid rlp.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_INVALID_TO","title":"<code>RLP_INVALID_TO = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction to field is invalid rlp.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_INVALID_ACCESS_LIST_ADDRESS_TOO_LONG","title":"<code>RLP_INVALID_ACCESS_LIST_ADDRESS_TOO_LONG = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction access list address is &gt; 20 bytes.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_INVALID_ACCESS_LIST_ADDRESS_TOO_SHORT","title":"<code>RLP_INVALID_ACCESS_LIST_ADDRESS_TOO_SHORT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction access list address is &lt; 20 bytes.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_INVALID_ACCESS_LIST_STORAGE_TOO_LONG","title":"<code>RLP_INVALID_ACCESS_LIST_STORAGE_TOO_LONG = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction access list storage hash &gt; 32 bytes.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_INVALID_ACCESS_LIST_STORAGE_TOO_SHORT","title":"<code>RLP_INVALID_ACCESS_LIST_STORAGE_TOO_SHORT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction access list storage hash &lt; 32 bytes.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_INVALID_HEADER","title":"<code>RLP_INVALID_HEADER = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction failed to read from RLP as rlp header is invalid.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.RLP_INVALID_VALUE","title":"<code>RLP_INVALID_VALUE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction value field is invalid rlp/structure.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.EC_RECOVERY_FAIL","title":"<code>EC_RECOVERY_FAIL = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction has correct signature, but ec recovery failed.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.INSUFFICIENT_ACCOUNT_FUNDS","title":"<code>INSUFFICIENT_ACCOUNT_FUNDS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's sender does not have enough funds to pay for the transaction.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.INSUFFICIENT_MAX_FEE_PER_GAS","title":"<code>INSUFFICIENT_MAX_FEE_PER_GAS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's max-fee-per-gas is lower than the block base-fee.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.PRIORITY_OVERFLOW","title":"<code>PRIORITY_OVERFLOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's max-priority-fee-per-gas is exceeds 2^256-1 maximum value.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.PRIORITY_GREATER_THAN_MAX_FEE_PER_GAS","title":"<code>PRIORITY_GREATER_THAN_MAX_FEE_PER_GAS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's max-priority-fee-per-gas is greater than the max-fee-per-gas.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.PRIORITY_GREATER_THAN_MAX_FEE_PER_GAS_2","title":"<code>PRIORITY_GREATER_THAN_MAX_FEE_PER_GAS_2 = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's max-priority-fee-per-gas is greater than the max-fee-per-gas (TransactionTests).</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.INSUFFICIENT_MAX_FEE_PER_BLOB_GAS","title":"<code>INSUFFICIENT_MAX_FEE_PER_BLOB_GAS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's max-fee-per-blob-gas is lower than the block's blob-gas price.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.INTRINSIC_GAS_TOO_LOW","title":"<code>INTRINSIC_GAS_TOO_LOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's gas limit is too low.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.INITCODE_SIZE_EXCEEDED","title":"<code>INITCODE_SIZE_EXCEEDED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction's initcode for a contract-creating transaction is too large.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.TYPE_3_TX_PRE_FORK","title":"<code>TYPE_3_TX_PRE_FORK = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction type 3 included before activation fork.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.TYPE_3_TX_ZERO_BLOBS_PRE_FORK","title":"<code>TYPE_3_TX_ZERO_BLOBS_PRE_FORK = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction type 3, with zero blobs, included before activation fork.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.TYPE_3_TX_INVALID_BLOB_VERSIONED_HASH","title":"<code>TYPE_3_TX_INVALID_BLOB_VERSIONED_HASH = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction contains a blob versioned hash with an invalid version.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.TYPE_3_TX_WITH_FULL_BLOBS","title":"<code>TYPE_3_TX_WITH_FULL_BLOBS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction contains full blobs (network-version of the transaction).</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.TYPE_3_TX_BLOB_COUNT_EXCEEDED","title":"<code>TYPE_3_TX_BLOB_COUNT_EXCEEDED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction contains too many blob versioned hashes.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.TYPE_3_TX_CONTRACT_CREATION","title":"<code>TYPE_3_TX_CONTRACT_CREATION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction is a type 3 transaction and has an empty <code>to</code>.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.TYPE_3_TX_MAX_BLOB_GAS_ALLOWANCE_EXCEEDED","title":"<code>TYPE_3_TX_MAX_BLOB_GAS_ALLOWANCE_EXCEEDED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction causes block to go over blob gas limit.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.GAS_ALLOWANCE_EXCEEDED","title":"<code>GAS_ALLOWANCE_EXCEEDED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction causes block to go over blob gas limit.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.TYPE_3_TX_ZERO_BLOBS","title":"<code>TYPE_3_TX_ZERO_BLOBS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction is type 3, but has no blobs.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.TYPE_4_EMPTY_AUTHORIZATION_LIST","title":"<code>TYPE_4_EMPTY_AUTHORIZATION_LIST = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction is type 4, but has an empty authorization list.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.TYPE_4_INVALID_AUTHORITY_SIGNATURE","title":"<code>TYPE_4_INVALID_AUTHORITY_SIGNATURE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction authority signature is invalid</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.TYPE_4_INVALID_AUTHORITY_SIGNATURE_S_TOO_HIGH","title":"<code>TYPE_4_INVALID_AUTHORITY_SIGNATURE_S_TOO_HIGH = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction authority signature is invalid</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.TYPE_4_TX_CONTRACT_CREATION","title":"<code>TYPE_4_TX_CONTRACT_CREATION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction is a type 4 transaction and has an empty <code>to</code>.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionException.TYPE_4_INVALID_AUTHORIZATION_FORMAT","title":"<code>TYPE_4_INVALID_AUTHORIZATION_FORMAT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction is type 4, but contains an authorization that has an invalid format.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BaseFixture","title":"<code>BaseFixture</code>","text":"<p>               Bases: <code>CamelModel</code></p> <p>Represents a base Ethereum test fixture of any type.</p> Source code in <code>src/ethereum_test_fixtures/base.py</code> <pre><code>class BaseFixture(CamelModel):\n    \"\"\"Represents a base Ethereum test fixture of any type.\"\"\"\n\n    # Base Fixture class properties\n    formats: ClassVar[Dict[str, Type[\"BaseFixture\"]]] = {}\n    formats_type_adapter: ClassVar[TypeAdapter]\n\n    info: Dict[str, Dict[str, Any] | str] = Field(default_factory=dict, alias=\"_info\")\n\n    # Fixture format properties\n    format_name: ClassVar[str] = \"\"\n    output_file_extension: ClassVar[str] = \".json\"\n    description: ClassVar[str] = \"Unknown fixture format; it has not been set.\"\n\n    @classmethod\n    def output_base_dir_name(cls) -&gt; str:\n        \"\"\"Return name of the subdirectory where this type of fixture should be dumped to.\"\"\"\n        return cls.format_name.replace(\"test\", \"tests\")\n\n    @classmethod\n    def __pydantic_init_subclass__(cls, **kwargs):\n        \"\"\"\n        Register all subclasses of BaseFixture with a fixture format name set\n        as possible fixture formats.\n        \"\"\"\n        if cls.format_name:\n            # Register the new fixture format\n            BaseFixture.formats[cls.format_name] = cls\n            if len(BaseFixture.formats) &gt; 1:\n                BaseFixture.formats_type_adapter = TypeAdapter(\n                    Annotated[\n                        Union[\n                            tuple(\n                                Annotated[fixture_format, Tag(format_name)]\n                                for (\n                                    format_name,\n                                    fixture_format,\n                                ) in BaseFixture.formats.items()\n                            )\n                        ],\n                        Discriminator(fixture_format_discriminator),\n                    ]\n                )\n            else:\n                BaseFixture.formats_type_adapter = TypeAdapter(cls)\n\n    @model_validator(mode=\"wrap\")\n    @classmethod\n    def _parse_into_subclass(cls, v: Any, handler: ValidatorFunctionWrapHandler) -&gt; \"BaseFixture\":\n        \"\"\"Parse the fixture into the correct subclass.\"\"\"\n        if cls is BaseFixture:\n            return BaseFixture.formats_type_adapter.validate_python(v)\n        return handler(v)\n\n    @cached_property\n    def json_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Returns the JSON representation of the fixture.\"\"\"\n        return self.model_dump(mode=\"json\", by_alias=True, exclude_none=True, exclude={\"info\"})\n\n    @cached_property\n    def hash(self) -&gt; str:\n        \"\"\"Returns the hash of the fixture.\"\"\"\n        json_str = json.dumps(self.json_dict, sort_keys=True, separators=(\",\", \":\"))\n        h = hashlib.sha256(json_str.encode(\"utf-8\")).hexdigest()\n        return f\"0x{h}\"\n\n    def json_dict_with_info(self, hash_only: bool = False) -&gt; Dict[str, Any]:\n        \"\"\"Return JSON representation of the fixture with the info field.\"\"\"\n        dict_with_info = self.json_dict.copy()\n        dict_with_info[\"_info\"] = {\"hash\": self.hash}\n        if not hash_only:\n            dict_with_info[\"_info\"].update(self.info)\n        return dict_with_info\n\n    def fill_info(\n        self,\n        t8n_version: str,\n        test_case_description: str,\n        fixture_source_url: str,\n        ref_spec: ReferenceSpec | None,\n        _info_metadata: Dict[str, Any],\n    ):\n        \"\"\"Fill the info field for this fixture.\"\"\"\n        if \"comment\" not in self.info:\n            self.info[\"comment\"] = \"`execution-spec-tests` generated test\"\n        self.info[\"filling-transition-tool\"] = t8n_version\n        self.info[\"description\"] = test_case_description\n        self.info[\"url\"] = fixture_source_url\n        self.info[\"fixture-format\"] = self.format_name\n        if ref_spec is not None:\n            ref_spec.write_info(self.info)\n        if _info_metadata:\n            self.info.update(_info_metadata)\n\n    def get_fork(self) -&gt; str | None:\n        \"\"\"Return fork of the fixture as a string.\"\"\"\n        raise NotImplementedError\n\n    @classmethod\n    def supports_fork(cls, fork: Fork) -&gt; bool:\n        \"\"\"\n        Return whether the fixture can be generated for the given fork.\n\n        By default, all fixtures support all forks.\n        \"\"\"\n        return True\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BaseFixture.output_base_dir_name","title":"<code>output_base_dir_name()</code>  <code>classmethod</code>","text":"<p>Return name of the subdirectory where this type of fixture should be dumped to.</p> Source code in <code>src/ethereum_test_fixtures/base.py</code> <pre><code>@classmethod\ndef output_base_dir_name(cls) -&gt; str:\n    \"\"\"Return name of the subdirectory where this type of fixture should be dumped to.\"\"\"\n    return cls.format_name.replace(\"test\", \"tests\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BaseFixture.__pydantic_init_subclass__","title":"<code>__pydantic_init_subclass__(**kwargs)</code>  <code>classmethod</code>","text":"<p>Register all subclasses of BaseFixture with a fixture format name set as possible fixture formats.</p> Source code in <code>src/ethereum_test_fixtures/base.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Register all subclasses of BaseFixture with a fixture format name set\n    as possible fixture formats.\n    \"\"\"\n    if cls.format_name:\n        # Register the new fixture format\n        BaseFixture.formats[cls.format_name] = cls\n        if len(BaseFixture.formats) &gt; 1:\n            BaseFixture.formats_type_adapter = TypeAdapter(\n                Annotated[\n                    Union[\n                        tuple(\n                            Annotated[fixture_format, Tag(format_name)]\n                            for (\n                                format_name,\n                                fixture_format,\n                            ) in BaseFixture.formats.items()\n                        )\n                    ],\n                    Discriminator(fixture_format_discriminator),\n                ]\n            )\n        else:\n            BaseFixture.formats_type_adapter = TypeAdapter(cls)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BaseFixture.json_dict","title":"<code>json_dict: Dict[str, Any]</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the JSON representation of the fixture.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BaseFixture.hash","title":"<code>hash: str</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the hash of the fixture.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BaseFixture.json_dict_with_info","title":"<code>json_dict_with_info(hash_only=False)</code>","text":"<p>Return JSON representation of the fixture with the info field.</p> Source code in <code>src/ethereum_test_fixtures/base.py</code> <pre><code>def json_dict_with_info(self, hash_only: bool = False) -&gt; Dict[str, Any]:\n    \"\"\"Return JSON representation of the fixture with the info field.\"\"\"\n    dict_with_info = self.json_dict.copy()\n    dict_with_info[\"_info\"] = {\"hash\": self.hash}\n    if not hash_only:\n        dict_with_info[\"_info\"].update(self.info)\n    return dict_with_info\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BaseFixture.fill_info","title":"<code>fill_info(t8n_version, test_case_description, fixture_source_url, ref_spec, _info_metadata)</code>","text":"<p>Fill the info field for this fixture.</p> Source code in <code>src/ethereum_test_fixtures/base.py</code> <pre><code>def fill_info(\n    self,\n    t8n_version: str,\n    test_case_description: str,\n    fixture_source_url: str,\n    ref_spec: ReferenceSpec | None,\n    _info_metadata: Dict[str, Any],\n):\n    \"\"\"Fill the info field for this fixture.\"\"\"\n    if \"comment\" not in self.info:\n        self.info[\"comment\"] = \"`execution-spec-tests` generated test\"\n    self.info[\"filling-transition-tool\"] = t8n_version\n    self.info[\"description\"] = test_case_description\n    self.info[\"url\"] = fixture_source_url\n    self.info[\"fixture-format\"] = self.format_name\n    if ref_spec is not None:\n        ref_spec.write_info(self.info)\n    if _info_metadata:\n        self.info.update(_info_metadata)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BaseFixture.get_fork","title":"<code>get_fork()</code>","text":"<p>Return fork of the fixture as a string.</p> Source code in <code>src/ethereum_test_fixtures/base.py</code> <pre><code>def get_fork(self) -&gt; str | None:\n    \"\"\"Return fork of the fixture as a string.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BaseFixture.supports_fork","title":"<code>supports_fork(fork)</code>  <code>classmethod</code>","text":"<p>Return whether the fixture can be generated for the given fork.</p> <p>By default, all fixtures support all forks.</p> Source code in <code>src/ethereum_test_fixtures/base.py</code> <pre><code>@classmethod\ndef supports_fork(cls, fork: Fork) -&gt; bool:\n    \"\"\"\n    Return whether the fixture can be generated for the given fork.\n\n    By default, all fixtures support all forks.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.FixtureCollector","title":"<code>FixtureCollector</code>  <code>dataclass</code>","text":"<p>Collects all fixtures generated by the test cases.</p> Source code in <code>src/ethereum_test_fixtures/collector.py</code> <pre><code>@dataclass(kw_only=True)\nclass FixtureCollector:\n    \"\"\"Collects all fixtures generated by the test cases.\"\"\"\n\n    output_dir: Path\n    flat_output: bool\n    single_fixture_per_file: bool\n    filler_path: Path\n    base_dump_dir: Optional[Path] = None\n\n    # Internal state\n    all_fixtures: Dict[Path, Fixtures] = field(default_factory=dict)\n    json_path_to_test_item: Dict[Path, TestInfo] = field(default_factory=dict)\n\n    def get_fixture_basename(self, info: TestInfo) -&gt; Path:\n        \"\"\"Return basename of the fixture file for a given test case.\"\"\"\n        if self.flat_output:\n            if self.single_fixture_per_file:\n                return Path(strip_test_prefix(info.get_single_test_name()))\n            return Path(strip_test_prefix(info.original_name))\n        else:\n            relative_fixture_output_dir = Path(info.path).parent / strip_test_prefix(\n                Path(info.path).stem\n            )\n            module_relative_output_dir = get_module_relative_output_dir(\n                relative_fixture_output_dir, self.filler_path\n            )\n\n            if self.single_fixture_per_file:\n                return module_relative_output_dir / strip_test_prefix(info.get_single_test_name())\n            return module_relative_output_dir / strip_test_prefix(info.original_name)\n\n    def add_fixture(self, info: TestInfo, fixture: BaseFixture) -&gt; Path:\n        \"\"\"Add fixture to the list of fixtures of a given test case.\"\"\"\n        fixture_basename = self.get_fixture_basename(info)\n\n        fixture_path = (\n            self.output_dir\n            / fixture.output_base_dir_name()\n            / fixture_basename.with_suffix(fixture.output_file_extension)\n        )\n        if fixture_path not in self.all_fixtures.keys():  # relevant when we group by test function\n            self.all_fixtures[fixture_path] = Fixtures(root={})\n            self.json_path_to_test_item[fixture_path] = info\n\n        self.all_fixtures[fixture_path][info.id] = fixture\n\n        return fixture_path\n\n    def dump_fixtures(self) -&gt; None:\n        \"\"\"Dump all collected fixtures to their respective files.\"\"\"\n        if self.output_dir.name == \"stdout\":\n            combined_fixtures = {\n                k: to_json(v) for fixture in self.all_fixtures.values() for k, v in fixture.items()\n            }\n            json.dump(combined_fixtures, sys.stdout, indent=4)\n            return\n        os.makedirs(self.output_dir, exist_ok=True)\n        for fixture_path, fixtures in self.all_fixtures.items():\n            os.makedirs(fixture_path.parent, exist_ok=True)\n            if len({fixture.__class__ for fixture in fixtures.values()}) != 1:\n                raise TypeError(\"All fixtures in a single file must have the same format.\")\n            fixtures.collect_into_file(fixture_path)\n\n    def verify_fixture_files(self, evm_fixture_verification: FixtureConsumer) -&gt; None:\n        \"\"\"Run `evm [state|block]test` on each fixture.\"\"\"\n        for fixture_path, name_fixture_dict in self.all_fixtures.items():\n            for _fixture_name, fixture in name_fixture_dict.items():\n                if evm_fixture_verification.can_consume(fixture.__class__):\n                    info = self.json_path_to_test_item[fixture_path]\n                    consume_direct_dump_dir = self._get_consume_direct_dump_dir(info)\n                    evm_fixture_verification.consume_fixture(\n                        fixture.__class__,\n                        fixture_path,\n                        fixture_name=None,\n                        debug_output_path=consume_direct_dump_dir,\n                    )\n\n    def _get_consume_direct_dump_dir(\n        self,\n        info: TestInfo,\n    ):\n        \"\"\"\n        Directory to dump the current test function's fixture.json and fixture\n        verification debug output.\n        \"\"\"\n        if not self.base_dump_dir:\n            return None\n        if self.single_fixture_per_file:\n            return info.get_dump_dir_path(\n                self.base_dump_dir, self.filler_path, level=\"test_parameter\"\n            )\n        else:\n            return info.get_dump_dir_path(\n                self.base_dump_dir, self.filler_path, level=\"test_function\"\n            )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.FixtureCollector.get_fixture_basename","title":"<code>get_fixture_basename(info)</code>","text":"<p>Return basename of the fixture file for a given test case.</p> Source code in <code>src/ethereum_test_fixtures/collector.py</code> <pre><code>def get_fixture_basename(self, info: TestInfo) -&gt; Path:\n    \"\"\"Return basename of the fixture file for a given test case.\"\"\"\n    if self.flat_output:\n        if self.single_fixture_per_file:\n            return Path(strip_test_prefix(info.get_single_test_name()))\n        return Path(strip_test_prefix(info.original_name))\n    else:\n        relative_fixture_output_dir = Path(info.path).parent / strip_test_prefix(\n            Path(info.path).stem\n        )\n        module_relative_output_dir = get_module_relative_output_dir(\n            relative_fixture_output_dir, self.filler_path\n        )\n\n        if self.single_fixture_per_file:\n            return module_relative_output_dir / strip_test_prefix(info.get_single_test_name())\n        return module_relative_output_dir / strip_test_prefix(info.original_name)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.FixtureCollector.add_fixture","title":"<code>add_fixture(info, fixture)</code>","text":"<p>Add fixture to the list of fixtures of a given test case.</p> Source code in <code>src/ethereum_test_fixtures/collector.py</code> <pre><code>def add_fixture(self, info: TestInfo, fixture: BaseFixture) -&gt; Path:\n    \"\"\"Add fixture to the list of fixtures of a given test case.\"\"\"\n    fixture_basename = self.get_fixture_basename(info)\n\n    fixture_path = (\n        self.output_dir\n        / fixture.output_base_dir_name()\n        / fixture_basename.with_suffix(fixture.output_file_extension)\n    )\n    if fixture_path not in self.all_fixtures.keys():  # relevant when we group by test function\n        self.all_fixtures[fixture_path] = Fixtures(root={})\n        self.json_path_to_test_item[fixture_path] = info\n\n    self.all_fixtures[fixture_path][info.id] = fixture\n\n    return fixture_path\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.FixtureCollector.dump_fixtures","title":"<code>dump_fixtures()</code>","text":"<p>Dump all collected fixtures to their respective files.</p> Source code in <code>src/ethereum_test_fixtures/collector.py</code> <pre><code>def dump_fixtures(self) -&gt; None:\n    \"\"\"Dump all collected fixtures to their respective files.\"\"\"\n    if self.output_dir.name == \"stdout\":\n        combined_fixtures = {\n            k: to_json(v) for fixture in self.all_fixtures.values() for k, v in fixture.items()\n        }\n        json.dump(combined_fixtures, sys.stdout, indent=4)\n        return\n    os.makedirs(self.output_dir, exist_ok=True)\n    for fixture_path, fixtures in self.all_fixtures.items():\n        os.makedirs(fixture_path.parent, exist_ok=True)\n        if len({fixture.__class__ for fixture in fixtures.values()}) != 1:\n            raise TypeError(\"All fixtures in a single file must have the same format.\")\n        fixtures.collect_into_file(fixture_path)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.FixtureCollector.verify_fixture_files","title":"<code>verify_fixture_files(evm_fixture_verification)</code>","text":"<p>Run <code>evm [state|block]test</code> on each fixture.</p> Source code in <code>src/ethereum_test_fixtures/collector.py</code> <pre><code>def verify_fixture_files(self, evm_fixture_verification: FixtureConsumer) -&gt; None:\n    \"\"\"Run `evm [state|block]test` on each fixture.\"\"\"\n    for fixture_path, name_fixture_dict in self.all_fixtures.items():\n        for _fixture_name, fixture in name_fixture_dict.items():\n            if evm_fixture_verification.can_consume(fixture.__class__):\n                info = self.json_path_to_test_item[fixture_path]\n                consume_direct_dump_dir = self._get_consume_direct_dump_dir(info)\n                evm_fixture_verification.consume_fixture(\n                    fixture.__class__,\n                    fixture_path,\n                    fixture_name=None,\n                    debug_output_path=consume_direct_dump_dir,\n                )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TestInfo","title":"<code>TestInfo</code>  <code>dataclass</code>","text":"<p>Contains test information from the current node.</p> Source code in <code>src/ethereum_test_fixtures/collector.py</code> <pre><code>@dataclass(kw_only=True)\nclass TestInfo:\n    \"\"\"Contains test information from the current node.\"\"\"\n\n    name: str  # pytest: Item.name\n    id: str  # pytest: Item.nodeid\n    original_name: str  # pytest: Item.originalname\n    path: Path  # pytest: Item.path\n\n    def get_name_and_parameters(self) -&gt; Tuple[str, str]:\n        \"\"\"\n        Convert test name to a tuple containing the test name and test parameters.\n\n        Example:\n        test_push0_key_sstore[fork_Shanghai] -&gt; test_push0_key_sstore, fork_Shanghai\n\n        \"\"\"\n        test_name, parameters = self.name.split(\"[\")\n        return test_name, re.sub(r\"[\\[\\-]\", \"_\", parameters).replace(\"]\", \"\")\n\n    def get_single_test_name(self) -&gt; str:\n        \"\"\"Convert test name to a single test name.\"\"\"\n        test_name, test_parameters = self.get_name_and_parameters()\n        return f\"{test_name}__{test_parameters}\"\n\n    def get_dump_dir_path(\n        self,\n        base_dump_dir: Optional[Path],\n        filler_path: Path,\n        level: Literal[\"test_module\", \"test_function\", \"test_parameter\"] = \"test_parameter\",\n    ) -&gt; Optional[Path]:\n        \"\"\"Path to dump the debug output as defined by the level to dump at.\"\"\"\n        if not base_dump_dir:\n            return None\n        test_module_relative_dir = get_module_relative_output_dir(self.path, filler_path)\n        if level == \"test_module\":\n            return Path(base_dump_dir) / Path(str(test_module_relative_dir).replace(os.sep, \"__\"))\n        test_name, test_parameter_string = self.get_name_and_parameters()\n        flat_path = f\"{str(test_module_relative_dir).replace(os.sep, '__')}__{test_name}\"\n        if level == \"test_function\":\n            return Path(base_dump_dir) / flat_path\n        elif level == \"test_parameter\":\n            return Path(base_dump_dir) / flat_path / test_parameter_string\n        raise Exception(\"Unexpected level.\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TestInfo.get_name_and_parameters","title":"<code>get_name_and_parameters()</code>","text":"<p>Convert test name to a tuple containing the test name and test parameters.</p> <p>Example: test_push0_key_sstore[fork_Shanghai] -&gt; test_push0_key_sstore, fork_Shanghai</p> Source code in <code>src/ethereum_test_fixtures/collector.py</code> <pre><code>def get_name_and_parameters(self) -&gt; Tuple[str, str]:\n    \"\"\"\n    Convert test name to a tuple containing the test name and test parameters.\n\n    Example:\n    test_push0_key_sstore[fork_Shanghai] -&gt; test_push0_key_sstore, fork_Shanghai\n\n    \"\"\"\n    test_name, parameters = self.name.split(\"[\")\n    return test_name, re.sub(r\"[\\[\\-]\", \"_\", parameters).replace(\"]\", \"\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TestInfo.get_single_test_name","title":"<code>get_single_test_name()</code>","text":"<p>Convert test name to a single test name.</p> Source code in <code>src/ethereum_test_fixtures/collector.py</code> <pre><code>def get_single_test_name(self) -&gt; str:\n    \"\"\"Convert test name to a single test name.\"\"\"\n    test_name, test_parameters = self.get_name_and_parameters()\n    return f\"{test_name}__{test_parameters}\"\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TestInfo.get_dump_dir_path","title":"<code>get_dump_dir_path(base_dump_dir, filler_path, level='test_parameter')</code>","text":"<p>Path to dump the debug output as defined by the level to dump at.</p> Source code in <code>src/ethereum_test_fixtures/collector.py</code> <pre><code>def get_dump_dir_path(\n    self,\n    base_dump_dir: Optional[Path],\n    filler_path: Path,\n    level: Literal[\"test_module\", \"test_function\", \"test_parameter\"] = \"test_parameter\",\n) -&gt; Optional[Path]:\n    \"\"\"Path to dump the debug output as defined by the level to dump at.\"\"\"\n    if not base_dump_dir:\n        return None\n    test_module_relative_dir = get_module_relative_output_dir(self.path, filler_path)\n    if level == \"test_module\":\n        return Path(base_dump_dir) / Path(str(test_module_relative_dir).replace(os.sep, \"__\"))\n    test_name, test_parameter_string = self.get_name_and_parameters()\n    flat_path = f\"{str(test_module_relative_dir).replace(os.sep, '__')}__{test_name}\"\n    if level == \"test_function\":\n        return Path(base_dump_dir) / flat_path\n    elif level == \"test_parameter\":\n        return Path(base_dump_dir) / flat_path / test_parameter_string\n    raise Exception(\"Unexpected level.\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BaseTest","title":"<code>BaseTest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a base Ethereum test which must return a single test fixture.</p> Source code in <code>src/ethereum_test_specs/base.py</code> <pre><code>class BaseTest(BaseModel):\n    \"\"\"Represents a base Ethereum test which must return a single test fixture.\"\"\"\n\n    tag: str = \"\"\n\n    # Transition tool specific fields\n    t8n_dump_dir: Path | None = Field(None, exclude=True)\n    _t8n_call_counter: Iterator[int] = count(0)\n\n    supported_fixture_formats: ClassVar[Sequence[FixtureFormat | LabeledFixtureFormat]] = []\n    supported_execute_formats: ClassVar[Sequence[ExecuteFormat | LabeledExecuteFormat]] = []\n\n    supported_markers: ClassVar[Dict[str, str]] = {}\n\n    @classmethod\n    def discard_fixture_format_by_marks(\n        cls,\n        fixture_format: FixtureFormat,\n        fork: Fork,\n        markers: List[pytest.Mark],\n    ) -&gt; bool:\n        \"\"\"Discard a fixture format from filling if the appropriate marker is used.\"\"\"\n        return False\n\n    @classmethod\n    def discard_execute_format_by_marks(\n        cls,\n        execute_format: ExecuteFormat,\n        fork: Fork,\n        markers: List[pytest.Mark],\n    ) -&gt; bool:\n        \"\"\"Discard an execute format from executing if the appropriate marker is used.\"\"\"\n        return False\n\n    @abstractmethod\n    def generate(\n        self,\n        *,\n        request: pytest.FixtureRequest,\n        t8n: TransitionTool,\n        fork: Fork,\n        fixture_format: FixtureFormat,\n        eips: Optional[List[int]] = None,\n    ) -&gt; BaseFixture:\n        \"\"\"Generate the list of test fixtures.\"\"\"\n        pass\n\n    def execute(\n        self,\n        *,\n        fork: Fork,\n        execute_format: ExecuteFormat,\n        eips: Optional[List[int]] = None,\n    ) -&gt; BaseExecute:\n        \"\"\"Generate the list of test fixtures.\"\"\"\n        raise Exception(f\"Unsupported execute format: {execute_format}\")\n\n    @classmethod\n    def pytest_parameter_name(cls) -&gt; str:\n        \"\"\"\n        Must return the name of the parameter used in pytest to select this\n        spec type as filler for the test.\n\n        By default, it returns the underscore separated name of the class.\n        \"\"\"\n        return reduce(lambda x, y: x + (\"_\" if y.isupper() else \"\") + y, cls.__name__).lower()\n\n    def get_next_transition_tool_output_path(self) -&gt; str:\n        \"\"\"Return path to the next transition tool output file.\"\"\"\n        if not self.t8n_dump_dir:\n            return \"\"\n        return path.join(\n            self.t8n_dump_dir,\n            str(next(self._t8n_call_counter)),\n        )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BaseTest.discard_fixture_format_by_marks","title":"<code>discard_fixture_format_by_marks(fixture_format, fork, markers)</code>  <code>classmethod</code>","text":"<p>Discard a fixture format from filling if the appropriate marker is used.</p> Source code in <code>src/ethereum_test_specs/base.py</code> <pre><code>@classmethod\ndef discard_fixture_format_by_marks(\n    cls,\n    fixture_format: FixtureFormat,\n    fork: Fork,\n    markers: List[pytest.Mark],\n) -&gt; bool:\n    \"\"\"Discard a fixture format from filling if the appropriate marker is used.\"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BaseTest.discard_execute_format_by_marks","title":"<code>discard_execute_format_by_marks(execute_format, fork, markers)</code>  <code>classmethod</code>","text":"<p>Discard an execute format from executing if the appropriate marker is used.</p> Source code in <code>src/ethereum_test_specs/base.py</code> <pre><code>@classmethod\ndef discard_execute_format_by_marks(\n    cls,\n    execute_format: ExecuteFormat,\n    fork: Fork,\n    markers: List[pytest.Mark],\n) -&gt; bool:\n    \"\"\"Discard an execute format from executing if the appropriate marker is used.\"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BaseTest.generate","title":"<code>generate(*, request, t8n, fork, fixture_format, eips=None)</code>  <code>abstractmethod</code>","text":"<p>Generate the list of test fixtures.</p> Source code in <code>src/ethereum_test_specs/base.py</code> <pre><code>@abstractmethod\ndef generate(\n    self,\n    *,\n    request: pytest.FixtureRequest,\n    t8n: TransitionTool,\n    fork: Fork,\n    fixture_format: FixtureFormat,\n    eips: Optional[List[int]] = None,\n) -&gt; BaseFixture:\n    \"\"\"Generate the list of test fixtures.\"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BaseTest.execute","title":"<code>execute(*, fork, execute_format, eips=None)</code>","text":"<p>Generate the list of test fixtures.</p> Source code in <code>src/ethereum_test_specs/base.py</code> <pre><code>def execute(\n    self,\n    *,\n    fork: Fork,\n    execute_format: ExecuteFormat,\n    eips: Optional[List[int]] = None,\n) -&gt; BaseExecute:\n    \"\"\"Generate the list of test fixtures.\"\"\"\n    raise Exception(f\"Unsupported execute format: {execute_format}\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BaseTest.pytest_parameter_name","title":"<code>pytest_parameter_name()</code>  <code>classmethod</code>","text":"<p>Must return the name of the parameter used in pytest to select this spec type as filler for the test.</p> <p>By default, it returns the underscore separated name of the class.</p> Source code in <code>src/ethereum_test_specs/base.py</code> <pre><code>@classmethod\ndef pytest_parameter_name(cls) -&gt; str:\n    \"\"\"\n    Must return the name of the parameter used in pytest to select this\n    spec type as filler for the test.\n\n    By default, it returns the underscore separated name of the class.\n    \"\"\"\n    return reduce(lambda x, y: x + (\"_\" if y.isupper() else \"\") + y, cls.__name__).lower()\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BaseTest.get_next_transition_tool_output_path","title":"<code>get_next_transition_tool_output_path()</code>","text":"<p>Return path to the next transition tool output file.</p> Source code in <code>src/ethereum_test_specs/base.py</code> <pre><code>def get_next_transition_tool_output_path(self) -&gt; str:\n    \"\"\"Return path to the next transition tool output file.\"\"\"\n    if not self.t8n_dump_dir:\n        return \"\"\n    return path.join(\n        self.t8n_dump_dir,\n        str(next(self._t8n_call_counter)),\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockchainTest","title":"<code>BlockchainTest</code>","text":"<p>               Bases: <code>BaseTest</code></p> <p>Filler type that tests multiple blocks (valid or invalid) in a chain.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>class BlockchainTest(BaseTest):\n    \"\"\"Filler type that tests multiple blocks (valid or invalid) in a chain.\"\"\"\n\n    pre: Alloc\n    post: Alloc\n    blocks: List[Block]\n    genesis_environment: Environment = Field(default_factory=Environment)\n    verify_sync: bool = False\n    chain_id: int = 1\n\n    supported_fixture_formats: ClassVar[Sequence[FixtureFormat | LabeledFixtureFormat]] = [\n        BlockchainFixture,\n        BlockchainEngineFixture,\n    ]\n    supported_execute_formats: ClassVar[Sequence[ExecuteFormat | LabeledExecuteFormat]] = [\n        TransactionPost,\n    ]\n\n    supported_markers: ClassVar[Dict[str, str]] = {\n        \"blockchain_test_engine_only\": \"Only generate a blockchain test engine fixture\",\n        \"blockchain_test_only\": \"Only generate a blockchain test fixture\",\n    }\n\n    @classmethod\n    def discard_fixture_format_by_marks(\n        cls,\n        fixture_format: FixtureFormat,\n        fork: Fork,\n        markers: List[pytest.Mark],\n    ) -&gt; bool:\n        \"\"\"Discard a fixture format from filling if the appropriate marker is used.\"\"\"\n        if \"blockchain_test_only\" in [m.name for m in markers]:\n            return fixture_format != BlockchainFixture\n        if \"blockchain_test_engine_only\" in [m.name for m in markers]:\n            return fixture_format != BlockchainEngineFixture\n        return False\n\n    @staticmethod\n    def make_genesis(\n        genesis_environment: Environment,\n        pre: Alloc,\n        fork: Fork,\n    ) -&gt; Tuple[Alloc, FixtureBlock]:\n        \"\"\"Create a genesis block from the blockchain test definition.\"\"\"\n        env = genesis_environment.set_fork_requirements(fork)\n        assert env.withdrawals is None or len(env.withdrawals) == 0, (\n            \"withdrawals must be empty at genesis\"\n        )\n        assert env.parent_beacon_block_root is None or env.parent_beacon_block_root == Hash(0), (\n            \"parent_beacon_block_root must be empty at genesis\"\n        )\n\n        pre_alloc = Alloc.merge(\n            Alloc.model_validate(fork.pre_allocation_blockchain()),\n            pre,\n        )\n        if empty_accounts := pre_alloc.empty_accounts():\n            raise Exception(f\"Empty accounts in pre state: {empty_accounts}\")\n        state_root = pre_alloc.state_root()\n        genesis = FixtureHeader(\n            parent_hash=0,\n            ommers_hash=EmptyOmmersRoot,\n            fee_recipient=0,\n            state_root=state_root,\n            transactions_trie=EmptyTrieRoot,\n            receipts_root=EmptyTrieRoot,\n            logs_bloom=0,\n            difficulty=0x20000 if env.difficulty is None else env.difficulty,\n            number=0,\n            gas_limit=env.gas_limit,\n            gas_used=0,\n            timestamp=0,\n            extra_data=b\"\\x00\",\n            prev_randao=0,\n            nonce=0,\n            base_fee_per_gas=env.base_fee_per_gas,\n            blob_gas_used=env.blob_gas_used,\n            excess_blob_gas=env.excess_blob_gas,\n            withdrawals_root=(\n                Withdrawal.list_root(env.withdrawals) if env.withdrawals is not None else None\n            ),\n            parent_beacon_block_root=env.parent_beacon_block_root,\n            requests_hash=Requests() if fork.header_requests_required(0, 0) else None,\n            fork=fork,\n        )\n\n        return (\n            pre_alloc,\n            FixtureBlockBase(\n                header=genesis,\n                withdrawals=None if env.withdrawals is None else [],\n            ).with_rlp(txs=[]),\n        )\n\n    def generate_block_data(\n        self,\n        t8n: TransitionTool,\n        fork: Fork,\n        block: Block,\n        previous_env: Environment,\n        previous_alloc: Alloc,\n        eips: Optional[List[int]] = None,\n        slow: bool = False,\n    ) -&gt; Tuple[FixtureHeader, List[Transaction], List[Bytes] | None, Alloc, Environment]:\n        \"\"\"Generate common block data for both make_fixture and make_hive_fixture.\"\"\"\n        if block.rlp and block.exception is not None:\n            raise Exception(\n                \"test correctness: post-state cannot be verified if the \"\n                + \"block's rlp is supplied and the block is not supposed \"\n                + \"to produce an exception\"\n            )\n\n        env = block.set_environment(previous_env)\n        env = env.set_fork_requirements(fork)\n\n        txs = [tx.with_signature_and_sender() for tx in block.txs]\n\n        if failing_tx_count := len([tx for tx in txs if tx.error]) &gt; 0:\n            if failing_tx_count &gt; 1:\n                raise Exception(\n                    \"test correctness: only one transaction can produce an exception in a block\"\n                )\n            if not txs[-1].error:\n                raise Exception(\n                    \"test correctness: the transaction that produces an exception \"\n                    + \"must be the last transaction in the block\"\n                )\n\n        transition_tool_output = t8n.evaluate(\n            alloc=previous_alloc,\n            txs=txs,\n            env=env,\n            fork=fork,\n            chain_id=self.chain_id,\n            reward=fork.get_reward(env.number, env.timestamp),\n            blob_schedule=fork.blob_schedule(),\n            eips=eips,\n            debug_output_path=self.get_next_transition_tool_output_path(),\n            slow_request=slow,\n        )\n\n        try:\n            rejected_txs = verify_transactions(\n                txs=txs,\n                exception_mapper=t8n.exception_mapper,\n                result=transition_tool_output.result,\n            )\n            verify_result(transition_tool_output.result, env)\n        except Exception as e:\n            print_traces(t8n.get_traces())\n            pprint(transition_tool_output.result)\n            pprint(previous_alloc)\n            pprint(transition_tool_output.alloc)\n            raise e\n\n        if len(rejected_txs) &gt; 0 and block.exception is None:\n            print_traces(t8n.get_traces())\n            raise Exception(\n                \"one or more transactions in `BlockchainTest` are \"\n                + \"intrinsically invalid, but the block was not expected \"\n                + \"to be invalid. Please verify whether the transaction \"\n                + \"was indeed expected to fail and add the proper \"\n                + \"`block.exception`\"\n            )\n\n        # One special case of the invalid transactions is the blob gas used, since this value\n        # is not included in the transition tool result, but it is included in the block header,\n        # and some clients check it before executing the block by simply counting the type-3 txs,\n        # we need to set the correct value by default.\n        blob_gas_used: int | None = None\n        if (blob_gas_per_blob := fork.blob_gas_per_blob(env.number, env.timestamp)) &gt; 0:\n            blob_gas_used = blob_gas_per_blob * count_blobs(txs)\n\n        header = FixtureHeader(\n            **(\n                transition_tool_output.result.model_dump(\n                    exclude_none=True, exclude={\"blob_gas_used\", \"transactions_trie\"}\n                )\n                | env.model_dump(exclude_none=True, exclude={\"blob_gas_used\"})\n            ),\n            blob_gas_used=blob_gas_used,\n            transactions_trie=Transaction.list_root(txs),\n            extra_data=block.extra_data if block.extra_data is not None else b\"\",\n            fork=fork,\n        )\n\n        if block.header_verify is not None:\n            # Verify the header after transition tool processing.\n            block.header_verify.verify(header)\n\n        requests_list: List[Bytes] | None = None\n        if fork.header_requests_required(header.number, header.timestamp):\n            assert transition_tool_output.result.requests is not None, (\n                \"Requests are required for this block\"\n            )\n            requests = Requests(requests_lists=list(transition_tool_output.result.requests))\n\n            if Hash(requests) != header.requests_hash:\n                raise Exception(\n                    \"Requests root in header does not match the requests root in the transition \"\n                    \"tool output: \"\n                    f\"{header.requests_hash} != {Hash(requests)}\"\n                )\n\n            requests_list = requests.requests_list\n\n        if block.requests is not None:\n            header.requests_hash = Hash(Requests(requests_lists=list(block.requests)))\n            requests_list = block.requests\n\n        if block.rlp_modifier is not None:\n            # Modify any parameter specified in the `rlp_modifier` after\n            # transition tool processing.\n            header = block.rlp_modifier.apply(header)\n            header.fork = fork  # Deleted during `apply` because `exclude=True`\n\n        return (\n            header,\n            txs,\n            requests_list,\n            transition_tool_output.alloc,\n            env,\n        )\n\n    @staticmethod\n    def network_info(fork: Fork, eips: Optional[List[int]] = None):\n        \"\"\"Return fixture network information for the fork &amp; EIP/s.\"\"\"\n        return (\n            \"+\".join([fork.blockchain_test_network_name()] + [str(eip) for eip in eips])\n            if eips\n            else fork.blockchain_test_network_name()\n        )\n\n    def verify_post_state(self, t8n, t8n_state: Alloc, expected_state: Alloc | None = None):\n        \"\"\"Verify post alloc after all block/s or payload/s are generated.\"\"\"\n        try:\n            if expected_state:\n                expected_state.verify_post_alloc(t8n_state)\n            else:\n                self.post.verify_post_alloc(t8n_state)\n        except Exception as e:\n            print_traces(t8n.get_traces())\n            raise e\n\n    def make_fixture(\n        self,\n        t8n: TransitionTool,\n        fork: Fork,\n        eips: Optional[List[int]] = None,\n        slow: bool = False,\n    ) -&gt; BlockchainFixture:\n        \"\"\"Create a fixture from the blockchain test definition.\"\"\"\n        fixture_blocks: List[FixtureBlock | InvalidFixtureBlock] = []\n\n        pre, genesis = BlockchainTest.make_genesis(self.genesis_environment, self.pre, fork)\n\n        alloc = pre\n        env = environment_from_parent_header(genesis.header)\n        head = genesis.header.block_hash\n\n        for block in self.blocks:\n            if block.rlp is None:\n                # This is the most common case, the RLP needs to be constructed\n                # based on the transactions to be included in the block.\n                # Set the environment according to the block to execute.\n                header, txs, _, new_alloc, new_env = self.generate_block_data(\n                    t8n=t8n,\n                    fork=fork,\n                    block=block,\n                    previous_env=env,\n                    previous_alloc=alloc,\n                    eips=eips,\n                    slow=slow,\n                )\n                fixture_block = FixtureBlockBase(\n                    header=header,\n                    txs=[FixtureTransaction.from_transaction(tx) for tx in txs],\n                    ommers=[],\n                    withdrawals=(\n                        [FixtureWithdrawal.from_withdrawal(w) for w in new_env.withdrawals]\n                        if new_env.withdrawals is not None\n                        else None\n                    ),\n                    fork=fork,\n                ).with_rlp(txs=txs)\n                if block.exception is None:\n                    fixture_blocks.append(fixture_block)\n                    # Update env, alloc and last block hash for the next block.\n                    alloc = new_alloc\n                    env = apply_new_parent(new_env, header)\n                    head = header.block_hash\n                else:\n                    fixture_blocks.append(\n                        InvalidFixtureBlock(\n                            rlp=fixture_block.rlp,\n                            expect_exception=block.exception,\n                            rlp_decoded=(\n                                None\n                                if BlockException.RLP_STRUCTURES_ENCODING in block.exception\n                                else fixture_block.without_rlp()\n                            ),\n                        ),\n                    )\n            else:\n                assert block.exception is not None, (\n                    \"test correctness: if the block's rlp is hard-coded, \"\n                    + \"the block is expected to produce an exception\"\n                )\n                fixture_blocks.append(\n                    InvalidFixtureBlock(\n                        rlp=block.rlp,\n                        expect_exception=block.exception,\n                    ),\n                )\n\n            if block.expected_post_state:\n                self.verify_post_state(\n                    t8n, t8n_state=alloc, expected_state=block.expected_post_state\n                )\n\n        self.verify_post_state(t8n, t8n_state=alloc)\n        network_info = BlockchainTest.network_info(fork, eips)\n        return BlockchainFixture(\n            fork=network_info,\n            genesis=genesis.header,\n            genesis_rlp=genesis.rlp,\n            blocks=fixture_blocks,\n            last_block_hash=head,\n            pre=pre,\n            post_state=alloc,\n            config=FixtureConfig(\n                fork=network_info,\n                blob_schedule=FixtureBlobSchedule.from_blob_schedule(fork.blob_schedule()),\n                chain_id=self.chain_id,\n            ),\n        )\n\n    def make_hive_fixture(\n        self,\n        t8n: TransitionTool,\n        fork: Fork,\n        eips: Optional[List[int]] = None,\n        slow: bool = False,\n    ) -&gt; BlockchainEngineFixture:\n        \"\"\"Create a hive fixture from the blocktest definition.\"\"\"\n        fixture_payloads: List[FixtureEngineNewPayload] = []\n\n        pre, genesis = BlockchainTest.make_genesis(self.genesis_environment, self.pre, fork)\n        alloc = pre\n        env = environment_from_parent_header(genesis.header)\n        head_hash = genesis.header.block_hash\n\n        for block in self.blocks:\n            header, txs, requests, new_alloc, new_env = self.generate_block_data(\n                t8n=t8n,\n                fork=fork,\n                block=block,\n                previous_env=env,\n                previous_alloc=alloc,\n                eips=eips,\n                slow=slow,\n            )\n            if block.rlp is None:\n                fixture_payloads.append(\n                    FixtureEngineNewPayload.from_fixture_header(\n                        fork=fork,\n                        header=header,\n                        transactions=txs,\n                        withdrawals=new_env.withdrawals,\n                        requests=requests,\n                        validation_error=block.exception,\n                        error_code=block.engine_api_error_code,\n                    )\n                )\n                if block.exception is None:\n                    alloc = new_alloc\n                    env = apply_new_parent(env, header)\n                    head_hash = header.block_hash\n\n            if block.expected_post_state:\n                self.verify_post_state(\n                    t8n, t8n_state=alloc, expected_state=block.expected_post_state\n                )\n\n        fcu_version = fork.engine_forkchoice_updated_version(header.number, header.timestamp)\n        assert fcu_version is not None, (\n            \"A hive fixture was requested but no forkchoice update is defined.\"\n            \" The framework should never try to execute this test case.\"\n        )\n\n        self.verify_post_state(t8n, t8n_state=alloc)\n\n        sync_payload: Optional[FixtureEngineNewPayload] = None\n        if self.verify_sync:\n            # Test is marked for syncing verification.\n            assert genesis.header.block_hash != head_hash, (\n                \"Invalid payload tests negative test via sync is not supported yet.\"\n            )\n\n            # Most clients require the header to start the sync process, so we create an empty\n            # block on top of the last block of the test to send it as new payload and trigger the\n            # sync process.\n            sync_header, _, requests, _, _ = self.generate_block_data(\n                t8n=t8n,\n                fork=fork,\n                block=Block(),\n                previous_env=env,\n                previous_alloc=alloc,\n                eips=eips,\n            )\n            sync_payload = FixtureEngineNewPayload.from_fixture_header(\n                fork=fork,\n                header=sync_header,\n                transactions=[],\n                withdrawals=[],\n                requests=requests,\n                validation_error=None,\n                error_code=None,\n            )\n\n        network_info = BlockchainTest.network_info(fork, eips)\n        return BlockchainEngineFixture(\n            fork=network_info,\n            genesis=genesis.header,\n            payloads=fixture_payloads,\n            fcu_version=fcu_version,\n            pre=pre,\n            post_state=alloc,\n            sync_payload=sync_payload,\n            last_block_hash=head_hash,\n            config=FixtureConfig(\n                fork=network_info,\n                chain_id=self.chain_id,\n                blob_schedule=FixtureBlobSchedule.from_blob_schedule(fork.blob_schedule()),\n            ),\n        )\n\n    def generate(\n        self,\n        request: pytest.FixtureRequest,\n        t8n: TransitionTool,\n        fork: Fork,\n        fixture_format: FixtureFormat,\n        eips: Optional[List[int]] = None,\n    ) -&gt; BaseFixture:\n        \"\"\"Generate the BlockchainTest fixture.\"\"\"\n        t8n.reset_traces()\n        if fixture_format == BlockchainEngineFixture:\n            return self.make_hive_fixture(t8n, fork, eips, slow=is_slow_test(request))\n        elif fixture_format == BlockchainFixture:\n            return self.make_fixture(t8n, fork, eips, slow=is_slow_test(request))\n\n        raise Exception(f\"Unknown fixture format: {fixture_format}\")\n\n    def execute(\n        self,\n        *,\n        fork: Fork,\n        execute_format: ExecuteFormat,\n        eips: Optional[List[int]] = None,\n    ) -&gt; BaseExecute:\n        \"\"\"Generate the list of test fixtures.\"\"\"\n        if execute_format == TransactionPost:\n            txs: List[Transaction] = []\n            for block in self.blocks:\n                txs += block.txs\n            return TransactionPost(\n                transactions=txs,\n                post=self.post,\n            )\n        raise Exception(f\"Unsupported execute format: {execute_format}\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockchainTest.discard_fixture_format_by_marks","title":"<code>discard_fixture_format_by_marks(fixture_format, fork, markers)</code>  <code>classmethod</code>","text":"<p>Discard a fixture format from filling if the appropriate marker is used.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>@classmethod\ndef discard_fixture_format_by_marks(\n    cls,\n    fixture_format: FixtureFormat,\n    fork: Fork,\n    markers: List[pytest.Mark],\n) -&gt; bool:\n    \"\"\"Discard a fixture format from filling if the appropriate marker is used.\"\"\"\n    if \"blockchain_test_only\" in [m.name for m in markers]:\n        return fixture_format != BlockchainFixture\n    if \"blockchain_test_engine_only\" in [m.name for m in markers]:\n        return fixture_format != BlockchainEngineFixture\n    return False\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockchainTest.make_genesis","title":"<code>make_genesis(genesis_environment, pre, fork)</code>  <code>staticmethod</code>","text":"<p>Create a genesis block from the blockchain test definition.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>@staticmethod\ndef make_genesis(\n    genesis_environment: Environment,\n    pre: Alloc,\n    fork: Fork,\n) -&gt; Tuple[Alloc, FixtureBlock]:\n    \"\"\"Create a genesis block from the blockchain test definition.\"\"\"\n    env = genesis_environment.set_fork_requirements(fork)\n    assert env.withdrawals is None or len(env.withdrawals) == 0, (\n        \"withdrawals must be empty at genesis\"\n    )\n    assert env.parent_beacon_block_root is None or env.parent_beacon_block_root == Hash(0), (\n        \"parent_beacon_block_root must be empty at genesis\"\n    )\n\n    pre_alloc = Alloc.merge(\n        Alloc.model_validate(fork.pre_allocation_blockchain()),\n        pre,\n    )\n    if empty_accounts := pre_alloc.empty_accounts():\n        raise Exception(f\"Empty accounts in pre state: {empty_accounts}\")\n    state_root = pre_alloc.state_root()\n    genesis = FixtureHeader(\n        parent_hash=0,\n        ommers_hash=EmptyOmmersRoot,\n        fee_recipient=0,\n        state_root=state_root,\n        transactions_trie=EmptyTrieRoot,\n        receipts_root=EmptyTrieRoot,\n        logs_bloom=0,\n        difficulty=0x20000 if env.difficulty is None else env.difficulty,\n        number=0,\n        gas_limit=env.gas_limit,\n        gas_used=0,\n        timestamp=0,\n        extra_data=b\"\\x00\",\n        prev_randao=0,\n        nonce=0,\n        base_fee_per_gas=env.base_fee_per_gas,\n        blob_gas_used=env.blob_gas_used,\n        excess_blob_gas=env.excess_blob_gas,\n        withdrawals_root=(\n            Withdrawal.list_root(env.withdrawals) if env.withdrawals is not None else None\n        ),\n        parent_beacon_block_root=env.parent_beacon_block_root,\n        requests_hash=Requests() if fork.header_requests_required(0, 0) else None,\n        fork=fork,\n    )\n\n    return (\n        pre_alloc,\n        FixtureBlockBase(\n            header=genesis,\n            withdrawals=None if env.withdrawals is None else [],\n        ).with_rlp(txs=[]),\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockchainTest.generate_block_data","title":"<code>generate_block_data(t8n, fork, block, previous_env, previous_alloc, eips=None, slow=False)</code>","text":"<p>Generate common block data for both make_fixture and make_hive_fixture.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>def generate_block_data(\n    self,\n    t8n: TransitionTool,\n    fork: Fork,\n    block: Block,\n    previous_env: Environment,\n    previous_alloc: Alloc,\n    eips: Optional[List[int]] = None,\n    slow: bool = False,\n) -&gt; Tuple[FixtureHeader, List[Transaction], List[Bytes] | None, Alloc, Environment]:\n    \"\"\"Generate common block data for both make_fixture and make_hive_fixture.\"\"\"\n    if block.rlp and block.exception is not None:\n        raise Exception(\n            \"test correctness: post-state cannot be verified if the \"\n            + \"block's rlp is supplied and the block is not supposed \"\n            + \"to produce an exception\"\n        )\n\n    env = block.set_environment(previous_env)\n    env = env.set_fork_requirements(fork)\n\n    txs = [tx.with_signature_and_sender() for tx in block.txs]\n\n    if failing_tx_count := len([tx for tx in txs if tx.error]) &gt; 0:\n        if failing_tx_count &gt; 1:\n            raise Exception(\n                \"test correctness: only one transaction can produce an exception in a block\"\n            )\n        if not txs[-1].error:\n            raise Exception(\n                \"test correctness: the transaction that produces an exception \"\n                + \"must be the last transaction in the block\"\n            )\n\n    transition_tool_output = t8n.evaluate(\n        alloc=previous_alloc,\n        txs=txs,\n        env=env,\n        fork=fork,\n        chain_id=self.chain_id,\n        reward=fork.get_reward(env.number, env.timestamp),\n        blob_schedule=fork.blob_schedule(),\n        eips=eips,\n        debug_output_path=self.get_next_transition_tool_output_path(),\n        slow_request=slow,\n    )\n\n    try:\n        rejected_txs = verify_transactions(\n            txs=txs,\n            exception_mapper=t8n.exception_mapper,\n            result=transition_tool_output.result,\n        )\n        verify_result(transition_tool_output.result, env)\n    except Exception as e:\n        print_traces(t8n.get_traces())\n        pprint(transition_tool_output.result)\n        pprint(previous_alloc)\n        pprint(transition_tool_output.alloc)\n        raise e\n\n    if len(rejected_txs) &gt; 0 and block.exception is None:\n        print_traces(t8n.get_traces())\n        raise Exception(\n            \"one or more transactions in `BlockchainTest` are \"\n            + \"intrinsically invalid, but the block was not expected \"\n            + \"to be invalid. Please verify whether the transaction \"\n            + \"was indeed expected to fail and add the proper \"\n            + \"`block.exception`\"\n        )\n\n    # One special case of the invalid transactions is the blob gas used, since this value\n    # is not included in the transition tool result, but it is included in the block header,\n    # and some clients check it before executing the block by simply counting the type-3 txs,\n    # we need to set the correct value by default.\n    blob_gas_used: int | None = None\n    if (blob_gas_per_blob := fork.blob_gas_per_blob(env.number, env.timestamp)) &gt; 0:\n        blob_gas_used = blob_gas_per_blob * count_blobs(txs)\n\n    header = FixtureHeader(\n        **(\n            transition_tool_output.result.model_dump(\n                exclude_none=True, exclude={\"blob_gas_used\", \"transactions_trie\"}\n            )\n            | env.model_dump(exclude_none=True, exclude={\"blob_gas_used\"})\n        ),\n        blob_gas_used=blob_gas_used,\n        transactions_trie=Transaction.list_root(txs),\n        extra_data=block.extra_data if block.extra_data is not None else b\"\",\n        fork=fork,\n    )\n\n    if block.header_verify is not None:\n        # Verify the header after transition tool processing.\n        block.header_verify.verify(header)\n\n    requests_list: List[Bytes] | None = None\n    if fork.header_requests_required(header.number, header.timestamp):\n        assert transition_tool_output.result.requests is not None, (\n            \"Requests are required for this block\"\n        )\n        requests = Requests(requests_lists=list(transition_tool_output.result.requests))\n\n        if Hash(requests) != header.requests_hash:\n            raise Exception(\n                \"Requests root in header does not match the requests root in the transition \"\n                \"tool output: \"\n                f\"{header.requests_hash} != {Hash(requests)}\"\n            )\n\n        requests_list = requests.requests_list\n\n    if block.requests is not None:\n        header.requests_hash = Hash(Requests(requests_lists=list(block.requests)))\n        requests_list = block.requests\n\n    if block.rlp_modifier is not None:\n        # Modify any parameter specified in the `rlp_modifier` after\n        # transition tool processing.\n        header = block.rlp_modifier.apply(header)\n        header.fork = fork  # Deleted during `apply` because `exclude=True`\n\n    return (\n        header,\n        txs,\n        requests_list,\n        transition_tool_output.alloc,\n        env,\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockchainTest.network_info","title":"<code>network_info(fork, eips=None)</code>  <code>staticmethod</code>","text":"<p>Return fixture network information for the fork &amp; EIP/s.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>@staticmethod\ndef network_info(fork: Fork, eips: Optional[List[int]] = None):\n    \"\"\"Return fixture network information for the fork &amp; EIP/s.\"\"\"\n    return (\n        \"+\".join([fork.blockchain_test_network_name()] + [str(eip) for eip in eips])\n        if eips\n        else fork.blockchain_test_network_name()\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockchainTest.verify_post_state","title":"<code>verify_post_state(t8n, t8n_state, expected_state=None)</code>","text":"<p>Verify post alloc after all block/s or payload/s are generated.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>def verify_post_state(self, t8n, t8n_state: Alloc, expected_state: Alloc | None = None):\n    \"\"\"Verify post alloc after all block/s or payload/s are generated.\"\"\"\n    try:\n        if expected_state:\n            expected_state.verify_post_alloc(t8n_state)\n        else:\n            self.post.verify_post_alloc(t8n_state)\n    except Exception as e:\n        print_traces(t8n.get_traces())\n        raise e\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockchainTest.make_fixture","title":"<code>make_fixture(t8n, fork, eips=None, slow=False)</code>","text":"<p>Create a fixture from the blockchain test definition.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>def make_fixture(\n    self,\n    t8n: TransitionTool,\n    fork: Fork,\n    eips: Optional[List[int]] = None,\n    slow: bool = False,\n) -&gt; BlockchainFixture:\n    \"\"\"Create a fixture from the blockchain test definition.\"\"\"\n    fixture_blocks: List[FixtureBlock | InvalidFixtureBlock] = []\n\n    pre, genesis = BlockchainTest.make_genesis(self.genesis_environment, self.pre, fork)\n\n    alloc = pre\n    env = environment_from_parent_header(genesis.header)\n    head = genesis.header.block_hash\n\n    for block in self.blocks:\n        if block.rlp is None:\n            # This is the most common case, the RLP needs to be constructed\n            # based on the transactions to be included in the block.\n            # Set the environment according to the block to execute.\n            header, txs, _, new_alloc, new_env = self.generate_block_data(\n                t8n=t8n,\n                fork=fork,\n                block=block,\n                previous_env=env,\n                previous_alloc=alloc,\n                eips=eips,\n                slow=slow,\n            )\n            fixture_block = FixtureBlockBase(\n                header=header,\n                txs=[FixtureTransaction.from_transaction(tx) for tx in txs],\n                ommers=[],\n                withdrawals=(\n                    [FixtureWithdrawal.from_withdrawal(w) for w in new_env.withdrawals]\n                    if new_env.withdrawals is not None\n                    else None\n                ),\n                fork=fork,\n            ).with_rlp(txs=txs)\n            if block.exception is None:\n                fixture_blocks.append(fixture_block)\n                # Update env, alloc and last block hash for the next block.\n                alloc = new_alloc\n                env = apply_new_parent(new_env, header)\n                head = header.block_hash\n            else:\n                fixture_blocks.append(\n                    InvalidFixtureBlock(\n                        rlp=fixture_block.rlp,\n                        expect_exception=block.exception,\n                        rlp_decoded=(\n                            None\n                            if BlockException.RLP_STRUCTURES_ENCODING in block.exception\n                            else fixture_block.without_rlp()\n                        ),\n                    ),\n                )\n        else:\n            assert block.exception is not None, (\n                \"test correctness: if the block's rlp is hard-coded, \"\n                + \"the block is expected to produce an exception\"\n            )\n            fixture_blocks.append(\n                InvalidFixtureBlock(\n                    rlp=block.rlp,\n                    expect_exception=block.exception,\n                ),\n            )\n\n        if block.expected_post_state:\n            self.verify_post_state(\n                t8n, t8n_state=alloc, expected_state=block.expected_post_state\n            )\n\n    self.verify_post_state(t8n, t8n_state=alloc)\n    network_info = BlockchainTest.network_info(fork, eips)\n    return BlockchainFixture(\n        fork=network_info,\n        genesis=genesis.header,\n        genesis_rlp=genesis.rlp,\n        blocks=fixture_blocks,\n        last_block_hash=head,\n        pre=pre,\n        post_state=alloc,\n        config=FixtureConfig(\n            fork=network_info,\n            blob_schedule=FixtureBlobSchedule.from_blob_schedule(fork.blob_schedule()),\n            chain_id=self.chain_id,\n        ),\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockchainTest.make_hive_fixture","title":"<code>make_hive_fixture(t8n, fork, eips=None, slow=False)</code>","text":"<p>Create a hive fixture from the blocktest definition.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>def make_hive_fixture(\n    self,\n    t8n: TransitionTool,\n    fork: Fork,\n    eips: Optional[List[int]] = None,\n    slow: bool = False,\n) -&gt; BlockchainEngineFixture:\n    \"\"\"Create a hive fixture from the blocktest definition.\"\"\"\n    fixture_payloads: List[FixtureEngineNewPayload] = []\n\n    pre, genesis = BlockchainTest.make_genesis(self.genesis_environment, self.pre, fork)\n    alloc = pre\n    env = environment_from_parent_header(genesis.header)\n    head_hash = genesis.header.block_hash\n\n    for block in self.blocks:\n        header, txs, requests, new_alloc, new_env = self.generate_block_data(\n            t8n=t8n,\n            fork=fork,\n            block=block,\n            previous_env=env,\n            previous_alloc=alloc,\n            eips=eips,\n            slow=slow,\n        )\n        if block.rlp is None:\n            fixture_payloads.append(\n                FixtureEngineNewPayload.from_fixture_header(\n                    fork=fork,\n                    header=header,\n                    transactions=txs,\n                    withdrawals=new_env.withdrawals,\n                    requests=requests,\n                    validation_error=block.exception,\n                    error_code=block.engine_api_error_code,\n                )\n            )\n            if block.exception is None:\n                alloc = new_alloc\n                env = apply_new_parent(env, header)\n                head_hash = header.block_hash\n\n        if block.expected_post_state:\n            self.verify_post_state(\n                t8n, t8n_state=alloc, expected_state=block.expected_post_state\n            )\n\n    fcu_version = fork.engine_forkchoice_updated_version(header.number, header.timestamp)\n    assert fcu_version is not None, (\n        \"A hive fixture was requested but no forkchoice update is defined.\"\n        \" The framework should never try to execute this test case.\"\n    )\n\n    self.verify_post_state(t8n, t8n_state=alloc)\n\n    sync_payload: Optional[FixtureEngineNewPayload] = None\n    if self.verify_sync:\n        # Test is marked for syncing verification.\n        assert genesis.header.block_hash != head_hash, (\n            \"Invalid payload tests negative test via sync is not supported yet.\"\n        )\n\n        # Most clients require the header to start the sync process, so we create an empty\n        # block on top of the last block of the test to send it as new payload and trigger the\n        # sync process.\n        sync_header, _, requests, _, _ = self.generate_block_data(\n            t8n=t8n,\n            fork=fork,\n            block=Block(),\n            previous_env=env,\n            previous_alloc=alloc,\n            eips=eips,\n        )\n        sync_payload = FixtureEngineNewPayload.from_fixture_header(\n            fork=fork,\n            header=sync_header,\n            transactions=[],\n            withdrawals=[],\n            requests=requests,\n            validation_error=None,\n            error_code=None,\n        )\n\n    network_info = BlockchainTest.network_info(fork, eips)\n    return BlockchainEngineFixture(\n        fork=network_info,\n        genesis=genesis.header,\n        payloads=fixture_payloads,\n        fcu_version=fcu_version,\n        pre=pre,\n        post_state=alloc,\n        sync_payload=sync_payload,\n        last_block_hash=head_hash,\n        config=FixtureConfig(\n            fork=network_info,\n            chain_id=self.chain_id,\n            blob_schedule=FixtureBlobSchedule.from_blob_schedule(fork.blob_schedule()),\n        ),\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockchainTest.generate","title":"<code>generate(request, t8n, fork, fixture_format, eips=None)</code>","text":"<p>Generate the BlockchainTest fixture.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>def generate(\n    self,\n    request: pytest.FixtureRequest,\n    t8n: TransitionTool,\n    fork: Fork,\n    fixture_format: FixtureFormat,\n    eips: Optional[List[int]] = None,\n) -&gt; BaseFixture:\n    \"\"\"Generate the BlockchainTest fixture.\"\"\"\n    t8n.reset_traces()\n    if fixture_format == BlockchainEngineFixture:\n        return self.make_hive_fixture(t8n, fork, eips, slow=is_slow_test(request))\n    elif fixture_format == BlockchainFixture:\n        return self.make_fixture(t8n, fork, eips, slow=is_slow_test(request))\n\n    raise Exception(f\"Unknown fixture format: {fixture_format}\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockchainTest.execute","title":"<code>execute(*, fork, execute_format, eips=None)</code>","text":"<p>Generate the list of test fixtures.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>def execute(\n    self,\n    *,\n    fork: Fork,\n    execute_format: ExecuteFormat,\n    eips: Optional[List[int]] = None,\n) -&gt; BaseExecute:\n    \"\"\"Generate the list of test fixtures.\"\"\"\n    if execute_format == TransactionPost:\n        txs: List[Transaction] = []\n        for block in self.blocks:\n            txs += block.txs\n        return TransactionPost(\n            transactions=txs,\n            post=self.post,\n        )\n    raise Exception(f\"Unsupported execute format: {execute_format}\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFStateTest","title":"<code>EOFStateTest</code>","text":"<p>               Bases: <code>EOFTest</code>, <code>Transaction</code></p> <p>Filler type that generates an EOF test for container validation, and also tests the container during runtime using a state test (and blockchain test).</p> <p>In the state or blockchain test, the container is first deployed to the pre-allocation and then a transaction is sent to the deployed container.</p> <p>Container deployment/validation is not tested like in the <code>EOFTest</code> unless the container under test is an initcode container.</p> <p>All fields from <code>ethereum_test_types.Transaction</code> are available for use in the test.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>class EOFStateTest(EOFTest, Transaction):\n    \"\"\"\n    Filler type that generates an EOF test for container validation, and also tests the container\n    during runtime using a state test (and blockchain test).\n\n    In the state or blockchain test, the container is first deployed to the pre-allocation and\n    then a transaction is sent to the deployed container.\n\n    Container deployment/validation is **not** tested like in the `EOFTest` unless the container\n    under test is an initcode container.\n\n    All fields from `ethereum_test_types.Transaction` are available for use in the test.\n    \"\"\"\n\n    gas_limit: HexNumber = Field(HexNumber(10_000_000), serialization_alias=\"gas\")\n    \"\"\"\n    Gas limit for the transaction that deploys the container.\n    \"\"\"\n    tx_sender_funding_amount: int = 1_000_000_000_000_000_000_000\n    \"\"\"\n    Amount of funds to send to the sender EOA before the transaction.\n    \"\"\"\n    env: Environment = Field(default_factory=Environment)\n    \"\"\"\n    Environment object that is used during State Test generation.\n    \"\"\"\n    container_post: Account = Field(default_factory=Account)\n    \"\"\"\n    Account object used to verify the container post state.\n    \"\"\"\n\n    supported_fixture_formats: ClassVar[Sequence[FixtureFormat | LabeledFixtureFormat]] = [\n        EOFFixture\n    ] + [\n        LabeledFixtureFormat(\n            fixture_format,\n            f\"eof_{fixture_format.format_name}\",\n            f\"Tests that generate an EOF {fixture_format.format_name}.\",\n        )\n        for fixture_format in StateTest.supported_fixture_formats\n    ]\n\n    supported_execute_formats: ClassVar[Sequence[ExecuteFormat | LabeledExecuteFormat]] = [\n        LabeledExecuteFormat(\n            execute_format,\n            f\"eof_{execute_format.format_name}\",\n            f\"Tests that generate an EOF {execute_format.format_name}.\",\n        )\n        for execute_format in StateTest.supported_execute_formats\n    ]\n\n    @classmethod\n    def pytest_parameter_name(cls) -&gt; str:\n        \"\"\"Workaround for pytest parameter name.\"\"\"\n        return \"eof_state_test\"\n\n    def model_post_init(self, __context):\n        \"\"\"Prepare the transaction parameters required to fill the test.\"\"\"\n        assert self.pre is not None, \"pre must be set to generate a StateTest.\"\n\n        EOFTest.model_post_init(self, __context)\n\n        self.sender = self.pre.fund_eoa(amount=self.tx_sender_funding_amount)\n        if self.post is None:\n            self.post = Alloc()\n\n        if self.expect_exception is not None:  # Invalid EOF\n            self.to = None  # Make EIP-7698 create transaction\n            self.data = Bytes(\n                bytes(self.container) + self.data\n            )  # by concatenating container and tx data.\n\n            # Run transaction model validation\n            Transaction.model_post_init(self, __context)\n\n            self.post[self.created_contract] = None  # Expect failure.\n        elif self.container_kind == ContainerKind.INITCODE:\n            self.to = None  # Make EIP-7698 create transaction\n            self.data = Bytes(\n                bytes(self.container) + self.data\n            )  # by concatenating container and tx data.\n\n            # Run transaction model validation\n            Transaction.model_post_init(self, __context)\n\n            self.post[self.created_contract] = self.container_post  # Successful.\n        else:\n            self.to = self.pre.deploy_contract(code=self.container)\n\n            # Run transaction model validation\n            Transaction.model_post_init(self, __context)\n\n            self.post[self.to] = self.container_post\n\n    def generate_state_test(self, fork: Fork) -&gt; StateTest:\n        \"\"\"Generate the StateTest filler.\"\"\"\n        assert self.pre is not None, \"pre must be set to generate a StateTest.\"\n        assert self.post is not None, \"post must be set to generate a StateTest.\"\n\n        return StateTest(\n            pre=self.pre,\n            tx=self,\n            env=self.env,\n            post=self.post,\n            t8n_dump_dir=self.t8n_dump_dir,\n        )\n\n    def generate(\n        self,\n        *,\n        request: pytest.FixtureRequest,\n        t8n: TransitionTool,\n        fork: Fork,\n        eips: Optional[List[int]] = None,\n        fixture_format: FixtureFormat,\n        **_,\n    ) -&gt; BaseFixture:\n        \"\"\"Generate the BlockchainTest fixture.\"\"\"\n        if fixture_format == EOFFixture:\n            if Bytes(self.container) in existing_tests:\n                # Gracefully skip duplicate tests because one EOFStateTest can generate multiple\n                # state fixtures with the same data.\n                pytest.skip(f\"Duplicate EOF container on EOFStateTest: {request.node.nodeid}\")\n            return self.make_eof_test_fixture(request=request, fork=fork, eips=eips)\n        elif fixture_format in StateTest.supported_fixture_formats:\n            return self.generate_state_test(fork).generate(\n                request=request, t8n=t8n, fork=fork, fixture_format=fixture_format, eips=eips\n            )\n\n        raise Exception(f\"Unknown fixture format: {fixture_format}\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFStateTest.gas_limit","title":"<code>gas_limit: HexNumber = Field(HexNumber(10000000), serialization_alias='gas')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Gas limit for the transaction that deploys the container.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFStateTest.tx_sender_funding_amount","title":"<code>tx_sender_funding_amount: int = 1000000000000000000000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Amount of funds to send to the sender EOA before the transaction.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFStateTest.env","title":"<code>env: Environment = Field(default_factory=Environment)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Environment object that is used during State Test generation.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFStateTest.container_post","title":"<code>container_post: Account = Field(default_factory=Account)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Account object used to verify the container post state.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFStateTest.pytest_parameter_name","title":"<code>pytest_parameter_name()</code>  <code>classmethod</code>","text":"<p>Workaround for pytest parameter name.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>@classmethod\ndef pytest_parameter_name(cls) -&gt; str:\n    \"\"\"Workaround for pytest parameter name.\"\"\"\n    return \"eof_state_test\"\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFStateTest.model_post_init","title":"<code>model_post_init(__context)</code>","text":"<p>Prepare the transaction parameters required to fill the test.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>def model_post_init(self, __context):\n    \"\"\"Prepare the transaction parameters required to fill the test.\"\"\"\n    assert self.pre is not None, \"pre must be set to generate a StateTest.\"\n\n    EOFTest.model_post_init(self, __context)\n\n    self.sender = self.pre.fund_eoa(amount=self.tx_sender_funding_amount)\n    if self.post is None:\n        self.post = Alloc()\n\n    if self.expect_exception is not None:  # Invalid EOF\n        self.to = None  # Make EIP-7698 create transaction\n        self.data = Bytes(\n            bytes(self.container) + self.data\n        )  # by concatenating container and tx data.\n\n        # Run transaction model validation\n        Transaction.model_post_init(self, __context)\n\n        self.post[self.created_contract] = None  # Expect failure.\n    elif self.container_kind == ContainerKind.INITCODE:\n        self.to = None  # Make EIP-7698 create transaction\n        self.data = Bytes(\n            bytes(self.container) + self.data\n        )  # by concatenating container and tx data.\n\n        # Run transaction model validation\n        Transaction.model_post_init(self, __context)\n\n        self.post[self.created_contract] = self.container_post  # Successful.\n    else:\n        self.to = self.pre.deploy_contract(code=self.container)\n\n        # Run transaction model validation\n        Transaction.model_post_init(self, __context)\n\n        self.post[self.to] = self.container_post\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFStateTest.generate_state_test","title":"<code>generate_state_test(fork)</code>","text":"<p>Generate the StateTest filler.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>def generate_state_test(self, fork: Fork) -&gt; StateTest:\n    \"\"\"Generate the StateTest filler.\"\"\"\n    assert self.pre is not None, \"pre must be set to generate a StateTest.\"\n    assert self.post is not None, \"post must be set to generate a StateTest.\"\n\n    return StateTest(\n        pre=self.pre,\n        tx=self,\n        env=self.env,\n        post=self.post,\n        t8n_dump_dir=self.t8n_dump_dir,\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFStateTest.generate","title":"<code>generate(*, request, t8n, fork, eips=None, fixture_format, **_)</code>","text":"<p>Generate the BlockchainTest fixture.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>def generate(\n    self,\n    *,\n    request: pytest.FixtureRequest,\n    t8n: TransitionTool,\n    fork: Fork,\n    eips: Optional[List[int]] = None,\n    fixture_format: FixtureFormat,\n    **_,\n) -&gt; BaseFixture:\n    \"\"\"Generate the BlockchainTest fixture.\"\"\"\n    if fixture_format == EOFFixture:\n        if Bytes(self.container) in existing_tests:\n            # Gracefully skip duplicate tests because one EOFStateTest can generate multiple\n            # state fixtures with the same data.\n            pytest.skip(f\"Duplicate EOF container on EOFStateTest: {request.node.nodeid}\")\n        return self.make_eof_test_fixture(request=request, fork=fork, eips=eips)\n    elif fixture_format in StateTest.supported_fixture_formats:\n        return self.generate_state_test(fork).generate(\n            request=request, t8n=t8n, fork=fork, fixture_format=fixture_format, eips=eips\n        )\n\n    raise Exception(f\"Unknown fixture format: {fixture_format}\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFTest","title":"<code>EOFTest</code>","text":"<p>               Bases: <code>BaseTest</code></p> <p>Filler type that generates a test for EOF container validation.</p> <p>A state test is also automatically generated where the container is wrapped in a contract-creating transaction to test deployment/validation on the instantiated blockchain.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>class EOFTest(BaseTest):\n    \"\"\"\n    Filler type that generates a test for EOF container validation.\n\n    A state test is also automatically generated where the container is wrapped in a\n    contract-creating transaction to test deployment/validation on the instantiated blockchain.\n    \"\"\"\n\n    container: Container\n    \"\"\"\n    EOF container that will be tested for validity.\n\n    The only supported type at the moment is `ethereum_test_types.eof.v1.Container`.\n\n    If an invalid container needs to be tested, and it cannot be generated using the\n    Container class features, the `raw_bytes` field can be used to provide the raw\n    container bytes.\n    \"\"\"\n    expect_exception: EOFExceptionInstanceOrList | None = None\n    \"\"\"\n    Expected exception that the container should raise when parsed by an EOF parser.\n\n    Can be a single exception or a list of exceptions that the container is expected to raise,\n    in which case the test will pass if any of the exceptions are raised.\n\n    The list of supported exceptions can be found in the `ethereum_test_exceptions.EOFException`\n    class.\n    \"\"\"\n    container_kind: ContainerKind = ContainerKind.RUNTIME\n    \"\"\"\n    Container kind type that the container should be treated as.\n\n    The container kind can be one of the following:\n    - `ContainerKind.INITCODE`: The container is an initcode container.\n    - `ContainerKind.RUNTIME`: The container is a runtime container.\n\n    The default value is `ContainerKind.RUNTIME`.\n    \"\"\"\n    deployed_container: Container | None = None\n    \"\"\"\n    To be used when the container is an initcode container and the expected deployed container is\n    known.\n\n    The value is only used when a State Test is generated from this EOF test to set the expected\n    deployed container that should be found in the post state.\n\n    If this field is not set, and the container is valid:\n      - If the container kind is `ContainerKind.RUNTIME`, the deployed container is assumed to be\n        the container itself, and an initcode container that wraps the container is generated\n        automatically.\n      - If the container kind is `ContainerKind.INITCODE`, `model_post_init` will attempt to infer\n        the deployed container from the sections of the init-container, and the first\n        container-type section will be used. An error will be raised if the deployed container\n        cannot be inferred.\n\n    If the value is set to `None`, it is assumed that the container is invalid and the test will\n    expect that no contract is created.\n\n    It is considered an error if:\n      - The `deployed_container` field is set and the `container_kind` field is not set to\n        `ContainerKind.INITCODE`.\n      - The `deployed_container` field is set and the `expect_exception` is not `None`.\n\n    The deployed container is **not** executed at any point during the EOF validation test nor\n    the generated State Test. For container runtime testing use the `EOFStateTest` class.\n    \"\"\"\n    pre: Alloc | None = None\n    \"\"\"\n    Pre alloc object that is used during State Test generation.\n\n    This field is automatically set by the test filler when generating a State Test from this EOF\n    test and should otherwise be left unset.\n    \"\"\"\n    post: Alloc | None = None\n    \"\"\"\n    Post alloc object that is used during State Test generation.\n\n    This field is automatically set by the test filler when generating a State Test from this EOF\n    test and is normally not set by the user.\n    \"\"\"\n    sender: EOA | None = None\n    \"\"\"\n    Sender EOA object that is used during State Test generation.\n\n    This field is automatically set by the `model_post_init` method and should otherwise be left\n    unset.\n    \"\"\"\n\n    supported_fixture_formats: ClassVar[Sequence[FixtureFormat | LabeledFixtureFormat]] = [\n        EOFFixture\n    ] + [\n        LabeledFixtureFormat(\n            fixture_format,\n            f\"{fixture_format.format_name}_from_eof_test\",\n            f\"A {fixture_format.format_name} generated from an eof_test.\",\n        )\n        for fixture_format in StateTest.supported_fixture_formats\n    ]\n\n    supported_execute_formats: ClassVar[Sequence[ExecuteFormat | LabeledExecuteFormat]] = [\n        LabeledExecuteFormat(\n            execute_format,\n            f\"{execute_format.format_name}_from_eof_test\",\n            f\"A {execute_format.format_name} generated from an eof_test.\",\n        )\n        for execute_format in StateTest.supported_execute_formats\n    ]\n\n    supported_markers: ClassVar[Dict[str, str]] = {\n        \"eof_test_only\": \"Only generate an EOF test fixture\",\n    }\n\n    @classmethod\n    def discard_fixture_format_by_marks(\n        cls,\n        fixture_format: FixtureFormat,\n        fork: Fork,\n        markers: List[pytest.Mark],\n    ) -&gt; bool:\n        \"\"\"Discard a fixture format from filling if the appropriate marker is used.\"\"\"\n        if \"eof_test_only\" in [m.name for m in markers]:\n            return fixture_format != EOFFixture\n        return False\n\n    @classmethod\n    def pytest_parameter_name(cls) -&gt; str:\n        \"\"\"Workaround for pytest parameter name.\"\"\"\n        return \"eof_test\"\n\n    def model_post_init(self, __context):\n        \"\"\"Prepare the test exception based on the container.\"\"\"\n        if self.container.validity_error is not None:\n            if self.expect_exception is not None:\n                assert self.expect_exception == self.container.validity_error, (\n                    f\"Container validity error {self.container.validity_error} \"\n                    f\"does not match expected exception {self.expect_exception}.\"\n                )\n            self.expect_exception = self.container.validity_error\n            assert self.deployed_container is None, (\n                \"deployed_container must be None for invalid containers.\"\n            )\n        if \"kind\" in self.container.model_fields_set or \"container_kind\" in self.model_fields_set:\n            if (\n                \"kind\" in self.container.model_fields_set\n                and \"container_kind\" in self.model_fields_set\n            ):\n                assert self.container.kind == self.container_kind, (\n                    f\"Container kind type {str(self.container.kind)} \"\n                    f\"does not match test {self.container_kind}.\"\n                )\n            elif \"kind\" in self.container.model_fields_set:\n                self.container_kind = self.container.kind\n            elif \"container_kind\" in self.model_fields_set:\n                self.container.kind = self.container_kind\n\n        assert self.pre is not None, \"pre must be set to generate a StateTest.\"\n        self.sender = self.pre.fund_eoa()\n        if self.post is None:\n            self.post = Alloc()\n\n    def make_eof_test_fixture(\n        self,\n        *,\n        request: pytest.FixtureRequest,\n        fork: Fork,\n        eips: Optional[List[int]],\n    ) -&gt; EOFFixture:\n        \"\"\"Generate the EOF test fixture.\"\"\"\n        container_bytes = Bytes(self.container)\n        if container_bytes in existing_tests:\n            pytest.fail(\n                f\"Duplicate EOF test: {container_bytes}, \"\n                f\"existing test: {existing_tests[container_bytes]}\"\n            )\n        existing_tests[container_bytes] = request.node.nodeid\n        vectors = [\n            Vector(\n                code=container_bytes,\n                container_kind=self.container_kind,\n                results={\n                    fork.blockchain_test_network_name(): Result(\n                        exception=self.expect_exception,\n                        valid=self.expect_exception is None,\n                    ),\n                },\n            )\n        ]\n        fixture = EOFFixture(vectors=dict(enumerate(vectors)))\n        try:\n            eof_parse = EOFParse()\n        except FileNotFoundError as e:\n            warnings.warn(\n                f\"{e} Skipping EOF fixture verification. Fixtures may be invalid!\", stacklevel=2\n            )\n            return fixture\n\n        for _, vector in fixture.vectors.items():\n            expected_result = vector.results.get(fork.blockchain_test_network_name())\n            if expected_result is None:\n                raise Exception(f\"EOF Fixture missing vector result for fork: {fork}\")\n            args = []\n            if vector.container_kind == ContainerKind.INITCODE:\n                args.append(\"--initcode\")\n            result = eof_parse.run(*args, input_value=str(vector.code))\n            self.verify_result(result, expected_result, vector.code)\n\n        return fixture\n\n    def verify_result(self, result: CompletedProcess, expected_result: Result, code: Bytes):\n        \"\"\"Check that the reported exception string matches the expected error.\"\"\"\n        parser = EvmoneExceptionMapper()\n        actual_message = result.stdout.strip()\n        actual_exception = parser.message_to_exception(actual_message)\n\n        if expected_result.exception is None:\n            if \"OK\" in actual_message:\n                return\n            else:\n                raise UnexpectedEOFExceptionError(\n                    code=code, got=f\"{actual_exception} ({actual_message})\"\n                )\n        else:\n            expected_string = to_pipe_str(expected_result.exception)\n            print(expected_string)\n            print(actual_exception)\n            if \"OK\" in actual_message:\n                raise ExpectedEOFExceptionError(\n                    code=code,\n                    expected=f\"{expected_string}\",\n                )\n            elif actual_exception in expected_result.exception:\n                return\n            else:\n                raise EOFExceptionMismatchError(\n                    code=code,\n                    expected=f\"{expected_string}\",\n                    got=f\"{actual_exception} ({actual_message})\",\n                )\n\n    def generate_eof_contract_create_transaction(self) -&gt; Transaction:\n        \"\"\"Generate a transaction that creates a contract.\"\"\"\n        assert self.sender is not None, \"sender must be set to generate a StateTest.\"\n        assert self.post is not None, \"post must be set to generate a StateTest.\"\n\n        initcode: Container\n        deployed_container: Container | Bytes | None = None\n        if self.container_kind == ContainerKind.INITCODE:\n            initcode = self.container\n            if \"deployed_container\" in self.model_fields_set:\n                # In the case of an initcontainer where we know the deployed container,\n                # we can use the initcontainer as-is.\n                deployed_container = self.deployed_container\n            elif self.expect_exception is None:\n                # We have a valid init-container, but we don't know the deployed container.\n                # Try to infer the deployed container from the sections of the init-container.\n                assert self.container.raw_bytes is None, (\n                    \"deployed_container must be set for initcode containers with raw_bytes.\"\n                )\n                for section in self.container.sections:\n                    if section.kind == SectionKind.CONTAINER:\n                        deployed_container = section.data\n                        break\n\n                assert deployed_container is not None, (\n                    \"Unable to infer deployed container for init-container. \"\n                    \"Use field `deployed_container` to set the expected deployed container.\"\n                )\n        else:\n            assert self.deployed_container is None, (\n                \"deployed_container must be None for runtime containers.\"\n            )\n            initcode = Container(\n                sections=[\n                    Section.Code(Op.RETURNCODE[0](0, 0)),\n                    Section.Container(self.container),\n                ]\n            )\n            deployed_container = self.container\n\n        tx = Transaction(\n            sender=self.sender,\n            to=None,\n            gas_limit=10_000_000,\n            data=initcode,\n        )\n\n        if self.expect_exception is not None or deployed_container is None:\n            self.post[tx.created_contract] = None\n        else:\n            self.post[tx.created_contract] = Account(\n                code=deployed_container,\n            )\n        return tx\n\n    def generate_state_test(self, fork: Fork) -&gt; StateTest:\n        \"\"\"Generate the StateTest filler.\"\"\"\n        return StateTest(\n            pre=self.pre,\n            tx=self.generate_eof_contract_create_transaction(),\n            env=Environment(),\n            post=self.post,\n            t8n_dump_dir=self.t8n_dump_dir,\n        )\n\n    def generate(\n        self,\n        *,\n        request: pytest.FixtureRequest,\n        t8n: TransitionTool,\n        fork: Fork,\n        eips: Optional[List[int]] = None,\n        fixture_format: FixtureFormat,\n        **_,\n    ) -&gt; BaseFixture:\n        \"\"\"Generate the BlockchainTest fixture.\"\"\"\n        if fixture_format == EOFFixture:\n            return self.make_eof_test_fixture(request=request, fork=fork, eips=eips)\n        elif fixture_format in StateTest.supported_fixture_formats:\n            return self.generate_state_test(fork).generate(\n                request=request, t8n=t8n, fork=fork, fixture_format=fixture_format, eips=eips\n            )\n        raise Exception(f\"Unknown fixture format: {fixture_format}\")\n\n    def execute(\n        self,\n        *,\n        fork: Fork,\n        execute_format: ExecuteFormat,\n        eips: Optional[List[int]] = None,\n    ) -&gt; BaseExecute:\n        \"\"\"Generate the list of test fixtures.\"\"\"\n        if execute_format == TransactionPost:\n            return self.generate_state_test(fork).execute(\n                fork=fork, execute_format=execute_format, eips=eips\n            )\n        raise Exception(f\"Unsupported execute format: {execute_format}\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFTest.container","title":"<code>container: Container</code>  <code>instance-attribute</code>","text":"<p>EOF container that will be tested for validity.</p> <p>The only supported type at the moment is <code>ethereum_test_types.eof.v1.Container</code>.</p> <p>If an invalid container needs to be tested, and it cannot be generated using the Container class features, the <code>raw_bytes</code> field can be used to provide the raw container bytes.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFTest.expect_exception","title":"<code>expect_exception: EOFExceptionInstanceOrList | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Expected exception that the container should raise when parsed by an EOF parser.</p> <p>Can be a single exception or a list of exceptions that the container is expected to raise, in which case the test will pass if any of the exceptions are raised.</p> <p>The list of supported exceptions can be found in the <code>ethereum_test_exceptions.EOFException</code> class.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFTest.container_kind","title":"<code>container_kind: ContainerKind = ContainerKind.RUNTIME</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Container kind type that the container should be treated as.</p> <p>The container kind can be one of the following: - <code>ContainerKind.INITCODE</code>: The container is an initcode container. - <code>ContainerKind.RUNTIME</code>: The container is a runtime container.</p> <p>The default value is <code>ContainerKind.RUNTIME</code>.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFTest.deployed_container","title":"<code>deployed_container: Container | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>To be used when the container is an initcode container and the expected deployed container is known.</p> <p>The value is only used when a State Test is generated from this EOF test to set the expected deployed container that should be found in the post state.</p> <p>If this field is not set, and the container is valid:   - If the container kind is <code>ContainerKind.RUNTIME</code>, the deployed container is assumed to be     the container itself, and an initcode container that wraps the container is generated     automatically.   - If the container kind is <code>ContainerKind.INITCODE</code>, <code>model_post_init</code> will attempt to infer     the deployed container from the sections of the init-container, and the first     container-type section will be used. An error will be raised if the deployed container     cannot be inferred.</p> <p>If the value is set to <code>None</code>, it is assumed that the container is invalid and the test will expect that no contract is created.</p> It is considered an error if <ul> <li>The <code>deployed_container</code> field is set and the <code>container_kind</code> field is not set to   <code>ContainerKind.INITCODE</code>.</li> <li>The <code>deployed_container</code> field is set and the <code>expect_exception</code> is not <code>None</code>.</li> </ul> <p>The deployed container is not executed at any point during the EOF validation test nor the generated State Test. For container runtime testing use the <code>EOFStateTest</code> class.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFTest.pre","title":"<code>pre: Alloc | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Pre alloc object that is used during State Test generation.</p> <p>This field is automatically set by the test filler when generating a State Test from this EOF test and should otherwise be left unset.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFTest.post","title":"<code>post: Alloc | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Post alloc object that is used during State Test generation.</p> <p>This field is automatically set by the test filler when generating a State Test from this EOF test and is normally not set by the user.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFTest.sender","title":"<code>sender: EOA | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Sender EOA object that is used during State Test generation.</p> <p>This field is automatically set by the <code>model_post_init</code> method and should otherwise be left unset.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFTest.discard_fixture_format_by_marks","title":"<code>discard_fixture_format_by_marks(fixture_format, fork, markers)</code>  <code>classmethod</code>","text":"<p>Discard a fixture format from filling if the appropriate marker is used.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>@classmethod\ndef discard_fixture_format_by_marks(\n    cls,\n    fixture_format: FixtureFormat,\n    fork: Fork,\n    markers: List[pytest.Mark],\n) -&gt; bool:\n    \"\"\"Discard a fixture format from filling if the appropriate marker is used.\"\"\"\n    if \"eof_test_only\" in [m.name for m in markers]:\n        return fixture_format != EOFFixture\n    return False\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFTest.pytest_parameter_name","title":"<code>pytest_parameter_name()</code>  <code>classmethod</code>","text":"<p>Workaround for pytest parameter name.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>@classmethod\ndef pytest_parameter_name(cls) -&gt; str:\n    \"\"\"Workaround for pytest parameter name.\"\"\"\n    return \"eof_test\"\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFTest.model_post_init","title":"<code>model_post_init(__context)</code>","text":"<p>Prepare the test exception based on the container.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>def model_post_init(self, __context):\n    \"\"\"Prepare the test exception based on the container.\"\"\"\n    if self.container.validity_error is not None:\n        if self.expect_exception is not None:\n            assert self.expect_exception == self.container.validity_error, (\n                f\"Container validity error {self.container.validity_error} \"\n                f\"does not match expected exception {self.expect_exception}.\"\n            )\n        self.expect_exception = self.container.validity_error\n        assert self.deployed_container is None, (\n            \"deployed_container must be None for invalid containers.\"\n        )\n    if \"kind\" in self.container.model_fields_set or \"container_kind\" in self.model_fields_set:\n        if (\n            \"kind\" in self.container.model_fields_set\n            and \"container_kind\" in self.model_fields_set\n        ):\n            assert self.container.kind == self.container_kind, (\n                f\"Container kind type {str(self.container.kind)} \"\n                f\"does not match test {self.container_kind}.\"\n            )\n        elif \"kind\" in self.container.model_fields_set:\n            self.container_kind = self.container.kind\n        elif \"container_kind\" in self.model_fields_set:\n            self.container.kind = self.container_kind\n\n    assert self.pre is not None, \"pre must be set to generate a StateTest.\"\n    self.sender = self.pre.fund_eoa()\n    if self.post is None:\n        self.post = Alloc()\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFTest.make_eof_test_fixture","title":"<code>make_eof_test_fixture(*, request, fork, eips)</code>","text":"<p>Generate the EOF test fixture.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>def make_eof_test_fixture(\n    self,\n    *,\n    request: pytest.FixtureRequest,\n    fork: Fork,\n    eips: Optional[List[int]],\n) -&gt; EOFFixture:\n    \"\"\"Generate the EOF test fixture.\"\"\"\n    container_bytes = Bytes(self.container)\n    if container_bytes in existing_tests:\n        pytest.fail(\n            f\"Duplicate EOF test: {container_bytes}, \"\n            f\"existing test: {existing_tests[container_bytes]}\"\n        )\n    existing_tests[container_bytes] = request.node.nodeid\n    vectors = [\n        Vector(\n            code=container_bytes,\n            container_kind=self.container_kind,\n            results={\n                fork.blockchain_test_network_name(): Result(\n                    exception=self.expect_exception,\n                    valid=self.expect_exception is None,\n                ),\n            },\n        )\n    ]\n    fixture = EOFFixture(vectors=dict(enumerate(vectors)))\n    try:\n        eof_parse = EOFParse()\n    except FileNotFoundError as e:\n        warnings.warn(\n            f\"{e} Skipping EOF fixture verification. Fixtures may be invalid!\", stacklevel=2\n        )\n        return fixture\n\n    for _, vector in fixture.vectors.items():\n        expected_result = vector.results.get(fork.blockchain_test_network_name())\n        if expected_result is None:\n            raise Exception(f\"EOF Fixture missing vector result for fork: {fork}\")\n        args = []\n        if vector.container_kind == ContainerKind.INITCODE:\n            args.append(\"--initcode\")\n        result = eof_parse.run(*args, input_value=str(vector.code))\n        self.verify_result(result, expected_result, vector.code)\n\n    return fixture\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFTest.verify_result","title":"<code>verify_result(result, expected_result, code)</code>","text":"<p>Check that the reported exception string matches the expected error.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>def verify_result(self, result: CompletedProcess, expected_result: Result, code: Bytes):\n    \"\"\"Check that the reported exception string matches the expected error.\"\"\"\n    parser = EvmoneExceptionMapper()\n    actual_message = result.stdout.strip()\n    actual_exception = parser.message_to_exception(actual_message)\n\n    if expected_result.exception is None:\n        if \"OK\" in actual_message:\n            return\n        else:\n            raise UnexpectedEOFExceptionError(\n                code=code, got=f\"{actual_exception} ({actual_message})\"\n            )\n    else:\n        expected_string = to_pipe_str(expected_result.exception)\n        print(expected_string)\n        print(actual_exception)\n        if \"OK\" in actual_message:\n            raise ExpectedEOFExceptionError(\n                code=code,\n                expected=f\"{expected_string}\",\n            )\n        elif actual_exception in expected_result.exception:\n            return\n        else:\n            raise EOFExceptionMismatchError(\n                code=code,\n                expected=f\"{expected_string}\",\n                got=f\"{actual_exception} ({actual_message})\",\n            )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFTest.generate_eof_contract_create_transaction","title":"<code>generate_eof_contract_create_transaction()</code>","text":"<p>Generate a transaction that creates a contract.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>def generate_eof_contract_create_transaction(self) -&gt; Transaction:\n    \"\"\"Generate a transaction that creates a contract.\"\"\"\n    assert self.sender is not None, \"sender must be set to generate a StateTest.\"\n    assert self.post is not None, \"post must be set to generate a StateTest.\"\n\n    initcode: Container\n    deployed_container: Container | Bytes | None = None\n    if self.container_kind == ContainerKind.INITCODE:\n        initcode = self.container\n        if \"deployed_container\" in self.model_fields_set:\n            # In the case of an initcontainer where we know the deployed container,\n            # we can use the initcontainer as-is.\n            deployed_container = self.deployed_container\n        elif self.expect_exception is None:\n            # We have a valid init-container, but we don't know the deployed container.\n            # Try to infer the deployed container from the sections of the init-container.\n            assert self.container.raw_bytes is None, (\n                \"deployed_container must be set for initcode containers with raw_bytes.\"\n            )\n            for section in self.container.sections:\n                if section.kind == SectionKind.CONTAINER:\n                    deployed_container = section.data\n                    break\n\n            assert deployed_container is not None, (\n                \"Unable to infer deployed container for init-container. \"\n                \"Use field `deployed_container` to set the expected deployed container.\"\n            )\n    else:\n        assert self.deployed_container is None, (\n            \"deployed_container must be None for runtime containers.\"\n        )\n        initcode = Container(\n            sections=[\n                Section.Code(Op.RETURNCODE[0](0, 0)),\n                Section.Container(self.container),\n            ]\n        )\n        deployed_container = self.container\n\n    tx = Transaction(\n        sender=self.sender,\n        to=None,\n        gas_limit=10_000_000,\n        data=initcode,\n    )\n\n    if self.expect_exception is not None or deployed_container is None:\n        self.post[tx.created_contract] = None\n    else:\n        self.post[tx.created_contract] = Account(\n            code=deployed_container,\n        )\n    return tx\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFTest.generate_state_test","title":"<code>generate_state_test(fork)</code>","text":"<p>Generate the StateTest filler.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>def generate_state_test(self, fork: Fork) -&gt; StateTest:\n    \"\"\"Generate the StateTest filler.\"\"\"\n    return StateTest(\n        pre=self.pre,\n        tx=self.generate_eof_contract_create_transaction(),\n        env=Environment(),\n        post=self.post,\n        t8n_dump_dir=self.t8n_dump_dir,\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFTest.generate","title":"<code>generate(*, request, t8n, fork, eips=None, fixture_format, **_)</code>","text":"<p>Generate the BlockchainTest fixture.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>def generate(\n    self,\n    *,\n    request: pytest.FixtureRequest,\n    t8n: TransitionTool,\n    fork: Fork,\n    eips: Optional[List[int]] = None,\n    fixture_format: FixtureFormat,\n    **_,\n) -&gt; BaseFixture:\n    \"\"\"Generate the BlockchainTest fixture.\"\"\"\n    if fixture_format == EOFFixture:\n        return self.make_eof_test_fixture(request=request, fork=fork, eips=eips)\n    elif fixture_format in StateTest.supported_fixture_formats:\n        return self.generate_state_test(fork).generate(\n            request=request, t8n=t8n, fork=fork, fixture_format=fixture_format, eips=eips\n        )\n    raise Exception(f\"Unknown fixture format: {fixture_format}\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.EOFTest.execute","title":"<code>execute(*, fork, execute_format, eips=None)</code>","text":"<p>Generate the list of test fixtures.</p> Source code in <code>src/ethereum_test_specs/eof.py</code> <pre><code>def execute(\n    self,\n    *,\n    fork: Fork,\n    execute_format: ExecuteFormat,\n    eips: Optional[List[int]] = None,\n) -&gt; BaseExecute:\n    \"\"\"Generate the list of test fixtures.\"\"\"\n    if execute_format == TransactionPost:\n        return self.generate_state_test(fork).execute(\n            fork=fork, execute_format=execute_format, eips=eips\n        )\n    raise Exception(f\"Unsupported execute format: {execute_format}\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.StateTest","title":"<code>StateTest</code>","text":"<p>               Bases: <code>BaseTest</code></p> <p>Filler type that tests transactions over the period of a single block.</p> Source code in <code>src/ethereum_test_specs/state.py</code> <pre><code>class StateTest(BaseTest):\n    \"\"\"Filler type that tests transactions over the period of a single block.\"\"\"\n\n    env: Environment = Field(default_factory=Environment)\n    pre: Alloc\n    post: Alloc\n    tx: Transaction\n    engine_api_error_code: Optional[EngineAPIError] = None\n    blockchain_test_header_verify: Optional[Header] = None\n    blockchain_test_rlp_modifier: Optional[Header] = None\n    chain_id: int = 1\n\n    supported_fixture_formats: ClassVar[Sequence[FixtureFormat | LabeledFixtureFormat]] = [\n        StateFixture,\n    ] + [\n        LabeledFixtureFormat(\n            fixture_format,\n            f\"{fixture_format.format_name}_from_state_test\",\n            f\"A {fixture_format.format_name} generated from a state_test\",\n        )\n        for fixture_format in BlockchainTest.supported_fixture_formats\n    ]\n    supported_execute_formats: ClassVar[Sequence[ExecuteFormat | LabeledExecuteFormat]] = [\n        TransactionPost,\n    ]\n\n    supported_markers: ClassVar[Dict[str, str]] = {\n        \"state_test_only\": \"Only generate a state test fixture\",\n    }\n\n    @classmethod\n    def discard_fixture_format_by_marks(\n        cls,\n        fixture_format: FixtureFormat,\n        fork: Fork,\n        markers: List[pytest.Mark],\n    ) -&gt; bool:\n        \"\"\"Discard a fixture format from filling if the appropriate marker is used.\"\"\"\n        if \"state_test_only\" in [m.name for m in markers]:\n            return fixture_format != StateFixture\n        return False\n\n    def _generate_blockchain_genesis_environment(self, *, fork: Fork) -&gt; Environment:\n        \"\"\"Generate the genesis environment for the BlockchainTest formatted test.\"\"\"\n        assert self.env.number &gt;= 1, (\n            \"genesis block number cannot be negative, set state test env.number to 1\"\n        )\n\n        # Modify values to the proper values for the genesis block\n        # TODO: All of this can be moved to a new method in `Fork`\n        updated_values: Dict[str, Any] = {\n            \"withdrawals\": None,\n            \"parent_beacon_block_root\": None,\n            \"number\": self.env.number - 1,\n        }\n        if self.env.excess_blob_gas:\n            # The excess blob gas environment value means the value of the context (block header)\n            # where the transaction is executed. In a blockchain test, we need to indirectly\n            # set the excess blob gas by setting the excess blob gas of the genesis block\n            # to the expected value plus the TARGET_BLOB_GAS_PER_BLOCK, which is the value\n            # that will be subtracted from the excess blob gas when the first block is mined.\n            updated_values[\"excess_blob_gas\"] = self.env.excess_blob_gas + (\n                fork.target_blobs_per_block() * fork.blob_gas_per_blob()\n            )\n\n        return self.env.copy(**updated_values)\n\n    def _generate_blockchain_blocks(self) -&gt; List[Block]:\n        \"\"\"Generate the single block that represents this state test in a BlockchainTest format.\"\"\"\n        return [\n            Block(\n                number=self.env.number,\n                timestamp=self.env.timestamp,\n                fee_recipient=self.env.fee_recipient,\n                difficulty=self.env.difficulty,\n                gas_limit=self.env.gas_limit,\n                extra_data=self.env.extra_data,\n                withdrawals=self.env.withdrawals,\n                parent_beacon_block_root=self.env.parent_beacon_block_root,\n                txs=[self.tx],\n                ommers=[],\n                exception=self.tx.error,\n                header_verify=self.blockchain_test_header_verify,\n                rlp_modifier=self.blockchain_test_rlp_modifier,\n            )\n        ]\n\n    def generate_blockchain_test(self, *, fork: Fork) -&gt; BlockchainTest:\n        \"\"\"Generate a BlockchainTest fixture from this StateTest fixture.\"\"\"\n        return BlockchainTest(\n            genesis_environment=self._generate_blockchain_genesis_environment(fork=fork),\n            pre=self.pre,\n            post=self.post,\n            blocks=self._generate_blockchain_blocks(),\n            t8n_dump_dir=self.t8n_dump_dir,\n        )\n\n    def make_state_test_fixture(\n        self,\n        t8n: TransitionTool,\n        fork: Fork,\n        eips: Optional[List[int]] = None,\n        slow: bool = False,\n    ) -&gt; StateFixture:\n        \"\"\"Create a fixture from the state test definition.\"\"\"\n        # We can't generate a state test fixture that names a transition fork,\n        # so we get the fork at the block number and timestamp of the state test\n        fork = fork.fork_at(self.env.number, self.env.timestamp)\n\n        env = self.env.set_fork_requirements(fork)\n        tx = self.tx.with_signature_and_sender(keep_secret_key=True)\n        pre_alloc = Alloc.merge(\n            Alloc.model_validate(fork.pre_allocation()),\n            self.pre,\n        )\n        if empty_accounts := pre_alloc.empty_accounts():\n            raise Exception(f\"Empty accounts in pre state: {empty_accounts}\")\n\n        transition_tool_output = t8n.evaluate(\n            alloc=pre_alloc,\n            txs=[tx],\n            env=env,\n            fork=fork,\n            chain_id=self.chain_id,\n            reward=0,  # Reward on state tests is always zero\n            blob_schedule=fork.blob_schedule(),\n            eips=eips,\n            debug_output_path=self.get_next_transition_tool_output_path(),\n            state_test=True,\n            slow_request=slow,\n        )\n\n        try:\n            self.post.verify_post_alloc(transition_tool_output.alloc)\n        except Exception as e:\n            print_traces(t8n.get_traces())\n            raise e\n\n        try:\n            verify_transactions(\n                txs=[tx],\n                exception_mapper=t8n.exception_mapper,\n                result=transition_tool_output.result,\n            )\n        except Exception as e:\n            print_traces(t8n.get_traces())\n            pprint(transition_tool_output.result)\n            pprint(transition_tool_output.alloc)\n            raise e\n\n        return StateFixture(\n            env=FixtureEnvironment(**env.model_dump(exclude_none=True)),\n            pre=pre_alloc,\n            post={\n                fork.blockchain_test_network_name(): [\n                    FixtureForkPost(\n                        state_root=transition_tool_output.result.state_root,\n                        logs_hash=transition_tool_output.result.logs_hash,\n                        tx_bytes=tx.rlp,\n                        expect_exception=tx.error,\n                        state=transition_tool_output.alloc,\n                    )\n                ]\n            },\n            transaction=FixtureTransaction.from_transaction(tx),\n            config=FixtureConfig(\n                blob_schedule=FixtureBlobSchedule.from_blob_schedule(fork.blob_schedule()),\n                chain_id=self.chain_id,\n            ),\n        )\n\n    def generate(\n        self,\n        request: pytest.FixtureRequest,\n        t8n: TransitionTool,\n        fork: Fork,\n        fixture_format: FixtureFormat,\n        eips: Optional[List[int]] = None,\n    ) -&gt; BaseFixture:\n        \"\"\"Generate the BlockchainTest fixture.\"\"\"\n        if fixture_format in BlockchainTest.supported_fixture_formats:\n            return self.generate_blockchain_test(fork=fork).generate(\n                request=request, t8n=t8n, fork=fork, fixture_format=fixture_format, eips=eips\n            )\n        elif fixture_format == StateFixture:\n            return self.make_state_test_fixture(t8n, fork, eips, slow=is_slow_test(request))\n\n        raise Exception(f\"Unknown fixture format: {fixture_format}\")\n\n    def execute(\n        self,\n        *,\n        fork: Fork,\n        execute_format: ExecuteFormat,\n        eips: Optional[List[int]] = None,\n    ) -&gt; BaseExecute:\n        \"\"\"Generate the list of test fixtures.\"\"\"\n        if execute_format == TransactionPost:\n            return TransactionPost(\n                transactions=[self.tx],\n                post=self.post,\n            )\n        raise Exception(f\"Unsupported execute format: {execute_format}\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.StateTest.discard_fixture_format_by_marks","title":"<code>discard_fixture_format_by_marks(fixture_format, fork, markers)</code>  <code>classmethod</code>","text":"<p>Discard a fixture format from filling if the appropriate marker is used.</p> Source code in <code>src/ethereum_test_specs/state.py</code> <pre><code>@classmethod\ndef discard_fixture_format_by_marks(\n    cls,\n    fixture_format: FixtureFormat,\n    fork: Fork,\n    markers: List[pytest.Mark],\n) -&gt; bool:\n    \"\"\"Discard a fixture format from filling if the appropriate marker is used.\"\"\"\n    if \"state_test_only\" in [m.name for m in markers]:\n        return fixture_format != StateFixture\n    return False\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.StateTest.generate_blockchain_test","title":"<code>generate_blockchain_test(*, fork)</code>","text":"<p>Generate a BlockchainTest fixture from this StateTest fixture.</p> Source code in <code>src/ethereum_test_specs/state.py</code> <pre><code>def generate_blockchain_test(self, *, fork: Fork) -&gt; BlockchainTest:\n    \"\"\"Generate a BlockchainTest fixture from this StateTest fixture.\"\"\"\n    return BlockchainTest(\n        genesis_environment=self._generate_blockchain_genesis_environment(fork=fork),\n        pre=self.pre,\n        post=self.post,\n        blocks=self._generate_blockchain_blocks(),\n        t8n_dump_dir=self.t8n_dump_dir,\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.StateTest.make_state_test_fixture","title":"<code>make_state_test_fixture(t8n, fork, eips=None, slow=False)</code>","text":"<p>Create a fixture from the state test definition.</p> Source code in <code>src/ethereum_test_specs/state.py</code> <pre><code>def make_state_test_fixture(\n    self,\n    t8n: TransitionTool,\n    fork: Fork,\n    eips: Optional[List[int]] = None,\n    slow: bool = False,\n) -&gt; StateFixture:\n    \"\"\"Create a fixture from the state test definition.\"\"\"\n    # We can't generate a state test fixture that names a transition fork,\n    # so we get the fork at the block number and timestamp of the state test\n    fork = fork.fork_at(self.env.number, self.env.timestamp)\n\n    env = self.env.set_fork_requirements(fork)\n    tx = self.tx.with_signature_and_sender(keep_secret_key=True)\n    pre_alloc = Alloc.merge(\n        Alloc.model_validate(fork.pre_allocation()),\n        self.pre,\n    )\n    if empty_accounts := pre_alloc.empty_accounts():\n        raise Exception(f\"Empty accounts in pre state: {empty_accounts}\")\n\n    transition_tool_output = t8n.evaluate(\n        alloc=pre_alloc,\n        txs=[tx],\n        env=env,\n        fork=fork,\n        chain_id=self.chain_id,\n        reward=0,  # Reward on state tests is always zero\n        blob_schedule=fork.blob_schedule(),\n        eips=eips,\n        debug_output_path=self.get_next_transition_tool_output_path(),\n        state_test=True,\n        slow_request=slow,\n    )\n\n    try:\n        self.post.verify_post_alloc(transition_tool_output.alloc)\n    except Exception as e:\n        print_traces(t8n.get_traces())\n        raise e\n\n    try:\n        verify_transactions(\n            txs=[tx],\n            exception_mapper=t8n.exception_mapper,\n            result=transition_tool_output.result,\n        )\n    except Exception as e:\n        print_traces(t8n.get_traces())\n        pprint(transition_tool_output.result)\n        pprint(transition_tool_output.alloc)\n        raise e\n\n    return StateFixture(\n        env=FixtureEnvironment(**env.model_dump(exclude_none=True)),\n        pre=pre_alloc,\n        post={\n            fork.blockchain_test_network_name(): [\n                FixtureForkPost(\n                    state_root=transition_tool_output.result.state_root,\n                    logs_hash=transition_tool_output.result.logs_hash,\n                    tx_bytes=tx.rlp,\n                    expect_exception=tx.error,\n                    state=transition_tool_output.alloc,\n                )\n            ]\n        },\n        transaction=FixtureTransaction.from_transaction(tx),\n        config=FixtureConfig(\n            blob_schedule=FixtureBlobSchedule.from_blob_schedule(fork.blob_schedule()),\n            chain_id=self.chain_id,\n        ),\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.StateTest.generate","title":"<code>generate(request, t8n, fork, fixture_format, eips=None)</code>","text":"<p>Generate the BlockchainTest fixture.</p> Source code in <code>src/ethereum_test_specs/state.py</code> <pre><code>def generate(\n    self,\n    request: pytest.FixtureRequest,\n    t8n: TransitionTool,\n    fork: Fork,\n    fixture_format: FixtureFormat,\n    eips: Optional[List[int]] = None,\n) -&gt; BaseFixture:\n    \"\"\"Generate the BlockchainTest fixture.\"\"\"\n    if fixture_format in BlockchainTest.supported_fixture_formats:\n        return self.generate_blockchain_test(fork=fork).generate(\n            request=request, t8n=t8n, fork=fork, fixture_format=fixture_format, eips=eips\n        )\n    elif fixture_format == StateFixture:\n        return self.make_state_test_fixture(t8n, fork, eips, slow=is_slow_test(request))\n\n    raise Exception(f\"Unknown fixture format: {fixture_format}\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.StateTest.execute","title":"<code>execute(*, fork, execute_format, eips=None)</code>","text":"<p>Generate the list of test fixtures.</p> Source code in <code>src/ethereum_test_specs/state.py</code> <pre><code>def execute(\n    self,\n    *,\n    fork: Fork,\n    execute_format: ExecuteFormat,\n    eips: Optional[List[int]] = None,\n) -&gt; BaseExecute:\n    \"\"\"Generate the list of test fixtures.\"\"\"\n    if execute_format == TransactionPost:\n        return TransactionPost(\n            transactions=[self.tx],\n            post=self.post,\n        )\n    raise Exception(f\"Unsupported execute format: {execute_format}\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionTest","title":"<code>TransactionTest</code>","text":"<p>               Bases: <code>BaseTest</code></p> <p>Filler type that tests the transaction over the period of a single block.</p> Source code in <code>src/ethereum_test_specs/transaction.py</code> <pre><code>class TransactionTest(BaseTest):\n    \"\"\"Filler type that tests the transaction over the period of a single block.\"\"\"\n\n    tx: Transaction\n    pre: Alloc | None = None\n\n    supported_fixture_formats: ClassVar[Sequence[FixtureFormat | LabeledFixtureFormat]] = [\n        TransactionFixture,\n    ]\n    supported_execute_formats: ClassVar[Sequence[ExecuteFormat | LabeledExecuteFormat]] = [\n        TransactionPost,\n    ]\n\n    def make_transaction_test_fixture(\n        self,\n        fork: Fork,\n        eips: Optional[List[int]] = None,\n    ) -&gt; TransactionFixture:\n        \"\"\"Create a fixture from the transaction test definition.\"\"\"\n        if self.tx.error is not None:\n            result = FixtureResult(\n                exception=self.tx.error,\n                hash=None,\n                intrinsic_gas=0,\n                sender=None,\n            )\n        else:\n            intrinsic_gas_cost_calculator = fork.transaction_intrinsic_cost_calculator()\n            intrinsic_gas = intrinsic_gas_cost_calculator(\n                calldata=self.tx.data,\n                contract_creation=self.tx.to is None,\n                access_list=self.tx.access_list,\n                authorization_list_or_count=self.tx.authorization_list,\n            )\n            result = FixtureResult(\n                exception=None,\n                hash=self.tx.hash,\n                intrinsic_gas=intrinsic_gas,\n                sender=self.tx.sender,\n            )\n\n        return TransactionFixture(\n            result={\n                fork.blockchain_test_network_name(): result,\n            },\n            transaction=self.tx.with_signature_and_sender().rlp,\n        )\n\n    def generate(\n        self,\n        request: pytest.FixtureRequest,\n        t8n: TransitionTool,\n        fork: Fork,\n        fixture_format: FixtureFormat,\n        eips: Optional[List[int]] = None,\n    ) -&gt; BaseFixture:\n        \"\"\"Generate the TransactionTest fixture.\"\"\"\n        if fixture_format == TransactionFixture:\n            return self.make_transaction_test_fixture(fork, eips)\n\n        raise Exception(f\"Unknown fixture format: {fixture_format}\")\n\n    def execute(\n        self,\n        *,\n        fork: Fork,\n        execute_format: ExecuteFormat,\n        eips: Optional[List[int]] = None,\n    ) -&gt; BaseExecute:\n        \"\"\"Execute the transaction test by sending it to the live network.\"\"\"\n        if execute_format == TransactionPost:\n            return TransactionPost(\n                transactions=[self.tx],\n                post={},\n            )\n        raise Exception(f\"Unsupported execute format: {execute_format}\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionTest.make_transaction_test_fixture","title":"<code>make_transaction_test_fixture(fork, eips=None)</code>","text":"<p>Create a fixture from the transaction test definition.</p> Source code in <code>src/ethereum_test_specs/transaction.py</code> <pre><code>def make_transaction_test_fixture(\n    self,\n    fork: Fork,\n    eips: Optional[List[int]] = None,\n) -&gt; TransactionFixture:\n    \"\"\"Create a fixture from the transaction test definition.\"\"\"\n    if self.tx.error is not None:\n        result = FixtureResult(\n            exception=self.tx.error,\n            hash=None,\n            intrinsic_gas=0,\n            sender=None,\n        )\n    else:\n        intrinsic_gas_cost_calculator = fork.transaction_intrinsic_cost_calculator()\n        intrinsic_gas = intrinsic_gas_cost_calculator(\n            calldata=self.tx.data,\n            contract_creation=self.tx.to is None,\n            access_list=self.tx.access_list,\n            authorization_list_or_count=self.tx.authorization_list,\n        )\n        result = FixtureResult(\n            exception=None,\n            hash=self.tx.hash,\n            intrinsic_gas=intrinsic_gas,\n            sender=self.tx.sender,\n        )\n\n    return TransactionFixture(\n        result={\n            fork.blockchain_test_network_name(): result,\n        },\n        transaction=self.tx.with_signature_and_sender().rlp,\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionTest.generate","title":"<code>generate(request, t8n, fork, fixture_format, eips=None)</code>","text":"<p>Generate the TransactionTest fixture.</p> Source code in <code>src/ethereum_test_specs/transaction.py</code> <pre><code>def generate(\n    self,\n    request: pytest.FixtureRequest,\n    t8n: TransitionTool,\n    fork: Fork,\n    fixture_format: FixtureFormat,\n    eips: Optional[List[int]] = None,\n) -&gt; BaseFixture:\n    \"\"\"Generate the TransactionTest fixture.\"\"\"\n    if fixture_format == TransactionFixture:\n        return self.make_transaction_test_fixture(fork, eips)\n\n    raise Exception(f\"Unknown fixture format: {fixture_format}\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.TransactionTest.execute","title":"<code>execute(*, fork, execute_format, eips=None)</code>","text":"<p>Execute the transaction test by sending it to the live network.</p> Source code in <code>src/ethereum_test_specs/transaction.py</code> <pre><code>def execute(\n    self,\n    *,\n    fork: Fork,\n    execute_format: ExecuteFormat,\n    eips: Optional[List[int]] = None,\n) -&gt; BaseExecute:\n    \"\"\"Execute the transaction test by sending it to the live network.\"\"\"\n    if execute_format == TransactionPost:\n        return TransactionPost(\n            transactions=[self.tx],\n            post={},\n        )\n    raise Exception(f\"Unsupported execute format: {execute_format}\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Block","title":"<code>Block</code>","text":"<p>               Bases: <code>Header</code></p> <p>Block type used to describe block properties in test specs.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>class Block(Header):\n    \"\"\"Block type used to describe block properties in test specs.\"\"\"\n\n    rlp: Bytes | None = None\n    \"\"\"\n    If set, blockchain test will skip generating the block and will pass this value directly to\n    the Fixture.\n\n    Only meant to be used to simulate blocks with bad formats, and therefore\n    requires the block to produce an exception.\n    \"\"\"\n    header_verify: Header | None = None\n    \"\"\"\n    If set, the block header will be verified against the specified values.\n    \"\"\"\n    rlp_modifier: Header | None = None\n    \"\"\"\n    An RLP modifying header which values would be used to override the ones\n    returned by the `ethereum_clis.TransitionTool`.\n    \"\"\"\n    exception: (\n        List[TransactionException | BlockException] | TransactionException | BlockException | None\n    ) = None\n    \"\"\"\n    If set, the block is expected to be rejected by the client.\n    \"\"\"\n    engine_api_error_code: EngineAPIError | None = None\n    \"\"\"\n    If set, the block is expected to produce an error response from the Engine API.\n    \"\"\"\n    txs: List[Transaction] = Field(default_factory=list)\n    \"\"\"\n    List of transactions included in the block.\n    \"\"\"\n    ommers: List[Header] | None = None\n    \"\"\"\n    List of ommer headers included in the block.\n    \"\"\"\n    withdrawals: List[Withdrawal] | None = None\n    \"\"\"\n    List of withdrawals to perform for this block.\n    \"\"\"\n    requests: List[Bytes] | None = None\n    \"\"\"\n    Custom list of requests to embed in this block.\n    \"\"\"\n    expected_post_state: Alloc | None = None\n    \"\"\"\n    Post state for verification after block execution in BlockchainTest\n    \"\"\"\n\n    def set_environment(self, env: Environment) -&gt; Environment:\n        \"\"\"\n        Create copy of the environment with the characteristics of this\n        specific block.\n        \"\"\"\n        new_env_values: Dict[str, Any] = {}\n\n        \"\"\"\n        Values that need to be set in the environment and are `None` for\n        this block need to be set to their defaults.\n        \"\"\"\n        new_env_values[\"difficulty\"] = self.difficulty\n        new_env_values[\"fee_recipient\"] = (\n            self.fee_recipient if self.fee_recipient is not None else Environment().fee_recipient\n        )\n        new_env_values[\"gas_limit\"] = (\n            self.gas_limit or env.parent_gas_limit or Environment().gas_limit\n        )\n        if not isinstance(self.base_fee_per_gas, Removable):\n            new_env_values[\"base_fee_per_gas\"] = self.base_fee_per_gas\n        new_env_values[\"withdrawals\"] = self.withdrawals\n        if not isinstance(self.excess_blob_gas, Removable):\n            new_env_values[\"excess_blob_gas\"] = self.excess_blob_gas\n        if not isinstance(self.blob_gas_used, Removable):\n            new_env_values[\"blob_gas_used\"] = self.blob_gas_used\n        if not isinstance(self.parent_beacon_block_root, Removable):\n            new_env_values[\"parent_beacon_block_root\"] = self.parent_beacon_block_root\n        \"\"\"\n        These values are required, but they depend on the previous environment,\n        so they can be calculated here.\n        \"\"\"\n        if self.number is not None:\n            new_env_values[\"number\"] = self.number\n        else:\n            # calculate the next block number for the environment\n            if len(env.block_hashes) == 0:\n                new_env_values[\"number\"] = 0\n            else:\n                new_env_values[\"number\"] = max([Number(n) for n in env.block_hashes.keys()]) + 1\n\n        if self.timestamp is not None:\n            new_env_values[\"timestamp\"] = self.timestamp\n        else:\n            assert env.parent_timestamp is not None\n            new_env_values[\"timestamp\"] = int(Number(env.parent_timestamp) + 12)\n\n        return env.copy(**new_env_values)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Block.rlp","title":"<code>rlp: Bytes | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If set, blockchain test will skip generating the block and will pass this value directly to the Fixture.</p> <p>Only meant to be used to simulate blocks with bad formats, and therefore requires the block to produce an exception.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Block.header_verify","title":"<code>header_verify: Header | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If set, the block header will be verified against the specified values.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Block.rlp_modifier","title":"<code>rlp_modifier: Header | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An RLP modifying header which values would be used to override the ones returned by the <code>ethereum_clis.TransitionTool</code>.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Block.exception","title":"<code>exception: List[TransactionException | BlockException] | TransactionException | BlockException | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If set, the block is expected to be rejected by the client.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Block.engine_api_error_code","title":"<code>engine_api_error_code: EngineAPIError | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If set, the block is expected to produce an error response from the Engine API.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Block.txs","title":"<code>txs: List[Transaction] = Field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of transactions included in the block.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Block.ommers","title":"<code>ommers: List[Header] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of ommer headers included in the block.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Block.withdrawals","title":"<code>withdrawals: List[Withdrawal] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of withdrawals to perform for this block.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Block.requests","title":"<code>requests: List[Bytes] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Custom list of requests to embed in this block.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Block.expected_post_state","title":"<code>expected_post_state: Alloc | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Post state for verification after block execution in BlockchainTest</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Block.set_environment","title":"<code>set_environment(env)</code>","text":"<p>Create copy of the environment with the characteristics of this specific block.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>def set_environment(self, env: Environment) -&gt; Environment:\n    \"\"\"\n    Create copy of the environment with the characteristics of this\n    specific block.\n    \"\"\"\n    new_env_values: Dict[str, Any] = {}\n\n    \"\"\"\n    Values that need to be set in the environment and are `None` for\n    this block need to be set to their defaults.\n    \"\"\"\n    new_env_values[\"difficulty\"] = self.difficulty\n    new_env_values[\"fee_recipient\"] = (\n        self.fee_recipient if self.fee_recipient is not None else Environment().fee_recipient\n    )\n    new_env_values[\"gas_limit\"] = (\n        self.gas_limit or env.parent_gas_limit or Environment().gas_limit\n    )\n    if not isinstance(self.base_fee_per_gas, Removable):\n        new_env_values[\"base_fee_per_gas\"] = self.base_fee_per_gas\n    new_env_values[\"withdrawals\"] = self.withdrawals\n    if not isinstance(self.excess_blob_gas, Removable):\n        new_env_values[\"excess_blob_gas\"] = self.excess_blob_gas\n    if not isinstance(self.blob_gas_used, Removable):\n        new_env_values[\"blob_gas_used\"] = self.blob_gas_used\n    if not isinstance(self.parent_beacon_block_root, Removable):\n        new_env_values[\"parent_beacon_block_root\"] = self.parent_beacon_block_root\n    \"\"\"\n    These values are required, but they depend on the previous environment,\n    so they can be calculated here.\n    \"\"\"\n    if self.number is not None:\n        new_env_values[\"number\"] = self.number\n    else:\n        # calculate the next block number for the environment\n        if len(env.block_hashes) == 0:\n            new_env_values[\"number\"] = 0\n        else:\n            new_env_values[\"number\"] = max([Number(n) for n in env.block_hashes.keys()]) + 1\n\n    if self.timestamp is not None:\n        new_env_values[\"timestamp\"] = self.timestamp\n    else:\n        assert env.parent_timestamp is not None\n        new_env_values[\"timestamp\"] = int(Number(env.parent_timestamp) + 12)\n\n    return env.copy(**new_env_values)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Header","title":"<code>Header</code>","text":"<p>               Bases: <code>CamelModel</code></p> <p>Header type used to describe block header properties in test specs.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>class Header(CamelModel):\n    \"\"\"Header type used to describe block header properties in test specs.\"\"\"\n\n    parent_hash: Hash | None = None\n    ommers_hash: Hash | None = None\n    fee_recipient: Address | None = None\n    state_root: Hash | None = None\n    transactions_trie: Hash | None = None\n    receipts_root: Hash | None = None\n    logs_bloom: Bloom | None = None\n    difficulty: HexNumber | None = None\n    number: HexNumber | None = None\n    gas_limit: HexNumber | None = None\n    gas_used: HexNumber | None = None\n    timestamp: HexNumber | None = None\n    extra_data: Bytes | None = None\n    prev_randao: Hash | None = None\n    nonce: HeaderNonce | None = None\n    base_fee_per_gas: Removable | HexNumber | None = None\n    withdrawals_root: Removable | Hash | None = None\n    blob_gas_used: Removable | HexNumber | None = None\n    excess_blob_gas: Removable | HexNumber | None = None\n    parent_beacon_block_root: Removable | Hash | None = None\n    requests_hash: Removable | Hash | None = None\n\n    REMOVE_FIELD: ClassVar[Removable] = Removable()\n    \"\"\"\n    Sentinel object used to specify that a header field should be removed.\n    \"\"\"\n    EMPTY_FIELD: ClassVar[Removable] = Removable()\n    \"\"\"\n    Sentinel object used to specify that a header field must be empty during verification.\n\n    This can be used in a test to explicitly skip a field in a block's RLP encoding.\n    included in the (json) output when the model is serialized. For example:\n    ```\n    header_modifier = Header(\n        excess_blob_gas=Header.REMOVE_FIELD,\n    )\n    block = Block(\n        timestamp=TIMESTAMP,\n        rlp_modifier=header_modifier,\n        exception=BlockException.INCORRECT_BLOCK_FORMAT,\n        engine_api_error_code=EngineAPIError.InvalidParams,\n    )\n    ```\n    \"\"\"\n\n    model_config = ConfigDict(\n        arbitrary_types_allowed=True,\n        # explicitly set Removable items to None so they are not included in the serialization\n        # (in combination with exclude_None=True in model.dump()).\n        json_encoders={\n            Removable: lambda x: None,\n        },\n    )\n\n    @field_validator(\"withdrawals_root\", mode=\"before\")\n    @classmethod\n    def validate_withdrawals_root(cls, value):\n        \"\"\"Convert a list of withdrawals into the withdrawals root hash.\"\"\"\n        if isinstance(value, list):\n            return Withdrawal.list_root(value)\n        return value\n\n    def apply(self, target: FixtureHeader) -&gt; FixtureHeader:\n        \"\"\"Produce a fixture header copy with the set values from the modifier.\"\"\"\n        return target.copy(\n            **{\n                k: (v if v is not Header.REMOVE_FIELD else None)\n                for k, v in self.model_dump(exclude_none=True).items()\n            }\n        )\n\n    def verify(self, target: FixtureHeader):\n        \"\"\"Verify that the header fields from self are as expected.\"\"\"\n        for field_name in self.model_fields:\n            baseline_value = getattr(self, field_name)\n            if baseline_value is not None:\n                assert baseline_value is not Header.REMOVE_FIELD, \"invalid header\"\n                value = getattr(target, field_name)\n                if baseline_value is Header.EMPTY_FIELD:\n                    assert value is None, (\n                        f\"invalid header field {field_name}, got {value}, want None\"\n                    )\n                    continue\n                assert value == baseline_value, (\n                    f\"invalid header field ({field_name}) value, \"\n                    + f\"got {value}, want {baseline_value}\"\n                )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Header.REMOVE_FIELD","title":"<code>REMOVE_FIELD: Removable = Removable()</code>  <code>class-attribute</code>","text":"<p>Sentinel object used to specify that a header field should be removed.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Header.EMPTY_FIELD","title":"<code>EMPTY_FIELD: Removable = Removable()</code>  <code>class-attribute</code>","text":"<p>Sentinel object used to specify that a header field must be empty during verification.</p> <p>This can be used in a test to explicitly skip a field in a block's RLP encoding. included in the (json) output when the model is serialized. For example: <pre><code>header_modifier = Header(\n    excess_blob_gas=Header.REMOVE_FIELD,\n)\nblock = Block(\n    timestamp=TIMESTAMP,\n    rlp_modifier=header_modifier,\n    exception=BlockException.INCORRECT_BLOCK_FORMAT,\n    engine_api_error_code=EngineAPIError.InvalidParams,\n)\n</code></pre></p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Header.validate_withdrawals_root","title":"<code>validate_withdrawals_root(value)</code>  <code>classmethod</code>","text":"<p>Convert a list of withdrawals into the withdrawals root hash.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>@field_validator(\"withdrawals_root\", mode=\"before\")\n@classmethod\ndef validate_withdrawals_root(cls, value):\n    \"\"\"Convert a list of withdrawals into the withdrawals root hash.\"\"\"\n    if isinstance(value, list):\n        return Withdrawal.list_root(value)\n    return value\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Header.apply","title":"<code>apply(target)</code>","text":"<p>Produce a fixture header copy with the set values from the modifier.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>def apply(self, target: FixtureHeader) -&gt; FixtureHeader:\n    \"\"\"Produce a fixture header copy with the set values from the modifier.\"\"\"\n    return target.copy(\n        **{\n            k: (v if v is not Header.REMOVE_FIELD else None)\n            for k, v in self.model_dump(exclude_none=True).items()\n        }\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Header.verify","title":"<code>verify(target)</code>","text":"<p>Verify that the header fields from self are as expected.</p> Source code in <code>src/ethereum_test_specs/blockchain.py</code> <pre><code>def verify(self, target: FixtureHeader):\n    \"\"\"Verify that the header fields from self are as expected.\"\"\"\n    for field_name in self.model_fields:\n        baseline_value = getattr(self, field_name)\n        if baseline_value is not None:\n            assert baseline_value is not Header.REMOVE_FIELD, \"invalid header\"\n            value = getattr(target, field_name)\n            if baseline_value is Header.EMPTY_FIELD:\n                assert value is None, (\n                    f\"invalid header field {field_name}, got {value}, want None\"\n                )\n                continue\n            assert value == baseline_value, (\n                f\"invalid header field ({field_name}) value, \"\n                + f\"got {value}, want {baseline_value}\"\n            )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.CalldataCase","title":"<code>CalldataCase</code>","text":"<p>               Bases: <code>Case</code></p> <p>Small helper class to represent a single case whose condition depends on the value of the contract's calldata in a Switch case statement.</p> <p>By default the calldata is read from position zero, but this can be overridden using <code>position</code>.</p> <p>The <code>condition</code> is generated automatically based on the <code>value</code> (and optionally <code>position</code>) and may not be set directly.</p> Source code in <code>src/ethereum_test_tools/code/generators.py</code> <pre><code>class CalldataCase(Case):\n    \"\"\"\n    Small helper class to represent a single case whose condition depends\n    on the value of the contract's calldata in a Switch case statement.\n\n    By default the calldata is read from position zero, but this can be\n    overridden using `position`.\n\n    The `condition` is generated automatically based on the `value` (and\n    optionally `position`) and may not be set directly.\n    \"\"\"\n\n    def __init__(self, value: int | str | Bytecode, position: int = 0, **kwargs):\n        \"\"\"Generate the condition base on `value` and `position`.\"\"\"\n        condition = Op.EQ(Op.CALLDATALOAD(position), value)\n        super().__init__(condition=condition, **kwargs)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.CalldataCase.__init__","title":"<code>__init__(value, position=0, **kwargs)</code>","text":"<p>Generate the condition base on <code>value</code> and <code>position</code>.</p> Source code in <code>src/ethereum_test_tools/code/generators.py</code> <pre><code>def __init__(self, value: int | str | Bytecode, position: int = 0, **kwargs):\n    \"\"\"Generate the condition base on `value` and `position`.\"\"\"\n    condition = Op.EQ(Op.CALLDATALOAD(position), value)\n    super().__init__(condition=condition, **kwargs)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Case","title":"<code>Case</code>  <code>dataclass</code>","text":"<p>Small helper class to represent a single, generic case in a <code>Switch</code> cases list.</p> Source code in <code>src/ethereum_test_tools/code/generators.py</code> <pre><code>@dataclass(kw_only=True)\nclass Case:\n    \"\"\"\n    Small helper class to represent a single, generic case in a `Switch` cases\n    list.\n    \"\"\"\n\n    condition: Bytecode | Op\n    action: Bytecode | Op\n    terminating: bool | None = None\n\n    @property\n    def is_terminating(self) -&gt; bool:\n        \"\"\"Returns whether the case is terminating.\"\"\"\n        return self.terminating if self.terminating is not None else self.action.terminating\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Case.is_terminating","title":"<code>is_terminating: bool</code>  <code>property</code>","text":"<p>Returns whether the case is terminating.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.CodeGasMeasure","title":"<code>CodeGasMeasure</code>","text":"<p>               Bases: <code>Bytecode</code></p> <p>Helper class used to generate bytecode that measures gas usage of a bytecode, taking into account and subtracting any extra overhead gas costs required to execute. By default, the result gas calculation is saved to storage key 0.</p> Source code in <code>src/ethereum_test_tools/code/generators.py</code> <pre><code>class CodeGasMeasure(Bytecode):\n    \"\"\"\n    Helper class used to generate bytecode that measures gas usage of a\n    bytecode, taking into account and subtracting any extra overhead gas costs\n    required to execute.\n    By default, the result gas calculation is saved to storage key 0.\n    \"\"\"\n\n    code: Bytecode\n    \"\"\"\n    Bytecode to be executed to measure the gas usage.\n    \"\"\"\n    overhead_cost: int\n    \"\"\"\n    Extra gas cost to be subtracted from extra operations.\n    \"\"\"\n    extra_stack_items: int\n    \"\"\"\n    Extra stack items that remain at the end of the execution.\n    To be considered when subtracting the value of the previous GAS operation,\n    and to be popped at the end of the execution.\n    \"\"\"\n    sstore_key: int\n    \"\"\"\n    Storage key to save the gas used.\n    \"\"\"\n\n    def __new__(\n        cls,\n        *,\n        code: Bytecode,\n        overhead_cost: int = 0,\n        extra_stack_items: int = 0,\n        sstore_key: int = 0,\n        stop: bool = True,\n    ):\n        \"\"\"Assemble the bytecode that measures gas usage.\"\"\"\n        res = Op.GAS + code + Op.GAS\n        # We need to swap and pop for each extra stack item that remained from\n        # the execution of the code\n        res += (Op.SWAP1 + Op.POP) * extra_stack_items\n        res += (\n            Op.SWAP1\n            + Op.SUB\n            + Op.PUSH1(overhead_cost + 2)\n            + Op.SWAP1\n            + Op.SUB\n            + Op.PUSH1(sstore_key)\n            + Op.SSTORE\n        )\n        if stop:\n            res += Op.STOP\n\n        instance = super().__new__(cls, res)\n        instance.code = code\n        instance.overhead_cost = overhead_cost\n        instance.extra_stack_items = extra_stack_items\n        instance.sstore_key = sstore_key\n        return instance\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.CodeGasMeasure.code","title":"<code>code: Bytecode</code>  <code>instance-attribute</code>","text":"<p>Bytecode to be executed to measure the gas usage.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.CodeGasMeasure.overhead_cost","title":"<code>overhead_cost: int</code>  <code>instance-attribute</code>","text":"<p>Extra gas cost to be subtracted from extra operations.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.CodeGasMeasure.extra_stack_items","title":"<code>extra_stack_items: int</code>  <code>instance-attribute</code>","text":"<p>Extra stack items that remain at the end of the execution. To be considered when subtracting the value of the previous GAS operation, and to be popped at the end of the execution.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.CodeGasMeasure.sstore_key","title":"<code>sstore_key: int</code>  <code>instance-attribute</code>","text":"<p>Storage key to save the gas used.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.CodeGasMeasure.__new__","title":"<code>__new__(*, code, overhead_cost=0, extra_stack_items=0, sstore_key=0, stop=True)</code>","text":"<p>Assemble the bytecode that measures gas usage.</p> Source code in <code>src/ethereum_test_tools/code/generators.py</code> <pre><code>def __new__(\n    cls,\n    *,\n    code: Bytecode,\n    overhead_cost: int = 0,\n    extra_stack_items: int = 0,\n    sstore_key: int = 0,\n    stop: bool = True,\n):\n    \"\"\"Assemble the bytecode that measures gas usage.\"\"\"\n    res = Op.GAS + code + Op.GAS\n    # We need to swap and pop for each extra stack item that remained from\n    # the execution of the code\n    res += (Op.SWAP1 + Op.POP) * extra_stack_items\n    res += (\n        Op.SWAP1\n        + Op.SUB\n        + Op.PUSH1(overhead_cost + 2)\n        + Op.SWAP1\n        + Op.SUB\n        + Op.PUSH1(sstore_key)\n        + Op.SSTORE\n    )\n    if stop:\n        res += Op.STOP\n\n    instance = super().__new__(cls, res)\n    instance.code = code\n    instance.overhead_cost = overhead_cost\n    instance.extra_stack_items = extra_stack_items\n    instance.sstore_key = sstore_key\n    return instance\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Conditional","title":"<code>Conditional</code>","text":"<p>               Bases: <code>Bytecode</code></p> <p>Helper class used to generate conditional bytecode.</p> Source code in <code>src/ethereum_test_tools/code/generators.py</code> <pre><code>class Conditional(Bytecode):\n    \"\"\"Helper class used to generate conditional bytecode.\"\"\"\n\n    def __new__(\n        cls,\n        *,\n        condition: Bytecode | Op,\n        if_true: Bytecode | Op | None = None,\n        if_false: Bytecode | Op | None = None,\n        evm_code_type: EVMCodeType = EVMCodeType.LEGACY,\n    ):\n        \"\"\"\n        Assemble the conditional bytecode by generating the necessary jump and\n        jumpdest opcodes surrounding the condition and the two possible execution\n        paths.\n\n        In the future, PC usage should be replaced by using RJUMP and RJUMPI\n        \"\"\"\n        if if_true is None:\n            if_true = Bytecode()\n        if if_false is None:\n            if_false = Bytecode()\n\n        if evm_code_type == EVMCodeType.LEGACY:\n            # First we append a jumpdest to the start of the true branch\n            if_true = Op.JUMPDEST + if_true\n\n            # Then we append the unconditional jump to the end of the false branch, used to skip\n            # the true branch\n            if_false += Op.JUMP(Op.ADD(Op.PC, len(if_true) + 3))\n\n            # Then we need to do the conditional jump by skipping the false branch\n            condition = Op.JUMPI(Op.ADD(Op.PC, len(if_false) + 3), condition)\n\n            # Finally we append the condition, false and true branches, plus the jumpdest at the\n            # very end\n            bytecode = condition + if_false + if_true + Op.JUMPDEST\n\n        elif evm_code_type == EVMCodeType.EOF_V1:\n            if not if_false.terminating:\n                if_false += Op.RJUMP[len(if_true)]\n            condition = Op.RJUMPI[len(if_false)](condition)\n\n            # Finally we append the condition, false and true branches\n            bytecode = condition + if_false + if_true\n\n        return super().__new__(cls, bytecode)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Conditional.__new__","title":"<code>__new__(*, condition, if_true=None, if_false=None, evm_code_type=EVMCodeType.LEGACY)</code>","text":"<p>Assemble the conditional bytecode by generating the necessary jump and jumpdest opcodes surrounding the condition and the two possible execution paths.</p> <p>In the future, PC usage should be replaced by using RJUMP and RJUMPI</p> Source code in <code>src/ethereum_test_tools/code/generators.py</code> <pre><code>def __new__(\n    cls,\n    *,\n    condition: Bytecode | Op,\n    if_true: Bytecode | Op | None = None,\n    if_false: Bytecode | Op | None = None,\n    evm_code_type: EVMCodeType = EVMCodeType.LEGACY,\n):\n    \"\"\"\n    Assemble the conditional bytecode by generating the necessary jump and\n    jumpdest opcodes surrounding the condition and the two possible execution\n    paths.\n\n    In the future, PC usage should be replaced by using RJUMP and RJUMPI\n    \"\"\"\n    if if_true is None:\n        if_true = Bytecode()\n    if if_false is None:\n        if_false = Bytecode()\n\n    if evm_code_type == EVMCodeType.LEGACY:\n        # First we append a jumpdest to the start of the true branch\n        if_true = Op.JUMPDEST + if_true\n\n        # Then we append the unconditional jump to the end of the false branch, used to skip\n        # the true branch\n        if_false += Op.JUMP(Op.ADD(Op.PC, len(if_true) + 3))\n\n        # Then we need to do the conditional jump by skipping the false branch\n        condition = Op.JUMPI(Op.ADD(Op.PC, len(if_false) + 3), condition)\n\n        # Finally we append the condition, false and true branches, plus the jumpdest at the\n        # very end\n        bytecode = condition + if_false + if_true + Op.JUMPDEST\n\n    elif evm_code_type == EVMCodeType.EOF_V1:\n        if not if_false.terminating:\n            if_false += Op.RJUMP[len(if_true)]\n        condition = Op.RJUMPI[len(if_false)](condition)\n\n        # Finally we append the condition, false and true branches\n        bytecode = condition + if_false + if_true\n\n    return super().__new__(cls, bytecode)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Initcode","title":"<code>Initcode</code>","text":"<p>               Bases: <code>Bytecode</code></p> <p>Helper class used to generate initcode for the specified deployment code.</p> <p>The execution gas cost of the initcode is calculated, and also the deployment gas costs for the deployed code.</p> <p>The initcode can be padded to a certain length if necessary, which does not affect the deployed code.</p> <p>Other costs such as the CREATE2 hashing costs or the initcode_word_cost of EIP-3860 are not taken into account by any of these calculated costs.</p> Source code in <code>src/ethereum_test_tools/code/generators.py</code> <pre><code>class Initcode(Bytecode):\n    \"\"\"\n    Helper class used to generate initcode for the specified deployment code.\n\n    The execution gas cost of the initcode is calculated, and also the\n    deployment gas costs for the deployed code.\n\n    The initcode can be padded to a certain length if necessary, which\n    does not affect the deployed code.\n\n    Other costs such as the CREATE2 hashing costs or the initcode_word_cost\n    of EIP-3860 are *not* taken into account by any of these calculated\n    costs.\n    \"\"\"\n\n    deploy_code: SupportsBytes | Bytes\n    \"\"\"\n    Bytecode to be deployed by the initcode.\n    \"\"\"\n    execution_gas: int\n    \"\"\"\n    Gas cost of executing the initcode, without considering deployment gas\n    costs.\n    \"\"\"\n    deployment_gas: int\n    \"\"\"\n    Gas cost of deploying the cost, subtracted after initcode execution,\n    \"\"\"\n\n    def __new__(\n        cls,\n        *,\n        deploy_code: SupportsBytes | Bytes | None = None,\n        initcode_length: int | None = None,\n        initcode_prefix: Bytecode | None = None,\n        initcode_prefix_execution_gas: int = 0,\n        padding_byte: int = 0x00,\n        name: str = \"\",\n    ):\n        \"\"\"\n        Generate legacy initcode that inits a contract with the specified code.\n        The initcode can be padded to a specified length for testing purposes.\n        \"\"\"\n        if deploy_code is None:\n            deploy_code = Bytecode()\n        if initcode_prefix is None:\n            initcode_prefix = Bytecode()\n\n        initcode = initcode_prefix\n        code_length = len(bytes(deploy_code))\n        execution_gas = initcode_prefix_execution_gas\n\n        # PUSH2: length=&lt;bytecode length&gt;\n        initcode += Op.PUSH2(code_length)\n        execution_gas = 3\n\n        # PUSH1: offset=0\n        initcode += Op.PUSH1(0)\n        execution_gas += 3\n\n        # DUP2\n        initcode += Op.DUP2\n        execution_gas += 3\n\n        # PUSH1: initcode_length=11 + len(initcode_prefix_bytes) (constant)\n        no_prefix_length = 0x0B\n        assert no_prefix_length + len(initcode_prefix) &lt;= 0xFF, \"initcode prefix too long\"\n        initcode += Op.PUSH1(no_prefix_length + len(initcode_prefix))\n        execution_gas += 3\n\n        # DUP3\n        initcode += Op.DUP3\n        execution_gas += 3\n\n        # CODECOPY: destinationOffset=0, offset=0, length\n        initcode += Op.CODECOPY\n        execution_gas += (\n            3\n            + (3 * ceiling_division(code_length, 32))\n            + (3 * code_length)\n            + ((code_length * code_length) // 512)\n        )\n\n        # RETURN: offset=0, length\n        initcode += Op.RETURN\n        execution_gas += 0\n\n        initcode_plus_deploy_code = bytes(initcode) + bytes(deploy_code)\n        padding_bytes = bytes()\n\n        if initcode_length is not None:\n            assert initcode_length &gt;= len(initcode_plus_deploy_code), (\n                \"specified invalid length for initcode\"\n            )\n\n            padding_bytes = bytes(\n                [padding_byte] * (initcode_length - len(initcode_plus_deploy_code))\n            )\n\n        initcode_bytes = initcode_plus_deploy_code + padding_bytes\n        instance = super().__new__(\n            cls,\n            initcode_bytes,\n            popped_stack_items=initcode.popped_stack_items,\n            pushed_stack_items=initcode.pushed_stack_items,\n            max_stack_height=initcode.max_stack_height,\n            min_stack_height=initcode.min_stack_height,\n        )\n        instance._name_ = name\n        instance.deploy_code = deploy_code\n        instance.execution_gas = execution_gas\n        instance.deployment_gas = GAS_PER_DEPLOYED_CODE_BYTE * len(bytes(instance.deploy_code))\n\n        return instance\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Initcode.deploy_code","title":"<code>deploy_code: SupportsBytes | Bytes</code>  <code>instance-attribute</code>","text":"<p>Bytecode to be deployed by the initcode.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Initcode.execution_gas","title":"<code>execution_gas: int</code>  <code>instance-attribute</code>","text":"<p>Gas cost of executing the initcode, without considering deployment gas costs.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Initcode.deployment_gas","title":"<code>deployment_gas: int</code>  <code>instance-attribute</code>","text":"<p>Gas cost of deploying the cost, subtracted after initcode execution,</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Initcode.__new__","title":"<code>__new__(*, deploy_code=None, initcode_length=None, initcode_prefix=None, initcode_prefix_execution_gas=0, padding_byte=0, name='')</code>","text":"<p>Generate legacy initcode that inits a contract with the specified code. The initcode can be padded to a specified length for testing purposes.</p> Source code in <code>src/ethereum_test_tools/code/generators.py</code> <pre><code>def __new__(\n    cls,\n    *,\n    deploy_code: SupportsBytes | Bytes | None = None,\n    initcode_length: int | None = None,\n    initcode_prefix: Bytecode | None = None,\n    initcode_prefix_execution_gas: int = 0,\n    padding_byte: int = 0x00,\n    name: str = \"\",\n):\n    \"\"\"\n    Generate legacy initcode that inits a contract with the specified code.\n    The initcode can be padded to a specified length for testing purposes.\n    \"\"\"\n    if deploy_code is None:\n        deploy_code = Bytecode()\n    if initcode_prefix is None:\n        initcode_prefix = Bytecode()\n\n    initcode = initcode_prefix\n    code_length = len(bytes(deploy_code))\n    execution_gas = initcode_prefix_execution_gas\n\n    # PUSH2: length=&lt;bytecode length&gt;\n    initcode += Op.PUSH2(code_length)\n    execution_gas = 3\n\n    # PUSH1: offset=0\n    initcode += Op.PUSH1(0)\n    execution_gas += 3\n\n    # DUP2\n    initcode += Op.DUP2\n    execution_gas += 3\n\n    # PUSH1: initcode_length=11 + len(initcode_prefix_bytes) (constant)\n    no_prefix_length = 0x0B\n    assert no_prefix_length + len(initcode_prefix) &lt;= 0xFF, \"initcode prefix too long\"\n    initcode += Op.PUSH1(no_prefix_length + len(initcode_prefix))\n    execution_gas += 3\n\n    # DUP3\n    initcode += Op.DUP3\n    execution_gas += 3\n\n    # CODECOPY: destinationOffset=0, offset=0, length\n    initcode += Op.CODECOPY\n    execution_gas += (\n        3\n        + (3 * ceiling_division(code_length, 32))\n        + (3 * code_length)\n        + ((code_length * code_length) // 512)\n    )\n\n    # RETURN: offset=0, length\n    initcode += Op.RETURN\n    execution_gas += 0\n\n    initcode_plus_deploy_code = bytes(initcode) + bytes(deploy_code)\n    padding_bytes = bytes()\n\n    if initcode_length is not None:\n        assert initcode_length &gt;= len(initcode_plus_deploy_code), (\n            \"specified invalid length for initcode\"\n        )\n\n        padding_bytes = bytes(\n            [padding_byte] * (initcode_length - len(initcode_plus_deploy_code))\n        )\n\n    initcode_bytes = initcode_plus_deploy_code + padding_bytes\n    instance = super().__new__(\n        cls,\n        initcode_bytes,\n        popped_stack_items=initcode.popped_stack_items,\n        pushed_stack_items=initcode.pushed_stack_items,\n        max_stack_height=initcode.max_stack_height,\n        min_stack_height=initcode.min_stack_height,\n    )\n    instance._name_ = name\n    instance.deploy_code = deploy_code\n    instance.execution_gas = execution_gas\n    instance.deployment_gas = GAS_PER_DEPLOYED_CODE_BYTE * len(bytes(instance.deploy_code))\n\n    return instance\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Switch","title":"<code>Switch</code>","text":"<p>               Bases: <code>Bytecode</code></p> <p>Helper class used to generate switch-case expressions in EVM bytecode.</p> Switch-case behavior <ul> <li>If no condition is met in the list of BytecodeCases conditions,     the <code>default_action</code> bytecode is executed.</li> <li>If multiple conditions are met, the action from the first valid     condition is the only one executed.</li> <li>There is no fall through; it is not possible to execute multiple     actions.</li> </ul> Source code in <code>src/ethereum_test_tools/code/generators.py</code> <pre><code>class Switch(Bytecode):\n    \"\"\"\n    Helper class used to generate switch-case expressions in EVM bytecode.\n\n    Switch-case behavior:\n        - If no condition is met in the list of BytecodeCases conditions,\n            the `default_action` bytecode is executed.\n        - If multiple conditions are met, the action from the first valid\n            condition is the only one executed.\n        - There is no fall through; it is not possible to execute multiple\n            actions.\n    \"\"\"\n\n    default_action: Bytecode | Op | None\n    \"\"\"\n    The default bytecode to execute; if no condition is met, this bytecode is\n    executed.\n    \"\"\"\n\n    cases: List[Case]\n    \"\"\"\n    A list of Cases: The first element with a condition that\n    evaluates to a non-zero value is the one that is executed.\n    \"\"\"\n\n    evm_code_type: EVMCodeType\n    \"\"\"\n    The EVM code type to use for the switch-case bytecode.\n    \"\"\"\n\n    def __new__(\n        cls,\n        *,\n        default_action: Bytecode | Op | None = None,\n        cases: List[Case],\n        evm_code_type: EVMCodeType = EVMCodeType.LEGACY,\n    ):\n        \"\"\"\n        Assemble the bytecode by looping over the list of cases and adding\n        the necessary [R]JUMPI and JUMPDEST opcodes in order to replicate\n        switch-case behavior.\n        \"\"\"\n        # The length required to jump over subsequent actions to the final JUMPDEST at the end\n        # of the switch-case block:\n        # - add 6 per case for the length of the JUMPDEST and JUMP(ADD(PC, action_jump_length))\n        #   bytecode\n        # - add 3 to the total to account for this action's JUMP; the PC within the call\n        #   requires a \"correction\" of 3.\n\n        bytecode = Bytecode()\n\n        # All conditions get pre-pended to this bytecode; if none are met, we reach the default\n        if evm_code_type == EVMCodeType.LEGACY:\n            action_jump_length = sum(len(case.action) + 6 for case in cases) + 3\n            bytecode = default_action + Op.JUMP(Op.ADD(Op.PC, action_jump_length))\n            # The length required to jump over the default action and its JUMP bytecode\n            condition_jump_length = len(bytecode) + 3\n        elif evm_code_type == EVMCodeType.EOF_V1:\n            action_jump_length = sum(\n                len(case.action) + (len(Op.RJUMP[0]) if not case.is_terminating else 0)\n                for case in cases\n                # On not terminating cases, we need to add 3 bytes for the RJUMP\n            )\n            bytecode = default_action + Op.RJUMP[action_jump_length]\n            # The length required to jump over the default action and its JUMP bytecode\n            condition_jump_length = len(bytecode)\n\n        # Reversed: first case in the list has priority; it will become the outer-most onion layer.\n        # We build up layers around the default_action, after 1 iteration of the loop, a simplified\n        # representation of the bytecode is:\n        #\n        #  JUMPI(case[n-1].condition)\n        #  + default_action + JUMP()\n        #  + JUMPDEST + case[n-1].action + JUMP()\n        #\n        # and after n=len(cases) iterations:\n        #\n        #  JUMPI(case[0].condition)\n        #  + JUMPI(case[1].condition)\n        #    ...\n        #  + JUMPI(case[n-1].condition)\n        #  + default_action + JUMP()\n        #  + JUMPDEST + case[n-1].action + JUMP()\n        #  + ...\n        #  + JUMPDEST + case[1].action + JUMP()\n        #  + JUMPDEST + case[0].action + JUMP()\n        #\n        for case in reversed(cases):\n            action = case.action\n            if evm_code_type == EVMCodeType.LEGACY:\n                action_jump_length -= len(action) + 6\n                action = Op.JUMPDEST + action + Op.JUMP(Op.ADD(Op.PC, action_jump_length))\n                condition = Op.JUMPI(Op.ADD(Op.PC, condition_jump_length), case.condition)\n            elif evm_code_type == EVMCodeType.EOF_V1:\n                action_jump_length -= len(action) + (\n                    len(Op.RJUMP[0]) if not case.is_terminating else 0\n                )\n                if not case.is_terminating:\n                    action += Op.RJUMP[action_jump_length]\n                condition = Op.RJUMPI[condition_jump_length](case.condition)\n            # wrap the current case around the onion as its next layer\n            bytecode = condition + bytecode + action\n            condition_jump_length += len(condition) + len(action)\n\n        bytecode += Op.JUMPDEST\n\n        instance = super().__new__(cls, bytecode)\n        instance.default_action = default_action\n        instance.cases = cases\n        return instance\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Switch.default_action","title":"<code>default_action: Bytecode | Op | None</code>  <code>instance-attribute</code>","text":"<p>The default bytecode to execute; if no condition is met, this bytecode is executed.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Switch.cases","title":"<code>cases: List[Case]</code>  <code>instance-attribute</code>","text":"<p>A list of Cases: The first element with a condition that evaluates to a non-zero value is the one that is executed.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Switch.evm_code_type","title":"<code>evm_code_type: EVMCodeType</code>  <code>instance-attribute</code>","text":"<p>The EVM code type to use for the switch-case bytecode.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Switch.__new__","title":"<code>__new__(*, default_action=None, cases, evm_code_type=EVMCodeType.LEGACY)</code>","text":"<p>Assemble the bytecode by looping over the list of cases and adding the necessary [R]JUMPI and JUMPDEST opcodes in order to replicate switch-case behavior.</p> Source code in <code>src/ethereum_test_tools/code/generators.py</code> <pre><code>def __new__(\n    cls,\n    *,\n    default_action: Bytecode | Op | None = None,\n    cases: List[Case],\n    evm_code_type: EVMCodeType = EVMCodeType.LEGACY,\n):\n    \"\"\"\n    Assemble the bytecode by looping over the list of cases and adding\n    the necessary [R]JUMPI and JUMPDEST opcodes in order to replicate\n    switch-case behavior.\n    \"\"\"\n    # The length required to jump over subsequent actions to the final JUMPDEST at the end\n    # of the switch-case block:\n    # - add 6 per case for the length of the JUMPDEST and JUMP(ADD(PC, action_jump_length))\n    #   bytecode\n    # - add 3 to the total to account for this action's JUMP; the PC within the call\n    #   requires a \"correction\" of 3.\n\n    bytecode = Bytecode()\n\n    # All conditions get pre-pended to this bytecode; if none are met, we reach the default\n    if evm_code_type == EVMCodeType.LEGACY:\n        action_jump_length = sum(len(case.action) + 6 for case in cases) + 3\n        bytecode = default_action + Op.JUMP(Op.ADD(Op.PC, action_jump_length))\n        # The length required to jump over the default action and its JUMP bytecode\n        condition_jump_length = len(bytecode) + 3\n    elif evm_code_type == EVMCodeType.EOF_V1:\n        action_jump_length = sum(\n            len(case.action) + (len(Op.RJUMP[0]) if not case.is_terminating else 0)\n            for case in cases\n            # On not terminating cases, we need to add 3 bytes for the RJUMP\n        )\n        bytecode = default_action + Op.RJUMP[action_jump_length]\n        # The length required to jump over the default action and its JUMP bytecode\n        condition_jump_length = len(bytecode)\n\n    # Reversed: first case in the list has priority; it will become the outer-most onion layer.\n    # We build up layers around the default_action, after 1 iteration of the loop, a simplified\n    # representation of the bytecode is:\n    #\n    #  JUMPI(case[n-1].condition)\n    #  + default_action + JUMP()\n    #  + JUMPDEST + case[n-1].action + JUMP()\n    #\n    # and after n=len(cases) iterations:\n    #\n    #  JUMPI(case[0].condition)\n    #  + JUMPI(case[1].condition)\n    #    ...\n    #  + JUMPI(case[n-1].condition)\n    #  + default_action + JUMP()\n    #  + JUMPDEST + case[n-1].action + JUMP()\n    #  + ...\n    #  + JUMPDEST + case[1].action + JUMP()\n    #  + JUMPDEST + case[0].action + JUMP()\n    #\n    for case in reversed(cases):\n        action = case.action\n        if evm_code_type == EVMCodeType.LEGACY:\n            action_jump_length -= len(action) + 6\n            action = Op.JUMPDEST + action + Op.JUMP(Op.ADD(Op.PC, action_jump_length))\n            condition = Op.JUMPI(Op.ADD(Op.PC, condition_jump_length), case.condition)\n        elif evm_code_type == EVMCodeType.EOF_V1:\n            action_jump_length -= len(action) + (\n                len(Op.RJUMP[0]) if not case.is_terminating else 0\n            )\n            if not case.is_terminating:\n                action += Op.RJUMP[action_jump_length]\n            condition = Op.RJUMPI[condition_jump_length](case.condition)\n        # wrap the current case around the onion as its next layer\n        bytecode = condition + bytecode + action\n        condition_jump_length += len(condition) + len(action)\n\n    bytecode += Op.JUMPDEST\n\n    instance = super().__new__(cls, bytecode)\n    instance.default_action = default_action\n    instance.cases = cases\n    return instance\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Yul","title":"<code>Yul</code>","text":"<p>               Bases: <code>Bytecode</code></p> <p>Yul compiler. Compiles Yul source code into bytecode.</p> Source code in <code>src/ethereum_test_tools/code/yul.py</code> <pre><code>class Yul(Bytecode):\n    \"\"\"\n    Yul compiler.\n    Compiles Yul source code into bytecode.\n    \"\"\"\n\n    source: str\n    evm_version: str | None\n\n    def __new__(\n        cls,\n        source: str,\n        fork: Optional[Fork] = None,\n        binary: Optional[Path | str] = None,\n    ):\n        \"\"\"Compile Yul source code into bytecode.\"\"\"\n        solc = Solc(binary)\n        evm_version = fork.solc_name() if fork else None\n\n        solc_args = (\"--evm-version\", evm_version) if evm_version else ()\n\n        result = solc.run(*solc_args, *DEFAULT_SOLC_ARGS, input_value=source)\n\n        if result.returncode:\n            stderr_lines = result.stderr.splitlines()\n            stderr_message = \"\\n\".join(line.strip() for line in stderr_lines)\n            raise Exception(f\"failed to compile yul source:\\n{stderr_message[7:]}\")\n\n        lines = result.stdout.splitlines()\n\n        hex_str = lines[lines.index(\"Binary representation:\") + 1]\n\n        bytecode = bytes.fromhex(hex_str)\n        instance = super().__new__(\n            cls,\n            bytecode,\n            popped_stack_items=0,\n            pushed_stack_items=0,\n        )\n        instance.source = source\n        instance.evm_version = evm_version\n        return instance\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Yul.__new__","title":"<code>__new__(source, fork=None, binary=None)</code>","text":"<p>Compile Yul source code into bytecode.</p> Source code in <code>src/ethereum_test_tools/code/yul.py</code> <pre><code>def __new__(\n    cls,\n    source: str,\n    fork: Optional[Fork] = None,\n    binary: Optional[Path | str] = None,\n):\n    \"\"\"Compile Yul source code into bytecode.\"\"\"\n    solc = Solc(binary)\n    evm_version = fork.solc_name() if fork else None\n\n    solc_args = (\"--evm-version\", evm_version) if evm_version else ()\n\n    result = solc.run(*solc_args, *DEFAULT_SOLC_ARGS, input_value=source)\n\n    if result.returncode:\n        stderr_lines = result.stderr.splitlines()\n        stderr_message = \"\\n\".join(line.strip() for line in stderr_lines)\n        raise Exception(f\"failed to compile yul source:\\n{stderr_message[7:]}\")\n\n    lines = result.stdout.splitlines()\n\n    hex_str = lines[lines.index(\"Binary representation:\") + 1]\n\n    bytecode = bytes.fromhex(hex_str)\n    instance = super().__new__(\n        cls,\n        bytecode,\n        popped_stack_items=0,\n        pushed_stack_items=0,\n    )\n    instance.source = source\n    instance.evm_version = evm_version\n    return instance\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.DeploymentTestType","title":"<code>DeploymentTestType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Represents the type of deployment test.</p> Source code in <code>src/ethereum_test_tools/utility/generators.py</code> <pre><code>class DeploymentTestType(Enum):\n    \"\"\"Represents the type of deployment test.\"\"\"\n\n    DEPLOY_BEFORE_FORK = \"deploy_before_fork\"\n    DEPLOY_AFTER_FORK = \"deploy_after_fork\"\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.generate_system_contract_deploy_test","title":"<code>generate_system_contract_deploy_test(*, fork, tx_json_path, expected_deploy_address, expected_system_contract_storage=None)</code>","text":"<p>Generate a test that verifies the correct deployment of a system contract.</p> <p>Generates four test cases:</p> <pre><code>                                | before/after fork | has balance |\n</code></pre> <p>------------------------------------|-------------------|-------------| <code>deploy_before_fork-nonzero_balance</code>| before            | True        | <code>deploy_before_fork-zero_balance</code>   | before            | False       | <code>deploy_after_fork-nonzero_balance</code> | after             | True        | <code>deploy_after_fork-zero_balance</code>    | after             | False       |</p> <p>where <code>has balance</code> refers to whether the contract address has a non-zero balance before deployment, or not.</p> <p>Parameters:</p> Name Type Description Default <code>fork</code> <code>Fork</code> <p>The fork to test.</p> required <code>tx_json_path</code> <code>Path</code> <p>Path to the JSON file with the transaction to deploy the system contract. Providing a JSON file is useful to copy-paste the transaction from the EIP.</p> required <code>expected_deploy_address</code> <code>Address</code> <p>The expected address of the deployed contract.</p> required <code>expected_system_contract_storage</code> <code>Dict | None</code> <p>The expected storage of the system contract.</p> <code>None</code> Source code in <code>src/ethereum_test_tools/utility/generators.py</code> <pre><code>def generate_system_contract_deploy_test(\n    *,\n    fork: Fork,\n    tx_json_path: Path,\n    expected_deploy_address: Address,\n    expected_system_contract_storage: Dict | None = None,\n):\n    \"\"\"\n    Generate a test that verifies the correct deployment of a system contract.\n\n    Generates four test cases:\n\n                                        | before/after fork | has balance |\n    ------------------------------------|-------------------|-------------|\n    `deploy_before_fork-nonzero_balance`| before            | True        |\n    `deploy_before_fork-zero_balance`   | before            | False       |\n    `deploy_after_fork-nonzero_balance` | after             | True        |\n    `deploy_after_fork-zero_balance`    | after             | False       |\n\n    where `has balance` refers to whether the contract address has a non-zero balance before\n    deployment, or not.\n\n    Args:\n        fork (Fork): The fork to test.\n        tx_json_path (Path): Path to the JSON file with the transaction to deploy the system\n            contract.\n            Providing a JSON file is useful to copy-paste the transaction from the EIP.\n        expected_deploy_address (Address): The expected address of the deployed contract.\n        expected_system_contract_storage (Dict | None): The expected storage of the system\n            contract.\n\n    \"\"\"\n    with open(tx_json_path, mode=\"r\") as f:\n        tx_json = json.loads(f.read())\n    if \"gasLimit\" not in tx_json and \"gas\" in tx_json:\n        tx_json[\"gasLimit\"] = tx_json[\"gas\"]\n        del tx_json[\"gas\"]\n    if \"protected\" not in tx_json:\n        tx_json[\"protected\"] = False\n    deploy_tx = Transaction.model_validate(tx_json).with_signature_and_sender()  # type: ignore\n    gas_price = deploy_tx.gas_price\n    assert gas_price is not None\n    deployer_required_balance = deploy_tx.gas_limit * gas_price\n    deployer_address = deploy_tx.sender\n    if \"hash\" in tx_json:\n        assert deploy_tx.hash == Hash(tx_json[\"hash\"])\n    if \"sender\" in tx_json:\n        assert deploy_tx.sender == Address(tx_json[\"sender\"])\n\n    def decorator(func: SystemContractDeployTestFunction):\n        @pytest.mark.parametrize(\n            \"has_balance\",\n            [\n                pytest.param(ContractAddressHasBalance.NONZERO_BALANCE),\n                pytest.param(ContractAddressHasBalance.ZERO_BALANCE),\n            ],\n            ids=lambda x: x.name.lower(),\n        )\n        @pytest.mark.parametrize(\n            \"test_type\",\n            [\n                pytest.param(DeploymentTestType.DEPLOY_BEFORE_FORK),\n                pytest.param(DeploymentTestType.DEPLOY_AFTER_FORK),\n            ],\n            ids=lambda x: x.name.lower(),\n        )\n        @pytest.mark.execute(pytest.mark.skip(reason=\"modifies pre-alloc\"))\n        @pytest.mark.valid_at_transition_to(fork.name())\n        def wrapper(\n            blockchain_test: BlockchainTestFiller,\n            has_balance: ContractAddressHasBalance,\n            pre: Alloc,\n            test_type: DeploymentTestType,\n            fork: Fork,\n        ):\n            assert deployer_address is not None\n            assert deploy_tx.created_contract == expected_deploy_address\n            blocks: List[Block] = []\n\n            if test_type == DeploymentTestType.DEPLOY_BEFORE_FORK:\n                blocks = [\n                    Block(  # Deployment block\n                        txs=[deploy_tx],\n                        timestamp=14_999,\n                    ),\n                    Block(  # Empty block on fork\n                        txs=[],\n                        timestamp=15_000,\n                    ),\n                ]\n            elif test_type == DeploymentTestType.DEPLOY_AFTER_FORK:\n                blocks = [\n                    Block(  # Empty block on fork\n                        txs=[],\n                        timestamp=15_000,\n                    ),\n                    Block(  # Deployment block\n                        txs=[deploy_tx],\n                        timestamp=15_001,\n                    ),\n                ]\n            balance = 1 if has_balance == ContractAddressHasBalance.NONZERO_BALANCE else 0\n            pre[expected_deploy_address] = Account(\n                code=b\"\",  # Remove the code that is automatically allocated on the fork\n                nonce=0,\n                balance=balance,\n            )\n            pre[deployer_address] = Account(\n                balance=deployer_required_balance,\n            )\n\n            expected_deploy_address_int = int.from_bytes(expected_deploy_address, \"big\")\n\n            post = Alloc()\n            fork_pre_allocation = fork.pre_allocation_blockchain()\n            assert expected_deploy_address_int in fork_pre_allocation\n            expected_code = fork_pre_allocation[expected_deploy_address_int][\"code\"]\n            # Note: balance check is omitted; it may be modified by the underlying, decorated test\n            if expected_system_contract_storage is None:\n                post[expected_deploy_address] = Account(\n                    code=expected_code,\n                    nonce=1,\n                )\n            else:\n                post[expected_deploy_address] = Account(\n                    storage=expected_system_contract_storage,\n                    code=expected_code,\n                    nonce=1,\n                )\n            post[deployer_address] = Account(\n                nonce=1,\n            )\n\n            # Extra blocks (if any) returned by the decorated function to add after the\n            # contract is deployed.\n            blocks += list(func(fork=fork, pre=pre, post=post, test_type=test_type))\n\n            blockchain_test(\n                pre=pre,\n                blocks=blocks,\n                post=post,\n            )\n\n        wrapper.__name__ = func.__name__  # type: ignore\n        wrapper.__doc__ = func.__doc__  # type: ignore\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.extend_with_defaults","title":"<code>extend_with_defaults(defaults, cases, **parametrize_kwargs)</code>","text":"<p>Extend test cases with default parameter values.</p> <p>This utility function extends test case parameters by adding default values from the <code>defaults</code> dictionary to each case in the <code>cases</code> list. If a case already specifies a value for a parameter, its default is ignored.</p> <p>This function is particularly useful in scenarios where you want to define a common set of default values but allow individual test cases to override them as needed.</p> <p>The function returns a dictionary that can be directly unpacked and passed to the <code>@pytest.mark.parametrize</code> decorator.</p> <p>Parameters:</p> Name Type Description Default <code>defaults</code> <code>Dict[str, Any]</code> <p>A dictionary of default parameter names and their values. These values will be added to each case unless the case already defines a value for each parameter.</p> required <code>cases</code> <code>List[ParameterSet]</code> <p>A list of <code>pytest.param</code> objects representing different test cases. Its first argument must be a dictionary defining parameter names and values.</p> required <code>parametrize_kwargs</code> <code>Any</code> <p>Additional keyword arguments to be passed to <code>@pytest.mark.parametrize</code>. These arguments are not modified by this function and are passed through unchanged.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary with the following structure: <code>argnames</code>: A list of parameter names. <code>argvalues</code>: A list of test cases with modified parameter values. <code>parametrize_kwargs</code>: Additional keyword arguments passed through unchanged.</p> Example <pre><code>@pytest.mark.parametrize(**extend_with_defaults(\n    defaults=dict(\n        min_value=0,  # default minimum value is 0\n        max_value=100,  # default maximum value is 100\n        average=50,  # default average value is 50\n    ),\n    cases=[\n        pytest.param(\n            dict(),  # use default values\n            id='default_case',\n        ),\n        pytest.param(\n            dict(min_value=10),  # override with min_value=10\n            id='min_value_10',\n        ),\n        pytest.param(\n            dict(max_value=200),  # override with max_value=200\n            id='max_value_200',\n        ),\n        pytest.param(\n            dict(min_value=-10, max_value=50),  # override both min_value\n            # and max_value\n            id='min_-10_max_50',\n        ),\n        pytest.param(\n            dict(min_value=20, max_value=80, average=50),  # all defaults\n            # are overridden\n            id=\"min_20_max_80_avg_50\",\n        ),\n        pytest.param(\n            dict(min_value=100, max_value=0),  # invalid range\n            id='invalid_range',\n            marks=pytest.mark.xfail(reason='invalid range'),\n        )\n    ],\n))\ndef test_range(min_value, max_value, average):\n    assert min_value &lt;= max_value\n    assert min_value &lt;= average &lt;= max_value\n</code></pre> <p>The above test will execute with the following sets of parameters:</p> <pre><code>\"default_case\": {\"min_value\": 0, \"max_value\": 100, \"average\": 50}\n\"min_value_10\": {\"min_value\": 10, \"max_value\": 100, \"average\": 50}\n\"max_value_200\": {\"min_value\": 0, \"max_value\": 200, \"average\": 50}\n\"min_-10_max_50\": {\"min_value\": -10, \"max_value\": 50, \"average\": 50}\n\"min_20_max_80_avg_50\": {\"min_value\": 20, \"max_value\": 80, \"average\": 50}\n\"invalid_range\": {\"min_value\": 100, \"max_value\": 0, \"average\": 50}  # expected to fail\n</code></pre> Notes <ul> <li>Each case in <code>cases</code> must contain exactly one value, which is a dictionary   of parameter values.</li> <li>The function performs an in-place update of the <code>cases</code> list, so the   original <code>cases</code> list is modified.</li> </ul> Source code in <code>src/ethereum_test_tools/utility/pytest.py</code> <pre><code>def extend_with_defaults(\n    defaults: Dict[str, Any], cases: List[ParameterSet], **parametrize_kwargs: Any\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Extend test cases with default parameter values.\n\n    This utility function extends test case parameters by adding default values\n    from the `defaults` dictionary to each case in the `cases` list. If a case\n    already specifies a value for a parameter, its default is ignored.\n\n    This function is particularly useful in scenarios where you want to define\n    a common set of default values but allow individual test cases to override\n    them as needed.\n\n    The function returns a dictionary that can be directly unpacked and passed\n    to the `@pytest.mark.parametrize` decorator.\n\n    Args:\n        defaults (Dict[str, Any]): A dictionary of default parameter names and\n            their values. These values will be added to each case unless the case\n            already defines a value for each parameter.\n        cases (List[ParameterSet]): A list of `pytest.param` objects representing\n            different test cases. Its first argument must be a dictionary defining\n            parameter names and values.\n        parametrize_kwargs (Any): Additional keyword arguments to be passed to\n            `@pytest.mark.parametrize`. These arguments are not modified by this\n            function and are passed through unchanged.\n\n    Returns:\n        Dict[str, Any]: A dictionary with the following structure:\n            `argnames`: A list of parameter names.\n            `argvalues`: A list of test cases with modified parameter values.\n            `parametrize_kwargs`: Additional keyword arguments passed through unchanged.\n\n\n    Example:\n        ```python\n        @pytest.mark.parametrize(**extend_with_defaults(\n            defaults=dict(\n                min_value=0,  # default minimum value is 0\n                max_value=100,  # default maximum value is 100\n                average=50,  # default average value is 50\n            ),\n            cases=[\n                pytest.param(\n                    dict(),  # use default values\n                    id='default_case',\n                ),\n                pytest.param(\n                    dict(min_value=10),  # override with min_value=10\n                    id='min_value_10',\n                ),\n                pytest.param(\n                    dict(max_value=200),  # override with max_value=200\n                    id='max_value_200',\n                ),\n                pytest.param(\n                    dict(min_value=-10, max_value=50),  # override both min_value\n                    # and max_value\n                    id='min_-10_max_50',\n                ),\n                pytest.param(\n                    dict(min_value=20, max_value=80, average=50),  # all defaults\n                    # are overridden\n                    id=\"min_20_max_80_avg_50\",\n                ),\n                pytest.param(\n                    dict(min_value=100, max_value=0),  # invalid range\n                    id='invalid_range',\n                    marks=pytest.mark.xfail(reason='invalid range'),\n                )\n            ],\n        ))\n        def test_range(min_value, max_value, average):\n            assert min_value &lt;= max_value\n            assert min_value &lt;= average &lt;= max_value\n        ```\n\n    The above test will execute with the following sets of parameters:\n\n    ```python\n    \"default_case\": {\"min_value\": 0, \"max_value\": 100, \"average\": 50}\n    \"min_value_10\": {\"min_value\": 10, \"max_value\": 100, \"average\": 50}\n    \"max_value_200\": {\"min_value\": 0, \"max_value\": 200, \"average\": 50}\n    \"min_-10_max_50\": {\"min_value\": -10, \"max_value\": 50, \"average\": 50}\n    \"min_20_max_80_avg_50\": {\"min_value\": 20, \"max_value\": 80, \"average\": 50}\n    \"invalid_range\": {\"min_value\": 100, \"max_value\": 0, \"average\": 50}  # expected to fail\n    ```\n\n    Notes:\n        - Each case in `cases` must contain exactly one value, which is a dictionary\n          of parameter values.\n        - The function performs an in-place update of the `cases` list, so the\n          original `cases` list is modified.\n\n    \"\"\"\n    for i, case in enumerate(cases):\n        if not (len(case.values) == 1 and isinstance(case.values[0], dict)):\n            raise ValueError(\n                \"each case must contain exactly one value; a dict of parameter values\"\n            )\n        if set(case.values[0].keys()) - set(defaults.keys()):\n            raise UnknownParameterInCasesError()\n        # Overwrite values in defaults if the parameter is present in the test case values\n        merged_params = {**defaults, **case.values[0]}  # type: ignore\n        cases[i] = pytest.param(*merged_params.values(), id=case.id, marks=case.marks)\n\n    return {\"argnames\": list(defaults), \"argvalues\": cases, **parametrize_kwargs}\n</code></pre>"},{"location":"library/ethereum_test_types/","title":"Ethereum Test Types package","text":"<p>Common definitions and types.</p>"},{"location":"library/ethereum_test_types/#ethereum_test_types.TestParameterGroup","title":"<code>TestParameterGroup</code>  <code>dataclass</code>","text":"<p>Base class for grouping test parameters in a dataclass. Provides a generic repr method to generate clean test ids, including only non-default optional fields.</p> Source code in <code>src/ethereum_test_types/helpers.py</code> <pre><code>@dataclass(kw_only=True, frozen=True, repr=False)\nclass TestParameterGroup:\n    \"\"\"\n    Base class for grouping test parameters in a dataclass. Provides a generic\n    __repr__ method to generate clean test ids, including only non-default\n    optional fields.\n    \"\"\"\n\n    __test__ = False  # explicitly prevent pytest collecting this class\n\n    def __repr__(self):\n        \"\"\"\n        Generate repr string, intended to be used as a test id, based on the class\n        name and the values of the non-default optional fields.\n        \"\"\"\n        class_name = self.__class__.__name__\n        field_strings = []\n\n        for field in fields(self):\n            value = getattr(self, field.name)\n            # Include the field only if it is not optional or not set to its default value\n            if field.default is MISSING or field.default != value:\n                field_strings.append(f\"{field.name}_{value}\")\n\n        return f\"{class_name}_{'-'.join(field_strings)}\"\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.TestParameterGroup.__repr__","title":"<code>__repr__()</code>","text":"<p>Generate repr string, intended to be used as a test id, based on the class name and the values of the non-default optional fields.</p> Source code in <code>src/ethereum_test_types/helpers.py</code> <pre><code>def __repr__(self):\n    \"\"\"\n    Generate repr string, intended to be used as a test id, based on the class\n    name and the values of the non-default optional fields.\n    \"\"\"\n    class_name = self.__class__.__name__\n    field_strings = []\n\n    for field in fields(self):\n        value = getattr(self, field.name)\n        # Include the field only if it is not optional or not set to its default value\n        if field.default is MISSING or field.default != value:\n            field_strings.append(f\"{field.name}_{value}\")\n\n    return f\"{class_name}_{'-'.join(field_strings)}\"\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.add_kzg_version","title":"<code>add_kzg_version(b_hashes, kzg_version)</code>","text":"<p>Add  Kzg Version to each blob hash.</p> Source code in <code>src/ethereum_test_types/helpers.py</code> <pre><code>def add_kzg_version(\n    b_hashes: List[bytes | SupportsBytes | int | str], kzg_version: int\n) -&gt; List[Hash]:\n    \"\"\"Add  Kzg Version to each blob hash.\"\"\"\n    kzg_version_hex = bytes([kzg_version])\n    kzg_versioned_hashes = []\n\n    for b_hash in b_hashes:\n        b_hash = bytes(Hash(b_hash))\n        if isinstance(b_hash, int) or isinstance(b_hash, str):\n            kzg_versioned_hashes.append(Hash(kzg_version_hex + b_hash[1:]))\n        elif isinstance(b_hash, bytes) or isinstance(b_hash, SupportsBytes):\n            if isinstance(b_hash, SupportsBytes):\n                b_hash = bytes(b_hash)\n            kzg_versioned_hashes.append(Hash(kzg_version_hex + b_hash[1:]))\n        else:\n            raise TypeError(\"Blob hash must be either an integer, string or bytes\")\n    return kzg_versioned_hashes\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.ceiling_division","title":"<code>ceiling_division(a, b)</code>","text":"<p>Calculate ceil without using floating point. Used by many of the EVM's formulas.</p> Source code in <code>src/ethereum_test_types/helpers.py</code> <pre><code>def ceiling_division(a: int, b: int) -&gt; int:\n    \"\"\"\n    Calculate ceil without using floating point.\n    Used by many of the EVM's formulas.\n    \"\"\"\n    return -(a // -b)\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.compute_create2_address","title":"<code>compute_create2_address(address, salt, initcode)</code>","text":"<p>Compute address of the resulting contract created using the <code>CREATE2</code> opcode.</p> Source code in <code>src/ethereum_test_types/helpers.py</code> <pre><code>def compute_create2_address(\n    address: FixedSizeBytesConvertible, salt: FixedSizeBytesConvertible, initcode: BytesConvertible\n) -&gt; Address:\n    \"\"\"\n    Compute address of the resulting contract created using the `CREATE2`\n    opcode.\n    \"\"\"\n    hash_bytes = Bytes(\n        b\"\\xff\" + Address(address) + Hash(salt) + Bytes(initcode).keccak256()\n    ).keccak256()\n    return Address(hash_bytes[-20:])\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.compute_create_address","title":"<code>compute_create_address(*, address, nonce=None, salt=0, initcode=b'', opcode=Op.CREATE)</code>","text":"<p>Compute address of the resulting contract created using a transaction or the <code>CREATE</code> opcode.</p> Source code in <code>src/ethereum_test_types/helpers.py</code> <pre><code>def compute_create_address(\n    *,\n    address: FixedSizeBytesConvertible | EOA,\n    nonce: int | None = None,\n    salt: int = 0,\n    initcode: BytesConvertible = b\"\",\n    opcode: Op = Op.CREATE,\n) -&gt; Address:\n    \"\"\"\n    Compute address of the resulting contract created using a transaction\n    or the `CREATE` opcode.\n    \"\"\"\n    if opcode == Op.CREATE:\n        if isinstance(address, EOA):\n            if nonce is None:\n                nonce = address.nonce\n        else:\n            address = Address(address)\n        if nonce is None:\n            nonce = 0\n        hash_bytes = Bytes(eth_rlp.encode([address, int_to_bytes(nonce)])).keccak256()\n        return Address(hash_bytes[-20:])\n    if opcode == Op.CREATE2:\n        return compute_create2_address(address, salt, initcode)\n    raise ValueError(\"Unsupported opcode\")\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.compute_eofcreate_address","title":"<code>compute_eofcreate_address(address, salt, init_container)</code>","text":"<p>Compute address of the resulting contract created using the <code>EOFCREATE</code> opcode.</p> Source code in <code>src/ethereum_test_types/helpers.py</code> <pre><code>def compute_eofcreate_address(\n    address: FixedSizeBytesConvertible,\n    salt: FixedSizeBytesConvertible,\n    init_container: BytesConvertible,\n) -&gt; Address:\n    \"\"\"Compute address of the resulting contract created using the `EOFCREATE` opcode.\"\"\"\n    hash_bytes = Bytes(\n        b\"\\xff\" + Address(address) + Hash(salt) + Bytes(init_container).keccak256()\n    ).keccak256()\n    return Address(hash_bytes[-20:])\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.EOA","title":"<code>EOA</code>","text":"<p>               Bases: <code>Address</code></p> <p>An Externally Owned Account (EOA) is an account controlled by a private key.</p> <p>The EOA is defined by its address and (optionally) by its corresponding private key.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>class EOA(Address):\n    \"\"\"\n    An Externally Owned Account (EOA) is an account controlled by a private key.\n\n    The EOA is defined by its address and (optionally) by its corresponding private key.\n    \"\"\"\n\n    key: Hash | None\n    nonce: Number\n\n    def __new__(\n        cls,\n        address: \"FixedSizeBytesConvertible | Address | EOA | None\" = None,\n        *,\n        key: FixedSizeBytesConvertible | None = None,\n        nonce: NumberConvertible = 0,\n    ):\n        \"\"\"Init the EOA.\"\"\"\n        if address is None:\n            if key is None:\n                raise ValueError(\"impossible to initialize EOA without address\")\n            private_key = PrivateKey(Hash(key))\n            public_key = private_key.public_key\n            address = Address(keccak256(public_key.format(compressed=False)[1:])[32 - 20 :])\n        elif isinstance(address, EOA):\n            return address\n        instance = super(EOA, cls).__new__(cls, address)\n        instance.key = Hash(key) if key is not None else None\n        instance.nonce = Number(nonce)\n        return instance\n\n    def get_nonce(self) -&gt; Number:\n        \"\"\"Return current nonce of the EOA and increments it by one.\"\"\"\n        nonce = self.nonce\n        self.nonce = Number(nonce + 1)\n        return nonce\n\n    def copy(self) -&gt; \"EOA\":\n        \"\"\"Return copy of the EOA.\"\"\"\n        return EOA(Address(self), key=self.key, nonce=self.nonce)\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.EOA.__new__","title":"<code>__new__(address=None, *, key=None, nonce=0)</code>","text":"<p>Init the EOA.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def __new__(\n    cls,\n    address: \"FixedSizeBytesConvertible | Address | EOA | None\" = None,\n    *,\n    key: FixedSizeBytesConvertible | None = None,\n    nonce: NumberConvertible = 0,\n):\n    \"\"\"Init the EOA.\"\"\"\n    if address is None:\n        if key is None:\n            raise ValueError(\"impossible to initialize EOA without address\")\n        private_key = PrivateKey(Hash(key))\n        public_key = private_key.public_key\n        address = Address(keccak256(public_key.format(compressed=False)[1:])[32 - 20 :])\n    elif isinstance(address, EOA):\n        return address\n    instance = super(EOA, cls).__new__(cls, address)\n    instance.key = Hash(key) if key is not None else None\n    instance.nonce = Number(nonce)\n    return instance\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.EOA.get_nonce","title":"<code>get_nonce()</code>","text":"<p>Return current nonce of the EOA and increments it by one.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def get_nonce(self) -&gt; Number:\n    \"\"\"Return current nonce of the EOA and increments it by one.\"\"\"\n    nonce = self.nonce\n    self.nonce = Number(nonce + 1)\n    return nonce\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.EOA.copy","title":"<code>copy()</code>","text":"<p>Return copy of the EOA.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def copy(self) -&gt; \"EOA\":\n    \"\"\"Return copy of the EOA.\"\"\"\n    return EOA(Address(self), key=self.key, nonce=self.nonce)\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Account","title":"<code>Account</code>","text":"<p>               Bases: <code>CamelModel</code></p> <p>State associated with an address.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>class Account(CamelModel):\n    \"\"\"State associated with an address.\"\"\"\n\n    nonce: ZeroPaddedHexNumber = ZeroPaddedHexNumber(0)\n    \"\"\"\n    The scalar value equal to a) the number of transactions sent by\n    an Externally Owned Account, b) the amount of contracts created by a\n    contract.\n    \"\"\"\n    balance: ZeroPaddedHexNumber = ZeroPaddedHexNumber(0)\n    \"\"\"\n    The amount of Wei (10&lt;sup&gt;-18&lt;/sup&gt; Eth) the account has.\n    \"\"\"\n    code: Bytes = Bytes(b\"\")\n    \"\"\"\n    Bytecode contained by the account.\n    \"\"\"\n    storage: Storage = Field(default_factory=Storage)\n    \"\"\"\n    Storage within a contract.\n    \"\"\"\n\n    NONEXISTENT: ClassVar[None] = None\n    \"\"\"\n    Sentinel object used to specify when an account should not exist in the\n    state.\n    \"\"\"\n\n    @dataclass(kw_only=True)\n    class NonceMismatchError(Exception):\n        \"\"\"\n        Test expected a certain nonce value for an account but a different\n        value was found.\n        \"\"\"\n\n        address: Address\n        want: int | None\n        got: int | None\n\n        def __init__(self, address: Address, want: int | None, got: int | None, *args):\n            \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n            super().__init__(args)\n            self.address = address\n            self.want = want\n            self.got = got\n\n        def __str__(self):\n            \"\"\"Print exception string.\"\"\"\n            label_str = \"\"\n            if self.address.label is not None:\n                label_str = f\" ({self.address.label})\"\n            return (\n                f\"unexpected nonce for account {self.address}{label_str}: \"\n                + f\"want {self.want}, got {self.got}\"\n            )\n\n    @dataclass(kw_only=True)\n    class BalanceMismatchError(Exception):\n        \"\"\"\n        Test expected a certain balance for an account but a different\n        value was found.\n        \"\"\"\n\n        address: Address\n        want: int | None\n        got: int | None\n\n        def __init__(self, address: Address, want: int | None, got: int | None, *args):\n            \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n            super().__init__(args)\n            self.address = address\n            self.want = want\n            self.got = got\n\n        def __str__(self):\n            \"\"\"Print exception string.\"\"\"\n            label_str = \"\"\n            if self.address.label is not None:\n                label_str = f\" ({self.address.label})\"\n            return (\n                f\"unexpected balance for account {self.address}{label_str}: \"\n                + f\"want {self.want}, got {self.got}\"\n            )\n\n    @dataclass(kw_only=True)\n    class CodeMismatchError(Exception):\n        \"\"\"\n        Test expected a certain bytecode for an account but a different\n        one was found.\n        \"\"\"\n\n        address: Address\n        want: bytes | None\n        got: bytes | None\n\n        def __init__(self, address: Address, want: bytes | None, got: bytes | None, *args):\n            \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n            super().__init__(args)\n            self.address = address\n            self.want = want\n            self.got = got\n\n        def __str__(self):\n            \"\"\"Print exception string.\"\"\"\n            label_str = \"\"\n            if self.address.label is not None:\n                label_str = f\" ({self.address.label})\"\n            return (\n                f\"unexpected code for account {self.address}{label_str}: \"\n                + f\"want {self.want}, got {self.got}\"\n            )\n\n    def check_alloc(self: \"Account\", address: Address, account: \"Account\"):\n        \"\"\"\n        Check the returned alloc against an expected account in post state.\n        Raises exception on failure.\n        \"\"\"\n        if \"nonce\" in self.model_fields_set:\n            if self.nonce != account.nonce:\n                raise Account.NonceMismatchError(\n                    address=address,\n                    want=self.nonce,\n                    got=account.nonce,\n                )\n\n        if \"balance\" in self.model_fields_set:\n            if self.balance != account.balance:\n                raise Account.BalanceMismatchError(\n                    address=address,\n                    want=self.balance,\n                    got=account.balance,\n                )\n\n        if \"code\" in self.model_fields_set:\n            if self.code != account.code:\n                raise Account.CodeMismatchError(\n                    address=address,\n                    want=self.code,\n                    got=account.code,\n                )\n\n        if \"storage\" in self.model_fields_set:\n            self.storage.must_be_equal(address=address, other=account.storage)\n\n    def __bool__(self: \"Account\") -&gt; bool:\n        \"\"\"Return True on a non-empty account.\"\"\"\n        return any((self.nonce, self.balance, self.code, self.storage))\n\n    @classmethod\n    def with_code(cls: Type, code: BytesConvertible) -&gt; \"Account\":\n        \"\"\"Create account with provided `code` and nonce of `1`.\"\"\"\n        return Account(nonce=HexNumber(1), code=Bytes(code))\n\n    @classmethod\n    def merge(\n        cls: Type, account_1: \"Dict | Account | None\", account_2: \"Dict | Account | None\"\n    ) -&gt; \"Account\":\n        \"\"\"Create a merged account from two sources.\"\"\"\n\n        def to_kwargs_dict(account: \"Dict | Account | None\") -&gt; Dict:\n            if account is None:\n                return {}\n            if isinstance(account, dict):\n                return account\n            elif isinstance(account, cls):\n                return account.model_dump(exclude_unset=True)\n            raise TypeError(f\"Unexpected type for account merge: {type(account)}\")\n\n        kwargs = to_kwargs_dict(account_1)\n        kwargs.update(to_kwargs_dict(account_2))\n\n        return cls(**kwargs)\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Account.nonce","title":"<code>nonce: ZeroPaddedHexNumber = ZeroPaddedHexNumber(0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The scalar value equal to a) the number of transactions sent by an Externally Owned Account, b) the amount of contracts created by a contract.</p>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Account.balance","title":"<code>balance: ZeroPaddedHexNumber = ZeroPaddedHexNumber(0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The amount of Wei (10<sup>-18</sup> Eth) the account has.</p>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Account.code","title":"<code>code: Bytes = Bytes(b'')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Bytecode contained by the account.</p>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Account.storage","title":"<code>storage: Storage = Field(default_factory=Storage)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Storage within a contract.</p>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Account.NONEXISTENT","title":"<code>NONEXISTENT: None = None</code>  <code>class-attribute</code>","text":"<p>Sentinel object used to specify when an account should not exist in the state.</p>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Account.NonceMismatchError","title":"<code>NonceMismatchError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Test expected a certain nonce value for an account but a different value was found.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>@dataclass(kw_only=True)\nclass NonceMismatchError(Exception):\n    \"\"\"\n    Test expected a certain nonce value for an account but a different\n    value was found.\n    \"\"\"\n\n    address: Address\n    want: int | None\n    got: int | None\n\n    def __init__(self, address: Address, want: int | None, got: int | None, *args):\n        \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n        super().__init__(args)\n        self.address = address\n        self.want = want\n        self.got = got\n\n    def __str__(self):\n        \"\"\"Print exception string.\"\"\"\n        label_str = \"\"\n        if self.address.label is not None:\n            label_str = f\" ({self.address.label})\"\n        return (\n            f\"unexpected nonce for account {self.address}{label_str}: \"\n            + f\"want {self.want}, got {self.got}\"\n        )\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Account.NonceMismatchError.__init__","title":"<code>__init__(address, want, got, *args)</code>","text":"<p>Initialize the exception with the address, wanted and got values.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __init__(self, address: Address, want: int | None, got: int | None, *args):\n    \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n    super().__init__(args)\n    self.address = address\n    self.want = want\n    self.got = got\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Account.NonceMismatchError.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __str__(self):\n    \"\"\"Print exception string.\"\"\"\n    label_str = \"\"\n    if self.address.label is not None:\n        label_str = f\" ({self.address.label})\"\n    return (\n        f\"unexpected nonce for account {self.address}{label_str}: \"\n        + f\"want {self.want}, got {self.got}\"\n    )\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Account.BalanceMismatchError","title":"<code>BalanceMismatchError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Test expected a certain balance for an account but a different value was found.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>@dataclass(kw_only=True)\nclass BalanceMismatchError(Exception):\n    \"\"\"\n    Test expected a certain balance for an account but a different\n    value was found.\n    \"\"\"\n\n    address: Address\n    want: int | None\n    got: int | None\n\n    def __init__(self, address: Address, want: int | None, got: int | None, *args):\n        \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n        super().__init__(args)\n        self.address = address\n        self.want = want\n        self.got = got\n\n    def __str__(self):\n        \"\"\"Print exception string.\"\"\"\n        label_str = \"\"\n        if self.address.label is not None:\n            label_str = f\" ({self.address.label})\"\n        return (\n            f\"unexpected balance for account {self.address}{label_str}: \"\n            + f\"want {self.want}, got {self.got}\"\n        )\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Account.BalanceMismatchError.__init__","title":"<code>__init__(address, want, got, *args)</code>","text":"<p>Initialize the exception with the address, wanted and got values.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __init__(self, address: Address, want: int | None, got: int | None, *args):\n    \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n    super().__init__(args)\n    self.address = address\n    self.want = want\n    self.got = got\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Account.BalanceMismatchError.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __str__(self):\n    \"\"\"Print exception string.\"\"\"\n    label_str = \"\"\n    if self.address.label is not None:\n        label_str = f\" ({self.address.label})\"\n    return (\n        f\"unexpected balance for account {self.address}{label_str}: \"\n        + f\"want {self.want}, got {self.got}\"\n    )\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Account.CodeMismatchError","title":"<code>CodeMismatchError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Test expected a certain bytecode for an account but a different one was found.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>@dataclass(kw_only=True)\nclass CodeMismatchError(Exception):\n    \"\"\"\n    Test expected a certain bytecode for an account but a different\n    one was found.\n    \"\"\"\n\n    address: Address\n    want: bytes | None\n    got: bytes | None\n\n    def __init__(self, address: Address, want: bytes | None, got: bytes | None, *args):\n        \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n        super().__init__(args)\n        self.address = address\n        self.want = want\n        self.got = got\n\n    def __str__(self):\n        \"\"\"Print exception string.\"\"\"\n        label_str = \"\"\n        if self.address.label is not None:\n            label_str = f\" ({self.address.label})\"\n        return (\n            f\"unexpected code for account {self.address}{label_str}: \"\n            + f\"want {self.want}, got {self.got}\"\n        )\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Account.CodeMismatchError.__init__","title":"<code>__init__(address, want, got, *args)</code>","text":"<p>Initialize the exception with the address, wanted and got values.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __init__(self, address: Address, want: bytes | None, got: bytes | None, *args):\n    \"\"\"Initialize the exception with the address, wanted and got values.\"\"\"\n    super().__init__(args)\n    self.address = address\n    self.want = want\n    self.got = got\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Account.CodeMismatchError.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __str__(self):\n    \"\"\"Print exception string.\"\"\"\n    label_str = \"\"\n    if self.address.label is not None:\n        label_str = f\" ({self.address.label})\"\n    return (\n        f\"unexpected code for account {self.address}{label_str}: \"\n        + f\"want {self.want}, got {self.got}\"\n    )\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Account.check_alloc","title":"<code>check_alloc(address, account)</code>","text":"<p>Check the returned alloc against an expected account in post state. Raises exception on failure.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def check_alloc(self: \"Account\", address: Address, account: \"Account\"):\n    \"\"\"\n    Check the returned alloc against an expected account in post state.\n    Raises exception on failure.\n    \"\"\"\n    if \"nonce\" in self.model_fields_set:\n        if self.nonce != account.nonce:\n            raise Account.NonceMismatchError(\n                address=address,\n                want=self.nonce,\n                got=account.nonce,\n            )\n\n    if \"balance\" in self.model_fields_set:\n        if self.balance != account.balance:\n            raise Account.BalanceMismatchError(\n                address=address,\n                want=self.balance,\n                got=account.balance,\n            )\n\n    if \"code\" in self.model_fields_set:\n        if self.code != account.code:\n            raise Account.CodeMismatchError(\n                address=address,\n                want=self.code,\n                got=account.code,\n            )\n\n    if \"storage\" in self.model_fields_set:\n        self.storage.must_be_equal(address=address, other=account.storage)\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Account.__bool__","title":"<code>__bool__()</code>","text":"<p>Return True on a non-empty account.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __bool__(self: \"Account\") -&gt; bool:\n    \"\"\"Return True on a non-empty account.\"\"\"\n    return any((self.nonce, self.balance, self.code, self.storage))\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Account.with_code","title":"<code>with_code(code)</code>  <code>classmethod</code>","text":"<p>Create account with provided <code>code</code> and nonce of <code>1</code>.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>@classmethod\ndef with_code(cls: Type, code: BytesConvertible) -&gt; \"Account\":\n    \"\"\"Create account with provided `code` and nonce of `1`.\"\"\"\n    return Account(nonce=HexNumber(1), code=Bytes(code))\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Account.merge","title":"<code>merge(account_1, account_2)</code>  <code>classmethod</code>","text":"<p>Create a merged account from two sources.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>@classmethod\ndef merge(\n    cls: Type, account_1: \"Dict | Account | None\", account_2: \"Dict | Account | None\"\n) -&gt; \"Account\":\n    \"\"\"Create a merged account from two sources.\"\"\"\n\n    def to_kwargs_dict(account: \"Dict | Account | None\") -&gt; Dict:\n        if account is None:\n            return {}\n        if isinstance(account, dict):\n            return account\n        elif isinstance(account, cls):\n            return account.model_dump(exclude_unset=True)\n        raise TypeError(f\"Unexpected type for account merge: {type(account)}\")\n\n    kwargs = to_kwargs_dict(account_1)\n    kwargs.update(to_kwargs_dict(account_2))\n\n    return cls(**kwargs)\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Alloc","title":"<code>Alloc</code>","text":"<p>               Bases: <code>Alloc</code></p> <p>Allocation of accounts in the state, pre and post test execution.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>class Alloc(BaseAlloc):\n    \"\"\"Allocation of accounts in the state, pre and post test execution.\"\"\"\n\n    _eoa_fund_amount_default: int = PrivateAttr(10**21)\n\n    @dataclass(kw_only=True)\n    class UnexpectedAccountError(Exception):\n        \"\"\"Unexpected account found in the allocation.\"\"\"\n\n        address: Address\n        account: Account | None\n\n        def __init__(self, address: Address, account: Account | None, *args):\n            \"\"\"Initialize the exception.\"\"\"\n            super().__init__(args)\n            self.address = address\n            self.account = account\n\n        def __str__(self):\n            \"\"\"Print exception string.\"\"\"\n            return f\"unexpected account in allocation {self.address}: {self.account}\"\n\n    @dataclass(kw_only=True)\n    class MissingAccountError(Exception):\n        \"\"\"Expected account not found in the allocation.\"\"\"\n\n        address: Address\n\n        def __init__(self, address: Address, *args):\n            \"\"\"Initialize the exception.\"\"\"\n            super().__init__(args)\n            self.address = address\n\n        def __str__(self):\n            \"\"\"Print exception string.\"\"\"\n            return f\"Account missing from allocation {self.address}\"\n\n    @classmethod\n    def merge(cls, alloc_1: \"Alloc\", alloc_2: \"Alloc\") -&gt; \"Alloc\":\n        \"\"\"Return merged allocation of two sources.\"\"\"\n        merged = alloc_1.model_dump()\n\n        for address, other_account in alloc_2.root.items():\n            merged_account = Account.merge(merged.get(address, None), other_account)\n            if merged_account:\n                merged[address] = merged_account\n            elif address in merged:\n                merged.pop(address, None)\n\n        return Alloc(merged)\n\n    def __iter__(self):\n        \"\"\"Return iterator over the allocation.\"\"\"\n        return iter(self.root)\n\n    def items(self):\n        \"\"\"Return iterator over the allocation items.\"\"\"\n        return self.root.items()\n\n    def __getitem__(self, address: Address | FixedSizeBytesConvertible) -&gt; Account | None:\n        \"\"\"Return account associated with an address.\"\"\"\n        if not isinstance(address, Address):\n            address = Address(address)\n        return self.root[address]\n\n    def __setitem__(self, address: Address | FixedSizeBytesConvertible, account: Account | None):\n        \"\"\"Set account associated with an address.\"\"\"\n        if not isinstance(address, Address):\n            address = Address(address)\n        self.root[address] = account\n\n    def __delitem__(self, address: Address | FixedSizeBytesConvertible):\n        \"\"\"Delete account associated with an address.\"\"\"\n        if not isinstance(address, Address):\n            address = Address(address)\n        self.root.pop(address, None)\n\n    def __eq__(self, other) -&gt; bool:\n        \"\"\"Return True if both allocations are equal.\"\"\"\n        if not isinstance(other, Alloc):\n            return False\n        return self.root == other.root\n\n    def __contains__(self, address: Address | FixedSizeBytesConvertible) -&gt; bool:\n        \"\"\"Check if an account is in the allocation.\"\"\"\n        if not isinstance(address, Address):\n            address = Address(address)\n        return address in self.root\n\n    def empty_accounts(self) -&gt; List[Address]:\n        \"\"\"Return list of addresses of empty accounts.\"\"\"\n        return [address for address, account in self.root.items() if not account]\n\n    def state_root(self) -&gt; bytes:\n        \"\"\"Return state root of the allocation.\"\"\"\n        state = State()\n        for address, account in self.root.items():\n            if account is None:\n                continue\n            set_account(\n                state=state,\n                address=FrontierAddress(address),\n                account=FrontierAccount(\n                    nonce=Uint(account.nonce) if account.nonce is not None else Uint(0),\n                    balance=(U256(account.balance) if account.balance is not None else U256(0)),\n                    code=account.code if account.code is not None else b\"\",\n                ),\n            )\n            if account.storage is not None:\n                for key, value in account.storage.root.items():\n                    set_storage(\n                        state=state,\n                        address=FrontierAddress(address),\n                        key=Bytes32(Hash(key)),\n                        value=U256(value),\n                    )\n        return state_root(state)\n\n    def verify_post_alloc(self, got_alloc: \"Alloc\"):\n        \"\"\"\n        Verify that the allocation matches the expected post in the test.\n        Raises exception on unexpected values.\n        \"\"\"\n        assert isinstance(got_alloc, Alloc), f\"got_alloc is not an Alloc: {got_alloc}\"\n        for address, account in self.root.items():\n            if account is None:\n                # Account must not exist\n                if address in got_alloc.root and got_alloc.root[address] is not None:\n                    raise Alloc.UnexpectedAccountError(address, got_alloc.root[address])\n            else:\n                if address in got_alloc.root:\n                    got_account = got_alloc.root[address]\n                    assert isinstance(got_account, Account)\n                    assert isinstance(account, Account)\n                    account.check_alloc(address, got_account)\n                else:\n                    raise Alloc.MissingAccountError(address)\n\n    def deploy_contract(\n        self,\n        code: BytesConvertible,\n        *,\n        storage: Storage | StorageRootType | None = None,\n        balance: NumberConvertible = 0,\n        nonce: NumberConvertible = 1,\n        address: Address | None = None,\n        evm_code_type: EVMCodeType | None = None,\n        label: str | None = None,\n    ) -&gt; Address:\n        \"\"\"Deploy a contract to the allocation.\"\"\"\n        raise NotImplementedError(\"deploy_contract is not implemented in the base class\")\n\n    def fund_eoa(\n        self,\n        amount: NumberConvertible | None = None,\n        label: str | None = None,\n        storage: Storage | None = None,\n        delegation: Address | Literal[\"Self\"] | None = None,\n        nonce: NumberConvertible | None = None,\n    ) -&gt; EOA:\n        \"\"\"Add a previously unused EOA to the pre-alloc with the balance specified by `amount`.\"\"\"\n        raise NotImplementedError(\"fund_eoa is not implemented in the base class\")\n\n    def fund_address(self, address: Address, amount: NumberConvertible):\n        \"\"\"\n        Fund an address with a given amount.\n\n        If the address is already present in the pre-alloc the amount will be\n        added to its existing balance.\n        \"\"\"\n        raise NotImplementedError(\"fund_address is not implemented in the base class\")\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Alloc.UnexpectedAccountError","title":"<code>UnexpectedAccountError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Unexpected account found in the allocation.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass UnexpectedAccountError(Exception):\n    \"\"\"Unexpected account found in the allocation.\"\"\"\n\n    address: Address\n    account: Account | None\n\n    def __init__(self, address: Address, account: Account | None, *args):\n        \"\"\"Initialize the exception.\"\"\"\n        super().__init__(args)\n        self.address = address\n        self.account = account\n\n    def __str__(self):\n        \"\"\"Print exception string.\"\"\"\n        return f\"unexpected account in allocation {self.address}: {self.account}\"\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Alloc.UnexpectedAccountError.__init__","title":"<code>__init__(address, account, *args)</code>","text":"<p>Initialize the exception.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def __init__(self, address: Address, account: Account | None, *args):\n    \"\"\"Initialize the exception.\"\"\"\n    super().__init__(args)\n    self.address = address\n    self.account = account\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Alloc.UnexpectedAccountError.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def __str__(self):\n    \"\"\"Print exception string.\"\"\"\n    return f\"unexpected account in allocation {self.address}: {self.account}\"\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Alloc.MissingAccountError","title":"<code>MissingAccountError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Expected account not found in the allocation.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass MissingAccountError(Exception):\n    \"\"\"Expected account not found in the allocation.\"\"\"\n\n    address: Address\n\n    def __init__(self, address: Address, *args):\n        \"\"\"Initialize the exception.\"\"\"\n        super().__init__(args)\n        self.address = address\n\n    def __str__(self):\n        \"\"\"Print exception string.\"\"\"\n        return f\"Account missing from allocation {self.address}\"\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Alloc.MissingAccountError.__init__","title":"<code>__init__(address, *args)</code>","text":"<p>Initialize the exception.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def __init__(self, address: Address, *args):\n    \"\"\"Initialize the exception.\"\"\"\n    super().__init__(args)\n    self.address = address\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Alloc.MissingAccountError.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def __str__(self):\n    \"\"\"Print exception string.\"\"\"\n    return f\"Account missing from allocation {self.address}\"\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Alloc.merge","title":"<code>merge(alloc_1, alloc_2)</code>  <code>classmethod</code>","text":"<p>Return merged allocation of two sources.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>@classmethod\ndef merge(cls, alloc_1: \"Alloc\", alloc_2: \"Alloc\") -&gt; \"Alloc\":\n    \"\"\"Return merged allocation of two sources.\"\"\"\n    merged = alloc_1.model_dump()\n\n    for address, other_account in alloc_2.root.items():\n        merged_account = Account.merge(merged.get(address, None), other_account)\n        if merged_account:\n            merged[address] = merged_account\n        elif address in merged:\n            merged.pop(address, None)\n\n    return Alloc(merged)\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Alloc.__iter__","title":"<code>__iter__()</code>","text":"<p>Return iterator over the allocation.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def __iter__(self):\n    \"\"\"Return iterator over the allocation.\"\"\"\n    return iter(self.root)\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Alloc.items","title":"<code>items()</code>","text":"<p>Return iterator over the allocation items.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def items(self):\n    \"\"\"Return iterator over the allocation items.\"\"\"\n    return self.root.items()\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Alloc.__getitem__","title":"<code>__getitem__(address)</code>","text":"<p>Return account associated with an address.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def __getitem__(self, address: Address | FixedSizeBytesConvertible) -&gt; Account | None:\n    \"\"\"Return account associated with an address.\"\"\"\n    if not isinstance(address, Address):\n        address = Address(address)\n    return self.root[address]\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Alloc.__setitem__","title":"<code>__setitem__(address, account)</code>","text":"<p>Set account associated with an address.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def __setitem__(self, address: Address | FixedSizeBytesConvertible, account: Account | None):\n    \"\"\"Set account associated with an address.\"\"\"\n    if not isinstance(address, Address):\n        address = Address(address)\n    self.root[address] = account\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Alloc.__delitem__","title":"<code>__delitem__(address)</code>","text":"<p>Delete account associated with an address.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def __delitem__(self, address: Address | FixedSizeBytesConvertible):\n    \"\"\"Delete account associated with an address.\"\"\"\n    if not isinstance(address, Address):\n        address = Address(address)\n    self.root.pop(address, None)\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Alloc.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Return True if both allocations are equal.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def __eq__(self, other) -&gt; bool:\n    \"\"\"Return True if both allocations are equal.\"\"\"\n    if not isinstance(other, Alloc):\n        return False\n    return self.root == other.root\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Alloc.__contains__","title":"<code>__contains__(address)</code>","text":"<p>Check if an account is in the allocation.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def __contains__(self, address: Address | FixedSizeBytesConvertible) -&gt; bool:\n    \"\"\"Check if an account is in the allocation.\"\"\"\n    if not isinstance(address, Address):\n        address = Address(address)\n    return address in self.root\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Alloc.empty_accounts","title":"<code>empty_accounts()</code>","text":"<p>Return list of addresses of empty accounts.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def empty_accounts(self) -&gt; List[Address]:\n    \"\"\"Return list of addresses of empty accounts.\"\"\"\n    return [address for address, account in self.root.items() if not account]\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Alloc.state_root","title":"<code>state_root()</code>","text":"<p>Return state root of the allocation.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def state_root(self) -&gt; bytes:\n    \"\"\"Return state root of the allocation.\"\"\"\n    state = State()\n    for address, account in self.root.items():\n        if account is None:\n            continue\n        set_account(\n            state=state,\n            address=FrontierAddress(address),\n            account=FrontierAccount(\n                nonce=Uint(account.nonce) if account.nonce is not None else Uint(0),\n                balance=(U256(account.balance) if account.balance is not None else U256(0)),\n                code=account.code if account.code is not None else b\"\",\n            ),\n        )\n        if account.storage is not None:\n            for key, value in account.storage.root.items():\n                set_storage(\n                    state=state,\n                    address=FrontierAddress(address),\n                    key=Bytes32(Hash(key)),\n                    value=U256(value),\n                )\n    return state_root(state)\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Alloc.verify_post_alloc","title":"<code>verify_post_alloc(got_alloc)</code>","text":"<p>Verify that the allocation matches the expected post in the test. Raises exception on unexpected values.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def verify_post_alloc(self, got_alloc: \"Alloc\"):\n    \"\"\"\n    Verify that the allocation matches the expected post in the test.\n    Raises exception on unexpected values.\n    \"\"\"\n    assert isinstance(got_alloc, Alloc), f\"got_alloc is not an Alloc: {got_alloc}\"\n    for address, account in self.root.items():\n        if account is None:\n            # Account must not exist\n            if address in got_alloc.root and got_alloc.root[address] is not None:\n                raise Alloc.UnexpectedAccountError(address, got_alloc.root[address])\n        else:\n            if address in got_alloc.root:\n                got_account = got_alloc.root[address]\n                assert isinstance(got_account, Account)\n                assert isinstance(account, Account)\n                account.check_alloc(address, got_account)\n            else:\n                raise Alloc.MissingAccountError(address)\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Alloc.deploy_contract","title":"<code>deploy_contract(code, *, storage=None, balance=0, nonce=1, address=None, evm_code_type=None, label=None)</code>","text":"<p>Deploy a contract to the allocation.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def deploy_contract(\n    self,\n    code: BytesConvertible,\n    *,\n    storage: Storage | StorageRootType | None = None,\n    balance: NumberConvertible = 0,\n    nonce: NumberConvertible = 1,\n    address: Address | None = None,\n    evm_code_type: EVMCodeType | None = None,\n    label: str | None = None,\n) -&gt; Address:\n    \"\"\"Deploy a contract to the allocation.\"\"\"\n    raise NotImplementedError(\"deploy_contract is not implemented in the base class\")\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Alloc.fund_eoa","title":"<code>fund_eoa(amount=None, label=None, storage=None, delegation=None, nonce=None)</code>","text":"<p>Add a previously unused EOA to the pre-alloc with the balance specified by <code>amount</code>.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def fund_eoa(\n    self,\n    amount: NumberConvertible | None = None,\n    label: str | None = None,\n    storage: Storage | None = None,\n    delegation: Address | Literal[\"Self\"] | None = None,\n    nonce: NumberConvertible | None = None,\n) -&gt; EOA:\n    \"\"\"Add a previously unused EOA to the pre-alloc with the balance specified by `amount`.\"\"\"\n    raise NotImplementedError(\"fund_eoa is not implemented in the base class\")\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Alloc.fund_address","title":"<code>fund_address(address, amount)</code>","text":"<p>Fund an address with a given amount.</p> <p>If the address is already present in the pre-alloc the amount will be added to its existing balance.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def fund_address(self, address: Address, amount: NumberConvertible):\n    \"\"\"\n    Fund an address with a given amount.\n\n    If the address is already present in the pre-alloc the amount will be\n    added to its existing balance.\n    \"\"\"\n    raise NotImplementedError(\"fund_address is not implemented in the base class\")\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.AuthorizationTuple","title":"<code>AuthorizationTuple</code>","text":"<p>               Bases: <code>AuthorizationTupleGeneric[HexNumber]</code></p> <p>Authorization tuple for transactions.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>class AuthorizationTuple(AuthorizationTupleGeneric[HexNumber]):\n    \"\"\"Authorization tuple for transactions.\"\"\"\n\n    signer: EOA | None = None\n    secret_key: Hash | None = None\n\n    def model_post_init(self, __context: Any) -&gt; None:\n        \"\"\"Automatically signs the authorization tuple if a secret key or sender are provided.\"\"\"\n        super().model_post_init(__context)\n\n        if self.secret_key is not None:\n            self.sign(self.secret_key)\n        elif self.signer is not None:\n            assert self.signer.key is not None, \"signer must have a key\"\n            self.sign(self.signer.key)\n        else:\n            assert self.v is not None, \"v must be set\"\n            assert self.r is not None, \"r must be set\"\n            assert self.s is not None, \"s must be set\"\n\n            # Calculate the address from the signature\n            try:\n                signature_bytes = (\n                    int(self.r).to_bytes(32, byteorder=\"big\")\n                    + int(self.s).to_bytes(32, byteorder=\"big\")\n                    + bytes([self.v])\n                )\n                public_key = PublicKey.from_signature_and_message(\n                    signature_bytes, self.signing_bytes.keccak256(), hasher=None\n                )\n                self.signer = EOA(\n                    address=Address(keccak256(public_key.format(compressed=False)[1:])[32 - 20 :])\n                )\n            except Exception:\n                # Signer remains `None` in this case\n                pass\n\n    def sign(self, private_key: Hash) -&gt; None:\n        \"\"\"Signs the authorization tuple with a private key.\"\"\"\n        signature = self.signature(private_key)\n\n        self.v = HexNumber(signature[0])\n        self.r = HexNumber(signature[1])\n        self.s = HexNumber(signature[2])\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.AuthorizationTuple.model_post_init","title":"<code>model_post_init(__context)</code>","text":"<p>Automatically signs the authorization tuple if a secret key or sender are provided.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Automatically signs the authorization tuple if a secret key or sender are provided.\"\"\"\n    super().model_post_init(__context)\n\n    if self.secret_key is not None:\n        self.sign(self.secret_key)\n    elif self.signer is not None:\n        assert self.signer.key is not None, \"signer must have a key\"\n        self.sign(self.signer.key)\n    else:\n        assert self.v is not None, \"v must be set\"\n        assert self.r is not None, \"r must be set\"\n        assert self.s is not None, \"s must be set\"\n\n        # Calculate the address from the signature\n        try:\n            signature_bytes = (\n                int(self.r).to_bytes(32, byteorder=\"big\")\n                + int(self.s).to_bytes(32, byteorder=\"big\")\n                + bytes([self.v])\n            )\n            public_key = PublicKey.from_signature_and_message(\n                signature_bytes, self.signing_bytes.keccak256(), hasher=None\n            )\n            self.signer = EOA(\n                address=Address(keccak256(public_key.format(compressed=False)[1:])[32 - 20 :])\n            )\n        except Exception:\n            # Signer remains `None` in this case\n            pass\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.AuthorizationTuple.sign","title":"<code>sign(private_key)</code>","text":"<p>Signs the authorization tuple with a private key.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def sign(self, private_key: Hash) -&gt; None:\n    \"\"\"Signs the authorization tuple with a private key.\"\"\"\n    signature = self.signature(private_key)\n\n    self.v = HexNumber(signature[0])\n    self.r = HexNumber(signature[1])\n    self.s = HexNumber(signature[2])\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.CamelModel","title":"<code>CamelModel</code>","text":"<p>               Bases: <code>CopyValidateModel</code></p> <p>A base model that converts field names to camel case when serializing.</p> <p>For example, the field name <code>current_timestamp</code> in a Python model will be represented as <code>currentTimestamp</code> when it is serialized to json.</p> Source code in <code>src/ethereum_test_base_types/pydantic.py</code> <pre><code>class CamelModel(CopyValidateModel):\n    \"\"\"\n    A base model that converts field names to camel case when serializing.\n\n    For example, the field name `current_timestamp` in a Python model will be represented\n    as `currentTimestamp` when it is serialized to json.\n    \"\"\"\n\n    model_config = ConfigDict(\n        alias_generator=to_camel,\n        populate_by_name=True,\n        validate_default=True,\n    )\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.ConsolidationRequest","title":"<code>ConsolidationRequest</code>","text":"<p>               Bases: <code>RequestBase</code>, <code>CamelModel</code></p> <p>Consolidation Request type.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>class ConsolidationRequest(RequestBase, CamelModel):\n    \"\"\"Consolidation Request type.\"\"\"\n\n    source_address: Address = Address(0)\n    source_pubkey: BLSPublicKey\n    target_pubkey: BLSPublicKey\n\n    type: ClassVar[int] = 2\n\n    def __bytes__(self) -&gt; bytes:\n        \"\"\"Return consolidation's attributes as bytes.\"\"\"\n        return bytes(self.source_address) + bytes(self.source_pubkey) + bytes(self.target_pubkey)\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.ConsolidationRequest.__bytes__","title":"<code>__bytes__()</code>","text":"<p>Return consolidation's attributes as bytes.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def __bytes__(self) -&gt; bytes:\n    \"\"\"Return consolidation's attributes as bytes.\"\"\"\n    return bytes(self.source_address) + bytes(self.source_pubkey) + bytes(self.target_pubkey)\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.DepositRequest","title":"<code>DepositRequest</code>","text":"<p>               Bases: <code>RequestBase</code>, <code>CamelModel</code></p> <p>Deposit Request type.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>class DepositRequest(RequestBase, CamelModel):\n    \"\"\"Deposit Request type.\"\"\"\n\n    pubkey: BLSPublicKey\n    withdrawal_credentials: Hash\n    amount: HexNumber\n    signature: BLSSignature\n    index: HexNumber\n\n    type: ClassVar[int] = 0\n\n    def __bytes__(self) -&gt; bytes:\n        \"\"\"Return deposit's attributes as bytes.\"\"\"\n        return (\n            bytes(self.pubkey)\n            + bytes(self.withdrawal_credentials)\n            + self.amount.to_bytes(8, \"little\")\n            + bytes(self.signature)\n            + self.index.to_bytes(8, \"little\")\n        )\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.DepositRequest.__bytes__","title":"<code>__bytes__()</code>","text":"<p>Return deposit's attributes as bytes.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def __bytes__(self) -&gt; bytes:\n    \"\"\"Return deposit's attributes as bytes.\"\"\"\n    return (\n        bytes(self.pubkey)\n        + bytes(self.withdrawal_credentials)\n        + self.amount.to_bytes(8, \"little\")\n        + bytes(self.signature)\n        + self.index.to_bytes(8, \"little\")\n    )\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Environment","title":"<code>Environment</code>","text":"<p>               Bases: <code>EnvironmentGeneric[ZeroPaddedHexNumber]</code></p> <p>Structure used to keep track of the context in which a block must be executed.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>class Environment(EnvironmentGeneric[ZeroPaddedHexNumber]):\n    \"\"\"\n    Structure used to keep track of the context in which a block\n    must be executed.\n    \"\"\"\n\n    blob_gas_used: ZeroPaddedHexNumber | None = Field(None, alias=\"currentBlobGasUsed\")\n    parent_ommers_hash: Hash = Field(Hash(EmptyOmmersRoot), alias=\"parentUncleHash\")\n    parent_blob_gas_used: ZeroPaddedHexNumber | None = Field(None)\n    parent_excess_blob_gas: ZeroPaddedHexNumber | None = Field(None)\n    parent_beacon_block_root: Hash | None = Field(None)\n\n    block_hashes: Dict[Number, Hash] = Field(default_factory=dict)\n    ommers: List[Hash] = Field(default_factory=list)\n    withdrawals: List[Withdrawal] | None = Field(None)\n    extra_data: Bytes = Field(Bytes(b\"\\x00\"), exclude=True)\n\n    @computed_field  # type: ignore[misc]\n    @cached_property\n    def parent_hash(self) -&gt; Hash | None:\n        \"\"\"\n        Obtains the latest hash according to the highest block number in\n        `block_hashes`.\n        \"\"\"\n        if len(self.block_hashes) == 0:\n            return None\n\n        last_index = max(self.block_hashes.keys())\n        return Hash(self.block_hashes[last_index])\n\n    def set_fork_requirements(self, fork: Fork) -&gt; \"Environment\":\n        \"\"\"Fill required fields in an environment depending on the fork.\"\"\"\n        number = self.number\n        timestamp = self.timestamp\n\n        updated_values: Dict[str, Any] = {}\n\n        if fork.header_prev_randao_required(number, timestamp) and self.prev_randao is None:\n            updated_values[\"prev_randao\"] = 0\n\n        if fork.header_withdrawals_required(number, timestamp) and self.withdrawals is None:\n            updated_values[\"withdrawals\"] = []\n\n        if (\n            fork.header_base_fee_required(number, timestamp)\n            and self.base_fee_per_gas is None\n            and self.parent_base_fee_per_gas is None\n        ):\n            updated_values[\"base_fee_per_gas\"] = DEFAULT_BASE_FEE\n\n        if fork.header_zero_difficulty_required(number, timestamp):\n            updated_values[\"difficulty\"] = 0\n        elif self.difficulty is None and self.parent_difficulty is None:\n            updated_values[\"difficulty\"] = 0x20000\n\n        if (\n            fork.header_excess_blob_gas_required(number, timestamp)\n            and self.excess_blob_gas is None\n            and self.parent_excess_blob_gas is None\n        ):\n            updated_values[\"excess_blob_gas\"] = 0\n\n        if (\n            fork.header_blob_gas_used_required(number, timestamp)\n            and self.blob_gas_used is None\n            and self.parent_blob_gas_used is None\n        ):\n            updated_values[\"blob_gas_used\"] = 0\n\n        if (\n            fork.header_beacon_root_required(number, timestamp)\n            and self.parent_beacon_block_root is None\n        ):\n            updated_values[\"parent_beacon_block_root\"] = 0\n\n        return self.copy(**updated_values)\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Environment.parent_hash","title":"<code>parent_hash: Hash | None</code>  <code>cached</code> <code>property</code>","text":"<p>Obtains the latest hash according to the highest block number in <code>block_hashes</code>.</p>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Environment.set_fork_requirements","title":"<code>set_fork_requirements(fork)</code>","text":"<p>Fill required fields in an environment depending on the fork.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def set_fork_requirements(self, fork: Fork) -&gt; \"Environment\":\n    \"\"\"Fill required fields in an environment depending on the fork.\"\"\"\n    number = self.number\n    timestamp = self.timestamp\n\n    updated_values: Dict[str, Any] = {}\n\n    if fork.header_prev_randao_required(number, timestamp) and self.prev_randao is None:\n        updated_values[\"prev_randao\"] = 0\n\n    if fork.header_withdrawals_required(number, timestamp) and self.withdrawals is None:\n        updated_values[\"withdrawals\"] = []\n\n    if (\n        fork.header_base_fee_required(number, timestamp)\n        and self.base_fee_per_gas is None\n        and self.parent_base_fee_per_gas is None\n    ):\n        updated_values[\"base_fee_per_gas\"] = DEFAULT_BASE_FEE\n\n    if fork.header_zero_difficulty_required(number, timestamp):\n        updated_values[\"difficulty\"] = 0\n    elif self.difficulty is None and self.parent_difficulty is None:\n        updated_values[\"difficulty\"] = 0x20000\n\n    if (\n        fork.header_excess_blob_gas_required(number, timestamp)\n        and self.excess_blob_gas is None\n        and self.parent_excess_blob_gas is None\n    ):\n        updated_values[\"excess_blob_gas\"] = 0\n\n    if (\n        fork.header_blob_gas_used_required(number, timestamp)\n        and self.blob_gas_used is None\n        and self.parent_blob_gas_used is None\n    ):\n        updated_values[\"blob_gas_used\"] = 0\n\n    if (\n        fork.header_beacon_root_required(number, timestamp)\n        and self.parent_beacon_block_root is None\n    ):\n        updated_values[\"parent_beacon_block_root\"] = 0\n\n    return self.copy(**updated_values)\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Removable","title":"<code>Removable</code>","text":"<p>Sentinel class to detect if a parameter should be removed. (<code>None</code> normally means \"do not modify\").</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>class Removable:\n    \"\"\"\n    Sentinel class to detect if a parameter should be removed.\n    (`None` normally means \"do not modify\").\n    \"\"\"\n\n    def __eq__(self, other: Any) -&gt; bool:\n        \"\"\"Return True for all Removable.\"\"\"\n        if not isinstance(other, Removable):\n            return NotImplemented\n        return True\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Removable.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Return True for all Removable.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    \"\"\"Return True for all Removable.\"\"\"\n    if not isinstance(other, Removable):\n        return NotImplemented\n    return True\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Requests","title":"<code>Requests</code>","text":"<p>Requests for the transition tool.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>class Requests:\n    \"\"\"Requests for the transition tool.\"\"\"\n\n    requests_list: List[Bytes]\n\n    def __init__(\n        self,\n        *requests: RequestBase,\n        requests_lists: List[List[RequestBase] | Bytes] | None = None,\n    ):\n        \"\"\"Initialize requests object.\"\"\"\n        if requests_lists is not None:\n            assert len(requests) == 0, \"requests must be empty if list is provided\"\n            self.requests_list = []\n            for requests_list in requests_lists:\n                self.requests_list.append(requests_list_to_bytes(requests_list))\n            return\n        else:\n            lists: Dict[int, List[RequestBase]] = defaultdict(list)\n            for r in requests:\n                lists[r.type].append(r)\n\n            self.requests_list = [\n                Bytes(bytes([request_type]) + requests_list_to_bytes(lists[request_type]))\n                for request_type in sorted(lists.keys())\n            ]\n\n    def __bytes__(self) -&gt; bytes:\n        \"\"\"Return requests hash.\"\"\"\n        s: bytes = b\"\"\n        for r in self.requests_list:\n            # Append the index of the request type to the request data before hashing\n            s = s + r.sha256()\n        return Bytes(s).sha256()\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Requests.__init__","title":"<code>__init__(*requests, requests_lists=None)</code>","text":"<p>Initialize requests object.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def __init__(\n    self,\n    *requests: RequestBase,\n    requests_lists: List[List[RequestBase] | Bytes] | None = None,\n):\n    \"\"\"Initialize requests object.\"\"\"\n    if requests_lists is not None:\n        assert len(requests) == 0, \"requests must be empty if list is provided\"\n        self.requests_list = []\n        for requests_list in requests_lists:\n            self.requests_list.append(requests_list_to_bytes(requests_list))\n        return\n    else:\n        lists: Dict[int, List[RequestBase]] = defaultdict(list)\n        for r in requests:\n            lists[r.type].append(r)\n\n        self.requests_list = [\n            Bytes(bytes([request_type]) + requests_list_to_bytes(lists[request_type]))\n            for request_type in sorted(lists.keys())\n        ]\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Requests.__bytes__","title":"<code>__bytes__()</code>","text":"<p>Return requests hash.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def __bytes__(self) -&gt; bytes:\n    \"\"\"Return requests hash.\"\"\"\n    s: bytes = b\"\"\n    for r in self.requests_list:\n        # Append the index of the request type to the request data before hashing\n        s = s + r.sha256()\n    return Bytes(s).sha256()\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage","title":"<code>Storage</code>","text":"<p>               Bases: <code>EthereumTestRootModel[Dict[StorageKeyValueType, StorageKeyValueType]]</code></p> <p>Definition of contract storage in the <code>pre</code> or <code>post</code> state of a test.</p> <p>This model accepts a dictionary with keys and values as any of: str, int, bytes, or any type that supports conversion to bytes, and automatically casts them to <code>HashInt</code>.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>class Storage(EthereumTestRootModel[Dict[StorageKeyValueType, StorageKeyValueType]]):\n    \"\"\"\n    Definition of contract storage in the `pre` or `post` state of a test.\n\n    This model accepts a dictionary with keys and values as any of: str, int,\n    bytes, or any type that supports conversion to bytes, and automatically\n    casts them to `HashInt`.\n    \"\"\"\n\n    # internal storage is maintained as a dict with HashInt keys and values.\n    root: Dict[StorageKeyValueType, StorageKeyValueType] = Field(default_factory=dict)\n\n    _current_slot: int = PrivateAttr(0)\n    _hint_map: Dict[StorageKeyValueType, str] = PrivateAttr(default_factory=dict)\n\n    StorageDictType: ClassVar[TypeAlias] = Dict[\n        str | int | bytes | SupportsBytes, str | int | bytes | SupportsBytes\n    ]\n    \"\"\"\n    Dictionary type to be used when defining an input to initialize a storage.\n    \"\"\"\n\n    @dataclass(kw_only=True)\n    class InvalidTypeError(Exception):\n        \"\"\"Invalid type used when describing test's expected storage key or value.\"\"\"\n\n        key_or_value: Any\n\n        def __init__(self, key_or_value: Any, *args):\n            \"\"\"Initialize the exception with the invalid type.\"\"\"\n            super().__init__(args)\n            self.key_or_value = key_or_value\n\n        def __str__(self):\n            \"\"\"Print exception string.\"\"\"\n            return f\"invalid type for key/value: {self.key_or_value}\"\n\n    @dataclass(kw_only=True)\n    class InvalidValueError(Exception):\n        \"\"\"\n        Invalid value used when describing test's expected storage key or\n        value.\n        \"\"\"\n\n        key_or_value: Any\n\n        def __init__(self, key_or_value: Any, *args):\n            \"\"\"Initialize the exception with the invalid value.\"\"\"\n            super().__init__(args)\n            self.key_or_value = key_or_value\n\n        def __str__(self):\n            \"\"\"Print exception string.\"\"\"\n            return f\"invalid value for key/value: {self.key_or_value}\"\n\n    @dataclass(kw_only=True)\n    class MissingKeyError(Exception):\n        \"\"\"Test expected to find a storage key set but key was missing.\"\"\"\n\n        key: int\n\n        def __init__(self, key: int, *args):\n            \"\"\"Initialize the exception with the missing key.\"\"\"\n            super().__init__(args)\n            self.key = key\n\n        def __str__(self):\n            \"\"\"Print exception string.\"\"\"\n            return \"key {0} not found in storage\".format(Hash(self.key))\n\n    @dataclass(kw_only=True)\n    class KeyValueMismatchError(Exception):\n        \"\"\"\n        Test expected a certain value in a storage key but value found\n        was different.\n        \"\"\"\n\n        address: Address\n        key: int\n        want: int\n        got: int\n        hint: str\n\n        def __init__(self, address: Address, key: int, want: int, got: int, hint: str = \"\", *args):\n            \"\"\"Initialize the exception with the address, key, wanted and got values.\"\"\"\n            super().__init__(args)\n            self.address = address\n            self.key = key\n            self.want = want\n            self.got = got\n            self.hint = hint\n\n        def __str__(self):\n            \"\"\"Print exception string.\"\"\"\n            label_str = \"\"\n            if self.address.label is not None:\n                label_str = f\" ({self.address.label})\"\n            return (\n                f\"incorrect value in address {self.address}{label_str} for \"\n                + f\"key {Hash(self.key)}{f' ({self.hint})' if self.hint else ''}:\"\n                + f\" want {HexNumber(self.want)} (dec:{int(self.want)}),\"\n                + f\" got {HexNumber(self.got)} (dec:{int(self.got)})\"\n            )\n\n    def __contains__(self, key: StorageKeyValueTypeConvertible | StorageKeyValueType) -&gt; bool:\n        \"\"\"Check for an item in the storage.\"\"\"\n        return StorageKeyValueTypeAdapter.validate_python(key) in self.root\n\n    def __getitem__(\n        self, key: StorageKeyValueTypeConvertible | StorageKeyValueType\n    ) -&gt; StorageKeyValueType:\n        \"\"\"Return an item from the storage.\"\"\"\n        return self.root[StorageKeyValueTypeAdapter.validate_python(key)]\n\n    def __setitem__(\n        self,\n        key: StorageKeyValueTypeConvertible | StorageKeyValueType,\n        value: StorageKeyValueTypeConvertible | StorageKeyValueType,\n    ):  # noqa: SC200\n        \"\"\"Set an item in the storage.\"\"\"\n        self.root[StorageKeyValueTypeAdapter.validate_python(key)] = (\n            StorageKeyValueTypeAdapter.validate_python(value)\n        )\n\n    def __delitem__(self, key: StorageKeyValueTypeConvertible | StorageKeyValueType):\n        \"\"\"Delete an item from the storage.\"\"\"\n        del self.root[StorageKeyValueTypeAdapter.validate_python(key)]\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the storage.\"\"\"\n        return iter(self.root)\n\n    def __eq__(self, other) -&gt; bool:\n        \"\"\"Return True if both storages are equal.\"\"\"\n        if not isinstance(other, Storage):\n            return False\n        return self.root == other.root\n\n    def __ne__(self, other) -&gt; bool:\n        \"\"\"Return True if both storages are not equal.\"\"\"\n        if not isinstance(other, Storage):\n            return False\n        return self.root != other.root\n\n    def __bool__(self) -&gt; bool:\n        \"\"\"Return True if the storage is not empty.\"\"\"\n        return any(v for v in self.root.values())\n\n    def __add__(self, other: \"Storage\") -&gt; \"Storage\":\n        \"\"\"Return a new storage that is the sum of two storages.\"\"\"\n        return Storage({**self.root, **other.root})\n\n    def keys(self) -&gt; set[StorageKeyValueType]:\n        \"\"\"Return the keys of the storage.\"\"\"\n        return set(self.root.keys())\n\n    def set_next_slot(self, slot: int) -&gt; \"Storage\":\n        \"\"\"Set the next slot to be used by `store_next`.\"\"\"\n        self._current_slot = slot\n        return self\n\n    def items(self):\n        \"\"\"Return the items of the storage.\"\"\"\n        return self.root.items()\n\n    def store_next(\n        self, value: StorageKeyValueTypeConvertible | StorageKeyValueType | bool, hint: str = \"\"\n    ) -&gt; StorageKeyValueType:\n        \"\"\"\n        Store a value in the storage and returns the key where the value is stored.\n\n        Increments the key counter so the next time this function is called,\n        the next key is used.\n        \"\"\"\n        slot = StorageKeyValueTypeAdapter.validate_python(self._current_slot)\n        self._current_slot += 1\n        if hint:\n            self._hint_map[slot] = hint\n        self[slot] = StorageKeyValueTypeAdapter.validate_python(value)\n        return slot\n\n    def peek_slot(self) -&gt; int:\n        \"\"\"Peek the next slot that will be used by `store_next`.\"\"\"\n        return self._current_slot\n\n    def contains(self, other: \"Storage\") -&gt; bool:\n        \"\"\"\n        Return True if self contains all keys with equal value as\n        contained by second storage.\n        Used for comparison with test expected post state and alloc returned\n        by the transition tool.\n        \"\"\"\n        for key in other.keys():\n            if key not in self:\n                return False\n            if self[key] != other[key]:\n                return False\n        return True\n\n    def must_contain(self, address: Address, other: \"Storage\"):\n        \"\"\"\n        Succeeds only if self contains all keys with equal value as\n        contained by second storage.\n        Used for comparison with test expected post state and alloc returned\n        by the transition tool.\n        Raises detailed exception when a difference is found.\n        \"\"\"\n        for key in other.keys():\n            if key not in self:\n                # storage[key]==0 is equal to missing storage\n                if other[key] != 0:\n                    raise Storage.MissingKeyError(key=key)\n            elif self[key] != other[key]:\n                raise Storage.KeyValueMismatchError(\n                    address=address,\n                    key=key,\n                    want=self[key],\n                    got=other[key],\n                    hint=self._hint_map.get(key, \"\"),\n                )\n\n    def must_be_equal(self, address: Address, other: \"Storage | None\"):\n        \"\"\"Succeed only if \"self\" is equal to \"other\" storage.\"\"\"\n        # Test keys contained in both storage objects\n        if other is None:\n            other = Storage({})\n        for key in self.keys() &amp; other.keys():\n            if self[key] != other[key]:\n                raise Storage.KeyValueMismatchError(\n                    address=address,\n                    key=key,\n                    want=self[key],\n                    got=other[key],\n                    hint=self._hint_map.get(key, \"\"),\n                )\n\n        # Test keys contained in either one of the storage objects\n        for key in self.keys() ^ other.keys():\n            if key in self:\n                if self[key] != 0:\n                    raise Storage.KeyValueMismatchError(\n                        address=address,\n                        key=key,\n                        want=self[key],\n                        got=0,\n                        hint=self._hint_map.get(key, \"\"),\n                    )\n\n            elif other[key] != 0:\n                raise Storage.KeyValueMismatchError(\n                    address=address,\n                    key=key,\n                    want=0,\n                    got=other[key],\n                    hint=self._hint_map.get(key, \"\"),\n                )\n\n    def canary(self) -&gt; \"Storage\":\n        \"\"\"\n        Return a canary storage filled with non-zero values where the current storage expects\n        zero values, to guarantee that the test overwrites the storage.\n        \"\"\"\n        return Storage({key: HashInt(0xBA5E) for key in self.keys() if self[key] == 0})\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.StorageDictType","title":"<code>StorageDictType: TypeAlias = Dict[str | int | bytes | SupportsBytes, str | int | bytes | SupportsBytes]</code>  <code>class-attribute</code>","text":"<p>Dictionary type to be used when defining an input to initialize a storage.</p>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.InvalidTypeError","title":"<code>InvalidTypeError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Invalid type used when describing test's expected storage key or value.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>@dataclass(kw_only=True)\nclass InvalidTypeError(Exception):\n    \"\"\"Invalid type used when describing test's expected storage key or value.\"\"\"\n\n    key_or_value: Any\n\n    def __init__(self, key_or_value: Any, *args):\n        \"\"\"Initialize the exception with the invalid type.\"\"\"\n        super().__init__(args)\n        self.key_or_value = key_or_value\n\n    def __str__(self):\n        \"\"\"Print exception string.\"\"\"\n        return f\"invalid type for key/value: {self.key_or_value}\"\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.InvalidTypeError.__init__","title":"<code>__init__(key_or_value, *args)</code>","text":"<p>Initialize the exception with the invalid type.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __init__(self, key_or_value: Any, *args):\n    \"\"\"Initialize the exception with the invalid type.\"\"\"\n    super().__init__(args)\n    self.key_or_value = key_or_value\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.InvalidTypeError.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __str__(self):\n    \"\"\"Print exception string.\"\"\"\n    return f\"invalid type for key/value: {self.key_or_value}\"\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.InvalidValueError","title":"<code>InvalidValueError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Invalid value used when describing test's expected storage key or value.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>@dataclass(kw_only=True)\nclass InvalidValueError(Exception):\n    \"\"\"\n    Invalid value used when describing test's expected storage key or\n    value.\n    \"\"\"\n\n    key_or_value: Any\n\n    def __init__(self, key_or_value: Any, *args):\n        \"\"\"Initialize the exception with the invalid value.\"\"\"\n        super().__init__(args)\n        self.key_or_value = key_or_value\n\n    def __str__(self):\n        \"\"\"Print exception string.\"\"\"\n        return f\"invalid value for key/value: {self.key_or_value}\"\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.InvalidValueError.__init__","title":"<code>__init__(key_or_value, *args)</code>","text":"<p>Initialize the exception with the invalid value.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __init__(self, key_or_value: Any, *args):\n    \"\"\"Initialize the exception with the invalid value.\"\"\"\n    super().__init__(args)\n    self.key_or_value = key_or_value\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.InvalidValueError.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __str__(self):\n    \"\"\"Print exception string.\"\"\"\n    return f\"invalid value for key/value: {self.key_or_value}\"\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.MissingKeyError","title":"<code>MissingKeyError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Test expected to find a storage key set but key was missing.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>@dataclass(kw_only=True)\nclass MissingKeyError(Exception):\n    \"\"\"Test expected to find a storage key set but key was missing.\"\"\"\n\n    key: int\n\n    def __init__(self, key: int, *args):\n        \"\"\"Initialize the exception with the missing key.\"\"\"\n        super().__init__(args)\n        self.key = key\n\n    def __str__(self):\n        \"\"\"Print exception string.\"\"\"\n        return \"key {0} not found in storage\".format(Hash(self.key))\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.MissingKeyError.__init__","title":"<code>__init__(key, *args)</code>","text":"<p>Initialize the exception with the missing key.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __init__(self, key: int, *args):\n    \"\"\"Initialize the exception with the missing key.\"\"\"\n    super().__init__(args)\n    self.key = key\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.MissingKeyError.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __str__(self):\n    \"\"\"Print exception string.\"\"\"\n    return \"key {0} not found in storage\".format(Hash(self.key))\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.KeyValueMismatchError","title":"<code>KeyValueMismatchError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Test expected a certain value in a storage key but value found was different.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>@dataclass(kw_only=True)\nclass KeyValueMismatchError(Exception):\n    \"\"\"\n    Test expected a certain value in a storage key but value found\n    was different.\n    \"\"\"\n\n    address: Address\n    key: int\n    want: int\n    got: int\n    hint: str\n\n    def __init__(self, address: Address, key: int, want: int, got: int, hint: str = \"\", *args):\n        \"\"\"Initialize the exception with the address, key, wanted and got values.\"\"\"\n        super().__init__(args)\n        self.address = address\n        self.key = key\n        self.want = want\n        self.got = got\n        self.hint = hint\n\n    def __str__(self):\n        \"\"\"Print exception string.\"\"\"\n        label_str = \"\"\n        if self.address.label is not None:\n            label_str = f\" ({self.address.label})\"\n        return (\n            f\"incorrect value in address {self.address}{label_str} for \"\n            + f\"key {Hash(self.key)}{f' ({self.hint})' if self.hint else ''}:\"\n            + f\" want {HexNumber(self.want)} (dec:{int(self.want)}),\"\n            + f\" got {HexNumber(self.got)} (dec:{int(self.got)})\"\n        )\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.KeyValueMismatchError.__init__","title":"<code>__init__(address, key, want, got, hint='', *args)</code>","text":"<p>Initialize the exception with the address, key, wanted and got values.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __init__(self, address: Address, key: int, want: int, got: int, hint: str = \"\", *args):\n    \"\"\"Initialize the exception with the address, key, wanted and got values.\"\"\"\n    super().__init__(args)\n    self.address = address\n    self.key = key\n    self.want = want\n    self.got = got\n    self.hint = hint\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.KeyValueMismatchError.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __str__(self):\n    \"\"\"Print exception string.\"\"\"\n    label_str = \"\"\n    if self.address.label is not None:\n        label_str = f\" ({self.address.label})\"\n    return (\n        f\"incorrect value in address {self.address}{label_str} for \"\n        + f\"key {Hash(self.key)}{f' ({self.hint})' if self.hint else ''}:\"\n        + f\" want {HexNumber(self.want)} (dec:{int(self.want)}),\"\n        + f\" got {HexNumber(self.got)} (dec:{int(self.got)})\"\n    )\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.__contains__","title":"<code>__contains__(key)</code>","text":"<p>Check for an item in the storage.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __contains__(self, key: StorageKeyValueTypeConvertible | StorageKeyValueType) -&gt; bool:\n    \"\"\"Check for an item in the storage.\"\"\"\n    return StorageKeyValueTypeAdapter.validate_python(key) in self.root\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Return an item from the storage.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __getitem__(\n    self, key: StorageKeyValueTypeConvertible | StorageKeyValueType\n) -&gt; StorageKeyValueType:\n    \"\"\"Return an item from the storage.\"\"\"\n    return self.root[StorageKeyValueTypeAdapter.validate_python(key)]\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Set an item in the storage.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __setitem__(\n    self,\n    key: StorageKeyValueTypeConvertible | StorageKeyValueType,\n    value: StorageKeyValueTypeConvertible | StorageKeyValueType,\n):  # noqa: SC200\n    \"\"\"Set an item in the storage.\"\"\"\n    self.root[StorageKeyValueTypeAdapter.validate_python(key)] = (\n        StorageKeyValueTypeAdapter.validate_python(value)\n    )\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.__delitem__","title":"<code>__delitem__(key)</code>","text":"<p>Delete an item from the storage.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __delitem__(self, key: StorageKeyValueTypeConvertible | StorageKeyValueType):\n    \"\"\"Delete an item from the storage.\"\"\"\n    del self.root[StorageKeyValueTypeAdapter.validate_python(key)]\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.__iter__","title":"<code>__iter__()</code>","text":"<p>Return an iterator over the storage.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __iter__(self):\n    \"\"\"Return an iterator over the storage.\"\"\"\n    return iter(self.root)\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Return True if both storages are equal.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __eq__(self, other) -&gt; bool:\n    \"\"\"Return True if both storages are equal.\"\"\"\n    if not isinstance(other, Storage):\n        return False\n    return self.root == other.root\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Return True if both storages are not equal.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __ne__(self, other) -&gt; bool:\n    \"\"\"Return True if both storages are not equal.\"\"\"\n    if not isinstance(other, Storage):\n        return False\n    return self.root != other.root\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.__bool__","title":"<code>__bool__()</code>","text":"<p>Return True if the storage is not empty.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    \"\"\"Return True if the storage is not empty.\"\"\"\n    return any(v for v in self.root.values())\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.__add__","title":"<code>__add__(other)</code>","text":"<p>Return a new storage that is the sum of two storages.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def __add__(self, other: \"Storage\") -&gt; \"Storage\":\n    \"\"\"Return a new storage that is the sum of two storages.\"\"\"\n    return Storage({**self.root, **other.root})\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.keys","title":"<code>keys()</code>","text":"<p>Return the keys of the storage.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def keys(self) -&gt; set[StorageKeyValueType]:\n    \"\"\"Return the keys of the storage.\"\"\"\n    return set(self.root.keys())\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.set_next_slot","title":"<code>set_next_slot(slot)</code>","text":"<p>Set the next slot to be used by <code>store_next</code>.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def set_next_slot(self, slot: int) -&gt; \"Storage\":\n    \"\"\"Set the next slot to be used by `store_next`.\"\"\"\n    self._current_slot = slot\n    return self\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.items","title":"<code>items()</code>","text":"<p>Return the items of the storage.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def items(self):\n    \"\"\"Return the items of the storage.\"\"\"\n    return self.root.items()\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.store_next","title":"<code>store_next(value, hint='')</code>","text":"<p>Store a value in the storage and returns the key where the value is stored.</p> <p>Increments the key counter so the next time this function is called, the next key is used.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def store_next(\n    self, value: StorageKeyValueTypeConvertible | StorageKeyValueType | bool, hint: str = \"\"\n) -&gt; StorageKeyValueType:\n    \"\"\"\n    Store a value in the storage and returns the key where the value is stored.\n\n    Increments the key counter so the next time this function is called,\n    the next key is used.\n    \"\"\"\n    slot = StorageKeyValueTypeAdapter.validate_python(self._current_slot)\n    self._current_slot += 1\n    if hint:\n        self._hint_map[slot] = hint\n    self[slot] = StorageKeyValueTypeAdapter.validate_python(value)\n    return slot\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.peek_slot","title":"<code>peek_slot()</code>","text":"<p>Peek the next slot that will be used by <code>store_next</code>.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def peek_slot(self) -&gt; int:\n    \"\"\"Peek the next slot that will be used by `store_next`.\"\"\"\n    return self._current_slot\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.contains","title":"<code>contains(other)</code>","text":"<p>Return True if self contains all keys with equal value as contained by second storage. Used for comparison with test expected post state and alloc returned by the transition tool.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def contains(self, other: \"Storage\") -&gt; bool:\n    \"\"\"\n    Return True if self contains all keys with equal value as\n    contained by second storage.\n    Used for comparison with test expected post state and alloc returned\n    by the transition tool.\n    \"\"\"\n    for key in other.keys():\n        if key not in self:\n            return False\n        if self[key] != other[key]:\n            return False\n    return True\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.must_contain","title":"<code>must_contain(address, other)</code>","text":"<p>Succeeds only if self contains all keys with equal value as contained by second storage. Used for comparison with test expected post state and alloc returned by the transition tool. Raises detailed exception when a difference is found.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def must_contain(self, address: Address, other: \"Storage\"):\n    \"\"\"\n    Succeeds only if self contains all keys with equal value as\n    contained by second storage.\n    Used for comparison with test expected post state and alloc returned\n    by the transition tool.\n    Raises detailed exception when a difference is found.\n    \"\"\"\n    for key in other.keys():\n        if key not in self:\n            # storage[key]==0 is equal to missing storage\n            if other[key] != 0:\n                raise Storage.MissingKeyError(key=key)\n        elif self[key] != other[key]:\n            raise Storage.KeyValueMismatchError(\n                address=address,\n                key=key,\n                want=self[key],\n                got=other[key],\n                hint=self._hint_map.get(key, \"\"),\n            )\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.must_be_equal","title":"<code>must_be_equal(address, other)</code>","text":"<p>Succeed only if \"self\" is equal to \"other\" storage.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def must_be_equal(self, address: Address, other: \"Storage | None\"):\n    \"\"\"Succeed only if \"self\" is equal to \"other\" storage.\"\"\"\n    # Test keys contained in both storage objects\n    if other is None:\n        other = Storage({})\n    for key in self.keys() &amp; other.keys():\n        if self[key] != other[key]:\n            raise Storage.KeyValueMismatchError(\n                address=address,\n                key=key,\n                want=self[key],\n                got=other[key],\n                hint=self._hint_map.get(key, \"\"),\n            )\n\n    # Test keys contained in either one of the storage objects\n    for key in self.keys() ^ other.keys():\n        if key in self:\n            if self[key] != 0:\n                raise Storage.KeyValueMismatchError(\n                    address=address,\n                    key=key,\n                    want=self[key],\n                    got=0,\n                    hint=self._hint_map.get(key, \"\"),\n                )\n\n        elif other[key] != 0:\n            raise Storage.KeyValueMismatchError(\n                address=address,\n                key=key,\n                want=0,\n                got=other[key],\n                hint=self._hint_map.get(key, \"\"),\n            )\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Storage.canary","title":"<code>canary()</code>","text":"<p>Return a canary storage filled with non-zero values where the current storage expects zero values, to guarantee that the test overwrites the storage.</p> Source code in <code>src/ethereum_test_base_types/composite_types.py</code> <pre><code>def canary(self) -&gt; \"Storage\":\n    \"\"\"\n    Return a canary storage filled with non-zero values where the current storage expects\n    zero values, to guarantee that the test overwrites the storage.\n    \"\"\"\n    return Storage({key: HashInt(0xBA5E) for key in self.keys() if self[key] == 0})\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Transaction","title":"<code>Transaction</code>","text":"<p>               Bases: <code>TransactionGeneric[HexNumber]</code>, <code>TransactionTransitionToolConverter</code></p> <p>Generic object that can represent all Ethereum transaction types.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>class Transaction(TransactionGeneric[HexNumber], TransactionTransitionToolConverter):\n    \"\"\"Generic object that can represent all Ethereum transaction types.\"\"\"\n\n    gas_limit: HexNumber = Field(HexNumber(21_000), serialization_alias=\"gas\")\n    to: Address | None = Field(Address(0xAA))\n    data: Bytes = Field(Bytes(b\"\"), alias=\"input\")\n\n    authorization_list: List[AuthorizationTuple] | None = None\n\n    secret_key: Hash | None = None\n    error: List[TransactionException] | TransactionException | None = Field(None, exclude=True)\n\n    protected: bool = Field(True, exclude=True)\n    rlp_override: Bytes | None = Field(None, exclude=True)\n\n    expected_receipt: TransactionReceipt | None = Field(None, exclude=True)\n\n    wrapped_blob_transaction: bool = Field(False, exclude=True)\n    blobs: Sequence[Bytes] | None = Field(None, exclude=True)\n    blob_kzg_commitments: Sequence[Bytes] | None = Field(None, exclude=True)\n    blob_kzg_proofs: Sequence[Bytes] | None = Field(None, exclude=True)\n\n    model_config = ConfigDict(validate_assignment=True)\n\n    class InvalidFeePaymentError(Exception):\n        \"\"\"Transaction described more than one fee payment type.\"\"\"\n\n        def __str__(self):\n            \"\"\"Print exception string.\"\"\"\n            return \"only one type of fee payment field can be used in a single tx\"\n\n    class InvalidSignaturePrivateKeyError(Exception):\n        \"\"\"\n        Transaction describes both the signature and private key of\n        source account.\n        \"\"\"\n\n        def __str__(self):\n            \"\"\"Print exception string.\"\"\"\n            return \"can't define both 'signature' and 'private_key'\"\n\n    def model_post_init(self, __context):\n        \"\"\"Ensure transaction has no conflicting properties.\"\"\"\n        super().model_post_init(__context)\n\n        if self.gas_price is not None and (\n            self.max_fee_per_gas is not None\n            or self.max_priority_fee_per_gas is not None\n            or self.max_fee_per_blob_gas is not None\n        ):\n            raise Transaction.InvalidFeePaymentError()\n\n        if \"ty\" not in self.model_fields_set:\n            # Try to deduce transaction type from included fields\n            if self.authorization_list is not None:\n                self.ty = 4\n            elif self.max_fee_per_blob_gas is not None or self.blob_kzg_commitments is not None:\n                self.ty = 3\n            elif self.max_fee_per_gas is not None or self.max_priority_fee_per_gas is not None:\n                self.ty = 2\n            elif self.access_list is not None:\n                self.ty = 1\n            else:\n                self.ty = 0\n\n        if self.v is not None and self.secret_key is not None:\n            raise Transaction.InvalidSignaturePrivateKeyError()\n\n        if self.v is None and self.secret_key is None:\n            if self.sender is not None:\n                self.secret_key = self.sender.key\n            else:\n                self.secret_key = Hash(TestPrivateKey)\n                self.sender = EOA(address=TestAddress, key=self.secret_key, nonce=0)\n\n        # Set default values for fields that are required for certain tx types\n        if self.ty &lt;= 1 and self.gas_price is None:\n            self.gas_price = TransactionDefaults.gas_price\n        if self.ty &gt;= 1 and self.access_list is None:\n            self.access_list = []\n        if self.ty &lt; 1:\n            assert self.access_list is None, \"access_list must be None\"\n\n        if self.ty &gt;= 2 and self.max_fee_per_gas is None:\n            self.max_fee_per_gas = TransactionDefaults.max_fee_per_gas\n        if self.ty &gt;= 2 and self.max_priority_fee_per_gas is None:\n            self.max_priority_fee_per_gas = TransactionDefaults.max_priority_fee_per_gas\n        if self.ty &lt; 2:\n            assert self.max_fee_per_gas is None, \"max_fee_per_gas must be None\"\n            assert self.max_priority_fee_per_gas is None, \"max_priority_fee_per_gas must be None\"\n\n        if self.ty == 3 and self.max_fee_per_blob_gas is None:\n            self.max_fee_per_blob_gas = 1\n        if self.ty != 3:\n            assert self.blob_versioned_hashes is None, \"blob_versioned_hashes must be None\"\n            assert self.max_fee_per_blob_gas is None, \"max_fee_per_blob_gas must be None\"\n\n        if self.ty == 4 and self.authorization_list is None:\n            self.authorization_list = []\n        if self.ty != 4:\n            assert self.authorization_list is None, \"authorization_list must be None\"\n\n        if \"nonce\" not in self.model_fields_set and self.sender is not None:\n            self.nonce = HexNumber(self.sender.get_nonce())\n\n    def with_error(\n        self, error: List[TransactionException] | TransactionException\n    ) -&gt; \"Transaction\":\n        \"\"\"Create a copy of the transaction with an added error.\"\"\"\n        return self.copy(error=error)\n\n    def with_nonce(self, nonce: int) -&gt; \"Transaction\":\n        \"\"\"Create a copy of the transaction with a modified nonce.\"\"\"\n        return self.copy(nonce=nonce)\n\n    def with_signature_and_sender(self, *, keep_secret_key: bool = False) -&gt; \"Transaction\":\n        \"\"\"Return signed version of the transaction using the private key.\"\"\"\n        updated_values: Dict[str, Any] = {}\n\n        if self.v is not None:\n            # Transaction already signed\n            if self.sender is not None:\n                return self\n\n            public_key = PublicKey.from_signature_and_message(\n                self.signature_bytes, self.signing_bytes.keccak256(), hasher=None\n            )\n            updated_values[\"sender\"] = Address(\n                keccak256(public_key.format(compressed=False)[1:])[32 - 20 :]\n            )\n            return self.copy(**updated_values)\n\n        if self.secret_key is None:\n            raise ValueError(\"secret_key must be set to sign a transaction\")\n\n        # Get the signing bytes\n        signing_hash = self.signing_bytes.keccak256()\n\n        # Sign the bytes\n        signature_bytes = PrivateKey(secret=self.secret_key).sign_recoverable(\n            signing_hash, hasher=None\n        )\n        public_key = PublicKey.from_signature_and_message(\n            signature_bytes, signing_hash, hasher=None\n        )\n\n        sender = keccak256(public_key.format(compressed=False)[1:])[32 - 20 :]\n        updated_values[\"sender\"] = Address(sender)\n\n        v, r, s = (\n            signature_bytes[64],\n            int.from_bytes(signature_bytes[0:32], byteorder=\"big\"),\n            int.from_bytes(signature_bytes[32:64], byteorder=\"big\"),\n        )\n        if self.ty == 0:\n            if self.protected:\n                v += 35 + (self.chain_id * 2)\n            else:  # not protected\n                v += 27\n\n        updated_values[\"v\"] = HexNumber(v)\n        updated_values[\"r\"] = HexNumber(r)\n        updated_values[\"s\"] = HexNumber(s)\n\n        updated_values[\"secret_key\"] = None\n\n        updated_tx: \"Transaction\" = self.model_copy(update=updated_values)\n\n        # Remove the secret key if requested\n        if keep_secret_key:\n            updated_tx.secret_key = self.secret_key\n        return updated_tx\n\n    @cached_property\n    def signing_envelope(self) -&gt; List[Any]:\n        \"\"\"Returns the list of values included in the envelope used for signing.\"\"\"\n        to = self.to if self.to else bytes()\n        if self.ty == 4:\n            # EIP-7702: https://eips.ethereum.org/EIPS/eip-7702\n            if self.max_priority_fee_per_gas is None:\n                raise ValueError(f\"max_priority_fee_per_gas must be set for type {self.ty} tx\")\n            if self.max_fee_per_gas is None:\n                raise ValueError(f\"max_fee_per_gas must be set for type {self.ty} tx\")\n            if self.access_list is None:\n                raise ValueError(f\"access_list must be set for type {self.ty} tx\")\n            if self.authorization_list is None:\n                raise ValueError(f\"authorization_tuples must be set for type {self.ty} tx\")\n            return [\n                Uint(self.chain_id),\n                Uint(self.nonce),\n                Uint(self.max_priority_fee_per_gas),\n                Uint(self.max_fee_per_gas),\n                Uint(self.gas_limit),\n                to,\n                Uint(self.value),\n                self.data,\n                [a.to_list() for a in self.access_list],\n                [a.to_list() for a in self.authorization_list],\n            ]\n        elif self.ty == 3:\n            # EIP-4844: https://eips.ethereum.org/EIPS/eip-4844\n            if self.max_priority_fee_per_gas is None:\n                raise ValueError(f\"max_priority_fee_per_gas must be set for type {self.ty} tx\")\n            if self.max_fee_per_gas is None:\n                raise ValueError(f\"max_fee_per_gas must be set for type {self.ty} tx\")\n            if self.max_fee_per_blob_gas is None:\n                raise ValueError(f\"max_fee_per_blob_gas must be set for type {self.ty} tx\")\n            if self.blob_versioned_hashes is None:\n                raise ValueError(f\"blob_versioned_hashes must be set for type {self.ty} tx\")\n            if self.access_list is None:\n                raise ValueError(f\"access_list must be set for type {self.ty} tx\")\n            return [\n                Uint(self.chain_id),\n                Uint(self.nonce),\n                Uint(self.max_priority_fee_per_gas),\n                Uint(self.max_fee_per_gas),\n                Uint(self.gas_limit),\n                to,\n                Uint(self.value),\n                self.data,\n                [a.to_list() for a in self.access_list],\n                Uint(self.max_fee_per_blob_gas),\n                list(self.blob_versioned_hashes),\n            ]\n        elif self.ty == 2:\n            # EIP-1559: https://eips.ethereum.org/EIPS/eip-1559\n            if self.max_priority_fee_per_gas is None:\n                raise ValueError(f\"max_priority_fee_per_gas must be set for type {self.ty} tx\")\n            if self.max_fee_per_gas is None:\n                raise ValueError(f\"max_fee_per_gas must be set for type {self.ty} tx\")\n            if self.access_list is None:\n                raise ValueError(f\"access_list must be set for type {self.ty} tx\")\n            return [\n                Uint(self.chain_id),\n                Uint(self.nonce),\n                Uint(self.max_priority_fee_per_gas),\n                Uint(self.max_fee_per_gas),\n                Uint(self.gas_limit),\n                to,\n                Uint(self.value),\n                self.data,\n                [a.to_list() for a in self.access_list],\n            ]\n        elif self.ty == 1:\n            # EIP-2930: https://eips.ethereum.org/EIPS/eip-2930\n            if self.gas_price is None:\n                raise ValueError(f\"gas_price must be set for type {self.ty} tx\")\n            if self.access_list is None:\n                raise ValueError(f\"access_list must be set for type {self.ty} tx\")\n\n            return [\n                Uint(self.chain_id),\n                Uint(self.nonce),\n                Uint(self.gas_price),\n                Uint(self.gas_limit),\n                to,\n                Uint(self.value),\n                self.data,\n                [a.to_list() for a in self.access_list],\n            ]\n        elif self.ty == 0:\n            if self.gas_price is None:\n                raise ValueError(f\"gas_price must be set for type {self.ty} tx\")\n\n            if self.protected:\n                # EIP-155: https://eips.ethereum.org/EIPS/eip-155\n                return [\n                    Uint(self.nonce),\n                    Uint(self.gas_price),\n                    Uint(self.gas_limit),\n                    to,\n                    Uint(self.value),\n                    self.data,\n                    Uint(self.chain_id),\n                    Uint(0),\n                    Uint(0),\n                ]\n            else:\n                return [\n                    Uint(self.nonce),\n                    Uint(self.gas_price),\n                    Uint(self.gas_limit),\n                    to,\n                    Uint(self.value),\n                    self.data,\n                ]\n        raise NotImplementedError(\"signing for transaction type {self.ty} not implemented\")\n\n    @cached_property\n    def payload_body(self) -&gt; List[Any]:\n        \"\"\"Returns the list of values included in the transaction body.\"\"\"\n        if self.v is None or self.r is None or self.s is None:\n            raise ValueError(\"signature must be set before serializing any tx type\")\n\n        signing_envelope = self.signing_envelope\n\n        if self.ty == 0 and self.protected:\n            # Remove the chain_id and the two zeros from the signing envelope\n            signing_envelope = signing_envelope[:-3]\n        elif self.ty == 3 and self.wrapped_blob_transaction:\n            # EIP-4844: https://eips.ethereum.org/EIPS/eip-4844\n            if self.blobs is None:\n                raise ValueError(f\"blobs must be set for type {self.ty} tx\")\n            if self.blob_kzg_commitments is None:\n                raise ValueError(f\"blob_kzg_commitments must be set for type {self.ty} tx\")\n            if self.blob_kzg_proofs is None:\n                raise ValueError(f\"blob_kzg_proofs must be set for type {self.ty} tx\")\n            return [\n                signing_envelope + [Uint(self.v), Uint(self.r), Uint(self.s)],\n                list(self.blobs),\n                list(self.blob_kzg_commitments),\n                list(self.blob_kzg_proofs),\n            ]\n\n        return signing_envelope + [Uint(self.v), Uint(self.r), Uint(self.s)]\n\n    @cached_property\n    def rlp(self) -&gt; Bytes:\n        \"\"\"\n        Returns bytes of the serialized representation of the transaction,\n        which is almost always RLP encoding.\n        \"\"\"\n        if self.rlp_override is not None:\n            return self.rlp_override\n        if self.ty &gt; 0:\n            return Bytes(bytes([self.ty]) + eth_rlp.encode(self.payload_body))\n        else:\n            return Bytes(eth_rlp.encode(self.payload_body))\n\n    @cached_property\n    def hash(self) -&gt; Hash:\n        \"\"\"Returns hash of the transaction.\"\"\"\n        return self.rlp.keccak256()\n\n    @cached_property\n    def signing_bytes(self) -&gt; Bytes:\n        \"\"\"Returns the serialized bytes of the transaction used for signing.\"\"\"\n        return Bytes(\n            bytes([self.ty]) + eth_rlp.encode(self.signing_envelope)\n            if self.ty &gt; 0\n            else eth_rlp.encode(self.signing_envelope)\n        )\n\n    @cached_property\n    def signature_bytes(self) -&gt; Bytes:\n        \"\"\"Returns the serialized bytes of the transaction signature.\"\"\"\n        assert self.v is not None and self.r is not None and self.s is not None\n        v = int(self.v)\n        if self.ty == 0:\n            if self.protected:\n                assert self.chain_id is not None\n                v -= 35 + (self.chain_id * 2)\n            else:\n                v -= 27\n        return Bytes(\n            self.r.to_bytes(32, byteorder=\"big\")\n            + self.s.to_bytes(32, byteorder=\"big\")\n            + bytes([v])\n        )\n\n    @cached_property\n    def serializable_list(self) -&gt; Any:\n        \"\"\"Return list of values included in the transaction as a serializable object.\"\"\"\n        return self.rlp if self.ty &gt; 0 else self.payload_body\n\n    @staticmethod\n    def list_root(input_txs: List[\"Transaction\"]) -&gt; Hash:\n        \"\"\"Return transactions root of a list of transactions.\"\"\"\n        t = HexaryTrie(db={})\n        for i, tx in enumerate(input_txs):\n            t.set(eth_rlp.encode(Uint(i)), tx.rlp)\n        return Hash(t.root_hash)\n\n    @staticmethod\n    def list_blob_versioned_hashes(input_txs: List[\"Transaction\"]) -&gt; List[Hash]:\n        \"\"\"Get list of ordered blob versioned hashes from a list of transactions.\"\"\"\n        return [\n            blob_versioned_hash\n            for tx in input_txs\n            if tx.blob_versioned_hashes is not None\n            for blob_versioned_hash in tx.blob_versioned_hashes\n        ]\n\n    @cached_property\n    def created_contract(self) -&gt; Address:\n        \"\"\"Return address of the contract created by the transaction.\"\"\"\n        if self.to is not None:\n            raise ValueError(\"transaction is not a contract creation\")\n        if self.sender is None:\n            raise ValueError(\"sender address is None\")\n        hash_bytes = Bytes(eth_rlp.encode([self.sender, int_to_bytes(self.nonce)])).keccak256()\n        return Address(hash_bytes[-20:])\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Transaction.InvalidFeePaymentError","title":"<code>InvalidFeePaymentError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Transaction described more than one fee payment type.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>class InvalidFeePaymentError(Exception):\n    \"\"\"Transaction described more than one fee payment type.\"\"\"\n\n    def __str__(self):\n        \"\"\"Print exception string.\"\"\"\n        return \"only one type of fee payment field can be used in a single tx\"\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Transaction.InvalidFeePaymentError.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def __str__(self):\n    \"\"\"Print exception string.\"\"\"\n    return \"only one type of fee payment field can be used in a single tx\"\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Transaction.InvalidSignaturePrivateKeyError","title":"<code>InvalidSignaturePrivateKeyError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Transaction describes both the signature and private key of source account.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>class InvalidSignaturePrivateKeyError(Exception):\n    \"\"\"\n    Transaction describes both the signature and private key of\n    source account.\n    \"\"\"\n\n    def __str__(self):\n        \"\"\"Print exception string.\"\"\"\n        return \"can't define both 'signature' and 'private_key'\"\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Transaction.InvalidSignaturePrivateKeyError.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def __str__(self):\n    \"\"\"Print exception string.\"\"\"\n    return \"can't define both 'signature' and 'private_key'\"\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Transaction.model_post_init","title":"<code>model_post_init(__context)</code>","text":"<p>Ensure transaction has no conflicting properties.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def model_post_init(self, __context):\n    \"\"\"Ensure transaction has no conflicting properties.\"\"\"\n    super().model_post_init(__context)\n\n    if self.gas_price is not None and (\n        self.max_fee_per_gas is not None\n        or self.max_priority_fee_per_gas is not None\n        or self.max_fee_per_blob_gas is not None\n    ):\n        raise Transaction.InvalidFeePaymentError()\n\n    if \"ty\" not in self.model_fields_set:\n        # Try to deduce transaction type from included fields\n        if self.authorization_list is not None:\n            self.ty = 4\n        elif self.max_fee_per_blob_gas is not None or self.blob_kzg_commitments is not None:\n            self.ty = 3\n        elif self.max_fee_per_gas is not None or self.max_priority_fee_per_gas is not None:\n            self.ty = 2\n        elif self.access_list is not None:\n            self.ty = 1\n        else:\n            self.ty = 0\n\n    if self.v is not None and self.secret_key is not None:\n        raise Transaction.InvalidSignaturePrivateKeyError()\n\n    if self.v is None and self.secret_key is None:\n        if self.sender is not None:\n            self.secret_key = self.sender.key\n        else:\n            self.secret_key = Hash(TestPrivateKey)\n            self.sender = EOA(address=TestAddress, key=self.secret_key, nonce=0)\n\n    # Set default values for fields that are required for certain tx types\n    if self.ty &lt;= 1 and self.gas_price is None:\n        self.gas_price = TransactionDefaults.gas_price\n    if self.ty &gt;= 1 and self.access_list is None:\n        self.access_list = []\n    if self.ty &lt; 1:\n        assert self.access_list is None, \"access_list must be None\"\n\n    if self.ty &gt;= 2 and self.max_fee_per_gas is None:\n        self.max_fee_per_gas = TransactionDefaults.max_fee_per_gas\n    if self.ty &gt;= 2 and self.max_priority_fee_per_gas is None:\n        self.max_priority_fee_per_gas = TransactionDefaults.max_priority_fee_per_gas\n    if self.ty &lt; 2:\n        assert self.max_fee_per_gas is None, \"max_fee_per_gas must be None\"\n        assert self.max_priority_fee_per_gas is None, \"max_priority_fee_per_gas must be None\"\n\n    if self.ty == 3 and self.max_fee_per_blob_gas is None:\n        self.max_fee_per_blob_gas = 1\n    if self.ty != 3:\n        assert self.blob_versioned_hashes is None, \"blob_versioned_hashes must be None\"\n        assert self.max_fee_per_blob_gas is None, \"max_fee_per_blob_gas must be None\"\n\n    if self.ty == 4 and self.authorization_list is None:\n        self.authorization_list = []\n    if self.ty != 4:\n        assert self.authorization_list is None, \"authorization_list must be None\"\n\n    if \"nonce\" not in self.model_fields_set and self.sender is not None:\n        self.nonce = HexNumber(self.sender.get_nonce())\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Transaction.with_error","title":"<code>with_error(error)</code>","text":"<p>Create a copy of the transaction with an added error.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def with_error(\n    self, error: List[TransactionException] | TransactionException\n) -&gt; \"Transaction\":\n    \"\"\"Create a copy of the transaction with an added error.\"\"\"\n    return self.copy(error=error)\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Transaction.with_nonce","title":"<code>with_nonce(nonce)</code>","text":"<p>Create a copy of the transaction with a modified nonce.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def with_nonce(self, nonce: int) -&gt; \"Transaction\":\n    \"\"\"Create a copy of the transaction with a modified nonce.\"\"\"\n    return self.copy(nonce=nonce)\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Transaction.with_signature_and_sender","title":"<code>with_signature_and_sender(*, keep_secret_key=False)</code>","text":"<p>Return signed version of the transaction using the private key.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def with_signature_and_sender(self, *, keep_secret_key: bool = False) -&gt; \"Transaction\":\n    \"\"\"Return signed version of the transaction using the private key.\"\"\"\n    updated_values: Dict[str, Any] = {}\n\n    if self.v is not None:\n        # Transaction already signed\n        if self.sender is not None:\n            return self\n\n        public_key = PublicKey.from_signature_and_message(\n            self.signature_bytes, self.signing_bytes.keccak256(), hasher=None\n        )\n        updated_values[\"sender\"] = Address(\n            keccak256(public_key.format(compressed=False)[1:])[32 - 20 :]\n        )\n        return self.copy(**updated_values)\n\n    if self.secret_key is None:\n        raise ValueError(\"secret_key must be set to sign a transaction\")\n\n    # Get the signing bytes\n    signing_hash = self.signing_bytes.keccak256()\n\n    # Sign the bytes\n    signature_bytes = PrivateKey(secret=self.secret_key).sign_recoverable(\n        signing_hash, hasher=None\n    )\n    public_key = PublicKey.from_signature_and_message(\n        signature_bytes, signing_hash, hasher=None\n    )\n\n    sender = keccak256(public_key.format(compressed=False)[1:])[32 - 20 :]\n    updated_values[\"sender\"] = Address(sender)\n\n    v, r, s = (\n        signature_bytes[64],\n        int.from_bytes(signature_bytes[0:32], byteorder=\"big\"),\n        int.from_bytes(signature_bytes[32:64], byteorder=\"big\"),\n    )\n    if self.ty == 0:\n        if self.protected:\n            v += 35 + (self.chain_id * 2)\n        else:  # not protected\n            v += 27\n\n    updated_values[\"v\"] = HexNumber(v)\n    updated_values[\"r\"] = HexNumber(r)\n    updated_values[\"s\"] = HexNumber(s)\n\n    updated_values[\"secret_key\"] = None\n\n    updated_tx: \"Transaction\" = self.model_copy(update=updated_values)\n\n    # Remove the secret key if requested\n    if keep_secret_key:\n        updated_tx.secret_key = self.secret_key\n    return updated_tx\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Transaction.signing_envelope","title":"<code>signing_envelope: List[Any]</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the list of values included in the envelope used for signing.</p>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Transaction.payload_body","title":"<code>payload_body: List[Any]</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the list of values included in the transaction body.</p>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Transaction.rlp","title":"<code>rlp: Bytes</code>  <code>cached</code> <code>property</code>","text":"<p>Returns bytes of the serialized representation of the transaction, which is almost always RLP encoding.</p>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Transaction.hash","title":"<code>hash: Hash</code>  <code>cached</code> <code>property</code>","text":"<p>Returns hash of the transaction.</p>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Transaction.signing_bytes","title":"<code>signing_bytes: Bytes</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the serialized bytes of the transaction used for signing.</p>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Transaction.signature_bytes","title":"<code>signature_bytes: Bytes</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the serialized bytes of the transaction signature.</p>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Transaction.serializable_list","title":"<code>serializable_list: Any</code>  <code>cached</code> <code>property</code>","text":"<p>Return list of values included in the transaction as a serializable object.</p>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Transaction.list_root","title":"<code>list_root(input_txs)</code>  <code>staticmethod</code>","text":"<p>Return transactions root of a list of transactions.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>@staticmethod\ndef list_root(input_txs: List[\"Transaction\"]) -&gt; Hash:\n    \"\"\"Return transactions root of a list of transactions.\"\"\"\n    t = HexaryTrie(db={})\n    for i, tx in enumerate(input_txs):\n        t.set(eth_rlp.encode(Uint(i)), tx.rlp)\n    return Hash(t.root_hash)\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Transaction.list_blob_versioned_hashes","title":"<code>list_blob_versioned_hashes(input_txs)</code>  <code>staticmethod</code>","text":"<p>Get list of ordered blob versioned hashes from a list of transactions.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>@staticmethod\ndef list_blob_versioned_hashes(input_txs: List[\"Transaction\"]) -&gt; List[Hash]:\n    \"\"\"Get list of ordered blob versioned hashes from a list of transactions.\"\"\"\n    return [\n        blob_versioned_hash\n        for tx in input_txs\n        if tx.blob_versioned_hashes is not None\n        for blob_versioned_hash in tx.blob_versioned_hashes\n    ]\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Transaction.created_contract","title":"<code>created_contract: Address</code>  <code>cached</code> <code>property</code>","text":"<p>Return address of the contract created by the transaction.</p>"},{"location":"library/ethereum_test_types/#ethereum_test_types.TransactionDefaults","title":"<code>TransactionDefaults</code>  <code>dataclass</code>","text":"<p>Default values for transactions.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>@dataclass\nclass TransactionDefaults:\n    \"\"\"Default values for transactions.\"\"\"\n\n    chain_id: int = 1\n    gas_price = 10\n    max_fee_per_gas = 7\n    max_priority_fee_per_gas: int = 0\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.TransactionReceipt","title":"<code>TransactionReceipt</code>","text":"<p>               Bases: <code>CamelModel</code></p> <p>Transaction receipt.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>class TransactionReceipt(CamelModel):\n    \"\"\"Transaction receipt.\"\"\"\n\n    transaction_hash: Hash | None = None\n    gas_used: HexNumber | None = None\n    root: Bytes | None = None\n    status: HexNumber | None = None\n    cumulative_gas_used: HexNumber | None = None\n    logs_bloom: Bloom | None = None\n    logs: List[TransactionLog] | None = None\n    contract_address: Address | None = None\n    effective_gas_price: HexNumber | None = None\n    block_hash: Hash | None = None\n    transaction_index: HexNumber | None = None\n    blob_gas_used: HexNumber | None = None\n    blob_gas_price: HexNumber | None = None\n    delegations: List[ReceiptDelegation] | None = None\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.Withdrawal","title":"<code>Withdrawal</code>","text":"<p>               Bases: <code>WithdrawalGeneric[HexNumber]</code></p> <p>Withdrawal type.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>class Withdrawal(WithdrawalGeneric[HexNumber]):\n    \"\"\"Withdrawal type.\"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.WithdrawalRequest","title":"<code>WithdrawalRequest</code>","text":"<p>               Bases: <code>RequestBase</code>, <code>CamelModel</code></p> <p>Withdrawal Request type.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>class WithdrawalRequest(RequestBase, CamelModel):\n    \"\"\"Withdrawal Request type.\"\"\"\n\n    source_address: Address = Address(0)\n    validator_pubkey: BLSPublicKey\n    amount: HexNumber\n\n    type: ClassVar[int] = 1\n\n    def __bytes__(self) -&gt; bytes:\n        \"\"\"Return withdrawal's attributes as bytes.\"\"\"\n        return (\n            bytes(self.source_address)\n            + bytes(self.validator_pubkey)\n            + self.amount.to_bytes(8, \"little\")\n        )\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.WithdrawalRequest.__bytes__","title":"<code>__bytes__()</code>","text":"<p>Return withdrawal's attributes as bytes.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def __bytes__(self) -&gt; bytes:\n    \"\"\"Return withdrawal's attributes as bytes.\"\"\"\n    return (\n        bytes(self.source_address)\n        + bytes(self.validator_pubkey)\n        + self.amount.to_bytes(8, \"little\")\n    )\n</code></pre>"},{"location":"library/ethereum_test_types/#ethereum_test_types.keccak256","title":"<code>keccak256(data)</code>","text":"<p>Calculate keccak256 hash of the given data.</p> Source code in <code>src/ethereum_test_types/types.py</code> <pre><code>def keccak256(data: bytes) -&gt; Hash:\n    \"\"\"Calculate keccak256 hash of the given data.\"\"\"\n    return Bytes(data).keccak256()\n</code></pre>"},{"location":"library/ethereum_test_vm/","title":"Ethereum Test VM package","text":"<p>Ethereum Virtual Machine related definitions and utilities.</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Bytecode","title":"<code>Bytecode</code>","text":"<p>Base class to represent EVM bytecode.</p> <p>Stack calculations are automatically done after an addition operation between two bytecode objects. The stack height is not guaranteed to be correct, so the user must take this into consideration.</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Bytecode--parameters","title":"Parameters","text":"<ul> <li>popped_stack_items: number of items the bytecode pops from the stack</li> <li>pushed_stack_items: number of items the bytecode pushes to the stack</li> <li>min_stack_height: minimum stack height required by the bytecode</li> <li>max_stack_height: maximum stack height reached by the bytecode</li> </ul> Source code in <code>src/ethereum_test_vm/bytecode.py</code> <pre><code>class Bytecode:\n    \"\"\"\n    Base class to represent EVM bytecode.\n\n    Stack calculations are automatically done after an addition operation between two bytecode\n    objects. The stack height is not guaranteed to be correct, so the user must take this into\n    consideration.\n\n    Parameters\n    ----------\n    - popped_stack_items: number of items the bytecode pops from the stack\n    - pushed_stack_items: number of items the bytecode pushes to the stack\n    - min_stack_height: minimum stack height required by the bytecode\n    - max_stack_height: maximum stack height reached by the bytecode\n\n    \"\"\"\n\n    _name_: str = \"\"\n    _bytes_: bytes\n\n    popped_stack_items: int\n    pushed_stack_items: int\n    max_stack_height: int\n    min_stack_height: int\n\n    terminating: bool\n\n    def __new__(\n        cls,\n        bytes_or_byte_code_base: \"bytes | Bytecode | None\" = None,\n        *,\n        popped_stack_items: int | None = None,\n        pushed_stack_items: int | None = None,\n        max_stack_height: int | None = None,\n        min_stack_height: int | None = None,\n        terminating: bool = False,\n        name: str = \"\",\n    ):\n        \"\"\"Create new opcode instance.\"\"\"\n        if bytes_or_byte_code_base is None:\n            instance = super().__new__(cls)\n            instance._bytes_ = b\"\"\n            instance.popped_stack_items = 0\n            instance.pushed_stack_items = 0\n            instance.min_stack_height = 0\n            instance.max_stack_height = 0\n            instance.terminating = False\n            instance._name_ = name\n            return instance\n\n        if isinstance(bytes_or_byte_code_base, Bytecode):\n            # Required because Enum class calls the base class with the instantiated object as\n            # parameter.\n            obj = super().__new__(cls)\n            obj._bytes_ = bytes_or_byte_code_base._bytes_\n            obj.popped_stack_items = bytes_or_byte_code_base.popped_stack_items\n            obj.pushed_stack_items = bytes_or_byte_code_base.pushed_stack_items\n            obj.min_stack_height = bytes_or_byte_code_base.min_stack_height\n            obj.max_stack_height = bytes_or_byte_code_base.max_stack_height\n            obj.terminating = bytes_or_byte_code_base.terminating\n            obj._name_ = bytes_or_byte_code_base._name_\n            return obj\n\n        if isinstance(bytes_or_byte_code_base, bytes):\n            obj = super().__new__(cls)\n            obj._bytes_ = bytes_or_byte_code_base\n            assert popped_stack_items is not None\n            assert pushed_stack_items is not None\n            obj.popped_stack_items = popped_stack_items\n            obj.pushed_stack_items = pushed_stack_items\n            if min_stack_height is None:\n                obj.min_stack_height = obj.popped_stack_items\n            else:\n                obj.min_stack_height = min_stack_height\n            if max_stack_height is None:\n                obj.max_stack_height = max(obj.popped_stack_items, obj.pushed_stack_items)\n            else:\n                obj.max_stack_height = max_stack_height\n            obj.terminating = terminating\n            obj._name_ = name\n            return obj\n\n        raise TypeError(\"Bytecode constructor '__new__' didn't return an instance!\")\n\n    def __bytes__(self) -&gt; bytes:\n        \"\"\"Return the opcode byte representation.\"\"\"\n        return self._bytes_\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the length of the opcode byte representation.\"\"\"\n        return len(self._bytes_)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the name of the opcode, assigned at Enum creation.\"\"\"\n        return self._name_\n\n    def __eq__(self, other):\n        \"\"\"\n        Allow comparison between Bytecode instances and bytes objects.\n\n        Raises:\n        - NotImplementedError: if the comparison is not between an Bytecode\n            or a bytes object.\n\n        \"\"\"\n        if isinstance(other, Bytecode):\n            return (\n                bytes(self) == bytes(other)\n                and self.popped_stack_items == other.popped_stack_items\n                and self.pushed_stack_items == other.pushed_stack_items\n                and self.max_stack_height == other.max_stack_height\n                and self.min_stack_height == other.min_stack_height\n            )\n        if isinstance(other, SupportsBytes) or isinstance(other, bytes):\n            return bytes(self) == bytes(other)\n        raise NotImplementedError(f\"Unsupported type for comparison: {type(other)}\")\n\n    def __hash__(self):\n        \"\"\"Return the hash of the bytecode representation.\"\"\"\n        return hash(\n            (\n                bytes(self),\n                self.popped_stack_items,\n                self.pushed_stack_items,\n                self.max_stack_height,\n                self.min_stack_height,\n            )\n        )\n\n    def __add__(self, other: \"Bytecode | bytes | int | None\") -&gt; \"Bytecode\":\n        \"\"\"Concatenate the bytecode representation with another bytecode object.\"\"\"\n        if other is None or (isinstance(other, int) and other == 0):\n            # Edge case for sum() function\n            return self\n\n        if isinstance(other, bytes):\n            c = Bytecode(self)\n            c._bytes_ += other\n            c._name_ = \"\"\n            return c\n\n        assert isinstance(other, Bytecode), \"Can only concatenate Bytecode instances\"\n        # Figure out the stack height after executing the two opcodes.\n        a_pop, a_push = self.popped_stack_items, self.pushed_stack_items\n        a_min, a_max = self.min_stack_height, self.max_stack_height\n        b_pop, b_push = other.popped_stack_items, other.pushed_stack_items\n        b_min, b_max = other.min_stack_height, other.max_stack_height\n\n        # NOTE: \"_pop\" is understood as the number of elements required by an instruction or\n        # bytecode to be popped off the stack before it starts returning (pushing).\n\n        # Auxiliary variables representing \"stages\" of the execution of `c = a + b` bytecode:\n        # Assume starting point 0 as reference:\n        a_start = 0\n        # A (potentially) pops some elements and reaches its \"bottom\", might be negative:\n        a_bottom = a_start - a_pop\n        # After this A pushes some elements, then B pops and reaches its \"bottom\":\n        b_bottom = a_bottom + a_push - b_pop\n\n        # C's bottom is either at the bottom of A or B:\n        c_bottom = min(a_bottom, b_bottom)\n        if c_bottom == a_bottom:\n            # C pops the same as A to reach its bottom, then the rest of A and B are C's \"push\"\n            c_pop = a_pop\n            c_push = a_push - b_pop + b_push\n        else:\n            # A and B are C's \"pop\" to reach its bottom, then pushes the same as B\n            c_pop = a_pop - a_push + b_pop\n            c_push = b_push\n\n        # C's minimum required stack is either A's or B's shifted by the net stack balance of A\n        c_min = max(a_min, b_min + a_pop - a_push)\n\n        # C starts from c_min, then reaches max either in the spot where A reached a_max or in the\n        # spot where B reached b_max, after A had completed.\n        c_max = max(c_min + a_max - a_min, c_min - a_pop + a_push + b_max - b_min)\n\n        return Bytecode(\n            bytes(self) + bytes(other),\n            popped_stack_items=c_pop,\n            pushed_stack_items=c_push,\n            min_stack_height=c_min,\n            max_stack_height=c_max,\n            terminating=other.terminating,\n        )\n\n    def __radd__(self, other: \"Bytecode | int | None\") -&gt; \"Bytecode\":\n        \"\"\"Concatenate the opcode byte representation with another bytes object.\"\"\"\n        if other is None or (isinstance(other, int) and other == 0):\n            # Edge case for sum() function\n            return self\n        assert isinstance(other, Bytecode), \"Can only concatenate Bytecode instances\"\n        return other.__add__(self)\n\n    def __mul__(self, other: int) -&gt; \"Bytecode\":\n        \"\"\"Concatenate another bytes object with the opcode byte representation.\"\"\"\n        if other &lt; 0:\n            raise ValueError(\"Cannot multiply by a negative number\")\n        if other == 0:\n            return Bytecode()\n        output = self\n        for _ in range(other - 1):\n            output += self\n        return output\n\n    def hex(self) -&gt; str:\n        \"\"\"Return the hexadecimal representation of the opcode byte representation.\"\"\"\n        return bytes(self).hex()\n\n    def keccak256(self) -&gt; Hash:\n        \"\"\"Return the keccak256 hash of the opcode byte representation.\"\"\"\n        return Bytes(self._bytes_).keccak256()\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Bytecode.__new__","title":"<code>__new__(bytes_or_byte_code_base=None, *, popped_stack_items=None, pushed_stack_items=None, max_stack_height=None, min_stack_height=None, terminating=False, name='')</code>","text":"<p>Create new opcode instance.</p> Source code in <code>src/ethereum_test_vm/bytecode.py</code> <pre><code>def __new__(\n    cls,\n    bytes_or_byte_code_base: \"bytes | Bytecode | None\" = None,\n    *,\n    popped_stack_items: int | None = None,\n    pushed_stack_items: int | None = None,\n    max_stack_height: int | None = None,\n    min_stack_height: int | None = None,\n    terminating: bool = False,\n    name: str = \"\",\n):\n    \"\"\"Create new opcode instance.\"\"\"\n    if bytes_or_byte_code_base is None:\n        instance = super().__new__(cls)\n        instance._bytes_ = b\"\"\n        instance.popped_stack_items = 0\n        instance.pushed_stack_items = 0\n        instance.min_stack_height = 0\n        instance.max_stack_height = 0\n        instance.terminating = False\n        instance._name_ = name\n        return instance\n\n    if isinstance(bytes_or_byte_code_base, Bytecode):\n        # Required because Enum class calls the base class with the instantiated object as\n        # parameter.\n        obj = super().__new__(cls)\n        obj._bytes_ = bytes_or_byte_code_base._bytes_\n        obj.popped_stack_items = bytes_or_byte_code_base.popped_stack_items\n        obj.pushed_stack_items = bytes_or_byte_code_base.pushed_stack_items\n        obj.min_stack_height = bytes_or_byte_code_base.min_stack_height\n        obj.max_stack_height = bytes_or_byte_code_base.max_stack_height\n        obj.terminating = bytes_or_byte_code_base.terminating\n        obj._name_ = bytes_or_byte_code_base._name_\n        return obj\n\n    if isinstance(bytes_or_byte_code_base, bytes):\n        obj = super().__new__(cls)\n        obj._bytes_ = bytes_or_byte_code_base\n        assert popped_stack_items is not None\n        assert pushed_stack_items is not None\n        obj.popped_stack_items = popped_stack_items\n        obj.pushed_stack_items = pushed_stack_items\n        if min_stack_height is None:\n            obj.min_stack_height = obj.popped_stack_items\n        else:\n            obj.min_stack_height = min_stack_height\n        if max_stack_height is None:\n            obj.max_stack_height = max(obj.popped_stack_items, obj.pushed_stack_items)\n        else:\n            obj.max_stack_height = max_stack_height\n        obj.terminating = terminating\n        obj._name_ = name\n        return obj\n\n    raise TypeError(\"Bytecode constructor '__new__' didn't return an instance!\")\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Bytecode.__bytes__","title":"<code>__bytes__()</code>","text":"<p>Return the opcode byte representation.</p> Source code in <code>src/ethereum_test_vm/bytecode.py</code> <pre><code>def __bytes__(self) -&gt; bytes:\n    \"\"\"Return the opcode byte representation.\"\"\"\n    return self._bytes_\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Bytecode.__len__","title":"<code>__len__()</code>","text":"<p>Return the length of the opcode byte representation.</p> Source code in <code>src/ethereum_test_vm/bytecode.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the length of the opcode byte representation.\"\"\"\n    return len(self._bytes_)\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Bytecode.__str__","title":"<code>__str__()</code>","text":"<p>Return the name of the opcode, assigned at Enum creation.</p> Source code in <code>src/ethereum_test_vm/bytecode.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the name of the opcode, assigned at Enum creation.\"\"\"\n    return self._name_\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Bytecode.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Allow comparison between Bytecode instances and bytes objects.</p> <ul> <li>NotImplementedError: if the comparison is not between an Bytecode     or a bytes object.</li> </ul> Source code in <code>src/ethereum_test_vm/bytecode.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Allow comparison between Bytecode instances and bytes objects.\n\n    Raises:\n    - NotImplementedError: if the comparison is not between an Bytecode\n        or a bytes object.\n\n    \"\"\"\n    if isinstance(other, Bytecode):\n        return (\n            bytes(self) == bytes(other)\n            and self.popped_stack_items == other.popped_stack_items\n            and self.pushed_stack_items == other.pushed_stack_items\n            and self.max_stack_height == other.max_stack_height\n            and self.min_stack_height == other.min_stack_height\n        )\n    if isinstance(other, SupportsBytes) or isinstance(other, bytes):\n        return bytes(self) == bytes(other)\n    raise NotImplementedError(f\"Unsupported type for comparison: {type(other)}\")\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Bytecode.__hash__","title":"<code>__hash__()</code>","text":"<p>Return the hash of the bytecode representation.</p> Source code in <code>src/ethereum_test_vm/bytecode.py</code> <pre><code>def __hash__(self):\n    \"\"\"Return the hash of the bytecode representation.\"\"\"\n    return hash(\n        (\n            bytes(self),\n            self.popped_stack_items,\n            self.pushed_stack_items,\n            self.max_stack_height,\n            self.min_stack_height,\n        )\n    )\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Bytecode.__add__","title":"<code>__add__(other)</code>","text":"<p>Concatenate the bytecode representation with another bytecode object.</p> Source code in <code>src/ethereum_test_vm/bytecode.py</code> <pre><code>def __add__(self, other: \"Bytecode | bytes | int | None\") -&gt; \"Bytecode\":\n    \"\"\"Concatenate the bytecode representation with another bytecode object.\"\"\"\n    if other is None or (isinstance(other, int) and other == 0):\n        # Edge case for sum() function\n        return self\n\n    if isinstance(other, bytes):\n        c = Bytecode(self)\n        c._bytes_ += other\n        c._name_ = \"\"\n        return c\n\n    assert isinstance(other, Bytecode), \"Can only concatenate Bytecode instances\"\n    # Figure out the stack height after executing the two opcodes.\n    a_pop, a_push = self.popped_stack_items, self.pushed_stack_items\n    a_min, a_max = self.min_stack_height, self.max_stack_height\n    b_pop, b_push = other.popped_stack_items, other.pushed_stack_items\n    b_min, b_max = other.min_stack_height, other.max_stack_height\n\n    # NOTE: \"_pop\" is understood as the number of elements required by an instruction or\n    # bytecode to be popped off the stack before it starts returning (pushing).\n\n    # Auxiliary variables representing \"stages\" of the execution of `c = a + b` bytecode:\n    # Assume starting point 0 as reference:\n    a_start = 0\n    # A (potentially) pops some elements and reaches its \"bottom\", might be negative:\n    a_bottom = a_start - a_pop\n    # After this A pushes some elements, then B pops and reaches its \"bottom\":\n    b_bottom = a_bottom + a_push - b_pop\n\n    # C's bottom is either at the bottom of A or B:\n    c_bottom = min(a_bottom, b_bottom)\n    if c_bottom == a_bottom:\n        # C pops the same as A to reach its bottom, then the rest of A and B are C's \"push\"\n        c_pop = a_pop\n        c_push = a_push - b_pop + b_push\n    else:\n        # A and B are C's \"pop\" to reach its bottom, then pushes the same as B\n        c_pop = a_pop - a_push + b_pop\n        c_push = b_push\n\n    # C's minimum required stack is either A's or B's shifted by the net stack balance of A\n    c_min = max(a_min, b_min + a_pop - a_push)\n\n    # C starts from c_min, then reaches max either in the spot where A reached a_max or in the\n    # spot where B reached b_max, after A had completed.\n    c_max = max(c_min + a_max - a_min, c_min - a_pop + a_push + b_max - b_min)\n\n    return Bytecode(\n        bytes(self) + bytes(other),\n        popped_stack_items=c_pop,\n        pushed_stack_items=c_push,\n        min_stack_height=c_min,\n        max_stack_height=c_max,\n        terminating=other.terminating,\n    )\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Bytecode.__radd__","title":"<code>__radd__(other)</code>","text":"<p>Concatenate the opcode byte representation with another bytes object.</p> Source code in <code>src/ethereum_test_vm/bytecode.py</code> <pre><code>def __radd__(self, other: \"Bytecode | int | None\") -&gt; \"Bytecode\":\n    \"\"\"Concatenate the opcode byte representation with another bytes object.\"\"\"\n    if other is None or (isinstance(other, int) and other == 0):\n        # Edge case for sum() function\n        return self\n    assert isinstance(other, Bytecode), \"Can only concatenate Bytecode instances\"\n    return other.__add__(self)\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Bytecode.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Concatenate another bytes object with the opcode byte representation.</p> Source code in <code>src/ethereum_test_vm/bytecode.py</code> <pre><code>def __mul__(self, other: int) -&gt; \"Bytecode\":\n    \"\"\"Concatenate another bytes object with the opcode byte representation.\"\"\"\n    if other &lt; 0:\n        raise ValueError(\"Cannot multiply by a negative number\")\n    if other == 0:\n        return Bytecode()\n    output = self\n    for _ in range(other - 1):\n        output += self\n    return output\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Bytecode.hex","title":"<code>hex()</code>","text":"<p>Return the hexadecimal representation of the opcode byte representation.</p> Source code in <code>src/ethereum_test_vm/bytecode.py</code> <pre><code>def hex(self) -&gt; str:\n    \"\"\"Return the hexadecimal representation of the opcode byte representation.\"\"\"\n    return bytes(self).hex()\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Bytecode.keccak256","title":"<code>keccak256()</code>","text":"<p>Return the keccak256 hash of the opcode byte representation.</p> Source code in <code>src/ethereum_test_vm/bytecode.py</code> <pre><code>def keccak256(self) -&gt; Hash:\n    \"\"\"Return the keccak256 hash of the opcode byte representation.\"\"\"\n    return Bytes(self._bytes_).keccak256()\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.EVMCodeType","title":"<code>EVMCodeType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum representing the type of EVM code that is supported in a given fork.</p> Source code in <code>src/ethereum_test_vm/evm_types.py</code> <pre><code>class EVMCodeType(str, Enum):\n    \"\"\"Enum representing the type of EVM code that is supported in a given fork.\"\"\"\n\n    LEGACY = \"legacy\"\n    EOF_V1 = \"eof_v1\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the name of the EVM code type.\"\"\"\n        return self.name\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.EVMCodeType.__str__","title":"<code>__str__()</code>","text":"<p>Return the name of the EVM code type.</p> Source code in <code>src/ethereum_test_vm/evm_types.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the name of the EVM code type.\"\"\"\n    return self.name\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.call_return_code","title":"<code>call_return_code(opcode, success, *, revert=False)</code>","text":"<p>Return return code for a CALL operation.</p> Source code in <code>src/ethereum_test_vm/helpers.py</code> <pre><code>def call_return_code(opcode: Op, success: bool, *, revert: bool = False) -&gt; int:\n    \"\"\"Return return code for a CALL operation.\"\"\"\n    if opcode in [Op.CALL, Op.CALLCODE, Op.DELEGATECALL, Op.STATICCALL]:\n        return int(success)\n    elif opcode in [Op.EXTCALL, Op.EXTDELEGATECALL, Op.EXTSTATICCALL]:\n        if success:\n            return 0\n        if revert:\n            return 1\n        return 2\n    raise ValueError(f\"Not a call opcode: {opcode}\")\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Macro","title":"<code>Macro</code>","text":"<p>               Bases: <code>Bytecode</code></p> <p>Represents opcode macro replacement, basically holds bytes.</p> Source code in <code>src/ethereum_test_vm/opcode.py</code> <pre><code>class Macro(Bytecode):\n    \"\"\"Represents opcode macro replacement, basically holds bytes.\"\"\"\n\n    lambda_operation: Callable[..., Bytecode] | None\n\n    def __new__(\n        cls,\n        macro_or_bytes: Optional[\"Bytecode | Macro\"] = None,\n        *,\n        lambda_operation: Callable[..., Bytecode] | None = None,\n    ):\n        \"\"\"Create new opcode macro instance.\"\"\"\n        if macro_or_bytes is None:\n            macro_or_bytes = Bytecode()\n        if isinstance(macro_or_bytes, Macro):\n            # Required because Enum class calls the base class with the instantiated object as\n            # parameter.\n            return macro_or_bytes\n        else:\n            instance = super().__new__(cls, macro_or_bytes)\n            instance.lambda_operation = lambda_operation\n            return instance\n\n    def __call__(self, *args_t: OpcodeCallArg) -&gt; Bytecode:\n        \"\"\"Perform macro operation if any. Otherwise is a no-op.\"\"\"\n        if self.lambda_operation is not None:\n            return self.lambda_operation(*args_t)\n\n        pre_opcode_bytecode = Bytecode()\n        for arg in args_t:\n            pre_opcode_bytecode += _stack_argument_to_bytecode(arg)\n        return pre_opcode_bytecode + self\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Macro.__new__","title":"<code>__new__(macro_or_bytes=None, *, lambda_operation=None)</code>","text":"<p>Create new opcode macro instance.</p> Source code in <code>src/ethereum_test_vm/opcode.py</code> <pre><code>def __new__(\n    cls,\n    macro_or_bytes: Optional[\"Bytecode | Macro\"] = None,\n    *,\n    lambda_operation: Callable[..., Bytecode] | None = None,\n):\n    \"\"\"Create new opcode macro instance.\"\"\"\n    if macro_or_bytes is None:\n        macro_or_bytes = Bytecode()\n    if isinstance(macro_or_bytes, Macro):\n        # Required because Enum class calls the base class with the instantiated object as\n        # parameter.\n        return macro_or_bytes\n    else:\n        instance = super().__new__(cls, macro_or_bytes)\n        instance.lambda_operation = lambda_operation\n        return instance\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Macro.__call__","title":"<code>__call__(*args_t)</code>","text":"<p>Perform macro operation if any. Otherwise is a no-op.</p> Source code in <code>src/ethereum_test_vm/opcode.py</code> <pre><code>def __call__(self, *args_t: OpcodeCallArg) -&gt; Bytecode:\n    \"\"\"Perform macro operation if any. Otherwise is a no-op.\"\"\"\n    if self.lambda_operation is not None:\n        return self.lambda_operation(*args_t)\n\n    pre_opcode_bytecode = Bytecode()\n    for arg in args_t:\n        pre_opcode_bytecode += _stack_argument_to_bytecode(arg)\n    return pre_opcode_bytecode + self\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Macros","title":"<code>Macros</code>","text":"<p>               Bases: <code>Macro</code>, <code>Enum</code></p> <p>Enum containing all macros.</p> Source code in <code>src/ethereum_test_vm/opcode.py</code> <pre><code>class Macros(Macro, Enum):\n    \"\"\"Enum containing all macros.\"\"\"\n\n    OOG = Macro(Opcodes.SHA3(0, 100000000000))\n    \"\"\"\n    OOG()\n    ----\n\n    Halt execution by consuming all available gas.\n\n    Inputs\n    ----\n    - None. Any input arguments are ignored.\n\n    Outputs\n    ----\n    - None\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    `SHA3(0, 100000000000)` results in 19073514453125027 gas used and an OOG\n    exception.\n\n    Note:\n    If a value &gt; `100000000000` is used as second argument, the resulting geth\n     trace reports gas `30` and an OOG exception.\n    `SHA3(0, SUB(0, 1))` causes a gas &gt; u64 exception and an OOG exception.\n\n    Bytecode\n    ----\n    SHA3(0, 100000000000)\n    \"\"\"\n\n    MSTORE = Macro(lambda_operation=_mstore_operation)\n    \"\"\"\n    MSTORE(data, offset)\n    ----\n\n    Place data of arbitrary length into memory at a given offset.\n\n    Inputs\n    ----\n    - data: The data to store in memory. Can be an integer or bytes.\n    - offset: The offset in memory to store the data.\n\n    Outputs\n    ----\n    - None\n    \"\"\"\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Macros.OOG","title":"<code>OOG = Macro(Opcodes.SHA3(0, 100000000000))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Macros.OOG--oog","title":"OOG()","text":"<p>Halt execution by consuming all available gas.</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Macros.OOG--inputs","title":"Inputs","text":"<ul> <li>None. Any input arguments are ignored.</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Macros.OOG--outputs","title":"Outputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Macros.OOG--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Macros.OOG--gas","title":"Gas","text":"<p><code>SHA3(0, 100000000000)</code> results in 19073514453125027 gas used and an OOG exception.</p> <p>Note: If a value &gt; <code>100000000000</code> is used as second argument, the resulting geth  trace reports gas <code>30</code> and an OOG exception. <code>SHA3(0, SUB(0, 1))</code> causes a gas &gt; u64 exception and an OOG exception.</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Macros.OOG--bytecode","title":"Bytecode","text":"<p>SHA3(0, 100000000000)</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Macros.MSTORE","title":"<code>MSTORE = Macro(lambda_operation=_mstore_operation)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Macros.MSTORE--mstoredata-offset","title":"MSTORE(data, offset)","text":"<p>Place data of arbitrary length into memory at a given offset.</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Macros.MSTORE--inputs","title":"Inputs","text":"<ul> <li>data: The data to store in memory. Can be an integer or bytes.</li> <li>offset: The offset in memory to store the data.</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Macros.MSTORE--outputs","title":"Outputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcode","title":"<code>Opcode</code>","text":"<p>               Bases: <code>Bytecode</code></p> <p>Represents a single Opcode instruction in the EVM, with extra metadata useful to parametrize tests.</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcode--parameters","title":"Parameters","text":"<ul> <li>data_portion_length: number of bytes after the opcode in the bytecode     that represent data</li> <li>data_portion_formatter: function to format the data portion of the opcode, if any</li> <li>stack_properties_modifier: function to modify the stack properties of the opcode after the     data portion has been processed</li> <li>kwargs: list of keyword arguments that can be passed to the opcode, in the order they are     meant to be placed in the stack</li> <li>kwargs_defaults: default values for the keyword arguments if any, otherwise 0</li> <li>unchecked_stack: whether the bytecode should ignore stack checks when being called</li> </ul> Source code in <code>src/ethereum_test_vm/opcode.py</code> <pre><code>class Opcode(Bytecode):\n    \"\"\"\n    Represents a single Opcode instruction in the EVM, with extra metadata useful to parametrize\n    tests.\n\n    Parameters\n    ----------\n    - data_portion_length: number of bytes after the opcode in the bytecode\n        that represent data\n    - data_portion_formatter: function to format the data portion of the opcode, if any\n    - stack_properties_modifier: function to modify the stack properties of the opcode after the\n        data portion has been processed\n    - kwargs: list of keyword arguments that can be passed to the opcode, in the order they are\n        meant to be placed in the stack\n    - kwargs_defaults: default values for the keyword arguments if any, otherwise 0\n    - unchecked_stack: whether the bytecode should ignore stack checks when being called\n\n    \"\"\"\n\n    data_portion_length: int\n    data_portion_formatter: Optional[Callable[[Any], bytes]]\n    stack_properties_modifier: Optional[Callable[[Any], tuple[int, int, int, int]]]\n    kwargs: List[str] | None\n    kwargs_defaults: KW_ARGS_DEFAULTS_TYPE\n    unchecked_stack: bool = False\n\n    def __new__(\n        cls,\n        opcode_or_byte: \"int | bytes | Opcode\",\n        *,\n        popped_stack_items: int = 0,\n        pushed_stack_items: int = 0,\n        max_stack_height: int | None = None,\n        min_stack_height: int | None = None,\n        data_portion_length: int = 0,\n        data_portion_formatter=None,\n        stack_properties_modifier=None,\n        unchecked_stack=False,\n        terminating: bool = False,\n        kwargs: List[str] | None = None,\n        kwargs_defaults: Optional[KW_ARGS_DEFAULTS_TYPE] = None,\n    ):\n        \"\"\"Create new opcode instance.\"\"\"\n        if kwargs_defaults is None:\n            kwargs_defaults = {}\n        if type(opcode_or_byte) is Opcode:\n            # Required because Enum class calls the base class with the instantiated object as\n            # parameter.\n            return opcode_or_byte\n        elif isinstance(opcode_or_byte, int) or isinstance(opcode_or_byte, bytes):\n            obj_bytes = (\n                bytes([opcode_or_byte]) if isinstance(opcode_or_byte, int) else opcode_or_byte\n            )\n            if min_stack_height is None:\n                min_stack_height = popped_stack_items\n            if max_stack_height is None:\n                max_stack_height = max(\n                    min_stack_height - popped_stack_items + pushed_stack_items, min_stack_height\n                )\n            obj = super().__new__(\n                cls,\n                obj_bytes,\n                popped_stack_items=popped_stack_items,\n                pushed_stack_items=pushed_stack_items,\n                max_stack_height=max_stack_height,\n                min_stack_height=min_stack_height,\n                terminating=terminating,\n            )\n            obj.data_portion_length = data_portion_length\n            obj.data_portion_formatter = data_portion_formatter\n            obj.stack_properties_modifier = stack_properties_modifier\n            obj.unchecked_stack = unchecked_stack\n            obj.kwargs = kwargs\n            obj.kwargs_defaults = kwargs_defaults\n            return obj\n        raise TypeError(\"Opcode constructor '__new__' didn't return an instance!\")\n\n    def __getitem__(self, *args: \"int | bytes | str | Iterable[int]\") -&gt; \"Opcode\":\n        \"\"\"\n        Initialize a new instance of the opcode with the data portion set, and also clear\n        the data portion variables to avoid reusing them.\n        \"\"\"\n        if self.data_portion_formatter is None and self.data_portion_length == 0:\n            raise ValueError(\"Opcode does not have a data portion or has already been set\")\n        data_portion = bytes()\n\n        if self.data_portion_formatter is not None:\n            if len(args) == 1 and isinstance(args[0], Iterable) and not isinstance(args[0], bytes):\n                data_portion = self.data_portion_formatter(*args[0])\n            else:\n                data_portion = self.data_portion_formatter(*args)\n        elif self.data_portion_length &gt; 0:\n            # For opcodes with a data portion, the first argument is the data and the rest of the\n            # arguments form the stack.\n            assert len(args) == 1, \"Opcode with data portion requires exactly one argument\"\n            data = args[0]\n            if isinstance(data, bytes) or isinstance(data, SupportsBytes) or isinstance(data, str):\n                if isinstance(data, str):\n                    if data.startswith(\"0x\"):\n                        data = data[2:]\n                    data = bytes.fromhex(data)\n                elif isinstance(data, SupportsBytes):\n                    data = bytes(data)\n                assert len(data) &lt;= self.data_portion_length\n                data_portion = data.rjust(self.data_portion_length, b\"\\x00\")\n            elif isinstance(data, int):\n                signed = data &lt; 0\n                data_portion = data.to_bytes(\n                    length=self.data_portion_length,\n                    byteorder=\"big\",\n                    signed=signed,\n                )\n            else:\n                raise TypeError(\"Opcode data portion must be either an int or bytes/hex string\")\n        popped_stack_items = self.popped_stack_items\n        pushed_stack_items = self.pushed_stack_items\n        min_stack_height = self.min_stack_height\n        max_stack_height = self.max_stack_height\n        assert (\n            popped_stack_items is not None\n            and pushed_stack_items is not None\n            and min_stack_height is not None\n        )\n        if self.stack_properties_modifier is not None:\n            (\n                popped_stack_items,\n                pushed_stack_items,\n                min_stack_height,\n                max_stack_height,\n            ) = self.stack_properties_modifier(data_portion)\n\n        new_opcode = Opcode(\n            bytes(self) + data_portion,\n            popped_stack_items=popped_stack_items,\n            pushed_stack_items=pushed_stack_items,\n            min_stack_height=min_stack_height,\n            max_stack_height=max_stack_height,\n            data_portion_length=0,\n            data_portion_formatter=None,\n            unchecked_stack=self.unchecked_stack,\n            terminating=self.terminating,\n            kwargs=self.kwargs,\n            kwargs_defaults=self.kwargs_defaults,\n        )\n        new_opcode._name_ = f\"{self._name_}_0x{data_portion.hex()}\"\n        return new_opcode\n\n    def __call__(\n        self,\n        *args_t: \"int | bytes | str | Opcode | Bytecode | Iterable[int]\",\n        unchecked: bool = False,\n        **kwargs: \"int | bytes | str | Opcode | Bytecode\",\n    ) -&gt; Bytecode:\n        \"\"\"\n        Make all opcode instances callable to return formatted bytecode, which constitutes a data\n        portion, that is located after the opcode byte, and pre-opcode bytecode, which is normally\n        used to set up the stack.\n\n        This useful to automatically format, e.g., call opcodes and their stack arguments as\n        `Opcodes.CALL(Opcodes.GAS, 0x1234, 0x0, 0x0, 0x0, 0x0, 0x0)`.\n\n        Data sign is automatically detected but for this reason the range of the input must be:\n        `[-2^(data_portion_bits-1), 2^(data_portion_bits)]` where: `data_portion_bits ==\n        data_portion_length * 8`\n\n        For the stack, the arguments are set up in the opposite order they are given, so the first\n        argument is the last item pushed to the stack.\n\n        The resulting stack arrangement does not take into account opcode stack element\n        consumption, so the stack height is not guaranteed to be correct and the user must take\n        this into consideration.\n\n        Integers can also be used as stack elements, in which case they are automatically converted\n        to PUSH operations, and negative numbers always use a PUSH32 operation.\n\n        Hex-strings will be automatically converted to bytes.\n        \"\"\"\n        args: List[\"int | bytes | str | Opcode | Bytecode | Iterable[int]\"] = list(args_t)\n\n        if self.has_data_portion():\n            if len(args) == 0:\n                raise ValueError(\"Opcode with data portion requires at least one argument\")\n            assert type(self) is Opcode\n            get_item_arg = args.pop()\n            assert not isinstance(get_item_arg, Bytecode)\n            return self[get_item_arg](*args)\n\n        if self.kwargs is not None and len(kwargs) &gt; 0:\n            assert len(args) == 0, f\"Cannot mix positional and keyword arguments {args} {kwargs}\"\n            for kw in self.kwargs:\n                args.append(kwargs[kw] if kw in kwargs else self.kwargs_defaults.get(kw, 0))\n\n        # The rest of the arguments form the stack.\n        if len(args) != self.popped_stack_items and not (unchecked or self.unchecked_stack):\n            raise ValueError(\n                f\"Opcode {self._name_} requires {self.popped_stack_items} stack elements, but \"\n                f\"{len(args)} were provided. Use 'unchecked=True' parameter to ignore this check.\"\n            )\n\n        pre_opcode_bytecode = Bytecode()\n        while len(args) &gt; 0:\n            pre_opcode_bytecode += _stack_argument_to_bytecode(args.pop())\n        return pre_opcode_bytecode + self\n\n    def __lt__(self, other: \"Opcode\") -&gt; bool:\n        \"\"\"Compare two opcodes by their integer value.\"\"\"\n        return self.int() &lt; other.int()\n\n    def __gt__(self, other: \"Opcode\") -&gt; bool:\n        \"\"\"Compare two opcodes by their integer value.\"\"\"\n        return self.int() &gt; other.int()\n\n    def int(self) -&gt; int:\n        \"\"\"Return integer representation of the opcode.\"\"\"\n        return int.from_bytes(self, byteorder=\"big\")\n\n    def has_data_portion(self) -&gt; bool:\n        \"\"\"Return whether the opcode has a data portion.\"\"\"\n        return self.data_portion_length &gt; 0 or self.data_portion_formatter is not None\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcode.__new__","title":"<code>__new__(opcode_or_byte, *, popped_stack_items=0, pushed_stack_items=0, max_stack_height=None, min_stack_height=None, data_portion_length=0, data_portion_formatter=None, stack_properties_modifier=None, unchecked_stack=False, terminating=False, kwargs=None, kwargs_defaults=None)</code>","text":"<p>Create new opcode instance.</p> Source code in <code>src/ethereum_test_vm/opcode.py</code> <pre><code>def __new__(\n    cls,\n    opcode_or_byte: \"int | bytes | Opcode\",\n    *,\n    popped_stack_items: int = 0,\n    pushed_stack_items: int = 0,\n    max_stack_height: int | None = None,\n    min_stack_height: int | None = None,\n    data_portion_length: int = 0,\n    data_portion_formatter=None,\n    stack_properties_modifier=None,\n    unchecked_stack=False,\n    terminating: bool = False,\n    kwargs: List[str] | None = None,\n    kwargs_defaults: Optional[KW_ARGS_DEFAULTS_TYPE] = None,\n):\n    \"\"\"Create new opcode instance.\"\"\"\n    if kwargs_defaults is None:\n        kwargs_defaults = {}\n    if type(opcode_or_byte) is Opcode:\n        # Required because Enum class calls the base class with the instantiated object as\n        # parameter.\n        return opcode_or_byte\n    elif isinstance(opcode_or_byte, int) or isinstance(opcode_or_byte, bytes):\n        obj_bytes = (\n            bytes([opcode_or_byte]) if isinstance(opcode_or_byte, int) else opcode_or_byte\n        )\n        if min_stack_height is None:\n            min_stack_height = popped_stack_items\n        if max_stack_height is None:\n            max_stack_height = max(\n                min_stack_height - popped_stack_items + pushed_stack_items, min_stack_height\n            )\n        obj = super().__new__(\n            cls,\n            obj_bytes,\n            popped_stack_items=popped_stack_items,\n            pushed_stack_items=pushed_stack_items,\n            max_stack_height=max_stack_height,\n            min_stack_height=min_stack_height,\n            terminating=terminating,\n        )\n        obj.data_portion_length = data_portion_length\n        obj.data_portion_formatter = data_portion_formatter\n        obj.stack_properties_modifier = stack_properties_modifier\n        obj.unchecked_stack = unchecked_stack\n        obj.kwargs = kwargs\n        obj.kwargs_defaults = kwargs_defaults\n        return obj\n    raise TypeError(\"Opcode constructor '__new__' didn't return an instance!\")\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcode.__getitem__","title":"<code>__getitem__(*args)</code>","text":"<p>Initialize a new instance of the opcode with the data portion set, and also clear the data portion variables to avoid reusing them.</p> Source code in <code>src/ethereum_test_vm/opcode.py</code> <pre><code>def __getitem__(self, *args: \"int | bytes | str | Iterable[int]\") -&gt; \"Opcode\":\n    \"\"\"\n    Initialize a new instance of the opcode with the data portion set, and also clear\n    the data portion variables to avoid reusing them.\n    \"\"\"\n    if self.data_portion_formatter is None and self.data_portion_length == 0:\n        raise ValueError(\"Opcode does not have a data portion or has already been set\")\n    data_portion = bytes()\n\n    if self.data_portion_formatter is not None:\n        if len(args) == 1 and isinstance(args[0], Iterable) and not isinstance(args[0], bytes):\n            data_portion = self.data_portion_formatter(*args[0])\n        else:\n            data_portion = self.data_portion_formatter(*args)\n    elif self.data_portion_length &gt; 0:\n        # For opcodes with a data portion, the first argument is the data and the rest of the\n        # arguments form the stack.\n        assert len(args) == 1, \"Opcode with data portion requires exactly one argument\"\n        data = args[0]\n        if isinstance(data, bytes) or isinstance(data, SupportsBytes) or isinstance(data, str):\n            if isinstance(data, str):\n                if data.startswith(\"0x\"):\n                    data = data[2:]\n                data = bytes.fromhex(data)\n            elif isinstance(data, SupportsBytes):\n                data = bytes(data)\n            assert len(data) &lt;= self.data_portion_length\n            data_portion = data.rjust(self.data_portion_length, b\"\\x00\")\n        elif isinstance(data, int):\n            signed = data &lt; 0\n            data_portion = data.to_bytes(\n                length=self.data_portion_length,\n                byteorder=\"big\",\n                signed=signed,\n            )\n        else:\n            raise TypeError(\"Opcode data portion must be either an int or bytes/hex string\")\n    popped_stack_items = self.popped_stack_items\n    pushed_stack_items = self.pushed_stack_items\n    min_stack_height = self.min_stack_height\n    max_stack_height = self.max_stack_height\n    assert (\n        popped_stack_items is not None\n        and pushed_stack_items is not None\n        and min_stack_height is not None\n    )\n    if self.stack_properties_modifier is not None:\n        (\n            popped_stack_items,\n            pushed_stack_items,\n            min_stack_height,\n            max_stack_height,\n        ) = self.stack_properties_modifier(data_portion)\n\n    new_opcode = Opcode(\n        bytes(self) + data_portion,\n        popped_stack_items=popped_stack_items,\n        pushed_stack_items=pushed_stack_items,\n        min_stack_height=min_stack_height,\n        max_stack_height=max_stack_height,\n        data_portion_length=0,\n        data_portion_formatter=None,\n        unchecked_stack=self.unchecked_stack,\n        terminating=self.terminating,\n        kwargs=self.kwargs,\n        kwargs_defaults=self.kwargs_defaults,\n    )\n    new_opcode._name_ = f\"{self._name_}_0x{data_portion.hex()}\"\n    return new_opcode\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcode.__call__","title":"<code>__call__(*args_t, unchecked=False, **kwargs)</code>","text":"<p>Make all opcode instances callable to return formatted bytecode, which constitutes a data portion, that is located after the opcode byte, and pre-opcode bytecode, which is normally used to set up the stack.</p> <p>This useful to automatically format, e.g., call opcodes and their stack arguments as <code>Opcodes.CALL(Opcodes.GAS, 0x1234, 0x0, 0x0, 0x0, 0x0, 0x0)</code>.</p> <p>Data sign is automatically detected but for this reason the range of the input must be: <code>[-2^(data_portion_bits-1), 2^(data_portion_bits)]</code> where: <code>data_portion_bits == data_portion_length * 8</code></p> <p>For the stack, the arguments are set up in the opposite order they are given, so the first argument is the last item pushed to the stack.</p> <p>The resulting stack arrangement does not take into account opcode stack element consumption, so the stack height is not guaranteed to be correct and the user must take this into consideration.</p> <p>Integers can also be used as stack elements, in which case they are automatically converted to PUSH operations, and negative numbers always use a PUSH32 operation.</p> <p>Hex-strings will be automatically converted to bytes.</p> Source code in <code>src/ethereum_test_vm/opcode.py</code> <pre><code>def __call__(\n    self,\n    *args_t: \"int | bytes | str | Opcode | Bytecode | Iterable[int]\",\n    unchecked: bool = False,\n    **kwargs: \"int | bytes | str | Opcode | Bytecode\",\n) -&gt; Bytecode:\n    \"\"\"\n    Make all opcode instances callable to return formatted bytecode, which constitutes a data\n    portion, that is located after the opcode byte, and pre-opcode bytecode, which is normally\n    used to set up the stack.\n\n    This useful to automatically format, e.g., call opcodes and their stack arguments as\n    `Opcodes.CALL(Opcodes.GAS, 0x1234, 0x0, 0x0, 0x0, 0x0, 0x0)`.\n\n    Data sign is automatically detected but for this reason the range of the input must be:\n    `[-2^(data_portion_bits-1), 2^(data_portion_bits)]` where: `data_portion_bits ==\n    data_portion_length * 8`\n\n    For the stack, the arguments are set up in the opposite order they are given, so the first\n    argument is the last item pushed to the stack.\n\n    The resulting stack arrangement does not take into account opcode stack element\n    consumption, so the stack height is not guaranteed to be correct and the user must take\n    this into consideration.\n\n    Integers can also be used as stack elements, in which case they are automatically converted\n    to PUSH operations, and negative numbers always use a PUSH32 operation.\n\n    Hex-strings will be automatically converted to bytes.\n    \"\"\"\n    args: List[\"int | bytes | str | Opcode | Bytecode | Iterable[int]\"] = list(args_t)\n\n    if self.has_data_portion():\n        if len(args) == 0:\n            raise ValueError(\"Opcode with data portion requires at least one argument\")\n        assert type(self) is Opcode\n        get_item_arg = args.pop()\n        assert not isinstance(get_item_arg, Bytecode)\n        return self[get_item_arg](*args)\n\n    if self.kwargs is not None and len(kwargs) &gt; 0:\n        assert len(args) == 0, f\"Cannot mix positional and keyword arguments {args} {kwargs}\"\n        for kw in self.kwargs:\n            args.append(kwargs[kw] if kw in kwargs else self.kwargs_defaults.get(kw, 0))\n\n    # The rest of the arguments form the stack.\n    if len(args) != self.popped_stack_items and not (unchecked or self.unchecked_stack):\n        raise ValueError(\n            f\"Opcode {self._name_} requires {self.popped_stack_items} stack elements, but \"\n            f\"{len(args)} were provided. Use 'unchecked=True' parameter to ignore this check.\"\n        )\n\n    pre_opcode_bytecode = Bytecode()\n    while len(args) &gt; 0:\n        pre_opcode_bytecode += _stack_argument_to_bytecode(args.pop())\n    return pre_opcode_bytecode + self\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcode.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Compare two opcodes by their integer value.</p> Source code in <code>src/ethereum_test_vm/opcode.py</code> <pre><code>def __lt__(self, other: \"Opcode\") -&gt; bool:\n    \"\"\"Compare two opcodes by their integer value.\"\"\"\n    return self.int() &lt; other.int()\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcode.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Compare two opcodes by their integer value.</p> Source code in <code>src/ethereum_test_vm/opcode.py</code> <pre><code>def __gt__(self, other: \"Opcode\") -&gt; bool:\n    \"\"\"Compare two opcodes by their integer value.\"\"\"\n    return self.int() &gt; other.int()\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcode.int","title":"<code>int()</code>","text":"<p>Return integer representation of the opcode.</p> Source code in <code>src/ethereum_test_vm/opcode.py</code> <pre><code>def int(self) -&gt; int:\n    \"\"\"Return integer representation of the opcode.\"\"\"\n    return int.from_bytes(self, byteorder=\"big\")\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcode.has_data_portion","title":"<code>has_data_portion()</code>","text":"<p>Return whether the opcode has a data portion.</p> Source code in <code>src/ethereum_test_vm/opcode.py</code> <pre><code>def has_data_portion(self) -&gt; bool:\n    \"\"\"Return whether the opcode has a data portion.\"\"\"\n    return self.data_portion_length &gt; 0 or self.data_portion_formatter is not None\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes","title":"<code>Opcodes</code>","text":"<p>               Bases: <code>Opcode</code>, <code>Enum</code></p> <p>Enum containing all known opcodes.</p> <p>Contains deprecated and not yet implemented opcodes.</p> <p>This enum is !! NOT !! meant to be iterated over by the tests. Instead, create a list with cherry-picked opcodes from this Enum within the test if iteration is needed.</p> <p>Do !! NOT !! remove or modify existing opcodes from this list.</p> Source code in <code>src/ethereum_test_vm/opcode.py</code> <pre><code>class Opcodes(Opcode, Enum):\n    \"\"\"\n    Enum containing all known opcodes.\n\n    Contains deprecated and not yet implemented opcodes.\n\n    This enum is !! NOT !! meant to be iterated over by the tests. Instead, create a list with\n    cherry-picked opcodes from this Enum within the test if iteration is needed.\n\n    Do !! NOT !! remove or modify existing opcodes from this list.\n    \"\"\"\n\n    STOP = Opcode(0x00, terminating=True)\n    \"\"\"\n    STOP()\n    ----\n\n    Description\n    ----\n    Stop execution\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - None\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    0\n\n    Source: [evm.codes/#00](https://www.evm.codes/#00)\n    \"\"\"\n\n    ADD = Opcode(0x01, popped_stack_items=2, pushed_stack_items=1)\n    \"\"\"\n    ADD(a, b) = c\n    ----\n\n    Description\n    ----\n    Addition operation\n\n    Inputs\n    ----\n    - a: first integer value to add\n    - b: second integer value to add\n\n    Outputs\n    ----\n    - c: integer result of the addition modulo 2**256\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#01](https://www.evm.codes/#01)\n    \"\"\"\n\n    MUL = Opcode(0x02, popped_stack_items=2, pushed_stack_items=1)\n    \"\"\"\n    MUL(a, b) = c\n    ----\n\n    Description\n    ----\n    Multiplication operation\n\n    Inputs\n    ----\n    - a: first integer value to multiply\n    - b: second integer value to multiply\n\n    Outputs\n    ----\n    - c: integer result of the multiplication modulo 2**256\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    5\n\n    Source: [evm.codes/#02](https://www.evm.codes/#02)\n    \"\"\"\n\n    SUB = Opcode(0x03, popped_stack_items=2, pushed_stack_items=1)\n    \"\"\"\n    SUB(a, b) = c\n    ----\n\n    Description\n    ----\n    Subtraction operation\n\n    Inputs\n    ----\n    - a: first integer value\n    - b: second integer value\n\n    Outputs\n    ----\n    - c: integer result of the subtraction modulo 2**256\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#03](https://www.evm.codes/#03)\n    \"\"\"\n\n    DIV = Opcode(0x04, popped_stack_items=2, pushed_stack_items=1)\n    \"\"\"\n    DIV(a, b) = c\n    ----\n\n    Description\n    ----\n    Division operation\n\n    Inputs\n    ----\n    - a: numerator\n    - b: denominator (must be non-zero)\n\n    Outputs\n    ----\n    - c: integer result of the division\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    5\n\n    Source: [evm.codes/#04](https://www.evm.codes/#04)\n    \"\"\"\n\n    SDIV = Opcode(0x05, popped_stack_items=2, pushed_stack_items=1)\n    \"\"\"\n    SDIV(a, b) = c\n    ----\n\n    Description\n    ----\n    Signed division operation\n\n    Inputs\n    ----\n    - a: signed numerator\n    - b: signed denominator\n\n    Outputs\n    ----\n    - c: signed integer result of the division. If the denominator is 0, the result will be 0\n    ----\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    5\n\n    Source: [evm.codes/#05](https://www.evm.codes/#05)\n    \"\"\"\n\n    MOD = Opcode(0x06, popped_stack_items=2, pushed_stack_items=1)\n    \"\"\"\n    MOD(a, b) = c\n    ----\n\n    Description\n    ----\n    Modulo operation\n\n    Inputs\n    ----\n    - a: integer numerator\n    - b: integer denominator\n\n    Outputs\n    ----\n    - a % b: integer result of the integer modulo. If the denominator is 0, the result will be 0\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    5\n\n    Source: [evm.codes/#06](https://www.evm.codes/#06)\n    \"\"\"\n\n    SMOD = Opcode(0x07, popped_stack_items=2, pushed_stack_items=1)\n    \"\"\"\n    SMOD(a, b) = c\n    ----\n\n    Description\n    ----\n    Signed modulo remainder operation\n\n    Inputs\n    ----\n    - a: integer numerator\n    - b: integer denominator\n\n    Outputs\n    ----\n    - a % b: integer result of the signed integer modulo. If the denominator is 0, the result will\n        be 0\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    5\n\n    Source: [evm.codes/#07](https://www.evm.codes/#07)\n    \"\"\"\n\n    ADDMOD = Opcode(0x08, popped_stack_items=3, pushed_stack_items=1)\n    \"\"\"\n    ADDMOD(a, b, c) = d\n    ----\n\n    Description\n    ----\n    Modular addition operation with overflow check\n\n    Inputs\n    ----\n    - a: first integer value\n    - b: second integer value\n    - c: integer denominator\n\n    Outputs\n    ----\n    - (a + b) % N: integer result of the addition followed by a modulo. If the denominator is 0,\n        the result will be 0\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    8\n\n    Source: [evm.codes/#08](https://www.evm.codes/#08)\n    \"\"\"\n\n    MULMOD = Opcode(0x09, popped_stack_items=3, pushed_stack_items=1)\n    \"\"\"\n    MULMOD(a, b, N) = d\n    ----\n\n    Description\n    ----\n    Modulo multiplication operation\n\n    Inputs\n    ----\n    - a: first integer value to multiply\n    - b: second integer value to multiply\n    - N: integer denominator\n\n    Outputs\n    ----\n    - (a * b) % N: integer result of the multiplication followed by a modulo. If the denominator\n        is 0, the result will be 0\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    8\n\n    Source: [evm.codes/#09](https://www.evm.codes/#09)\n    \"\"\"\n\n    EXP = Opcode(0x0A, popped_stack_items=2, pushed_stack_items=1)\n    \"\"\"\n    EXP(a, exponent) = a ** exponent\n    ----\n\n    Description\n    ----\n    Exponential operation\n\n    Inputs\n    ----\n    - a: integer base\n    - exponent: integer exponent\n\n    Outputs\n    ----\n    - a ** exponent: integer result of the exponential operation modulo 2**256\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    - static_gas = 10\n    - dynamic_gas = 50 * exponent_byte_size\n\n    Source: [evm.codes/#0A](https://www.evm.codes/#0A)\n    \"\"\"\n\n    SIGNEXTEND = Opcode(0x0B, popped_stack_items=2, pushed_stack_items=1)\n    \"\"\"\n    SIGNEXTEND(b, x) = y\n    ----\n\n    Description\n    ----\n    Sign extension operation\n\n    Inputs\n    ----\n    - b: size in byte - 1 of the integer to sign extend\n    - x: integer value to sign extend\n\n    Outputs\n    ----\n    - y: integer result of the sign extend\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    5\n\n    Source: [evm.codes/#0B](https://www.evm.codes/#0B)\n    \"\"\"\n\n    LT = Opcode(0x10, popped_stack_items=2, pushed_stack_items=1)\n    \"\"\"\n    LT(a, b) = a &lt; b\n    ----\n\n    Description\n    ----\n    Less-than comparison\n\n    Inputs\n    ----\n    - a: left side integer value\n    - b: right side integer value\n\n    Outputs\n    ----\n    - a &lt; b: 1 if the left side is smaller, 0 otherwise\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#10](https://www.evm.codes/#10)\n    \"\"\"\n\n    GT = Opcode(0x11, popped_stack_items=2, pushed_stack_items=1)\n    \"\"\"\n    GT(a, b) = a &gt; b\n    ----\n\n    Description\n    ----\n    Greater-than comparison\n\n    Inputs\n    ----\n    - a: left side integer\n    - b: right side integer\n\n    Outputs\n    ----\n    - a &gt; b: 1 if the left side is bigger, 0 otherwise\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#11](https://www.evm.codes/#11)\n    \"\"\"\n\n    SLT = Opcode(0x12, popped_stack_items=2, pushed_stack_items=1)\n    \"\"\"\n    SLT(a, b) = a &lt; b\n    ----\n\n    Description\n    ----\n    Signed less-than comparison\n\n    Inputs\n    ----\n    - a: left side signed integer\n    - b: right side signed integer\n\n    Outputs\n    ----\n    - a &lt; b: 1 if the left side is smaller, 0 otherwise\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#12](https://www.evm.codes/#12)\n    \"\"\"\n\n    SGT = Opcode(0x13, popped_stack_items=2, pushed_stack_items=1)\n    \"\"\"\n    SGT(a, b) = a &gt; b\n    ----\n\n    Description\n    ----\n    Signed greater-than comparison\n\n    Inputs\n    ----\n    - a: left side signed integer\n    - b: right side signed integer\n\n    Outputs\n    ----\n    - a &gt; b: 1 if the left side is bigger, 0 otherwise\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#13](https://www.evm.codes/#13)\n    \"\"\"\n\n    EQ = Opcode(0x14, popped_stack_items=2, pushed_stack_items=1)\n    \"\"\"\n    EQ(a, b) = a == b\n    ----\n\n    Description\n    ----\n    Equality comparison\n\n    Inputs\n    ----\n    - a: left side integer\n    - b: right side integer\n\n    Outputs\n    ----\n    - a == b: 1 if the left side is equal to the right side, 0 otherwise\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#14](https://www.evm.codes/#14)\n    \"\"\"\n\n    ISZERO = Opcode(0x15, popped_stack_items=1, pushed_stack_items=1)\n    \"\"\"\n    ISZERO(a) = a == 0\n    ----\n\n    Description\n    ----\n    Is-zero comparison\n\n    Inputs\n    ----\n    - a: integer\n\n    Outputs\n    ----\n    - a == 0: 1 if a is 0, 0 otherwise\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#15](https://www.evm.codes/#15)\n    \"\"\"\n\n    AND = Opcode(0x16, popped_stack_items=2, pushed_stack_items=1)\n    \"\"\"\n    AND(a, b) = a &amp; b\n    ----\n\n    Description\n    ----\n    Bitwise AND operation\n\n    Inputs\n    ----\n    - a: first binary value\n    - b: second binary value\n\n    Outputs\n    ----\n    - a &amp; b: the bitwise AND result\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#16](https://www.evm.codes/#16)\n    \"\"\"\n\n    OR = Opcode(0x17, popped_stack_items=2, pushed_stack_items=1)\n    \"\"\"\n    OR(a, b) = a | b\n    ----\n\n    Description\n    ----\n    Bitwise OR operation\n\n    Inputs\n    ----\n    - a: first binary value\n    - b: second binary value\n\n    Outputs\n    ----\n    - a | b: the bitwise OR result\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#17](https://www.evm.codes/#17)\n    \"\"\"\n\n    XOR = Opcode(0x18, popped_stack_items=2, pushed_stack_items=1)\n    \"\"\"\n    XOR(a, b) = a ^ b\n    ----\n\n    Description\n    ----\n    Bitwise XOR operation\n\n    Inputs\n    ----\n    - a: first binary value\n    - b: second binary value\n\n    Outputs\n    ----\n    - a ^ b: the bitwise XOR result\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#18](https://www.evm.codes/#18)\n    \"\"\"\n\n    NOT = Opcode(0x19, popped_stack_items=1, pushed_stack_items=1)\n    \"\"\"\n    NOT(a) = ~a\n    ----\n\n    Description\n    ----\n    Bitwise NOT operation\n\n    Inputs\n    ----\n    - a: binary value\n\n    Outputs\n    ----\n    - ~a: the bitwise NOT result\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#19](https://www.evm.codes/#19)\n    \"\"\"\n\n    BYTE = Opcode(0x1A, popped_stack_items=2, pushed_stack_items=1)\n    \"\"\"\n    BYTE(i, x) = y\n    ----\n\n    Description\n    ----\n    Extract a byte from the given position in the value\n\n    Inputs\n    ----\n    - i: byte offset starting from the most significant byte\n    - x: 32-byte value\n\n    Outputs\n    ----\n    - y: the indicated byte at the least significant position. If the byte offset is out of range,\n        the result is 0\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#1A](https://www.evm.codes/#1A)\n    \"\"\"\n\n    SHL = Opcode(0x1B, popped_stack_items=2, pushed_stack_items=1)\n    \"\"\"\n    SHL(shift, value) = value &lt;&lt; shift\n    ----\n\n    Description\n    ----\n    Shift left operation\n\n    Inputs\n    ----\n    - shift: number of bits to shift to the left\n    - value: 32 bytes to shift\n\n    Outputs\n    ----\n    - value &lt;&lt; shift: the shifted value. If shift is bigger than 255, returns 0\n\n    Fork\n    ----\n    Constantinople\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#1B](https://www.evm.codes/#1B)\n    \"\"\"\n\n    SHR = Opcode(0x1C, popped_stack_items=2, pushed_stack_items=1)\n    \"\"\"\n    SHR(shift, value) = value &gt;&gt; shift\n    ----\n\n    Description\n    ----\n    Logical shift right operation\n\n    Inputs\n    ----\n    - shift: number of bits to shift to the right.\n    - value: 32 bytes to shift\n\n    Outputs\n    ----\n    - value &gt;&gt; shift: the shifted value. If shift is bigger than 255, returns 0\n\n    Fork\n    ----\n    Constantinople\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#1C](https://www.evm.codes/#1C)\n    \"\"\"\n\n    SAR = Opcode(0x1D, popped_stack_items=2, pushed_stack_items=1)\n    \"\"\"\n    SAR(shift, value) = value &gt;&gt; shift\n    ----\n\n    Description\n    ----\n    Arithmetic shift right operation\n\n    Inputs\n    ----\n    - shift: number of bits to shift to the right\n    - value: integer to shift\n\n    Outputs\n    ----\n    - value &gt;&gt; shift: the shifted value\n\n    Fork\n    ----\n    Constantinople\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#1D](https://www.evm.codes/#1D)\n    \"\"\"\n\n    SHA3 = Opcode(0x20, popped_stack_items=2, pushed_stack_items=1, kwargs=[\"offset\", \"size\"])\n    \"\"\"\n    SHA3(offset, size) = hash\n    ----\n\n    Description\n    ----\n    Compute Keccak-256 hash\n\n    Inputs\n    ----\n    - offset: byte offset in the memory\n    - size: byte size to read in the memory\n\n    Outputs\n    ----\n    - hash: Keccak-256 hash of the given data in memory\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    - minimum_word_size = (size + 31) / 32\n    - static_gas = 30\n    - dynamic_gas = 6 * minimum_word_size + memory_expansion_cost\n\n    Source: [evm.codes/#20](https://www.evm.codes/#20)\n    \"\"\"\n\n    ADDRESS = Opcode(0x30, pushed_stack_items=1)\n    \"\"\"\n    ADDRESS() = address\n    ----\n\n    Description\n    ----\n    Get address of currently executing account\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - address: the 20-byte address of the current account\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    2\n\n    Source: [evm.codes/#30](https://www.evm.codes/#30)\n    \"\"\"\n\n    BALANCE = Opcode(0x31, popped_stack_items=1, pushed_stack_items=1, kwargs=[\"address\"])\n    \"\"\"\n    BALANCE(address) = balance\n    ----\n\n    Description\n    ----\n    Get the balance of the specified account\n\n    Inputs\n    ----\n    - address: 20-byte address of the account to check\n\n    Outputs\n    ----\n    - balance: balance of the given account in wei. Returns 0 if the account doesn't exist\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    - static_gas = 0\n    - dynamic_gas = 100 if warm_address, 2600 if cold_address\n\n    Source: [evm.codes/#31](https://www.evm.codes/#31)\n    \"\"\"\n\n    ORIGIN = Opcode(0x32, pushed_stack_items=1)\n    \"\"\"\n    ORIGIN() = address\n    ----\n\n    Description\n    ----\n    Get execution origination address\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - address: the 20-byte address of the sender of the transaction. It can only be an account\n        without code\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    2\n\n    Source: [evm.codes/#32](https://www.evm.codes/#32)\n    \"\"\"\n\n    CALLER = Opcode(0x33, pushed_stack_items=1)\n    \"\"\"\n    CALLER() = address\n    ----\n\n    Description\n    ----\n    Get caller address\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - address: the 20-byte address of the caller account. This is the account that did the last\n        call (except delegate call)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    2\n\n    Source: [evm.codes/#33](https://www.evm.codes/#33)\n    \"\"\"\n\n    CALLVALUE = Opcode(0x34, pushed_stack_items=1)\n    \"\"\"\n    CALLVALUE() = value\n    ----\n\n    Description\n    ----\n    Get deposited value by the instruction/transaction responsible for this execution\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: the value of the current call in wei\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    2\n\n    Source: [evm.codes/#34](https://www.evm.codes/#34)\n    \"\"\"\n\n    CALLDATALOAD = Opcode(0x35, popped_stack_items=1, pushed_stack_items=1, kwargs=[\"offset\"])\n    \"\"\"\n    CALLDATALOAD(offset) = data[offset]\n    ----\n\n    Description\n    ----\n    Get input data of current environment\n\n    Inputs\n    ----\n    - offset: byte offset in the calldata\n\n    Outputs\n    ----\n    - data[offset]: 32-byte value starting from the given offset of the calldata. All bytes after\n        the end of the calldata are set to 0\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#35](https://www.evm.codes/#35)\n    \"\"\"\n\n    CALLDATASIZE = Opcode(0x36, pushed_stack_items=1)\n    \"\"\"\n    CALLDATASIZE() = size\n    ----\n\n    Description\n    ----\n    Get size of input data in current environment\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - size: byte size of the calldata\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    2\n\n    Source: [evm.codes/#36](https://www.evm.codes/#36)\n    \"\"\"\n\n    CALLDATACOPY = Opcode(0x37, popped_stack_items=3, kwargs=[\"dest_offset\", \"offset\", \"size\"])\n    \"\"\"\n    CALLDATACOPY(dest_offset, offset, size)\n    ----\n\n    Description\n    ----\n    Copy input data in current environment to memory\n\n    Inputs\n    ----\n    - dest_offset: byte offset in the memory where the result will be copied\n    - offset: byte offset in the calldata to copy\n    - size: byte size to copy\n\n    Outputs\n    ----\n    - None\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    - minimum_word_size = (size + 31) / 32\n    - static_gas = 3\n    - dynamic_gas = 3 * minimum_word_size + memory_expansion_cost\n\n    Source: [evm.codes/#37](https://www.evm.codes/#37)\n    \"\"\"\n\n    CODESIZE = Opcode(0x38, pushed_stack_items=1)\n    \"\"\"\n    CODESIZE() = size\n    ----\n\n    Description\n    ----\n    Get size of code running in current environment\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - size: byte size of the code\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    2\n\n    Source: [evm.codes/#38](https://www.evm.codes/#38)\n    \"\"\"\n\n    CODECOPY = Opcode(0x39, popped_stack_items=3, kwargs=[\"dest_offset\", \"offset\", \"size\"])\n    \"\"\"\n    CODECOPY(dest_offset, offset, size)\n    ----\n\n    Description\n    ----\n    Copy code running in current environment to memory\n\n    Inputs\n    ----\n    - dest_offset: byte offset in the memory where the result will be copied.\n    - offset: byte offset in the code to copy.\n    - size: byte size to copy\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    - minimum_word_size = (size + 31) / 32\n    - static_gas = 3\n    - dynamic_gas = 3 * minimum_word_size + memory_expansion_cost\n\n    Source: [evm.codes/#39](https://www.evm.codes/#39)\n    \"\"\"\n\n    GASPRICE = Opcode(0x3A, pushed_stack_items=1)\n    \"\"\"\n    GASPRICE() = price\n    ----\n\n    Description\n    ----\n    Get price of gas in current environment\n\n    Outputs\n    ----\n    - price: gas price in wei per gas\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    2\n\n    Source: [evm.codes/#3A](https://www.evm.codes/#3A)\n    \"\"\"\n\n    EXTCODESIZE = Opcode(0x3B, popped_stack_items=1, pushed_stack_items=1, kwargs=[\"address\"])\n    \"\"\"\n    EXTCODESIZE(address) = size\n    ----\n\n    Description\n    ----\n    Get size of an account's code\n\n    Inputs\n    ----\n    - address: 20-byte address of the contract to query\n\n    Outputs\n    ----\n    - size: byte size of the code\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    - static_gas = 0\n    - dynamic_gas = 100 if warm_address, 2600 if cold_address\n\n    Source: [evm.codes/#3B](https://www.evm.codes/#3B)\n    \"\"\"\n\n    EXTCODECOPY = Opcode(\n        0x3C, popped_stack_items=4, kwargs=[\"address\", \"dest_offset\", \"offset\", \"size\"]\n    )\n    \"\"\"\n    EXTCODECOPY(address, dest_offset, offset, size)\n    ----\n\n    Description\n    ----\n    Copy an account's code to memory\n\n    Inputs\n    ----\n    - address: 20-byte address of the contract to query\n    - dest_offset: byte offset in the memory where the result will be copied\n    - offset: byte offset in the code to copy\n    - size: byte size to copy\n\n    Outputs\n    ----\n    - None\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    - minimum_word_size = (size + 31) / 32\n    - static_gas = 0\n    - dynamic_gas = 3 * minimum_word_size + memory_expansion_cost + address_access_cost\n\n    Source: [evm.codes/#3C](https://www.evm.codes/#3C)\n    \"\"\"\n\n    RETURNDATASIZE = Opcode(0x3D, pushed_stack_items=1)\n    \"\"\"\n    RETURNDATASIZE() = size\n    ----\n\n    Description\n    ----\n    Get size of output data from the previous call from the current environment\n\n    Outputs\n    ----\n    - size: byte size of the return data from the last executed sub context\n\n    Fork\n    ----\n    Byzantium\n\n    Gas\n    ----\n    2\n\n    Source: [evm.codes/#3D](https://www.evm.codes/#3D)\n    \"\"\"\n\n    RETURNDATACOPY = Opcode(0x3E, popped_stack_items=3, kwargs=[\"dest_offset\", \"offset\", \"size\"])\n    \"\"\"\n    RETURNDATACOPY(dest_offset, offset, size)\n    ----\n\n    Description\n    ----\n    Copy output data from the previous call to memory\n\n    Inputs\n    ----\n    - dest_offset: byte offset in the memory where the result will be copied\n    - offset: byte offset in the return data from the last executed sub context to copy\n    - size: byte size to copy\n\n    Fork\n    ----\n    Byzantium\n\n    Gas\n    ----\n    - minimum_word_size = (size + 31) / 32\n    - static_gas = 3\n    - dynamic_gas = 3 * minimum_word_size + memory_expansion_cost\n\n    Source: [evm.codes/#3E](https://www.evm.codes/#3E)\n    \"\"\"\n\n    EXTCODEHASH = Opcode(0x3F, popped_stack_items=1, pushed_stack_items=1, kwargs=[\"address\"])\n    \"\"\"\n    EXTCODEHASH(address) = hash\n    ----\n\n    Description\n    ----\n    Get hash of an account's code\n\n    Inputs\n    ----\n    - address: 20-byte address of the account\n\n    Outputs\n    ----\n    - hash: hash of the chosen account's code, the empty hash (0xc5d24601...) if the account has no\n        code, or 0 if the account does not exist or has been destroyed\n\n    Fork\n    ----\n    Constantinople\n\n    Gas\n    ----\n    - static_gas = 0\n    - dynamic_gas = 100 if warm_address, 2600 if cold_address\n\n    Source: [evm.codes/#3F](https://www.evm.codes/#3F)\n    \"\"\"\n\n    BLOCKHASH = Opcode(0x40, popped_stack_items=1, pushed_stack_items=1, kwargs=[\"block_number\"])\n    \"\"\"\n    BLOCKHASH(block_number) = hash\n    ----\n\n    Description\n    ----\n    Get the hash of one of the 256 most recent complete blocks\n\n    Inputs\n    ----\n    - blockNumber: block number to get the hash from. Valid range is the last 256 blocks (not\n        including the current one). Current block number can be queried with NUMBER\n\n    Outputs\n    ----\n    - hash: hash of the chosen block, or 0 if the block number is not in the valid range\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    20\n\n    Source: [evm.codes/#40](https://www.evm.codes/#40)\n    \"\"\"\n\n    COINBASE = Opcode(0x41, pushed_stack_items=1)\n    \"\"\"\n    COINBASE() = address\n    ----\n\n    Description\n    ----\n    Get the block's beneficiary address\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - address: miner's 20-byte address\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    2\n\n    Source: [evm.codes/#41](https://www.evm.codes/#41)\n    \"\"\"\n\n    TIMESTAMP = Opcode(0x42, pushed_stack_items=1)\n    \"\"\"\n    TIMESTAMP() = timestamp\n    ----\n\n    Description\n    ----\n    Get the block's timestamp\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - timestamp: unix timestamp of the current block\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    2\n\n    Source: [evm.codes/#42](https://www.evm.codes/#42)\n    \"\"\"\n\n    NUMBER = Opcode(0x43, pushed_stack_items=1)\n    \"\"\"\n    NUMBER() = blockNumber\n    ----\n\n    Description\n    ----\n    Get the block's number\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - blockNumber: current block number\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    2\n\n    Source: [evm.codes/#43](https://www.evm.codes/#43)\n    \"\"\"\n\n    PREVRANDAO = Opcode(0x44, pushed_stack_items=1)\n    \"\"\"\n    PREVRANDAO() = prevRandao\n    ----\n\n    Description\n    ----\n    Get the previous block's RANDAO mix\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - prevRandao: previous block's RANDAO mix\n\n    Fork\n    ----\n    Merge\n\n    Gas\n    ----\n    2\n\n    Source: [evm.codes/#44](https://www.evm.codes/#44)\n    \"\"\"\n\n    GASLIMIT = Opcode(0x45, pushed_stack_items=1)\n    \"\"\"\n    GASLIMIT() = gasLimit\n    ----\n\n    Description\n    ----\n    Get the block's gas limit\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - gasLimit: gas limit\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    2\n\n    Source: [evm.codes/#45](https://www.evm.codes/#45)\n    \"\"\"\n\n    CHAINID = Opcode(0x46, pushed_stack_items=1)\n    \"\"\"\n    CHAINID() = chainId\n    ----\n\n    Description\n    ----\n    Get the chain ID\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - chainId: chain id of the network\n\n    Fork\n    ----\n    Istanbul\n\n    Gas\n    ----\n    2\n\n    Source: [evm.codes/#46](https://www.evm.codes/#46)\n    \"\"\"\n\n    SELFBALANCE = Opcode(0x47, pushed_stack_items=1)\n    \"\"\"\n    SELFBALANCE() = balance\n    ----\n\n    Description\n    ----\n    Get balance of currently executing account\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - balance: balance of the current account in wei\n\n    Fork\n    ----\n    Istanbul\n\n    Gas\n    ----\n    5\n\n    Source: [evm.codes/#47](https://www.evm.codes/#47)\n    \"\"\"\n\n    BASEFEE = Opcode(0x48, pushed_stack_items=1)\n    \"\"\"\n    BASEFEE() = baseFee\n    ----\n\n    Description\n    ----\n    Get the base fee\n\n    Outputs\n    ----\n    - baseFee: base fee in wei\n\n    Fork\n    ----\n    London\n\n    Gas\n    ----\n    2\n\n    Source: [evm.codes/#48](https://www.evm.codes/#48)\n    \"\"\"\n\n    BLOBHASH = Opcode(0x49, popped_stack_items=1, pushed_stack_items=1, kwargs=[\"index\"])\n    \"\"\"\n    BLOBHASH(index) = versionedHash\n    ----\n\n    Description\n    ----\n    Returns the versioned hash of a single blob contained in the type-3 transaction\n\n    Inputs\n    ----\n    - index: index of the blob\n\n    Outputs\n    ----\n    - versionedHash: versioned hash of the blob\n\n    Fork\n    ----\n    Cancun\n\n    Gas\n    ----\n    3\n\n    Source: [eips.ethereum.org/EIPS/eip-4844](https://eips.ethereum.org/EIPS/eip-4844)\n    \"\"\"\n\n    BLOBBASEFEE = Opcode(0x4A, popped_stack_items=0, pushed_stack_items=1)\n    \"\"\"\n    BLOBBASEFEE() = fee\n    ----\n\n    Description\n    ----\n    Returns the value of the blob base fee of the block it is executing in\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - baseFeePerBlobGas: base fee for the blob gas in wei\n\n    Fork\n    ----\n    Cancun\n\n    Gas\n    ----\n    2\n\n    Source: [eips.ethereum.org/EIPS/eip-7516](https://eips.ethereum.org/EIPS/eip-7516)\n    \"\"\"\n\n    POP = Opcode(0x50, popped_stack_items=1)\n    \"\"\"\n    POP()\n    ----\n\n    Description\n    ----\n    Remove item from stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - None\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    2\n\n    Source: [evm.codes/#50](https://www.evm.codes/#50)\n    \"\"\"\n\n    MLOAD = Opcode(0x51, popped_stack_items=1, pushed_stack_items=1, kwargs=[\"offset\"])\n    \"\"\"\n    MLOAD(offset) = value\n    ----\n\n    Description\n    ----\n    Load word from memory\n\n    Inputs\n    ----\n    - offset: offset in the memory in bytes\n\n    Outputs\n    ----\n    - value: the 32 bytes in memory starting at that offset. If it goes beyond its current size\n        (see MSIZE), writes 0s\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    - static_gas = 3\n    - dynamic_gas = memory_expansion_cost\n\n    Source: [evm.codes/#51](https://www.evm.codes/#51)\n    \"\"\"\n\n    MSTORE = Opcode(0x52, popped_stack_items=2, kwargs=[\"offset\", \"value\"])\n    \"\"\"\n    MSTORE(offset, value)\n    ----\n\n    Description\n    ----\n    Save word to memory\n\n    Inputs\n    ----\n    - offset: offset in the memory in bytes\n    - value: 32-byte value to write in the memory\n\n    Outputs\n    ----\n    - None\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    - static_gas = 3\n    - dynamic_gas = memory_expansion_cost\n\n    Source: [evm.codes/#52](https://www.evm.codes/#52)\n    \"\"\"\n\n    MSTORE8 = Opcode(0x53, popped_stack_items=2, kwargs=[\"offset\", \"value\"])\n    \"\"\"\n    MSTORE8(offset, value)\n    ----\n\n    Description\n    ----\n    Save byte to memory\n\n    Inputs\n    ----\n    - offset: offset in the memory in bytes\n    - value: 1-byte value to write in the memory (the least significant byte of the 32-byte stack\n        value)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    - static_gas = 3\n    - dynamic_gas = memory_expansion_cost\n\n    Source: [evm.codes/#53](https://www.evm.codes/#53)\n    \"\"\"\n\n    SLOAD = Opcode(0x54, popped_stack_items=1, pushed_stack_items=1, kwargs=[\"key\"])\n    \"\"\"\n    SLOAD(key) = value\n    ----\n\n    Description\n    ----\n    Load word from storage\n\n    Inputs\n    ----\n    - key: 32-byte key in storage\n\n    Outputs\n    ----\n    - value: 32-byte value corresponding to that key. 0 if that key was never written before\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    - static_gas = 0\n    - dynamic_gas = 100 if warm_address, 2600 if cold_address\n\n    Source: [evm.codes/#54](https://www.evm.codes/#54)\n    \"\"\"\n\n    SSTORE = Opcode(0x55, popped_stack_items=2, kwargs=[\"key\", \"value\"])\n    \"\"\"\n    SSTORE(key, value)\n    ----\n\n    Description\n    ----\n    Save word to storage\n\n    Inputs\n    ----\n    - key: 32-byte key in storage\n    - value: 32-byte value to store\n\n    Outputs\n    ----\n    - None\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    ```\n    static_gas = 0\n\n    if value == current_value\n        if key is warm\n            base_dynamic_gas = 100\n        else\n            base_dynamic_gas = 100\n    else if current_value == original_value\n        if original_value == 0\n            base_dynamic_gas = 20000\n        else\n            base_dynamic_gas = 2900\n    else\n        base_dynamic_gas = 100\n\n    if key is cold:\n        base_dynamic_gas += 2100\n    ```\n\n    Source: [evm.codes/#55](https://www.evm.codes/#55)\n    \"\"\"\n\n    JUMP = Opcode(0x56, popped_stack_items=1, kwargs=[\"pc\"])\n    \"\"\"\n    JUMP(pc)\n    ----\n\n    Description\n    ----\n    Alter the program counter\n\n    Inputs\n    ----\n    - pc: byte offset in the deployed code where execution will continue from. Must be a\n        JUMPDEST instruction\n\n    Outputs\n    ----\n    - None\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    8\n\n    Source: [evm.codes/#56](https://www.evm.codes/#56)\n    \"\"\"\n\n    JUMPI = Opcode(0x57, popped_stack_items=2, kwargs=[\"pc\", \"condition\"])\n    \"\"\"\n    JUMPI(pc, condition)\n    ----\n\n    Description\n    ----\n    Conditionally alter the program counter\n\n    Inputs\n    ----\n    - pc: byte offset in the deployed code where execution will continue from. Must be a\n        JUMPDEST instruction\n    - condition: the program counter will be altered with the new value only if this value is\n        different from 0. Otherwise, the program counter is simply incremented and the next\n        instruction will be executed\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    10\n\n    Source: [evm.codes/#57](https://www.evm.codes/#57)\n    \"\"\"\n\n    PC = Opcode(0x58, pushed_stack_items=1)\n    \"\"\"\n    PC() = counter\n    ----\n\n    Description\n    ----\n    Get the value of the program counter prior to the increment corresponding to this instruction\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - counter: PC of this instruction in the current program.\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    2\n\n    Source: [evm.codes/#58](https://www.evm.codes/#58)\n    \"\"\"\n\n    MSIZE = Opcode(0x59, pushed_stack_items=1)\n    \"\"\"\n    MSIZE() = size\n    ----\n\n    Description\n    ----\n    Get the size of active memory in bytes\n\n    Outputs\n    ----\n    - size: current memory size in bytes (higher offset accessed until now + 1)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    2\n\n    Source: [evm.codes/#59](https://www.evm.codes/#59)\n    \"\"\"\n\n    GAS = Opcode(0x5A, pushed_stack_items=1)\n    \"\"\"\n    GAS() = gas_remaining\n    ----\n\n    Description\n    ----\n    Get the amount of available gas, including the corresponding reduction for the cost of this\n    instruction\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - gas: remaining gas (after this instruction)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    2\n\n    Source: [evm.codes/#5A](https://www.evm.codes/#5A)\n    \"\"\"\n\n    JUMPDEST = Opcode(0x5B)\n    \"\"\"\n    JUMPDEST()\n    ----\n\n    Description\n    ----\n    Mark a valid destination for jumps\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - None\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    1\n\n    Source: [evm.codes/#5B](https://www.evm.codes/#5B)\n    \"\"\"\n\n    NOOP = Opcode(0x5B)\n    \"\"\"\n    NOOP()\n    ----\n\n    Description\n    ----\n    Synonym for JUMPDEST. Performs no operation.\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - None\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    1\n\n    Source: [evm.codes/#5B](https://www.evm.codes/#5B)\n    \"\"\"\n\n    TLOAD = Opcode(0x5C, popped_stack_items=1, pushed_stack_items=1, kwargs=[\"key\"])\n    \"\"\"\n    TLOAD(key) = value\n    ----\n\n    Description\n    ----\n    Load word from transient storage\n\n    Inputs\n    ----\n    - key: 32-byte key in transient storage\n\n    Outputs\n    ----\n    - value: 32-byte value corresponding to that key. 0 if that key was never written\n\n    Fork\n    ----\n    Cancun\n\n    Gas\n    ----\n    100\n\n    Source: [eips.ethereum.org/EIPS/eip-1153](https://eips.ethereum.org/EIPS/eip-1153)\n    \"\"\"\n\n    TSTORE = Opcode(0x5D, popped_stack_items=2, kwargs=[\"key\", \"value\"])\n    \"\"\"\n    TSTORE(key, value)\n    ----\n\n    Description\n    ----\n    Save word to transient storage\n\n    Inputs\n    ----\n    - key: 32-byte key in transient storage\n    - value: 32-byte value to store\n\n    Fork\n    ----\n    Cancun\n\n    Gas\n    ----\n    100\n\n    Source: [eips.ethereum.org/EIPS/eip-1153](https://eips.ethereum.org/EIPS/eip-1153)\n    \"\"\"\n\n    MCOPY = Opcode(0x5E, popped_stack_items=3, kwargs=[\"dest_offset\", \"offset\", \"size\"])\n    \"\"\"\n    MCOPY(dest_offset, offset, size)\n    ----\n\n    Description\n    ----\n    Copies areas in memory\n\n    Inputs\n    ----\n    - dest_offset: byte offset in the memory where the result will be copied\n    - offset: byte offset in the calldata to copy\n    - size: byte size to copy\n\n    Outputs\n    ----\n    - None\n\n    Fork\n    ----\n    Cancun\n\n    Gas\n    ----\n    - minimum_word_size = (size + 31) / 32\n    - static_gas = 3\n    - dynamic_gas = 3 * minimum_word_size + memory_expansion_cost\n\n    Source: [eips.ethereum.org/EIPS/eip-5656](https://eips.ethereum.org/EIPS/eip-5656)\n    \"\"\"\n\n    PUSH0 = Opcode(0x5F, pushed_stack_items=1)\n    \"\"\"\n    PUSH0() = value\n    ----\n\n    Description\n    ----\n    Place value 0 on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, equal to 0\n\n    Fork\n    ----\n    Shanghai\n\n    Gas\n    ----\n    2\n\n    Source: [evm.codes/#5F](https://www.evm.codes/#5F)\n    \"\"\"\n\n    PUSH1 = Opcode(0x60, pushed_stack_items=1, data_portion_length=1)\n    \"\"\"\n    PUSH1() = value\n    ----\n\n    Description\n    ----\n    Place 1 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#60](https://www.evm.codes/#60)\n    \"\"\"\n\n    PUSH2 = Opcode(0x61, pushed_stack_items=1, data_portion_length=2)\n    \"\"\"\n    PUSH2() = value\n    ----\n\n    Description\n    ----\n    Place 2 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#61](https://www.evm.codes/#61)\n    \"\"\"\n\n    PUSH3 = Opcode(0x62, pushed_stack_items=1, data_portion_length=3)\n    \"\"\"\n    PUSH3() = value\n    ----\n\n    Description\n    ----\n    Place 3 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#62](https://www.evm.codes/#62)\n    \"\"\"\n\n    PUSH4 = Opcode(0x63, pushed_stack_items=1, data_portion_length=4)\n    \"\"\"\n    PUSH4() = value\n    ----\n\n    Description\n    ----\n    Place 4 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#63](https://www.evm.codes/#63)\n    \"\"\"\n\n    PUSH5 = Opcode(0x64, pushed_stack_items=1, data_portion_length=5)\n    \"\"\"\n    PUSH5() = value\n    ----\n\n    Description\n    ----\n    Place 5 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#64](https://www.evm.codes/#64)\n    \"\"\"\n\n    PUSH6 = Opcode(0x65, pushed_stack_items=1, data_portion_length=6)\n    \"\"\"\n    PUSH6() = value\n    ----\n\n    Description\n    ----\n    Place 6 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#65](https://www.evm.codes/#65)\n    \"\"\"\n\n    PUSH7 = Opcode(0x66, pushed_stack_items=1, data_portion_length=7)\n    \"\"\"\n    PUSH7() = value\n    ----\n\n    Description\n    ----\n    Place 7 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#66](https://www.evm.codes/#66)\n    \"\"\"\n\n    PUSH8 = Opcode(0x67, pushed_stack_items=1, data_portion_length=8)\n    \"\"\"\n    PUSH8() = value\n    ----\n\n    Description\n    ----\n    Place 8 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#67](https://www.evm.codes/#67)\n    \"\"\"\n\n    PUSH9 = Opcode(0x68, pushed_stack_items=1, data_portion_length=9)\n    \"\"\"\n    PUSH9() = value\n    ----\n\n    Description\n    ----\n    Place 9 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#68](https://www.evm.codes/#68)\n    \"\"\"\n\n    PUSH10 = Opcode(0x69, pushed_stack_items=1, data_portion_length=10)\n    \"\"\"\n    PUSH10() = value\n    ----\n\n    Description\n    ----\n    Place 10 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#69](https://www.evm.codes/#69)\n    \"\"\"\n\n    PUSH11 = Opcode(0x6A, pushed_stack_items=1, data_portion_length=11)\n    \"\"\"\n    PUSH11() = value\n    ----\n\n    Description\n    ----\n    Place 11 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#6A](https://www.evm.codes/#6A)\n    \"\"\"\n\n    PUSH12 = Opcode(0x6B, pushed_stack_items=1, data_portion_length=12)\n    \"\"\"\n    PUSH12() = value\n    ----\n\n    Description\n    ----\n    Place 12 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#6B](https://www.evm.codes/#6B)\n    \"\"\"\n\n    PUSH13 = Opcode(0x6C, pushed_stack_items=1, data_portion_length=13)\n    \"\"\"\n    PUSH13() = value\n    ----\n\n    Description\n    ----\n    Place 13 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#6C](https://www.evm.codes/#6C)\n    \"\"\"\n\n    PUSH14 = Opcode(0x6D, pushed_stack_items=1, data_portion_length=14)\n    \"\"\"\n    PUSH14() = value\n    ----\n\n    Description\n    ----\n    Place 14 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#6D](https://www.evm.codes/#6D)\n    \"\"\"\n\n    PUSH15 = Opcode(0x6E, pushed_stack_items=1, data_portion_length=15)\n    \"\"\"\n    PUSH15() = value\n    ----\n\n    Description\n    ----\n    Place 15 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#6E](https://www.evm.codes/#6E)\n    \"\"\"\n\n    PUSH16 = Opcode(0x6F, pushed_stack_items=1, data_portion_length=16)\n    \"\"\"\n    PUSH16() = value\n    ----\n\n    Description\n    ----\n    Place 16 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#6F](https://www.evm.codes/#6F)\n    \"\"\"\n\n    PUSH17 = Opcode(0x70, pushed_stack_items=1, data_portion_length=17)\n    \"\"\"\n    PUSH17() = value\n    ----\n\n    Description\n    ----\n    Place 17 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#70](https://www.evm.codes/#70)\n    \"\"\"\n\n    PUSH18 = Opcode(0x71, pushed_stack_items=1, data_portion_length=18)\n    \"\"\"\n    PUSH18() = value\n    ----\n\n    Description\n    ----\n    Place 18 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#71](https://www.evm.codes/#71)\n    \"\"\"\n\n    PUSH19 = Opcode(0x72, pushed_stack_items=1, data_portion_length=19)\n    \"\"\"\n    PUSH19() = value\n    ----\n\n    Description\n    ----\n    Place 19 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#72](https://www.evm.codes/#72)\n    \"\"\"\n\n    PUSH20 = Opcode(0x73, pushed_stack_items=1, data_portion_length=20)\n    \"\"\"\n    PUSH20() = value\n    ----\n\n    Description\n    ----\n    Place 20 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#73](https://www.evm.codes/#73)\n    \"\"\"\n\n    PUSH21 = Opcode(0x74, pushed_stack_items=1, data_portion_length=21)\n    \"\"\"\n    PUSH21() = value\n    ----\n\n    Description\n    ----\n    Place 21 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#74](https://www.evm.codes/#74)\n    \"\"\"\n\n    PUSH22 = Opcode(0x75, pushed_stack_items=1, data_portion_length=22)\n    \"\"\"\n    PUSH22() = value\n    ----\n\n    Description\n    ----\n    Place 22 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#75](https://www.evm.codes/#75)\n    \"\"\"\n\n    PUSH23 = Opcode(0x76, pushed_stack_items=1, data_portion_length=23)\n    \"\"\"\n    PUSH23() = value\n    ----\n\n    Description\n    ----\n    Place 23 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#76](https://www.evm.codes/#76)\n    \"\"\"\n\n    PUSH24 = Opcode(0x77, pushed_stack_items=1, data_portion_length=24)\n    \"\"\"\n    PUSH24() = value\n    ----\n\n    Description\n    ----\n    Place 24 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#77](https://www.evm.codes/#77)\n    \"\"\"\n\n    PUSH25 = Opcode(0x78, pushed_stack_items=1, data_portion_length=25)\n    \"\"\"\n    PUSH25() = value\n    ----\n\n    Description\n    ----\n    Place 25 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#78](https://www.evm.codes/#78)\n    \"\"\"\n\n    PUSH26 = Opcode(0x79, pushed_stack_items=1, data_portion_length=26)\n    \"\"\"\n    PUSH26() = value\n    ----\n\n    Description\n    ----\n    Place 26 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#79](https://www.evm.codes/#79)\n    \"\"\"\n\n    PUSH27 = Opcode(0x7A, pushed_stack_items=1, data_portion_length=27)\n    \"\"\"\n    PUSH27() = value\n    ----\n\n    Description\n    ----\n    Place 27 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#7A](https://www.evm.codes/#7A)\n    \"\"\"\n\n    PUSH28 = Opcode(0x7B, pushed_stack_items=1, data_portion_length=28)\n    \"\"\"\n    PUSH28() = value\n    ----\n\n    Description\n    ----\n    Place 28 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#7B](https://www.evm.codes/#7B)\n    \"\"\"\n\n    PUSH29 = Opcode(0x7C, pushed_stack_items=1, data_portion_length=29)\n    \"\"\"\n    PUSH29() = value\n    ----\n\n    Description\n    ----\n    Place 29 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#7C](https://www.evm.codes/#7C)\n    \"\"\"\n\n    PUSH30 = Opcode(0x7D, pushed_stack_items=1, data_portion_length=30)\n    \"\"\"\n    PUSH30() = value\n    ----\n\n    Description\n    ----\n    Place 30 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#7D](https://www.evm.codes/#7D)\n    \"\"\"\n\n    PUSH31 = Opcode(0x7E, pushed_stack_items=1, data_portion_length=31)\n    \"\"\"\n    PUSH31() = value\n    ----\n\n    Description\n    ----\n    Place 31 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#7E](https://www.evm.codes/#7E)\n    \"\"\"\n\n    PUSH32 = Opcode(0x7F, pushed_stack_items=1, data_portion_length=32)\n    \"\"\"\n    PUSH32() = value\n    ----\n\n    Description\n    ----\n    Place 32 byte item on stack\n\n    Inputs\n    ----\n    - None\n\n    Outputs\n    ----\n    - value: pushed value, aligned to the right (put in the lowest significant bytes)\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#7F](https://www.evm.codes/#7F)\n    \"\"\"\n\n    DUP1 = Opcode(0x80, pushed_stack_items=1, min_stack_height=1)\n    \"\"\"\n    DUP1(value) = value, value\n    ----\n\n    Description\n    ----\n    Duplicate 1st stack item\n\n    Inputs\n    ----\n    - value: value to duplicate\n\n    Outputs\n    ----\n    - value: duplicated value\n    - value: original value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#80](https://www.evm.codes/#80)\n    \"\"\"\n\n    DUP2 = Opcode(0x81, pushed_stack_items=1, min_stack_height=2)\n    \"\"\"\n    DUP2(v1, v2) = v2, v1, v2\n    ----\n\n    Description\n    ----\n    Duplicate 2nd stack item\n\n    Inputs\n    ----\n    - v1: ignored value\n    - v2: value to duplicate\n\n    Outputs\n    ----\n    - v2: duplicated value\n    - v1: ignored value\n    - v2: original value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#81](https://www.evm.codes/#81)\n    \"\"\"\n\n    DUP3 = Opcode(0x82, pushed_stack_items=1, min_stack_height=3)\n    \"\"\"\n    DUP3(v1, v2, v3) = v3, v1, v2, v3\n    ----\n\n    Description\n    ----\n    Duplicate 3rd stack item\n\n    Inputs\n    ----\n    - v1: ignored value\n    - v2: ignored value\n    - v3: value to duplicate\n\n    Outputs\n    ----\n    - v3: duplicated value\n    - v1: ignored value\n    - v2: ignored value\n    - v3: original value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#82](https://www.evm.codes/#82)\n    \"\"\"\n\n    DUP4 = Opcode(0x83, pushed_stack_items=1, min_stack_height=4)\n    \"\"\"\n    DUP4(v1, v2, v3, v4) = v4, v1, v2, v3, v4\n    ----\n\n    Description\n    ----\n    Duplicate 4th stack item\n\n    Inputs\n    ----\n    - v1: ignored value\n    - v2: ignored value\n    - v3: ignored value\n    - v4: value to duplicate\n\n    Outputs\n    ----\n    - v4: duplicated value\n    - v1: ignored value\n    - v2: ignored value\n    - v3: ignored value\n    - v4: original value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#83](https://www.evm.codes/#83)\n    \"\"\"\n\n    DUP5 = Opcode(0x84, pushed_stack_items=1, min_stack_height=5)\n    \"\"\"\n    DUP5(v1, v2, v3, v4, v5) = v5, v1, v2, v3, v4, v5\n    ----\n\n    Description\n    ----\n    Duplicate 5th stack item\n\n    Inputs\n    ----\n    - v1: ignored value\n    - v2: ignored value\n    - v3: ignored value\n    - v4: ignored value\n    - v5: value to duplicate\n\n    Outputs\n    ----\n    - v5: duplicated value\n    - v1: ignored value\n    - v2: ignored value\n    - v3: ignored value\n    - v4: ignored value\n    - v5: original value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#84](https://www.evm.codes/#84)\n    \"\"\"\n\n    DUP6 = Opcode(0x85, pushed_stack_items=1, min_stack_height=6)\n    \"\"\"\n    DUP6(v1, v2, ..., v5, v6) = v6, v1, v2, ..., v5, v6\n    ----\n\n    Description\n    ----\n    Duplicate 6th stack item\n\n    Inputs\n    ----\n    - v1: ignored value\n    - v2: ignored value\n    - ...\n    - v5: ignored value\n    - v6: value to duplicate\n\n    Outputs\n    ----\n    - v6: duplicated value\n    - v1: ignored value\n    - v2: ignored value\n    - ...\n    - v5: ignored value\n    - v6: original value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#85](https://www.evm.codes/#85)\n    \"\"\"\n\n    DUP7 = Opcode(0x86, pushed_stack_items=1, min_stack_height=7)\n    \"\"\"\n    DUP7(v1, v2, ..., v6, v7) = v7, v1, v2, ..., v6, v7\n    ----\n\n    Description\n    ----\n    Duplicate 7th stack item\n\n    Inputs\n    ----\n    - v1: ignored value\n    - v2: ignored value\n    - ...\n    - v6: ignored value\n    - v7: value to duplicate\n\n    Outputs\n    ----\n    - v7: duplicated value\n    - v1: ignored value\n    - v2: ignored value\n    - ...\n    - v6: ignored value\n    - v7: original value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#86](https://www.evm.codes/#86)\n    \"\"\"\n\n    DUP8 = Opcode(0x87, pushed_stack_items=1, min_stack_height=8)\n    \"\"\"\n    DUP8(v1, v2, ..., v7, v8) = v8, v1, v2, ..., v7, v8\n    ----\n\n    Description\n    ----\n    Duplicate 8th stack item\n\n    Inputs\n    ----\n    - v1: ignored value\n    - v2: ignored value\n    - ...\n    - v7: ignored value\n    - v8: value to duplicate\n\n    Outputs\n    ----\n    - v8: duplicated value\n    - v1: ignored value\n    - v2: ignored value\n    - ...\n    - v7: ignored value\n    - v8: original value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#87](https://www.evm.codes/#87)\n    \"\"\"\n\n    DUP9 = Opcode(0x88, pushed_stack_items=1, min_stack_height=9)\n    \"\"\"\n    DUP9(v1, v2, ..., v8, v9) = v9, v1, v2, ..., v8, v9\n    ----\n\n    Description\n    ----\n    Duplicate 9th stack item\n\n    Inputs\n    ----\n    - v1: ignored value\n    - v2: ignored value\n    - ...\n    - v8: ignored value\n    - v9: value to duplicate\n\n    Outputs\n    ----\n    - v9: duplicated value\n    - v1: ignored value\n    - v2: ignored value\n    - ...\n    - v8: ignored value\n    - v9: original value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#88](https://www.evm.codes/#88)\n    \"\"\"\n    DUP10 = Opcode(0x89, pushed_stack_items=1, min_stack_height=10)\n    \"\"\"\n    DUP10(v1, v2, ..., v9, v10) = v10, v1, v2, ..., v9, v10\n    ----\n\n    Description\n    ----\n    Duplicate 10th stack item\n\n    Inputs\n    ----\n    - v1: ignored value\n    - v2: ignored value\n    - ...\n    - v9: ignored value\n    - v10: value to duplicate\n\n    Outputs\n    ----\n    - v10: duplicated value\n    - v1: ignored value\n    - v2: ignored value\n    - ...\n    - v9: ignored value\n    - v10: original value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#89](https://www.evm.codes/#89)\n    \"\"\"\n\n    DUP11 = Opcode(0x8A, pushed_stack_items=1, min_stack_height=11)\n    \"\"\"\n    DUP11(v1, v2, ..., v10, v11) = v11, v1, v2, ..., v10, v11\n    ----\n\n    Description\n    ----\n    Duplicate 11th stack item\n\n    Inputs\n    ----\n    - v1: ignored value\n    - v2: ignored value\n    - ...\n    - v10: ignored value\n    - v11: value to duplicate\n\n    Outputs\n    ----\n    - v11: duplicated value\n    - v1: ignored value\n    - v2: ignored value\n    - ...\n    - v10: ignored value\n    - v11: original value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#8A](https://www.evm.codes/#8A)\n    \"\"\"\n\n    DUP12 = Opcode(0x8B, pushed_stack_items=1, min_stack_height=12)\n    \"\"\"\n    DUP12(v1, v2, ..., v11, v12) = v12, v1, v2, ..., v11, v12\n    ----\n\n    Description\n    ----\n    Duplicate 12th stack item\n\n    Inputs\n    ----\n    - v1: ignored value\n    - v2: ignored value\n    - ...\n    - v11: ignored value\n    - v12: value to duplicate\n\n    Outputs\n    ----\n    - v12: duplicated value\n    - v1: ignored value\n    - v2: ignored value\n    - ...\n    - v11: ignored value\n    - v12: original value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#8B](https://www.evm.codes/#8B)\n    \"\"\"\n\n    DUP13 = Opcode(0x8C, pushed_stack_items=1, min_stack_height=13)\n    \"\"\"\n    DUP13(v1, v2, ..., v12, v13) = v13, v1, v2, ..., v12, v13\n    ----\n\n    Description\n    ----\n    Duplicate 13th stack item\n\n    Inputs\n    ----\n    - v1: ignored value\n    - v2: ignored value\n    - ...\n    - v12: ignored value\n    - v13: value to duplicate\n\n    Outputs\n    ----\n    - v13: duplicated value\n    - v1: ignored value\n    - v2: ignored value\n    - ...\n    - v12: ignored value\n    - v13: original value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#8C](https://www.evm.codes/#8C)\n    \"\"\"\n\n    DUP14 = Opcode(0x8D, pushed_stack_items=1, min_stack_height=14)\n    \"\"\"\n    DUP14(v1, v2, ..., v13, v14) = v14, v1, v2, ..., v13, v14\n    ----\n\n    Description\n    ----\n    Duplicate 14th stack item\n\n    Inputs\n    ----\n    - v1: ignored value\n    - v2: ignored value\n    - ...\n    - v13: ignored value\n    - v14: value to duplicate\n\n    Outputs\n    ----\n    - v14: duplicated value\n    - v1: ignored value\n    - v2: ignored value\n    - ...\n    - v13: ignored value\n    - v14: original value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#8D](https://www.evm.codes/#8D)\n    \"\"\"\n\n    DUP15 = Opcode(0x8E, pushed_stack_items=1, min_stack_height=15)\n    \"\"\"\n    DUP15(v1, v2, ..., v14, v15) = v15, v1, v2, ..., v14, v15\n    ----\n\n    Description\n    ----\n    Duplicate 15th stack item\n\n    Inputs\n    ----\n    - v1: ignored value\n    - v2: ignored value\n    - ...\n    - v14: ignored value\n    - v15: value to duplicate\n\n    Outputs\n    ----\n    - v15: duplicated value\n    - v1: ignored value\n    - v2: ignored value\n    - ...\n    - v14: ignored value\n    - v15: original value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#8E](https://www.evm.codes/#8E)\n    \"\"\"\n\n    DUP16 = Opcode(0x8F, pushed_stack_items=1, min_stack_height=16)\n    \"\"\"\n    DUP16(v1, v2, ..., v15, v16) = v16, v1, v2, ..., v15, v16\n    ----\n\n    Description\n    ----\n    Duplicate 16th stack item\n\n    Inputs\n    ----\n    - v1: ignored value\n    - v2: ignored value\n    - ...\n    - v15: ignored value\n    - v16: value to duplicate\n\n    Outputs\n    ----\n    - v16: duplicated value\n    - v1: ignored value\n    - v2: ignored value\n    - ...\n    - v15: ignored value\n    - v16: original value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#8F](https://www.evm.codes/#8F)\n    \"\"\"\n\n    SWAP1 = Opcode(0x90, min_stack_height=2)\n    \"\"\"\n    SWAP1(v1, v2) = v2, v1\n    ----\n\n    Description\n    ----\n    Exchange the top stack item with the second stack item.\n\n    Inputs\n    ----\n    - v1: value to swap\n    - v2: value to swap\n\n    Outputs\n    ----\n    - v1: swapped value\n    - v2: swapped value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#90](https://www.evm.codes/#90)\n    \"\"\"\n\n    SWAP2 = Opcode(0x91, min_stack_height=3)\n    \"\"\"\n    SWAP2(v1, v2, v3) = v3, v2, v1\n    ----\n\n    Description\n    ----\n    Exchange 1st and 3rd stack items\n\n    Inputs\n    ----\n    - v1: value to swap\n    - v2: ignored value\n    - v3: value to swap\n\n    Outputs\n    ----\n    - v3: swapped value\n    - v2: ignored value\n    - v1: swapped value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#91](https://www.evm.codes/#91)\n    \"\"\"\n\n    SWAP3 = Opcode(0x92, min_stack_height=4)\n    \"\"\"\n    SWAP3(v1, v2, v3, v4) = v4, v2, v3, v1\n    ----\n\n    Description\n    ----\n    Exchange 1st and 4th stack items\n\n    Inputs\n    ----\n    - v1: value to swap\n    - v2: ignored value\n    - v3: ignored value\n    - v4: value to swap\n\n    Outputs\n    ----\n    - v4: swapped value\n    - v2: ignored value\n    - v3: ignored value\n    - v1: swapped value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#92](https://www.evm.codes/#92)\n    \"\"\"\n\n    SWAP4 = Opcode(0x93, min_stack_height=5)\n    \"\"\"\n    SWAP4(v1, v2, ..., v4, v5) = v5, v2, ..., v4, v1\n    ----\n\n    Description\n    ----\n    Exchange 1st and 5th stack items\n\n    Inputs\n    ----\n    - v1: value to swap\n    - v2: ignored value\n    - ...\n    - v4: ignored value\n    - v5: value to swap\n\n    Outputs\n    ----\n    - v5: swapped value\n    - v2: ignored value\n    - ...\n    - v4: ignored value\n    - v1: swapped value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#93](https://www.evm.codes/#93)\n    \"\"\"\n\n    SWAP5 = Opcode(0x94, min_stack_height=6)\n    \"\"\"\n    SWAP5(v1, v2, ..., v5, v6) = v6, v2, ..., v5, v1\n    ----\n\n    Description\n    ----\n    Exchange 1st and 6th stack items\n\n    Inputs\n    ----\n    - v1: value to swap\n    - v2: ignored value\n    - ...\n    - v5: ignored value\n    - v6: value to swap\n\n    Outputs\n    ----\n    - v6: swapped value\n    - v2: ignored value\n    - ...\n    - v5: ignored value\n    - v1: swapped value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#94](https://www.evm.codes/#94)\n    \"\"\"\n\n    SWAP6 = Opcode(0x95, min_stack_height=7)\n    \"\"\"\n    SWAP6(v1, v2, ..., v6, v7) = v7, v2, ..., v6, v1\n    ----\n\n    Description\n    ----\n    Exchange 1st and 7th stack items\n\n    Inputs\n    ----\n    - v1: value to swap\n    - v2: ignored value\n    - ...\n    - v6: ignored value\n    - v7: value to swap\n\n    Outputs\n    ----\n    - v7: swapped value\n    - v2: ignored value\n    - ...\n    - v6: ignored value\n    - v1: swapped value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#95](https://www.evm.codes/#95)\n    \"\"\"\n\n    SWAP7 = Opcode(0x96, min_stack_height=8)\n    \"\"\"\n    SWAP7(v1, v2, ..., v7, v8) = v8, v2, ..., v7, v1\n    ----\n\n    Description\n    ----\n    Exchange 1st and 8th stack items\n\n    Inputs\n    ----\n    - v1: value to swap\n    - v2: ignored value\n    - ...\n    - v7: ignored value\n    - v8: value to swap\n\n    Outputs\n    ----\n    - v8: swapped value\n    - v2: ignored value\n    - ...\n    - v7: ignored value\n    - v1: swapped value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#96](https://www.evm.codes/#96)\n    \"\"\"\n\n    SWAP8 = Opcode(0x97, min_stack_height=9)\n    \"\"\"\n    SWAP8(v1, v2, ..., v8, v9) = v9, v2, ..., v8, v1\n    ----\n\n    Description\n    ----\n    Exchange 1st and 9th stack items\n\n    Inputs\n    ----\n    - v1: value to swap\n    - v2: ignored value\n    - ...\n    - v8: ignored value\n    - v9: value to swap\n\n    Outputs\n    ----\n    - v9: swapped value\n    - v2: ignored value\n    - ...\n    - v8: ignored value\n    - v1: swapped value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#97](https://www.evm.codes/#97)\n    \"\"\"\n\n    SWAP9 = Opcode(0x98, min_stack_height=10)\n    \"\"\"\n    SWAP9(v1, v2, ..., v9, v10) = v10, v2, ..., v9, v1\n    ----\n\n    Description\n    ----\n    Exchange 1st and 10th stack items\n\n    Inputs\n    ----\n    - v1: value to swap\n    - v2: ignored value\n    - ...\n    - v9: ignored value\n    - v10: value to swap\n\n    Outputs\n    ----\n    - v10: swapped value\n    - v2: ignored value\n    - ...\n    - v9: ignored value\n    - v1: swapped value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#98](https://www.evm.codes/#98)\n    \"\"\"\n\n    SWAP10 = Opcode(0x99, min_stack_height=11)\n    \"\"\"\n    SWAP10(v1, v2, ..., v10, v11) = v11, v2, ..., v10, v1\n    ----\n\n    Description\n    ----\n    Exchange 1st and 11th stack items\n\n    Inputs\n    ----\n    - v1: value to swap\n    - v2: ignored value\n    - ...\n    - v10: ignored value\n    - v11: value to swap\n\n    Outputs\n    ----\n    - v11: swapped value\n    - v2: ignored value\n    - ...\n    - v10: ignored value\n    - v1: swapped value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#99](https://www.evm.codes/#99)\n    \"\"\"\n\n    SWAP11 = Opcode(0x9A, min_stack_height=12)\n    \"\"\"\n    SWAP11(v1, v2, ..., v11, v12) = v12, v2, ..., v11, v1\n    ----\n\n    Description\n    ----\n    Exchange 1st and 12th stack items\n\n    Inputs\n    ----\n    - v1: value to swap\n    - v2: ignored value\n    - ...\n    - v11: ignored value\n    - v12: value to swap\n\n    Outputs\n    ----\n    - v12: swapped value\n    - v2: ignored value\n    - ...\n    - v11: ignored value\n    - v1: swapped value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#9A](https://www.evm.codes/#9A)\n    \"\"\"\n\n    SWAP12 = Opcode(0x9B, min_stack_height=13)\n    \"\"\"\n    SWAP12(v1, v2, ..., v12, v13) = v13, v2, ..., v12, v1\n    ----\n\n    Description\n    ----\n    Exchange 1st and 13th stack items\n\n    Inputs\n    ----\n    - v1: value to swap\n    - v2: ignored value\n    - ...\n    - v12: ignored value\n    - v13: value to swap\n\n    Outputs\n    ----\n    - v13: swapped value\n    - v2: ignored value\n    - ...\n    - v12: ignored value\n    - v1: swapped value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#9B](https://www.evm.codes/#9B)\n    \"\"\"\n\n    SWAP13 = Opcode(0x9C, min_stack_height=14)\n    \"\"\"\n    SWAP13(v1, v2, ..., v13, v14) = v14, v2, ..., v13, v1\n    ----\n\n    Description\n    ----\n    Exchange 1st and 14th stack items\n\n    Inputs\n    ----\n    - v1: value to swap\n    - v2: ignored value\n    - ...\n    - v13: ignored value\n    - v14: value to swap\n\n    Outputs\n    ----\n    - v14: swapped value\n    - v2: ignored value\n    - ...\n    - v13: ignored value\n    - v1: swapped value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#9C](https://www.evm.codes/#9C)\n    \"\"\"\n\n    SWAP14 = Opcode(0x9D, min_stack_height=15)\n    \"\"\"\n    SWAP14(v1, v2, ..., v14, v15) = v15, v2, ..., v14, v1\n    ----\n\n    Description\n    ----\n    Exchange 1st and 15th stack items\n\n    Inputs\n    ----\n    - v1: value to swap\n    - v2: ignored value\n    - ...\n    - v14: ignored value\n    - v15: value to swap\n\n    Outputs\n    ----\n    - v15: swapped value\n    - v2: ignored value\n    - ...\n    - v14: ignored value\n    - v1: swapped value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#9D](https://www.evm.codes/#9D)\n    \"\"\"\n\n    SWAP15 = Opcode(0x9E, min_stack_height=16)\n    \"\"\"\n    SWAP15(v1, v2, ..., v15, v16) = v16, v2, ..., v15, v1\n    ----\n\n    Description\n    ----\n    Exchange 1st and 16th stack items\n\n    Inputs\n    ----\n    - v1: value to swap\n    - v2: ignored value\n    - ...\n    - v15: ignored value\n    - v16: value to swap\n\n    Outputs\n    ----\n    - v16: swapped value\n    - v2: ignored value\n    - ...\n    - v15: ignored value\n    - v1: swapped value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#9E](https://www.evm.codes/#9E)\n    \"\"\"\n\n    SWAP16 = Opcode(0x9F, min_stack_height=17)\n    \"\"\"\n    SWAP16(v1, v2, ..., v16, v17) = v17, v2, ..., v16, v1\n    ----\n\n    Description\n    ----\n    Exchange 1st and 17th stack items\n\n    Inputs\n    ----\n    - v1: value to swap\n    - v2: ignored value\n    - ...\n    - v16: ignored value\n    - v17: value to swap\n\n    Outputs\n    ----\n    - v17: swapped value\n    - v2: ignored value\n    - ...\n    - v16: ignored value\n    - v1: swapped value\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    3\n\n    Source: [evm.codes/#9F](https://www.evm.codes/#9F)\n    \"\"\"\n\n    LOG0 = Opcode(0xA0, popped_stack_items=2, kwargs=[\"offset\", \"size\"])\n    \"\"\"\n    LOG0(offset, size)\n    ----\n\n    Description\n    ----\n    Append log record with no topics\n\n    Inputs\n    ----\n    - offset: byte offset in the memory in bytes\n    - size: byte size to copy\n\n    Outputs\n    ----\n    - None\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    - static_gas = 375\n    - dynamic_gas = 375 * topic_count + 8 * size + memory_expansion_cost\n\n    Source: [evm.codes/#A0](https://www.evm.codes/#A0)\n    \"\"\"\n\n    LOG1 = Opcode(0xA1, popped_stack_items=3, kwargs=[\"offset\", \"size\", \"topic_1\"])\n    \"\"\"\n    LOG1(offset, size, topic_1)\n    ----\n\n    Description\n    ----\n    Append log record with one topic\n\n    Inputs\n    ----\n    - offset: byte offset in the memory in bytes\n    - size: byte size to copy\n    - topic_1: 32-byte value\n\n    Outputs\n    ----\n    - None\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    - static_gas = 375\n    - dynamic_gas = 375 * topic_count + 8 * size + memory_expansion_cost\n\n    Source: [evm.codes/#A1](https://www.evm.codes/#A1)\n    \"\"\"\n\n    LOG2 = Opcode(0xA2, popped_stack_items=4, kwargs=[\"offset\", \"size\", \"topic_1\", \"topic_2\"])\n    \"\"\"\n    LOG2(offset, size, topic_1, topic_2)\n    ----\n\n    Description\n    ----\n    Append log record with two topics\n\n    Inputs\n    ----\n    - offset: byte offset in the memory in bytes\n    - size: byte size to copy\n    - topic_1: 32-byte value\n    - topic_2: 32-byte value\n\n    Outputs\n    ----\n    - None\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    - static_gas = 375\n    - dynamic_gas = 375 * topic_count + 8 * size + memory_expansion_cost\n\n    Source: [evm.codes/#A2](https://www.evm.codes/#A2)\n    \"\"\"\n\n    LOG3 = Opcode(\n        0xA3, popped_stack_items=5, kwargs=[\"offset\", \"size\", \"topic_1\", \"topic_2\", \"topic_3\"]\n    )\n    \"\"\"\n    LOG3(offset, size, topic_1, topic_2, topic_3)\n    ----\n\n    Description\n    ----\n    Append log record with three topics\n\n    Inputs\n    ----\n    - offset: byte offset in the memory in bytes\n    - size: byte size to copy\n    - topic_1: 32-byte value\n    - topic_2: 32-byte value\n    - topic_3: 32-byte value\n\n    Outputs\n    ----\n    - None\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    - static_gas = 375\n    - dynamic_gas = 375 * topic_count + 8 * size + memory_expansion_cost\n\n    Source: [evm.codes/#A3](https://www.evm.codes/#A3)\n    \"\"\"\n\n    LOG4 = Opcode(\n        0xA4,\n        popped_stack_items=6,\n        kwargs=[\"offset\", \"size\", \"topic_1\", \"topic_2\", \"topic_3\", \"topic_4\"],\n    )\n    \"\"\"\n    LOG4(offset, size, topic_1, topic_2, topic_3, topic_4)\n    ----\n\n    Description\n    ----\n    Append log record with four topics\n\n    Inputs\n    ----\n    - offset: byte offset in the memory in bytes\n    - size: byte size to copy\n    - topic_1: 32-byte value\n    - topic_2: 32-byte value\n    - topic_3: 32-byte value\n    - topic_4: 32-byte value\n\n    Outputs\n    ----\n    - None\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    - static_gas = 375\n    - dynamic_gas = 375 * topic_count + 8 * size + memory_expansion_cost\n\n    Source: [evm.codes/#A4](https://www.evm.codes/#A4)\n    \"\"\"\n\n    RJUMP = Opcode(0xE0, data_portion_length=2)\n    \"\"\"\n    !!! Note: This opcode is under development\n\n    RJUMP()\n    ----\n\n    Description\n    ----\n\n    Inputs\n    ----\n\n    Outputs\n    ----\n\n    Fork\n    ----\n    EOF Fork\n\n    Gas\n    ----\n\n    Source: [eips.ethereum.org/EIPS/eip-4200](https://eips.ethereum.org/EIPS/eip-4200)\n    \"\"\"\n\n    DATALOAD = Opcode(0xD0, popped_stack_items=1, pushed_stack_items=1, kwargs=[\"offset\"])\n    \"\"\"\n    !!! Note: This opcode is under development\n\n    DATALOAD(offset)\n    ----\n\n    Description\n    ----\n    Reads 32 bytes of data at offset onto the stack\n\n    Inputs\n    ----\n    - offset: offset within the data section to start copying\n\n    Outputs\n    ----\n    none\n\n    Fork\n    ----\n    EOF Fork\n\n    Gas\n    ----\n    4\n\n    Source: [eips.ethereum.org/EIPS/eip-7480](https://eips.ethereum.org/EIPS/eip-7480)\n    \"\"\"\n\n    DATALOADN = Opcode(0xD1, pushed_stack_items=1, data_portion_length=2)\n    \"\"\"\n    !!! Note: This opcode is under development\n\n    DATALOADN()\n    ----\n\n    Description\n    ----\n    Reads 32 bytes of data at offset onto the stack\n\n    Immediates\n    ----\n    2 bytes forming a UInt16, which is the offset into the data section.\n\n    Inputs\n    ----\n    none\n\n    Outputs\n    ----\n    none\n\n    Fork\n    ----\n    EOF Fork\n\n    Gas\n    ----\n    3\n\n    Source: [eips.ethereum.org/EIPS/eip-7480](https://eips.ethereum.org/EIPS/eip-7480)\n    \"\"\"\n\n    DATASIZE = Opcode(0xD2, pushed_stack_items=1)\n    \"\"\"\n    !!! Note: This opcode is under development\n\n    DATASIZE()\n    ----\n\n    Description\n    ----\n    Returns the size of the data section\n\n    Inputs\n    ----\n\n    Outputs\n    ----\n    The size of the data section. If there is no data section, returns 0.\n\n    Fork\n    ----\n    EOF Fork\n\n    Gas\n    ----\n    2\n\n    Source: [eips.ethereum.org/EIPS/eip-7480](https://eips.ethereum.org/EIPS/eip-7480)\n    \"\"\"\n\n    DATACOPY = Opcode(0xD3, popped_stack_items=3, kwargs=[\"dest_offset\", \"offset\", \"size\"])\n    \"\"\"\n    !!! Note: This opcode is under development\n\n    DATACOPY(dest_offset, offset, size)\n    ----\n\n    Description\n    ----\n    Copies data from the data section into call frame memory\n\n    Inputs\n    ----\n    - dest_offset: The offset within the memory section to start copying to\n    - offset: The offset within the data section to start copying from\n    - size: The number of bytes to copy\n\n    Outputs\n    ----\n    none\n\n    Fork\n    ----\n    EOF Fork\n\n    Gas\n    ----\n    - minimum_word_size = (size + 31) / 32\n    - static_gas = 3\n    - dynamic_gas = 3 * minimum_word_size + memory_expansion_cost\n\n    Source: [eips.ethereum.org/EIPS/eip-7480](https://eips.ethereum.org/EIPS/eip-7480)\n    \"\"\"\n\n    RJUMPI = Opcode(0xE1, popped_stack_items=1, data_portion_length=2)\n    \"\"\"\n    !!! Note: This opcode is under development\n\n    RJUMPI()\n    ----\n\n    Description\n    ----\n\n    Inputs\n    ----\n\n    Outputs\n    ----\n\n    Fork\n    ----\n    EOF Fork\n\n    Gas\n    ----\n\n    Source: [eips.ethereum.org/EIPS/eip-4200](https://eips.ethereum.org/EIPS/eip-4200)\n    \"\"\"\n\n    RJUMPV = Opcode(\n        0xE2,\n        popped_stack_items=1,\n        data_portion_formatter=_rjumpv_encoder,\n    )\n    \"\"\"\n    !!! Note: This opcode is under development\n\n    RJUMPV()\n    ----\n\n    Description\n    ----\n    Relative jump with variable offset.\n\n    When calling this opcode to generate bytecode, the first argument is used to format the data\n    portion of the opcode, and it can be either of two types:\n    - A bytes type, and in this instance the bytes are used verbatim as the data portion.\n    - An integer iterable, list or tuple or any other iterable, where each element is a\n        jump offset.\n\n    Inputs\n    ----\n\n    Outputs\n    ----\n\n    Fork\n    ----\n    EOF Fork\n\n    Gas\n    ----\n\n    Source: [eips.ethereum.org/EIPS/eip-4200](https://eips.ethereum.org/EIPS/eip-4200)\n    \"\"\"\n\n    CALLF = Opcode(0xE3, data_portion_length=2, unchecked_stack=True)\n    \"\"\"\n    !!! Note: This opcode is under development\n\n    CALLF()\n    ----\n\n    Description\n    ----\n\n    - deduct 5 gas\n    - read uint16 operand idx\n    - if 1024 &lt; len(stack) + types[idx].max_stack_height - types[idx].inputs, execution results in\n        an exceptional halt\n    - if 1024 &lt;= len(return_stack), execution results in an exceptional halt\n    - push new element to return_stack (current_code_idx, pc+3)\n    - update current_code_idx to idx and set pc to 0\n\n    Inputs\n    ----\n    Any: The inputs are not checked because we cannot know how many inputs the callee\n    function/section requires\n\n    Outputs\n    ----\n    Any: The outputs are variable because we cannot know how many outputs the callee\n    function/section produces\n\n    Fork\n    ----\n    EOF Fork\n\n    Gas\n    ----\n    5\n\n    Source:\n    [ipsilon/eof/blob/main/spec/eof.md](https://github.com/ipsilon/eof/blob/main/spec/eof.md)\n    \"\"\"\n\n    RETF = Opcode(0xE4, terminating=True)\n    \"\"\"\n    !!! Note: This opcode is under development\n\n    RETF()\n    ----\n\n    Description\n    ----\n\n    Inputs\n    ----\n\n    Outputs\n    ----\n\n    Fork\n    ----\n    EOF Fork\n\n    Gas\n    ----\n    3\n    \"\"\"\n\n    JUMPF = Opcode(0xE5, data_portion_length=2, terminating=True, unchecked_stack=True)\n    \"\"\"\n    !!! Note: This opcode is under development\n\n    JUMPF()\n    ----\n\n    Description\n    ----\n\n    - deduct 5 gas\n    - read uint16 operand idx\n    - if 1024 &lt; len(stack) + types[idx].max_stack_height - types[idx].inputs, execution results in\n        an exceptional halt\n    - set current_code_idx to idx\n    - set pc = 0\n\n\n    Inputs\n    ----\n\n    Outputs\n    ----\n\n    Fork\n    ----\n    EOF Fork\n\n    Gas\n    ----\n    5\n\n    \"\"\"\n\n    DUPN = Opcode(\n        0xE6,\n        pushed_stack_items=1,\n        data_portion_length=1,\n        stack_properties_modifier=_dupn_stack_properties_modifier,\n    )\n    \"\"\"\n    !!! Note: This opcode is under development\n\n    DUPN()\n    ----\n\n    Description\n    ----\n\n    - deduct 3 gas\n    - read uint8 operand imm\n    - n = imm + 1\n    - n\u2018th (1-based) stack item is duplicated at the top of the stack\n    - Stack validation: stack_height &gt;= n\n\n\n    Inputs\n    ----\n\n    Outputs\n    ----\n\n    Fork\n    ----\n    EOF Fork\n\n    Gas\n    ----\n\n    \"\"\"\n\n    SWAPN = Opcode(\n        0xE7, data_portion_length=1, stack_properties_modifier=_swapn_stack_properties_modifier\n    )\n    \"\"\"\n    !!! Note: This opcode is under development\n\n    SWAPN()\n    ----\n\n    Description\n    ----\n\n    - deduct 3 gas\n    - read uint8 operand imm\n    - n = imm + 1\n    - n + 1th stack item is swapped with the top stack item (1-based).\n    - Stack validation: stack_height &gt;= n + 1\n\n\n    Inputs\n    ----\n\n    Outputs\n    ----\n\n    Fork\n    ----\n    EOF Fork\n\n    Gas\n    ----\n\n    \"\"\"\n\n    EXCHANGE = Opcode(\n        0xE8,\n        data_portion_length=1,\n        data_portion_formatter=_exchange_encoder,\n        stack_properties_modifier=_exchange_stack_properties_modifier,\n    )\n    \"\"\"\n    !!! Note: This opcode is under development\n\n    EXCHANGE[x, y]\n    ----\n\n    Description\n    ----\n    Exchanges two stack positions.  Two nybbles, n is high 4 bits + 1, then  m is 4 low bits + 1.\n    Exchanges tne n+1'th item with the n + m + 1 item.\n\n    Inputs x and y when the opcode is used as `EXCHANGE[x, y]`, are equal to:\n    - x = n + 1\n    - y = n + m + 1\n    Which each equals to 1-based stack positions swapped.\n\n    Inputs\n    ----\n    n + m + 1, or ((imm &gt;&gt; 4) + (imm &amp;0x0F) + 3) from the raw immediate,\n\n    Outputs\n    ----\n    n + m + 1, or ((imm &gt;&gt; 4) + (imm &amp;0x0F) + 3) from the raw immediate,\n\n    Fork\n    ----\n    EOF_FORK\n\n    Gas\n    ----\n    3\n\n    \"\"\"\n\n    EOFCREATE = Opcode(\n        0xEC,\n        popped_stack_items=4,\n        pushed_stack_items=1,\n        data_portion_length=1,\n        kwargs=[\"value\", \"salt\", \"input_offset\", \"input_size\"],\n    )\n    \"\"\"\n    !!! Note: This opcode is under development\n\n    EOFCREATE[initcontainer_index] (value, salt, input_offset, input_size)\n    ----\n\n    Description\n    ----\n\n    Inputs\n    ----\n\n    Outputs\n    ----\n\n    Fork\n    ----\n\n    Gas\n    ----\n\n    \"\"\"\n\n    RETURNCODE = Opcode(\n        0xEE,\n        popped_stack_items=2,\n        data_portion_length=1,\n        terminating=True,\n        kwargs=[\"auxdata_offset\", \"auxdata_size\"],\n    )\n    \"\"\"\n    !!! Note: This opcode is under development\n\n    RETURNCODE()\n    ----\n\n    Description\n    ----\n\n    Inputs\n    ----\n\n    Outputs\n    ----\n\n    Fork\n    ----\n\n    Gas\n    ----\n\n    \"\"\"\n\n    CREATE = Opcode(\n        0xF0, popped_stack_items=3, pushed_stack_items=1, kwargs=[\"value\", \"offset\", \"size\"]\n    )\n    \"\"\"\n    CREATE(value, offset, size) = address\n    ----\n\n    Description\n    ----\n    Create a new contract with the given code\n\n    Inputs\n    ----\n    - value: value in wei to send to the new account\n    - offset: byte offset in the memory in bytes, the initialization code for the new account\n    - size: byte size to copy (size of the initialization code)\n\n    Outputs\n    ----\n    - address: the address of the deployed contract, 0 if the deployment failed\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    ```\n    minimum_word_size = (size + 31) / 32\n    init_code_cost = 2 * minimum_word_size\n    code_deposit_cost = 200 * deployed_code_size\n\n    static_gas = 32000\n    dynamic_gas = init_code_cost + memory_expansion_cost + deployment_code_execution_cost\n        + code_deposit_cost\n    ```\n\n    Source: [evm.codes/#F0](https://www.evm.codes/#F0)\n    \"\"\"\n\n    CALL = Opcode(\n        0xF1,\n        popped_stack_items=7,\n        pushed_stack_items=1,\n        kwargs=[\"gas\", \"address\", \"value\", \"args_offset\", \"args_size\", \"ret_offset\", \"ret_size\"],\n        kwargs_defaults={\"gas\": GAS},\n    )\n    \"\"\"\n    CALL(gas, address, value, args_offset, args_size, ret_offset, ret_size) = success\n    ----\n\n    Description\n    ----\n    Message-call into an account\n\n    Inputs\n    ----\n    - gas: amount of gas to send to the sub context to execute. The gas that is not used by the sub\n        context is returned to this one\n    - address: the account which context to execute\n    - value: value in wei to send to the account\n    - args_offset: byte offset in the memory in bytes, the calldata of the sub context\n    - args_size: byte size to copy (size of the calldata)\n    - ret_offset: byte offset in the memory in bytes, where to store the return data of the sub\n        context\n    - ret_size: byte size to copy (size of the return data)\n\n    Outputs\n    ----\n    - success: return 0 if the sub context reverted, 1 otherwise\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    ```\n    static_gas = 0\n    dynamic_gas = memory_expansion_cost + code_execution_cost + address_access_cost\n        + positive_value_cost + value_to_empty_account_cost\n    ```\n\n    Source: [evm.codes/#F1](https://www.evm.codes/#F1)\n    \"\"\"\n\n    CALLCODE = Opcode(\n        0xF2,\n        popped_stack_items=7,\n        pushed_stack_items=1,\n        kwargs=[\"gas\", \"address\", \"value\", \"args_offset\", \"args_size\", \"ret_offset\", \"ret_size\"],\n        kwargs_defaults={\"gas\": GAS},\n    )\n    \"\"\"\n    CALLCODE(gas, address, value, args_offset, args_size, ret_offset, ret_size) = success\n    ----\n\n    Description\n    ----\n    Message-call into this account with an alternative account's code. Executes code starting at\n    the address to which the call is made.\n\n    Inputs\n    ----\n    - gas: amount of gas to send to the sub context to execute. The gas that is not used by the sub\n        context is returned to this one\n    - address: the account which code to execute\n    - value: value in wei to send to the account\n    - args_offset: byte offset in the memory in bytes, the calldata of the sub context\n    - args_size: byte size to copy (size of the calldata)\n    - ret_offset: byte offset in the memory in bytes, where to store the return data of the sub\n        context\n    - ret_size: byte size to copy (size of the return data)\n\n    Outputs\n    ----\n    - success: return 0 if the sub context reverted, 1 otherwise\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    ```\n    static_gas = 0\n    dynamic_gas = memory_expansion_cost + code_execution_cost + address_access_cost\n        + positive_value_cost\n    ```\n\n    Source: [evm.codes/#F2](https://www.evm.codes/#F2)\n    \"\"\"\n\n    RETURN = Opcode(0xF3, popped_stack_items=2, kwargs=[\"offset\", \"size\"], terminating=True)\n    \"\"\"\n    RETURN(offset, size)\n    ----\n\n    Description\n    ----\n    Halt execution returning output data\n\n    Inputs\n    ----\n    - offset: byte offset in the memory in bytes, to copy what will be the return data of this\n        context\n    - size: byte size to copy (size of the return data)\n\n    Outputs\n    ----\n    - None\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    - static_gas = 0\n    - dynamic_gas = memory_expansion_cost\n\n    Source: [evm.codes/#F3](https://www.evm.codes/#F3)\n    \"\"\"\n\n    DELEGATECALL = Opcode(\n        0xF4,\n        popped_stack_items=6,\n        pushed_stack_items=1,\n        kwargs=[\"gas\", \"address\", \"args_offset\", \"args_size\", \"ret_offset\", \"ret_size\"],\n        kwargs_defaults={\"gas\": GAS},\n    )\n    \"\"\"\n    DELEGATECALL(gas, address, args_offset, args_size, ret_offset, ret_size) = success\n    ----\n\n    Description\n    ----\n    Message-call into this account with an alternative account's code, but persisting the current\n    values for sender and value\n\n    Inputs\n    ----\n    - gas: amount of gas to send to the sub context to execute. The gas that is not used by the sub\n        context is returned to this one\n    - address: the account which code to execute\n    - args_offset: byte offset in the memory in bytes, the calldata of the sub context\n    - args_size: byte size to copy (size of the calldata)\n    - ret_offset: byte offset in the memory in bytes, where to store the return data of the sub\n        context\n    - ret_size: byte size to copy (size of the return data)\n\n    Outputs\n    ----\n    - success: return 0 if the sub context reverted, 1 otherwise\n\n    Fork\n    ----\n    Byzantium\n\n    Gas\n    ----\n    - static_gas = 0\n    - dynamic_gas = memory_expansion_cost + code_execution_cost + address_access_cost\n\n    Source: [evm.codes/#F4](https://www.evm.codes/#F4)\n    \"\"\"\n\n    CREATE2 = Opcode(\n        0xF5,\n        popped_stack_items=4,\n        pushed_stack_items=1,\n        kwargs=[\"value\", \"offset\", \"size\", \"salt\"],\n    )\n    \"\"\"\n    CREATE2(value, offset, size, salt) = address\n    ----\n\n    Description\n    ----\n    Creates a new contract\n\n    Inputs\n    ----\n    - value: value in wei to send to the new account\n    - offset: byte offset in the memory in bytes, the initialization code of the new account\n    - size: byte size to copy (size of the initialization code)\n    - salt: 32-byte value used to create the new account at a deterministic address\n\n    Outputs\n    ----\n    - address: the address of the deployed contract, 0 if the deployment failed\n\n    Fork\n    ----\n    Constantinople\n\n    Gas\n    ----\n    ```\n    minimum_word_size = (size + 31) / 32\n    init_code_cost = 2 * minimum_word_size\n    hash_cost = 6 * minimum_word_size\n    code_deposit_cost = 200 * deployed_code_size\n\n    static_gas = 32000\n    dynamic_gas = init_code_cost + hash_cost + memory_expansion_cost\n        + deployment_code_execution_cost + code_deposit_cost\n    ```\n\n    Source: [evm.codes/#F5](https://www.evm.codes/#F5)\n    \"\"\"\n\n    EXTCALL = Opcode(\n        0xF8,\n        popped_stack_items=4,\n        pushed_stack_items=1,\n        kwargs=[\"address\", \"args_offset\", \"args_size\", \"value\"],\n    )\n    \"\"\"\n    EXTCALL(address, args_offset, args_size, value) = address\n    ----\n\n    Description\n    ----\n    Message-call into an account\n\n    Inputs\n    ----\n    - address: the account which context to execute\n    - args_offset: byte offset in the memory in bytes, the calldata of the sub context\n    - args_size: byte size to copy (size of the calldata)\n    - value: value in wei to send to the account\n\n    Outputs\n    ----\n    - success:\n        - `0` if the call was successful.\n        - `1` if the call has reverted (also can be pushed earlier in a light failure scenario).\n        - `2` if the call has failed.\n\n    Fork\n    ----\n    Prague\n\n    Gas\n    ----\n    ```\n    static_gas = 0\n    dynamic_gas = memory_expansion_cost + code_execution_cost + address_access_cost\n        + positive_value_cost + value_to_empty_account_cost\n    ```\n\n    Source: [EIP-7069](https://eips.ethereum.org/EIPS/eip-7069)\n    \"\"\"\n\n    EXTDELEGATECALL = Opcode(\n        0xF9,\n        popped_stack_items=3,\n        pushed_stack_items=1,\n        kwargs=[\"address\", \"args_offset\", \"args_size\"],\n    )\n    \"\"\"\n    EXTDELEGATECALL(address, args_offset, args_size) = address\n    ----\n\n    Description\n    ----\n    Message-call into this account with an alternative account's code, but persisting the current\n    values for sender and value\n\n    Inputs\n    ----\n    - address: the account which context to execute\n    - args_offset: byte offset in the memory in bytes, the calldata of the sub context\n    - args_size: byte size to copy (size of the calldata)\n\n    Outputs\n    ----\n    - success:\n        - `0` if the call was successful.\n        - `1` if the call has reverted (also can be pushed earlier in a light failure scenario).\n        - `2` if the call has failed.\n\n    Fork\n    ----\n    Prague\n\n    Gas\n    ----\n    - static_gas = 0\n    - dynamic_gas = memory_expansion_cost + code_execution_cost + address_access_cost\n\n    Source: [EIP-7069](https://eips.ethereum.org/EIPS/eip-7069)\n    \"\"\"\n\n    STATICCALL = Opcode(\n        0xFA,\n        popped_stack_items=6,\n        pushed_stack_items=1,\n        kwargs=[\"gas\", \"address\", \"args_offset\", \"args_size\", \"ret_offset\", \"ret_size\"],\n        kwargs_defaults={\"gas\": GAS},\n    )\n    \"\"\"\n    STATICCALL(gas, address, args_offset, args_size, ret_offset, ret_size) = success\n    ----\n\n    Description\n    ----\n    Static message-call into an account\n\n    Inputs\n    ----\n    - gas: amount of gas to send to the sub context to execute. The gas that is not used by the sub\n        context is returned to this one\n    - address: the account which context to execute\n    - args_offset: byte offset in the memory in bytes, the calldata of the sub context\n    - args_size: byte size to copy (size of the calldata)\n    - ret_offset: byte offset in the memory in bytes, where to store the return data of the sub\n        context\n    - ret_size: byte size to copy (size of the return data)\n\n    Outputs\n    ----\n    - success: return 0 if the sub context reverted, 1 otherwise\n\n    Fork\n    ----\n    Byzantium\n\n    Gas\n    ----\n    - static_gas = 0\n    - dynamic_gas = memory_expansion_cost + code_execution_cost + address_access_cost\n\n    Source: [evm.codes/#FA](https://www.evm.codes/#FA)\n    \"\"\"\n\n    EXTSTATICCALL = Opcode(\n        0xFB,\n        popped_stack_items=3,\n        pushed_stack_items=1,\n        kwargs=[\"address\", \"args_offset\", \"args_size\"],\n    )\n    \"\"\"\n    EXTSTATICCALL(address, args_offset, args_size) = address\n    ----\n\n    Description\n    ----\n    Static message-call into an account\n\n    Inputs\n    ----\n    - address: the account which context to execute\n    - args_offset: byte offset in the memory in bytes, the calldata of the sub context\n    - args_size: byte size to copy (size of the calldata)\n\n    Outputs\n    ----\n    - success:\n        - `0` if the call was successful.\n        - `1` if the call has reverted (also can be pushed earlier in a light failure scenario).\n        - `2` if the call has failed.\n\n    Fork\n    ----\n    Prague\n\n    Gas\n    ----\n    - static_gas = 0\n    - dynamic_gas = memory_expansion_cost + code_execution_cost + address_access_cost\n\n    Source: [EIP-7069](https://eips.ethereum.org/EIPS/eip-7069)\n    \"\"\"\n\n    RETURNDATALOAD = Opcode(0xF7, popped_stack_items=1, pushed_stack_items=1, kwargs=[\"offset\"])\n    \"\"\"\n    RETURNDATALOAD(offset)\n    ----\n\n    Description\n    ----\n    Copy 32 bytes from returndata at offset onto the stack\n\n    Inputs\n    ----\n    - offset: byte offset in the return data from the last executed sub context to copy\n\n    Fork\n    ----\n    EOF\n\n    Gas\n    ----\n    3\n    \"\"\"\n\n    REVERT = Opcode(0xFD, popped_stack_items=2, kwargs=[\"offset\", \"size\"], terminating=True)\n    \"\"\"\n    REVERT(offset, size)\n    ----\n\n    Description\n    ----\n    Halt execution reverting state changes but returning data and remaining gas\n\n    Inputs\n    ----\n    - offset: byte offset in the memory in bytes. The return data of the calling context\n    - size: byte size to copy (size of the return data)\n\n    Fork\n    ----\n    Byzantium\n\n    Gas\n    ----\n    static_gas = 0\n    dynamic_gas = memory_expansion_cost\n\n    Source: [evm.codes/#FD](https://www.evm.codes/#FD)\n    \"\"\"\n\n    INVALID = Opcode(0xFE, terminating=True)\n    \"\"\"\n    INVALID()\n    ----\n\n    Description\n    ----\n    Designated invalid instruction\n\n    Inputs\n    ----\n    None\n\n    Outputs\n    ----\n    None\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    All the remaining gas in this context is consumed\n\n    Source: [evm.codes/#FE](https://www.evm.codes/#FE)\n    \"\"\"\n\n    SELFDESTRUCT = Opcode(0xFF, popped_stack_items=1, kwargs=[\"address\"])\n    \"\"\"\n    SELFDESTRUCT(address)\n    ----\n\n    Description\n    ----\n    Halt execution and register the account for later deletion\n\n    Inputs\n    ----\n    - address: account to send the current balance to\n\n    Fork\n    ----\n    Frontier\n\n    Gas\n    ----\n    5000\n\n    Source: [evm.codes/#FF](https://www.evm.codes/#FF)\n    \"\"\"\n</code></pre>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.STOP","title":"<code>STOP = Opcode(0, terminating=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.STOP--stop","title":"STOP()","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.STOP--description","title":"Description","text":"<p>Stop execution</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.STOP--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.STOP--outputs","title":"Outputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.STOP--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.STOP--gas","title":"Gas","text":"<p>0</p> <p>Source: evm.codes/#00</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ADD","title":"<code>ADD = Opcode(1, popped_stack_items=2, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ADD--adda-b-c","title":"ADD(a, b) = c","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ADD--description","title":"Description","text":"<p>Addition operation</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ADD--inputs","title":"Inputs","text":"<ul> <li>a: first integer value to add</li> <li>b: second integer value to add</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ADD--outputs","title":"Outputs","text":"<ul> <li>c: integer result of the addition modulo 2**256</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ADD--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ADD--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#01</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MUL","title":"<code>MUL = Opcode(2, popped_stack_items=2, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MUL--mula-b-c","title":"MUL(a, b) = c","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MUL--description","title":"Description","text":"<p>Multiplication operation</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MUL--inputs","title":"Inputs","text":"<ul> <li>a: first integer value to multiply</li> <li>b: second integer value to multiply</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MUL--outputs","title":"Outputs","text":"<ul> <li>c: integer result of the multiplication modulo 2**256</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MUL--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MUL--gas","title":"Gas","text":"<p>5</p> <p>Source: evm.codes/#02</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SUB","title":"<code>SUB = Opcode(3, popped_stack_items=2, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SUB--suba-b-c","title":"SUB(a, b) = c","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SUB--description","title":"Description","text":"<p>Subtraction operation</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SUB--inputs","title":"Inputs","text":"<ul> <li>a: first integer value</li> <li>b: second integer value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SUB--outputs","title":"Outputs","text":"<ul> <li>c: integer result of the subtraction modulo 2**256</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SUB--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SUB--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#03</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DIV","title":"<code>DIV = Opcode(4, popped_stack_items=2, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DIV--diva-b-c","title":"DIV(a, b) = c","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DIV--description","title":"Description","text":"<p>Division operation</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DIV--inputs","title":"Inputs","text":"<ul> <li>a: numerator</li> <li>b: denominator (must be non-zero)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DIV--outputs","title":"Outputs","text":"<ul> <li>c: integer result of the division</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DIV--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DIV--gas","title":"Gas","text":"<p>5</p> <p>Source: evm.codes/#04</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SDIV","title":"<code>SDIV = Opcode(5, popped_stack_items=2, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SDIV--sdiva-b-c","title":"SDIV(a, b) = c","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SDIV--description","title":"Description","text":"<p>Signed division operation</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SDIV--inputs","title":"Inputs","text":"<ul> <li>a: signed numerator</li> <li>b: signed denominator</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SDIV--outputs","title":"Outputs","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SDIV---c-signed-integer-result-of-the-division-if-the-denominator-is-0-the-result-will-be-0","title":"- c: signed integer result of the division. If the denominator is 0, the result will be 0","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SDIV--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SDIV--gas","title":"Gas","text":"<p>5</p> <p>Source: evm.codes/#05</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MOD","title":"<code>MOD = Opcode(6, popped_stack_items=2, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MOD--moda-b-c","title":"MOD(a, b) = c","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MOD--description","title":"Description","text":"<p>Modulo operation</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MOD--inputs","title":"Inputs","text":"<ul> <li>a: integer numerator</li> <li>b: integer denominator</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MOD--outputs","title":"Outputs","text":"<ul> <li>a % b: integer result of the integer modulo. If the denominator is 0, the result will be 0</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MOD--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MOD--gas","title":"Gas","text":"<p>5</p> <p>Source: evm.codes/#06</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SMOD","title":"<code>SMOD = Opcode(7, popped_stack_items=2, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SMOD--smoda-b-c","title":"SMOD(a, b) = c","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SMOD--description","title":"Description","text":"<p>Signed modulo remainder operation</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SMOD--inputs","title":"Inputs","text":"<ul> <li>a: integer numerator</li> <li>b: integer denominator</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SMOD--outputs","title":"Outputs","text":"<ul> <li>a % b: integer result of the signed integer modulo. If the denominator is 0, the result will     be 0</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SMOD--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SMOD--gas","title":"Gas","text":"<p>5</p> <p>Source: evm.codes/#07</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ADDMOD","title":"<code>ADDMOD = Opcode(8, popped_stack_items=3, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ADDMOD--addmoda-b-c-d","title":"ADDMOD(a, b, c) = d","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ADDMOD--description","title":"Description","text":"<p>Modular addition operation with overflow check</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ADDMOD--inputs","title":"Inputs","text":"<ul> <li>a: first integer value</li> <li>b: second integer value</li> <li>c: integer denominator</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ADDMOD--outputs","title":"Outputs","text":"<ul> <li>(a + b) % N: integer result of the addition followed by a modulo. If the denominator is 0,     the result will be 0</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ADDMOD--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ADDMOD--gas","title":"Gas","text":"<p>8</p> <p>Source: evm.codes/#08</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MULMOD","title":"<code>MULMOD = Opcode(9, popped_stack_items=3, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MULMOD--mulmoda-b-n-d","title":"MULMOD(a, b, N) = d","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MULMOD--description","title":"Description","text":"<p>Modulo multiplication operation</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MULMOD--inputs","title":"Inputs","text":"<ul> <li>a: first integer value to multiply</li> <li>b: second integer value to multiply</li> <li>N: integer denominator</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MULMOD--outputs","title":"Outputs","text":"<ul> <li>(a * b) % N: integer result of the multiplication followed by a modulo. If the denominator     is 0, the result will be 0</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MULMOD--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MULMOD--gas","title":"Gas","text":"<p>8</p> <p>Source: evm.codes/#09</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXP","title":"<code>EXP = Opcode(10, popped_stack_items=2, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXP--expa-exponent-a-exponent","title":"EXP(a, exponent) = a ** exponent","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXP--description","title":"Description","text":"<p>Exponential operation</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXP--inputs","title":"Inputs","text":"<ul> <li>a: integer base</li> <li>exponent: integer exponent</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXP--outputs","title":"Outputs","text":"<ul> <li>a ** exponent: integer result of the exponential operation modulo 2**256</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXP--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXP--gas","title":"Gas","text":"<ul> <li>static_gas = 10</li> <li>dynamic_gas = 50 * exponent_byte_size</li> </ul> <p>Source: evm.codes/#0A</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SIGNEXTEND","title":"<code>SIGNEXTEND = Opcode(11, popped_stack_items=2, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SIGNEXTEND--signextendb-x-y","title":"SIGNEXTEND(b, x) = y","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SIGNEXTEND--description","title":"Description","text":"<p>Sign extension operation</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SIGNEXTEND--inputs","title":"Inputs","text":"<ul> <li>b: size in byte - 1 of the integer to sign extend</li> <li>x: integer value to sign extend</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SIGNEXTEND--outputs","title":"Outputs","text":"<ul> <li>y: integer result of the sign extend</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SIGNEXTEND--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SIGNEXTEND--gas","title":"Gas","text":"<p>5</p> <p>Source: evm.codes/#0B</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LT","title":"<code>LT = Opcode(16, popped_stack_items=2, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LT--lta-b-a-b","title":"LT(a, b) = a &lt; b","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LT--description","title":"Description","text":"<p>Less-than comparison</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LT--inputs","title":"Inputs","text":"<ul> <li>a: left side integer value</li> <li>b: right side integer value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LT--outputs","title":"Outputs","text":"<ul> <li>a &lt; b: 1 if the left side is smaller, 0 otherwise</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LT--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LT--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#10</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GT","title":"<code>GT = Opcode(17, popped_stack_items=2, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GT--gta-b-a-b","title":"GT(a, b) = a &gt; b","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GT--description","title":"Description","text":"<p>Greater-than comparison</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GT--inputs","title":"Inputs","text":"<ul> <li>a: left side integer</li> <li>b: right side integer</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GT--outputs","title":"Outputs","text":"<ul> <li>a &gt; b: 1 if the left side is bigger, 0 otherwise</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GT--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GT--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#11</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SLT","title":"<code>SLT = Opcode(18, popped_stack_items=2, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SLT--slta-b-a-b","title":"SLT(a, b) = a &lt; b","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SLT--description","title":"Description","text":"<p>Signed less-than comparison</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SLT--inputs","title":"Inputs","text":"<ul> <li>a: left side signed integer</li> <li>b: right side signed integer</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SLT--outputs","title":"Outputs","text":"<ul> <li>a &lt; b: 1 if the left side is smaller, 0 otherwise</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SLT--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SLT--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#12</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SGT","title":"<code>SGT = Opcode(19, popped_stack_items=2, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SGT--sgta-b-a-b","title":"SGT(a, b) = a &gt; b","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SGT--description","title":"Description","text":"<p>Signed greater-than comparison</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SGT--inputs","title":"Inputs","text":"<ul> <li>a: left side signed integer</li> <li>b: right side signed integer</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SGT--outputs","title":"Outputs","text":"<ul> <li>a &gt; b: 1 if the left side is bigger, 0 otherwise</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SGT--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SGT--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#13</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EQ","title":"<code>EQ = Opcode(20, popped_stack_items=2, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EQ--eqa-b-a-b","title":"EQ(a, b) = a == b","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EQ--description","title":"Description","text":"<p>Equality comparison</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EQ--inputs","title":"Inputs","text":"<ul> <li>a: left side integer</li> <li>b: right side integer</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EQ--outputs","title":"Outputs","text":"<ul> <li>a == b: 1 if the left side is equal to the right side, 0 otherwise</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EQ--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EQ--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#14</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ISZERO","title":"<code>ISZERO = Opcode(21, popped_stack_items=1, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ISZERO--iszeroa-a-0","title":"ISZERO(a) = a == 0","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ISZERO--description","title":"Description","text":"<p>Is-zero comparison</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ISZERO--inputs","title":"Inputs","text":"<ul> <li>a: integer</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ISZERO--outputs","title":"Outputs","text":"<ul> <li>a == 0: 1 if a is 0, 0 otherwise</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ISZERO--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ISZERO--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#15</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.AND","title":"<code>AND = Opcode(22, popped_stack_items=2, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.AND--anda-b-a-b","title":"AND(a, b) = a &amp; b","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.AND--description","title":"Description","text":"<p>Bitwise AND operation</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.AND--inputs","title":"Inputs","text":"<ul> <li>a: first binary value</li> <li>b: second binary value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.AND--outputs","title":"Outputs","text":"<ul> <li>a &amp; b: the bitwise AND result</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.AND--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.AND--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#16</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.OR","title":"<code>OR = Opcode(23, popped_stack_items=2, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.OR--ora-b-a-b","title":"OR(a, b) = a | b","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.OR--description","title":"Description","text":"<p>Bitwise OR operation</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.OR--inputs","title":"Inputs","text":"<ul> <li>a: first binary value</li> <li>b: second binary value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.OR--outputs","title":"Outputs","text":"<ul> <li>a | b: the bitwise OR result</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.OR--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.OR--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#17</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.XOR","title":"<code>XOR = Opcode(24, popped_stack_items=2, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.XOR--xora-b-a-b","title":"XOR(a, b) = a ^ b","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.XOR--description","title":"Description","text":"<p>Bitwise XOR operation</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.XOR--inputs","title":"Inputs","text":"<ul> <li>a: first binary value</li> <li>b: second binary value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.XOR--outputs","title":"Outputs","text":"<ul> <li>a ^ b: the bitwise XOR result</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.XOR--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.XOR--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#18</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.NOT","title":"<code>NOT = Opcode(25, popped_stack_items=1, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.NOT--nota-a","title":"NOT(a) = ~a","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.NOT--description","title":"Description","text":"<p>Bitwise NOT operation</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.NOT--inputs","title":"Inputs","text":"<ul> <li>a: binary value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.NOT--outputs","title":"Outputs","text":"<ul> <li>~a: the bitwise NOT result</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.NOT--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.NOT--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#19</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BYTE","title":"<code>BYTE = Opcode(26, popped_stack_items=2, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BYTE--bytei-x-y","title":"BYTE(i, x) = y","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BYTE--description","title":"Description","text":"<p>Extract a byte from the given position in the value</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BYTE--inputs","title":"Inputs","text":"<ul> <li>i: byte offset starting from the most significant byte</li> <li>x: 32-byte value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BYTE--outputs","title":"Outputs","text":"<ul> <li>y: the indicated byte at the least significant position. If the byte offset is out of range,     the result is 0</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BYTE--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BYTE--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#1A</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SHL","title":"<code>SHL = Opcode(27, popped_stack_items=2, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SHL--shlshift-value-value-shift","title":"SHL(shift, value) = value &lt;&lt; shift","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SHL--description","title":"Description","text":"<p>Shift left operation</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SHL--inputs","title":"Inputs","text":"<ul> <li>shift: number of bits to shift to the left</li> <li>value: 32 bytes to shift</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SHL--outputs","title":"Outputs","text":"<ul> <li>value &lt;&lt; shift: the shifted value. If shift is bigger than 255, returns 0</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SHL--fork","title":"Fork","text":"<p>Constantinople</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SHL--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#1B</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SHR","title":"<code>SHR = Opcode(28, popped_stack_items=2, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SHR--shrshift-value-value-shift","title":"SHR(shift, value) = value &gt;&gt; shift","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SHR--description","title":"Description","text":"<p>Logical shift right operation</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SHR--inputs","title":"Inputs","text":"<ul> <li>shift: number of bits to shift to the right.</li> <li>value: 32 bytes to shift</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SHR--outputs","title":"Outputs","text":"<ul> <li>value &gt;&gt; shift: the shifted value. If shift is bigger than 255, returns 0</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SHR--fork","title":"Fork","text":"<p>Constantinople</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SHR--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#1C</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SAR","title":"<code>SAR = Opcode(29, popped_stack_items=2, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SAR--sarshift-value-value-shift","title":"SAR(shift, value) = value &gt;&gt; shift","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SAR--description","title":"Description","text":"<p>Arithmetic shift right operation</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SAR--inputs","title":"Inputs","text":"<ul> <li>shift: number of bits to shift to the right</li> <li>value: integer to shift</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SAR--outputs","title":"Outputs","text":"<ul> <li>value &gt;&gt; shift: the shifted value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SAR--fork","title":"Fork","text":"<p>Constantinople</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SAR--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#1D</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SHA3","title":"<code>SHA3 = Opcode(32, popped_stack_items=2, pushed_stack_items=1, kwargs=['offset', 'size'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SHA3--sha3offset-size-hash","title":"SHA3(offset, size) = hash","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SHA3--description","title":"Description","text":"<p>Compute Keccak-256 hash</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SHA3--inputs","title":"Inputs","text":"<ul> <li>offset: byte offset in the memory</li> <li>size: byte size to read in the memory</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SHA3--outputs","title":"Outputs","text":"<ul> <li>hash: Keccak-256 hash of the given data in memory</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SHA3--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SHA3--gas","title":"Gas","text":"<ul> <li>minimum_word_size = (size + 31) / 32</li> <li>static_gas = 30</li> <li>dynamic_gas = 6 * minimum_word_size + memory_expansion_cost</li> </ul> <p>Source: evm.codes/#20</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ADDRESS","title":"<code>ADDRESS = Opcode(48, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ADDRESS--address-address","title":"ADDRESS() = address","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ADDRESS--description","title":"Description","text":"<p>Get address of currently executing account</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ADDRESS--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ADDRESS--outputs","title":"Outputs","text":"<ul> <li>address: the 20-byte address of the current account</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ADDRESS--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ADDRESS--gas","title":"Gas","text":"<p>2</p> <p>Source: evm.codes/#30</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BALANCE","title":"<code>BALANCE = Opcode(49, popped_stack_items=1, pushed_stack_items=1, kwargs=['address'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BALANCE--balanceaddress-balance","title":"BALANCE(address) = balance","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BALANCE--description","title":"Description","text":"<p>Get the balance of the specified account</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BALANCE--inputs","title":"Inputs","text":"<ul> <li>address: 20-byte address of the account to check</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BALANCE--outputs","title":"Outputs","text":"<ul> <li>balance: balance of the given account in wei. Returns 0 if the account doesn't exist</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BALANCE--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BALANCE--gas","title":"Gas","text":"<ul> <li>static_gas = 0</li> <li>dynamic_gas = 100 if warm_address, 2600 if cold_address</li> </ul> <p>Source: evm.codes/#31</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ORIGIN","title":"<code>ORIGIN = Opcode(50, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ORIGIN--origin-address","title":"ORIGIN() = address","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ORIGIN--description","title":"Description","text":"<p>Get execution origination address</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ORIGIN--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ORIGIN--outputs","title":"Outputs","text":"<ul> <li>address: the 20-byte address of the sender of the transaction. It can only be an account     without code</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ORIGIN--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.ORIGIN--gas","title":"Gas","text":"<p>2</p> <p>Source: evm.codes/#32</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLER","title":"<code>CALLER = Opcode(51, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLER--caller-address","title":"CALLER() = address","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLER--description","title":"Description","text":"<p>Get caller address</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLER--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLER--outputs","title":"Outputs","text":"<ul> <li>address: the 20-byte address of the caller account. This is the account that did the last     call (except delegate call)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLER--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLER--gas","title":"Gas","text":"<p>2</p> <p>Source: evm.codes/#33</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLVALUE","title":"<code>CALLVALUE = Opcode(52, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLVALUE--callvalue-value","title":"CALLVALUE() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLVALUE--description","title":"Description","text":"<p>Get deposited value by the instruction/transaction responsible for this execution</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLVALUE--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLVALUE--outputs","title":"Outputs","text":"<ul> <li>value: the value of the current call in wei</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLVALUE--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLVALUE--gas","title":"Gas","text":"<p>2</p> <p>Source: evm.codes/#34</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLDATALOAD","title":"<code>CALLDATALOAD = Opcode(53, popped_stack_items=1, pushed_stack_items=1, kwargs=['offset'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLDATALOAD--calldataloadoffset-dataoffset","title":"CALLDATALOAD(offset) = data[offset]","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLDATALOAD--description","title":"Description","text":"<p>Get input data of current environment</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLDATALOAD--inputs","title":"Inputs","text":"<ul> <li>offset: byte offset in the calldata</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLDATALOAD--outputs","title":"Outputs","text":"<ul> <li>data[offset]: 32-byte value starting from the given offset of the calldata. All bytes after     the end of the calldata are set to 0</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLDATALOAD--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLDATALOAD--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#35</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLDATASIZE","title":"<code>CALLDATASIZE = Opcode(54, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLDATASIZE--calldatasize-size","title":"CALLDATASIZE() = size","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLDATASIZE--description","title":"Description","text":"<p>Get size of input data in current environment</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLDATASIZE--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLDATASIZE--outputs","title":"Outputs","text":"<ul> <li>size: byte size of the calldata</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLDATASIZE--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLDATASIZE--gas","title":"Gas","text":"<p>2</p> <p>Source: evm.codes/#36</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLDATACOPY","title":"<code>CALLDATACOPY = Opcode(55, popped_stack_items=3, kwargs=['dest_offset', 'offset', 'size'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLDATACOPY--calldatacopydest_offset-offset-size","title":"CALLDATACOPY(dest_offset, offset, size)","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLDATACOPY--description","title":"Description","text":"<p>Copy input data in current environment to memory</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLDATACOPY--inputs","title":"Inputs","text":"<ul> <li>dest_offset: byte offset in the memory where the result will be copied</li> <li>offset: byte offset in the calldata to copy</li> <li>size: byte size to copy</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLDATACOPY--outputs","title":"Outputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLDATACOPY--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLDATACOPY--gas","title":"Gas","text":"<ul> <li>minimum_word_size = (size + 31) / 32</li> <li>static_gas = 3</li> <li>dynamic_gas = 3 * minimum_word_size + memory_expansion_cost</li> </ul> <p>Source: evm.codes/#37</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CODESIZE","title":"<code>CODESIZE = Opcode(56, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CODESIZE--codesize-size","title":"CODESIZE() = size","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CODESIZE--description","title":"Description","text":"<p>Get size of code running in current environment</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CODESIZE--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CODESIZE--outputs","title":"Outputs","text":"<ul> <li>size: byte size of the code</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CODESIZE--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CODESIZE--gas","title":"Gas","text":"<p>2</p> <p>Source: evm.codes/#38</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CODECOPY","title":"<code>CODECOPY = Opcode(57, popped_stack_items=3, kwargs=['dest_offset', 'offset', 'size'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CODECOPY--codecopydest_offset-offset-size","title":"CODECOPY(dest_offset, offset, size)","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CODECOPY--description","title":"Description","text":"<p>Copy code running in current environment to memory</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CODECOPY--inputs","title":"Inputs","text":"<ul> <li>dest_offset: byte offset in the memory where the result will be copied.</li> <li>offset: byte offset in the code to copy.</li> <li>size: byte size to copy</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CODECOPY--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CODECOPY--gas","title":"Gas","text":"<ul> <li>minimum_word_size = (size + 31) / 32</li> <li>static_gas = 3</li> <li>dynamic_gas = 3 * minimum_word_size + memory_expansion_cost</li> </ul> <p>Source: evm.codes/#39</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GASPRICE","title":"<code>GASPRICE = Opcode(58, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GASPRICE--gasprice-price","title":"GASPRICE() = price","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GASPRICE--description","title":"Description","text":"<p>Get price of gas in current environment</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GASPRICE--outputs","title":"Outputs","text":"<ul> <li>price: gas price in wei per gas</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GASPRICE--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GASPRICE--gas","title":"Gas","text":"<p>2</p> <p>Source: evm.codes/#3A</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCODESIZE","title":"<code>EXTCODESIZE = Opcode(59, popped_stack_items=1, pushed_stack_items=1, kwargs=['address'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCODESIZE--extcodesizeaddress-size","title":"EXTCODESIZE(address) = size","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCODESIZE--description","title":"Description","text":"<p>Get size of an account's code</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCODESIZE--inputs","title":"Inputs","text":"<ul> <li>address: 20-byte address of the contract to query</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCODESIZE--outputs","title":"Outputs","text":"<ul> <li>size: byte size of the code</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCODESIZE--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCODESIZE--gas","title":"Gas","text":"<ul> <li>static_gas = 0</li> <li>dynamic_gas = 100 if warm_address, 2600 if cold_address</li> </ul> <p>Source: evm.codes/#3B</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCODECOPY","title":"<code>EXTCODECOPY = Opcode(60, popped_stack_items=4, kwargs=['address', 'dest_offset', 'offset', 'size'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCODECOPY--extcodecopyaddress-dest_offset-offset-size","title":"EXTCODECOPY(address, dest_offset, offset, size)","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCODECOPY--description","title":"Description","text":"<p>Copy an account's code to memory</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCODECOPY--inputs","title":"Inputs","text":"<ul> <li>address: 20-byte address of the contract to query</li> <li>dest_offset: byte offset in the memory where the result will be copied</li> <li>offset: byte offset in the code to copy</li> <li>size: byte size to copy</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCODECOPY--outputs","title":"Outputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCODECOPY--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCODECOPY--gas","title":"Gas","text":"<ul> <li>minimum_word_size = (size + 31) / 32</li> <li>static_gas = 0</li> <li>dynamic_gas = 3 * minimum_word_size + memory_expansion_cost + address_access_cost</li> </ul> <p>Source: evm.codes/#3C</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNDATASIZE","title":"<code>RETURNDATASIZE = Opcode(61, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNDATASIZE--returndatasize-size","title":"RETURNDATASIZE() = size","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNDATASIZE--description","title":"Description","text":"<p>Get size of output data from the previous call from the current environment</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNDATASIZE--outputs","title":"Outputs","text":"<ul> <li>size: byte size of the return data from the last executed sub context</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNDATASIZE--fork","title":"Fork","text":"<p>Byzantium</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNDATASIZE--gas","title":"Gas","text":"<p>2</p> <p>Source: evm.codes/#3D</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNDATACOPY","title":"<code>RETURNDATACOPY = Opcode(62, popped_stack_items=3, kwargs=['dest_offset', 'offset', 'size'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNDATACOPY--returndatacopydest_offset-offset-size","title":"RETURNDATACOPY(dest_offset, offset, size)","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNDATACOPY--description","title":"Description","text":"<p>Copy output data from the previous call to memory</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNDATACOPY--inputs","title":"Inputs","text":"<ul> <li>dest_offset: byte offset in the memory where the result will be copied</li> <li>offset: byte offset in the return data from the last executed sub context to copy</li> <li>size: byte size to copy</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNDATACOPY--fork","title":"Fork","text":"<p>Byzantium</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNDATACOPY--gas","title":"Gas","text":"<ul> <li>minimum_word_size = (size + 31) / 32</li> <li>static_gas = 3</li> <li>dynamic_gas = 3 * minimum_word_size + memory_expansion_cost</li> </ul> <p>Source: evm.codes/#3E</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCODEHASH","title":"<code>EXTCODEHASH = Opcode(63, popped_stack_items=1, pushed_stack_items=1, kwargs=['address'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCODEHASH--extcodehashaddress-hash","title":"EXTCODEHASH(address) = hash","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCODEHASH--description","title":"Description","text":"<p>Get hash of an account's code</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCODEHASH--inputs","title":"Inputs","text":"<ul> <li>address: 20-byte address of the account</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCODEHASH--outputs","title":"Outputs","text":"<ul> <li>hash: hash of the chosen account's code, the empty hash (0xc5d24601...) if the account has no     code, or 0 if the account does not exist or has been destroyed</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCODEHASH--fork","title":"Fork","text":"<p>Constantinople</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCODEHASH--gas","title":"Gas","text":"<ul> <li>static_gas = 0</li> <li>dynamic_gas = 100 if warm_address, 2600 if cold_address</li> </ul> <p>Source: evm.codes/#3F</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BLOCKHASH","title":"<code>BLOCKHASH = Opcode(64, popped_stack_items=1, pushed_stack_items=1, kwargs=['block_number'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BLOCKHASH--blockhashblock_number-hash","title":"BLOCKHASH(block_number) = hash","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BLOCKHASH--description","title":"Description","text":"<p>Get the hash of one of the 256 most recent complete blocks</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BLOCKHASH--inputs","title":"Inputs","text":"<ul> <li>blockNumber: block number to get the hash from. Valid range is the last 256 blocks (not     including the current one). Current block number can be queried with NUMBER</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BLOCKHASH--outputs","title":"Outputs","text":"<ul> <li>hash: hash of the chosen block, or 0 if the block number is not in the valid range</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BLOCKHASH--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BLOCKHASH--gas","title":"Gas","text":"<p>20</p> <p>Source: evm.codes/#40</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.COINBASE","title":"<code>COINBASE = Opcode(65, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.COINBASE--coinbase-address","title":"COINBASE() = address","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.COINBASE--description","title":"Description","text":"<p>Get the block's beneficiary address</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.COINBASE--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.COINBASE--outputs","title":"Outputs","text":"<ul> <li>address: miner's 20-byte address</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.COINBASE--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.COINBASE--gas","title":"Gas","text":"<p>2</p> <p>Source: evm.codes/#41</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.TIMESTAMP","title":"<code>TIMESTAMP = Opcode(66, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.TIMESTAMP--timestamp-timestamp","title":"TIMESTAMP() = timestamp","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.TIMESTAMP--description","title":"Description","text":"<p>Get the block's timestamp</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.TIMESTAMP--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.TIMESTAMP--outputs","title":"Outputs","text":"<ul> <li>timestamp: unix timestamp of the current block</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.TIMESTAMP--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.TIMESTAMP--gas","title":"Gas","text":"<p>2</p> <p>Source: evm.codes/#42</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.NUMBER","title":"<code>NUMBER = Opcode(67, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.NUMBER--number-blocknumber","title":"NUMBER() = blockNumber","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.NUMBER--description","title":"Description","text":"<p>Get the block's number</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.NUMBER--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.NUMBER--outputs","title":"Outputs","text":"<ul> <li>blockNumber: current block number</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.NUMBER--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.NUMBER--gas","title":"Gas","text":"<p>2</p> <p>Source: evm.codes/#43</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PREVRANDAO","title":"<code>PREVRANDAO = Opcode(68, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PREVRANDAO--prevrandao-prevrandao","title":"PREVRANDAO() = prevRandao","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PREVRANDAO--description","title":"Description","text":"<p>Get the previous block's RANDAO mix</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PREVRANDAO--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PREVRANDAO--outputs","title":"Outputs","text":"<ul> <li>prevRandao: previous block's RANDAO mix</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PREVRANDAO--fork","title":"Fork","text":"<p>Merge</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PREVRANDAO--gas","title":"Gas","text":"<p>2</p> <p>Source: evm.codes/#44</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GASLIMIT","title":"<code>GASLIMIT = Opcode(69, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GASLIMIT--gaslimit-gaslimit","title":"GASLIMIT() = gasLimit","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GASLIMIT--description","title":"Description","text":"<p>Get the block's gas limit</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GASLIMIT--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GASLIMIT--outputs","title":"Outputs","text":"<ul> <li>gasLimit: gas limit</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GASLIMIT--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GASLIMIT--gas","title":"Gas","text":"<p>2</p> <p>Source: evm.codes/#45</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CHAINID","title":"<code>CHAINID = Opcode(70, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CHAINID--chainid-chainid","title":"CHAINID() = chainId","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CHAINID--description","title":"Description","text":"<p>Get the chain ID</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CHAINID--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CHAINID--outputs","title":"Outputs","text":"<ul> <li>chainId: chain id of the network</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CHAINID--fork","title":"Fork","text":"<p>Istanbul</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CHAINID--gas","title":"Gas","text":"<p>2</p> <p>Source: evm.codes/#46</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SELFBALANCE","title":"<code>SELFBALANCE = Opcode(71, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SELFBALANCE--selfbalance-balance","title":"SELFBALANCE() = balance","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SELFBALANCE--description","title":"Description","text":"<p>Get balance of currently executing account</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SELFBALANCE--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SELFBALANCE--outputs","title":"Outputs","text":"<ul> <li>balance: balance of the current account in wei</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SELFBALANCE--fork","title":"Fork","text":"<p>Istanbul</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SELFBALANCE--gas","title":"Gas","text":"<p>5</p> <p>Source: evm.codes/#47</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BASEFEE","title":"<code>BASEFEE = Opcode(72, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BASEFEE--basefee-basefee","title":"BASEFEE() = baseFee","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BASEFEE--description","title":"Description","text":"<p>Get the base fee</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BASEFEE--outputs","title":"Outputs","text":"<ul> <li>baseFee: base fee in wei</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BASEFEE--fork","title":"Fork","text":"<p>London</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BASEFEE--gas","title":"Gas","text":"<p>2</p> <p>Source: evm.codes/#48</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BLOBHASH","title":"<code>BLOBHASH = Opcode(73, popped_stack_items=1, pushed_stack_items=1, kwargs=['index'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BLOBHASH--blobhashindex-versionedhash","title":"BLOBHASH(index) = versionedHash","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BLOBHASH--description","title":"Description","text":"<p>Returns the versioned hash of a single blob contained in the type-3 transaction</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BLOBHASH--inputs","title":"Inputs","text":"<ul> <li>index: index of the blob</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BLOBHASH--outputs","title":"Outputs","text":"<ul> <li>versionedHash: versioned hash of the blob</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BLOBHASH--fork","title":"Fork","text":"<p>Cancun</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BLOBHASH--gas","title":"Gas","text":"<p>3</p> <p>Source: eips.ethereum.org/EIPS/eip-4844</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BLOBBASEFEE","title":"<code>BLOBBASEFEE = Opcode(74, popped_stack_items=0, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BLOBBASEFEE--blobbasefee-fee","title":"BLOBBASEFEE() = fee","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BLOBBASEFEE--description","title":"Description","text":"<p>Returns the value of the blob base fee of the block it is executing in</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BLOBBASEFEE--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BLOBBASEFEE--outputs","title":"Outputs","text":"<ul> <li>baseFeePerBlobGas: base fee for the blob gas in wei</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BLOBBASEFEE--fork","title":"Fork","text":"<p>Cancun</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.BLOBBASEFEE--gas","title":"Gas","text":"<p>2</p> <p>Source: eips.ethereum.org/EIPS/eip-7516</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.POP","title":"<code>POP = Opcode(80, popped_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.POP--pop","title":"POP()","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.POP--description","title":"Description","text":"<p>Remove item from stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.POP--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.POP--outputs","title":"Outputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.POP--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.POP--gas","title":"Gas","text":"<p>2</p> <p>Source: evm.codes/#50</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MLOAD","title":"<code>MLOAD = Opcode(81, popped_stack_items=1, pushed_stack_items=1, kwargs=['offset'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MLOAD--mloadoffset-value","title":"MLOAD(offset) = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MLOAD--description","title":"Description","text":"<p>Load word from memory</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MLOAD--inputs","title":"Inputs","text":"<ul> <li>offset: offset in the memory in bytes</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MLOAD--outputs","title":"Outputs","text":"<ul> <li>value: the 32 bytes in memory starting at that offset. If it goes beyond its current size     (see MSIZE), writes 0s</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MLOAD--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MLOAD--gas","title":"Gas","text":"<ul> <li>static_gas = 3</li> <li>dynamic_gas = memory_expansion_cost</li> </ul> <p>Source: evm.codes/#51</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MSTORE","title":"<code>MSTORE = Opcode(82, popped_stack_items=2, kwargs=['offset', 'value'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MSTORE--mstoreoffset-value","title":"MSTORE(offset, value)","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MSTORE--description","title":"Description","text":"<p>Save word to memory</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MSTORE--inputs","title":"Inputs","text":"<ul> <li>offset: offset in the memory in bytes</li> <li>value: 32-byte value to write in the memory</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MSTORE--outputs","title":"Outputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MSTORE--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MSTORE--gas","title":"Gas","text":"<ul> <li>static_gas = 3</li> <li>dynamic_gas = memory_expansion_cost</li> </ul> <p>Source: evm.codes/#52</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MSTORE8","title":"<code>MSTORE8 = Opcode(83, popped_stack_items=2, kwargs=['offset', 'value'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MSTORE8--mstore8offset-value","title":"MSTORE8(offset, value)","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MSTORE8--description","title":"Description","text":"<p>Save byte to memory</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MSTORE8--inputs","title":"Inputs","text":"<ul> <li>offset: offset in the memory in bytes</li> <li>value: 1-byte value to write in the memory (the least significant byte of the 32-byte stack     value)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MSTORE8--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MSTORE8--gas","title":"Gas","text":"<ul> <li>static_gas = 3</li> <li>dynamic_gas = memory_expansion_cost</li> </ul> <p>Source: evm.codes/#53</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SLOAD","title":"<code>SLOAD = Opcode(84, popped_stack_items=1, pushed_stack_items=1, kwargs=['key'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SLOAD--sloadkey-value","title":"SLOAD(key) = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SLOAD--description","title":"Description","text":"<p>Load word from storage</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SLOAD--inputs","title":"Inputs","text":"<ul> <li>key: 32-byte key in storage</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SLOAD--outputs","title":"Outputs","text":"<ul> <li>value: 32-byte value corresponding to that key. 0 if that key was never written before</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SLOAD--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SLOAD--gas","title":"Gas","text":"<ul> <li>static_gas = 0</li> <li>dynamic_gas = 100 if warm_address, 2600 if cold_address</li> </ul> <p>Source: evm.codes/#54</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SSTORE","title":"<code>SSTORE = Opcode(85, popped_stack_items=2, kwargs=['key', 'value'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SSTORE--sstorekey-value","title":"SSTORE(key, value)","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SSTORE--description","title":"Description","text":"<p>Save word to storage</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SSTORE--inputs","title":"Inputs","text":"<ul> <li>key: 32-byte key in storage</li> <li>value: 32-byte value to store</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SSTORE--outputs","title":"Outputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SSTORE--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SSTORE--gas","title":"Gas","text":"<pre><code>static_gas = 0\n\nif value == current_value\n    if key is warm\n        base_dynamic_gas = 100\n    else\n        base_dynamic_gas = 100\nelse if current_value == original_value\n    if original_value == 0\n        base_dynamic_gas = 20000\n    else\n        base_dynamic_gas = 2900\nelse\n    base_dynamic_gas = 100\n\nif key is cold:\n    base_dynamic_gas += 2100\n</code></pre> <p>Source: evm.codes/#55</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMP","title":"<code>JUMP = Opcode(86, popped_stack_items=1, kwargs=['pc'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMP--jumppc","title":"JUMP(pc)","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMP--description","title":"Description","text":"<p>Alter the program counter</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMP--inputs","title":"Inputs","text":"<ul> <li>pc: byte offset in the deployed code where execution will continue from. Must be a     JUMPDEST instruction</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMP--outputs","title":"Outputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMP--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMP--gas","title":"Gas","text":"<p>8</p> <p>Source: evm.codes/#56</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMPI","title":"<code>JUMPI = Opcode(87, popped_stack_items=2, kwargs=['pc', 'condition'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMPI--jumpipc-condition","title":"JUMPI(pc, condition)","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMPI--description","title":"Description","text":"<p>Conditionally alter the program counter</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMPI--inputs","title":"Inputs","text":"<ul> <li>pc: byte offset in the deployed code where execution will continue from. Must be a     JUMPDEST instruction</li> <li>condition: the program counter will be altered with the new value only if this value is     different from 0. Otherwise, the program counter is simply incremented and the next     instruction will be executed</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMPI--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMPI--gas","title":"Gas","text":"<p>10</p> <p>Source: evm.codes/#57</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PC","title":"<code>PC = Opcode(88, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PC--pc-counter","title":"PC() = counter","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PC--description","title":"Description","text":"<p>Get the value of the program counter prior to the increment corresponding to this instruction</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PC--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PC--outputs","title":"Outputs","text":"<ul> <li>counter: PC of this instruction in the current program.</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PC--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PC--gas","title":"Gas","text":"<p>2</p> <p>Source: evm.codes/#58</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MSIZE","title":"<code>MSIZE = Opcode(89, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MSIZE--msize-size","title":"MSIZE() = size","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MSIZE--description","title":"Description","text":"<p>Get the size of active memory in bytes</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MSIZE--outputs","title":"Outputs","text":"<ul> <li>size: current memory size in bytes (higher offset accessed until now + 1)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MSIZE--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MSIZE--gas","title":"Gas","text":"<p>2</p> <p>Source: evm.codes/#59</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GAS","title":"<code>GAS = Opcode(90, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GAS--gas-gas_remaining","title":"GAS() = gas_remaining","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GAS--description","title":"Description","text":"<p>Get the amount of available gas, including the corresponding reduction for the cost of this instruction</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GAS--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GAS--outputs","title":"Outputs","text":"<ul> <li>gas: remaining gas (after this instruction)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GAS--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.GAS--gas","title":"Gas","text":"<p>2</p> <p>Source: evm.codes/#5A</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMPDEST","title":"<code>JUMPDEST = Opcode(91)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMPDEST--jumpdest","title":"JUMPDEST()","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMPDEST--description","title":"Description","text":"<p>Mark a valid destination for jumps</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMPDEST--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMPDEST--outputs","title":"Outputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMPDEST--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMPDEST--gas","title":"Gas","text":"<p>1</p> <p>Source: evm.codes/#5B</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.NOOP","title":"<code>NOOP = Opcode(91)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.NOOP--noop","title":"NOOP()","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.NOOP--description","title":"Description","text":"<p>Synonym for JUMPDEST. Performs no operation.</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.NOOP--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.NOOP--outputs","title":"Outputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.NOOP--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.NOOP--gas","title":"Gas","text":"<p>1</p> <p>Source: evm.codes/#5B</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.TLOAD","title":"<code>TLOAD = Opcode(92, popped_stack_items=1, pushed_stack_items=1, kwargs=['key'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.TLOAD--tloadkey-value","title":"TLOAD(key) = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.TLOAD--description","title":"Description","text":"<p>Load word from transient storage</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.TLOAD--inputs","title":"Inputs","text":"<ul> <li>key: 32-byte key in transient storage</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.TLOAD--outputs","title":"Outputs","text":"<ul> <li>value: 32-byte value corresponding to that key. 0 if that key was never written</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.TLOAD--fork","title":"Fork","text":"<p>Cancun</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.TLOAD--gas","title":"Gas","text":"<p>100</p> <p>Source: eips.ethereum.org/EIPS/eip-1153</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.TSTORE","title":"<code>TSTORE = Opcode(93, popped_stack_items=2, kwargs=['key', 'value'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.TSTORE--tstorekey-value","title":"TSTORE(key, value)","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.TSTORE--description","title":"Description","text":"<p>Save word to transient storage</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.TSTORE--inputs","title":"Inputs","text":"<ul> <li>key: 32-byte key in transient storage</li> <li>value: 32-byte value to store</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.TSTORE--fork","title":"Fork","text":"<p>Cancun</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.TSTORE--gas","title":"Gas","text":"<p>100</p> <p>Source: eips.ethereum.org/EIPS/eip-1153</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MCOPY","title":"<code>MCOPY = Opcode(94, popped_stack_items=3, kwargs=['dest_offset', 'offset', 'size'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MCOPY--mcopydest_offset-offset-size","title":"MCOPY(dest_offset, offset, size)","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MCOPY--description","title":"Description","text":"<p>Copies areas in memory</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MCOPY--inputs","title":"Inputs","text":"<ul> <li>dest_offset: byte offset in the memory where the result will be copied</li> <li>offset: byte offset in the calldata to copy</li> <li>size: byte size to copy</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MCOPY--outputs","title":"Outputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MCOPY--fork","title":"Fork","text":"<p>Cancun</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.MCOPY--gas","title":"Gas","text":"<ul> <li>minimum_word_size = (size + 31) / 32</li> <li>static_gas = 3</li> <li>dynamic_gas = 3 * minimum_word_size + memory_expansion_cost</li> </ul> <p>Source: eips.ethereum.org/EIPS/eip-5656</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH0","title":"<code>PUSH0 = Opcode(95, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH0--push0-value","title":"PUSH0() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH0--description","title":"Description","text":"<p>Place value 0 on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH0--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH0--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, equal to 0</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH0--fork","title":"Fork","text":"<p>Shanghai</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH0--gas","title":"Gas","text":"<p>2</p> <p>Source: evm.codes/#5F</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH1","title":"<code>PUSH1 = Opcode(96, pushed_stack_items=1, data_portion_length=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH1--push1-value","title":"PUSH1() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH1--description","title":"Description","text":"<p>Place 1 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH1--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH1--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH1--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH1--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#60</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH2","title":"<code>PUSH2 = Opcode(97, pushed_stack_items=1, data_portion_length=2)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH2--push2-value","title":"PUSH2() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH2--description","title":"Description","text":"<p>Place 2 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH2--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH2--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH2--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH2--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#61</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH3","title":"<code>PUSH3 = Opcode(98, pushed_stack_items=1, data_portion_length=3)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH3--push3-value","title":"PUSH3() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH3--description","title":"Description","text":"<p>Place 3 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH3--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH3--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH3--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH3--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#62</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH4","title":"<code>PUSH4 = Opcode(99, pushed_stack_items=1, data_portion_length=4)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH4--push4-value","title":"PUSH4() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH4--description","title":"Description","text":"<p>Place 4 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH4--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH4--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH4--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH4--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#63</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH5","title":"<code>PUSH5 = Opcode(100, pushed_stack_items=1, data_portion_length=5)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH5--push5-value","title":"PUSH5() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH5--description","title":"Description","text":"<p>Place 5 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH5--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH5--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH5--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH5--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#64</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH6","title":"<code>PUSH6 = Opcode(101, pushed_stack_items=1, data_portion_length=6)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH6--push6-value","title":"PUSH6() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH6--description","title":"Description","text":"<p>Place 6 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH6--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH6--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH6--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH6--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#65</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH7","title":"<code>PUSH7 = Opcode(102, pushed_stack_items=1, data_portion_length=7)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH7--push7-value","title":"PUSH7() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH7--description","title":"Description","text":"<p>Place 7 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH7--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH7--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH7--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH7--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#66</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH8","title":"<code>PUSH8 = Opcode(103, pushed_stack_items=1, data_portion_length=8)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH8--push8-value","title":"PUSH8() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH8--description","title":"Description","text":"<p>Place 8 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH8--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH8--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH8--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH8--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#67</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH9","title":"<code>PUSH9 = Opcode(104, pushed_stack_items=1, data_portion_length=9)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH9--push9-value","title":"PUSH9() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH9--description","title":"Description","text":"<p>Place 9 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH9--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH9--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH9--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH9--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#68</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH10","title":"<code>PUSH10 = Opcode(105, pushed_stack_items=1, data_portion_length=10)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH10--push10-value","title":"PUSH10() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH10--description","title":"Description","text":"<p>Place 10 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH10--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH10--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH10--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH10--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#69</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH11","title":"<code>PUSH11 = Opcode(106, pushed_stack_items=1, data_portion_length=11)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH11--push11-value","title":"PUSH11() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH11--description","title":"Description","text":"<p>Place 11 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH11--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH11--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH11--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH11--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#6A</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH12","title":"<code>PUSH12 = Opcode(107, pushed_stack_items=1, data_portion_length=12)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH12--push12-value","title":"PUSH12() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH12--description","title":"Description","text":"<p>Place 12 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH12--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH12--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH12--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH12--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#6B</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH13","title":"<code>PUSH13 = Opcode(108, pushed_stack_items=1, data_portion_length=13)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH13--push13-value","title":"PUSH13() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH13--description","title":"Description","text":"<p>Place 13 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH13--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH13--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH13--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH13--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#6C</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH14","title":"<code>PUSH14 = Opcode(109, pushed_stack_items=1, data_portion_length=14)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH14--push14-value","title":"PUSH14() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH14--description","title":"Description","text":"<p>Place 14 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH14--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH14--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH14--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH14--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#6D</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH15","title":"<code>PUSH15 = Opcode(110, pushed_stack_items=1, data_portion_length=15)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH15--push15-value","title":"PUSH15() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH15--description","title":"Description","text":"<p>Place 15 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH15--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH15--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH15--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH15--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#6E</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH16","title":"<code>PUSH16 = Opcode(111, pushed_stack_items=1, data_portion_length=16)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH16--push16-value","title":"PUSH16() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH16--description","title":"Description","text":"<p>Place 16 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH16--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH16--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH16--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH16--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#6F</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH17","title":"<code>PUSH17 = Opcode(112, pushed_stack_items=1, data_portion_length=17)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH17--push17-value","title":"PUSH17() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH17--description","title":"Description","text":"<p>Place 17 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH17--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH17--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH17--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH17--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#70</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH18","title":"<code>PUSH18 = Opcode(113, pushed_stack_items=1, data_portion_length=18)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH18--push18-value","title":"PUSH18() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH18--description","title":"Description","text":"<p>Place 18 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH18--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH18--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH18--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH18--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#71</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH19","title":"<code>PUSH19 = Opcode(114, pushed_stack_items=1, data_portion_length=19)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH19--push19-value","title":"PUSH19() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH19--description","title":"Description","text":"<p>Place 19 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH19--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH19--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH19--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH19--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#72</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH20","title":"<code>PUSH20 = Opcode(115, pushed_stack_items=1, data_portion_length=20)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH20--push20-value","title":"PUSH20() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH20--description","title":"Description","text":"<p>Place 20 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH20--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH20--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH20--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH20--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#73</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH21","title":"<code>PUSH21 = Opcode(116, pushed_stack_items=1, data_portion_length=21)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH21--push21-value","title":"PUSH21() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH21--description","title":"Description","text":"<p>Place 21 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH21--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH21--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH21--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH21--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#74</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH22","title":"<code>PUSH22 = Opcode(117, pushed_stack_items=1, data_portion_length=22)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH22--push22-value","title":"PUSH22() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH22--description","title":"Description","text":"<p>Place 22 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH22--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH22--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH22--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH22--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#75</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH23","title":"<code>PUSH23 = Opcode(118, pushed_stack_items=1, data_portion_length=23)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH23--push23-value","title":"PUSH23() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH23--description","title":"Description","text":"<p>Place 23 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH23--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH23--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH23--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH23--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#76</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH24","title":"<code>PUSH24 = Opcode(119, pushed_stack_items=1, data_portion_length=24)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH24--push24-value","title":"PUSH24() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH24--description","title":"Description","text":"<p>Place 24 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH24--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH24--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH24--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH24--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#77</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH25","title":"<code>PUSH25 = Opcode(120, pushed_stack_items=1, data_portion_length=25)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH25--push25-value","title":"PUSH25() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH25--description","title":"Description","text":"<p>Place 25 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH25--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH25--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH25--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH25--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#78</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH26","title":"<code>PUSH26 = Opcode(121, pushed_stack_items=1, data_portion_length=26)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH26--push26-value","title":"PUSH26() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH26--description","title":"Description","text":"<p>Place 26 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH26--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH26--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH26--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH26--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#79</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH27","title":"<code>PUSH27 = Opcode(122, pushed_stack_items=1, data_portion_length=27)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH27--push27-value","title":"PUSH27() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH27--description","title":"Description","text":"<p>Place 27 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH27--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH27--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH27--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH27--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#7A</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH28","title":"<code>PUSH28 = Opcode(123, pushed_stack_items=1, data_portion_length=28)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH28--push28-value","title":"PUSH28() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH28--description","title":"Description","text":"<p>Place 28 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH28--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH28--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH28--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH28--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#7B</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH29","title":"<code>PUSH29 = Opcode(124, pushed_stack_items=1, data_portion_length=29)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH29--push29-value","title":"PUSH29() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH29--description","title":"Description","text":"<p>Place 29 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH29--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH29--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH29--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH29--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#7C</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH30","title":"<code>PUSH30 = Opcode(125, pushed_stack_items=1, data_portion_length=30)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH30--push30-value","title":"PUSH30() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH30--description","title":"Description","text":"<p>Place 30 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH30--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH30--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH30--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH30--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#7D</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH31","title":"<code>PUSH31 = Opcode(126, pushed_stack_items=1, data_portion_length=31)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH31--push31-value","title":"PUSH31() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH31--description","title":"Description","text":"<p>Place 31 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH31--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH31--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH31--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH31--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#7E</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH32","title":"<code>PUSH32 = Opcode(127, pushed_stack_items=1, data_portion_length=32)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH32--push32-value","title":"PUSH32() = value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH32--description","title":"Description","text":"<p>Place 32 byte item on stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH32--inputs","title":"Inputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH32--outputs","title":"Outputs","text":"<ul> <li>value: pushed value, aligned to the right (put in the lowest significant bytes)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH32--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.PUSH32--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#7F</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP1","title":"<code>DUP1 = Opcode(128, pushed_stack_items=1, min_stack_height=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP1--dup1value-value-value","title":"DUP1(value) = value, value","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP1--description","title":"Description","text":"<p>Duplicate 1<sup>st</sup> stack item</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP1--inputs","title":"Inputs","text":"<ul> <li>value: value to duplicate</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP1--outputs","title":"Outputs","text":"<ul> <li>value: duplicated value</li> <li>value: original value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP1--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP1--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#80</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP2","title":"<code>DUP2 = Opcode(129, pushed_stack_items=1, min_stack_height=2)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP2--dup2v1-v2-v2-v1-v2","title":"DUP2(v1, v2) = v2, v1, v2","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP2--description","title":"Description","text":"<p>Duplicate 2<sup>nd</sup> stack item</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP2--inputs","title":"Inputs","text":"<ul> <li>v1: ignored value</li> <li>v2: value to duplicate</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP2--outputs","title":"Outputs","text":"<ul> <li>v2: duplicated value</li> <li>v1: ignored value</li> <li>v2: original value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP2--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP2--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#81</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP3","title":"<code>DUP3 = Opcode(130, pushed_stack_items=1, min_stack_height=3)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP3--dup3v1-v2-v3-v3-v1-v2-v3","title":"DUP3(v1, v2, v3) = v3, v1, v2, v3","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP3--description","title":"Description","text":"<p>Duplicate 3<sup>rd</sup> stack item</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP3--inputs","title":"Inputs","text":"<ul> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>v3: value to duplicate</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP3--outputs","title":"Outputs","text":"<ul> <li>v3: duplicated value</li> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>v3: original value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP3--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP3--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#82</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP4","title":"<code>DUP4 = Opcode(131, pushed_stack_items=1, min_stack_height=4)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP4--dup4v1-v2-v3-v4-v4-v1-v2-v3-v4","title":"DUP4(v1, v2, v3, v4) = v4, v1, v2, v3, v4","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP4--description","title":"Description","text":"<p>Duplicate 4<sup>th</sup> stack item</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP4--inputs","title":"Inputs","text":"<ul> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>v3: ignored value</li> <li>v4: value to duplicate</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP4--outputs","title":"Outputs","text":"<ul> <li>v4: duplicated value</li> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>v3: ignored value</li> <li>v4: original value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP4--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP4--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#83</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP5","title":"<code>DUP5 = Opcode(132, pushed_stack_items=1, min_stack_height=5)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP5--dup5v1-v2-v3-v4-v5-v5-v1-v2-v3-v4-v5","title":"DUP5(v1, v2, v3, v4, v5) = v5, v1, v2, v3, v4, v5","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP5--description","title":"Description","text":"<p>Duplicate 5<sup>th</sup> stack item</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP5--inputs","title":"Inputs","text":"<ul> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>v3: ignored value</li> <li>v4: ignored value</li> <li>v5: value to duplicate</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP5--outputs","title":"Outputs","text":"<ul> <li>v5: duplicated value</li> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>v3: ignored value</li> <li>v4: ignored value</li> <li>v5: original value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP5--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP5--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#84</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP6","title":"<code>DUP6 = Opcode(133, pushed_stack_items=1, min_stack_height=6)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP6--dup6v1-v2-v5-v6-v6-v1-v2-v5-v6","title":"DUP6(v1, v2, ..., v5, v6) = v6, v1, v2, ..., v5, v6","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP6--description","title":"Description","text":"<p>Duplicate 6<sup>th</sup> stack item</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP6--inputs","title":"Inputs","text":"<ul> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>...</li> <li>v5: ignored value</li> <li>v6: value to duplicate</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP6--outputs","title":"Outputs","text":"<ul> <li>v6: duplicated value</li> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>...</li> <li>v5: ignored value</li> <li>v6: original value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP6--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP6--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#85</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP7","title":"<code>DUP7 = Opcode(134, pushed_stack_items=1, min_stack_height=7)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP7--dup7v1-v2-v6-v7-v7-v1-v2-v6-v7","title":"DUP7(v1, v2, ..., v6, v7) = v7, v1, v2, ..., v6, v7","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP7--description","title":"Description","text":"<p>Duplicate 7<sup>th</sup> stack item</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP7--inputs","title":"Inputs","text":"<ul> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>...</li> <li>v6: ignored value</li> <li>v7: value to duplicate</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP7--outputs","title":"Outputs","text":"<ul> <li>v7: duplicated value</li> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>...</li> <li>v6: ignored value</li> <li>v7: original value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP7--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP7--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#86</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP8","title":"<code>DUP8 = Opcode(135, pushed_stack_items=1, min_stack_height=8)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP8--dup8v1-v2-v7-v8-v8-v1-v2-v7-v8","title":"DUP8(v1, v2, ..., v7, v8) = v8, v1, v2, ..., v7, v8","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP8--description","title":"Description","text":"<p>Duplicate 8<sup>th</sup> stack item</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP8--inputs","title":"Inputs","text":"<ul> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>...</li> <li>v7: ignored value</li> <li>v8: value to duplicate</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP8--outputs","title":"Outputs","text":"<ul> <li>v8: duplicated value</li> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>...</li> <li>v7: ignored value</li> <li>v8: original value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP8--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP8--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#87</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP9","title":"<code>DUP9 = Opcode(136, pushed_stack_items=1, min_stack_height=9)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP9--dup9v1-v2-v8-v9-v9-v1-v2-v8-v9","title":"DUP9(v1, v2, ..., v8, v9) = v9, v1, v2, ..., v8, v9","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP9--description","title":"Description","text":"<p>Duplicate 9<sup>th</sup> stack item</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP9--inputs","title":"Inputs","text":"<ul> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>...</li> <li>v8: ignored value</li> <li>v9: value to duplicate</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP9--outputs","title":"Outputs","text":"<ul> <li>v9: duplicated value</li> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>...</li> <li>v8: ignored value</li> <li>v9: original value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP9--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP9--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#88</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP10","title":"<code>DUP10 = Opcode(137, pushed_stack_items=1, min_stack_height=10)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP10--dup10v1-v2-v9-v10-v10-v1-v2-v9-v10","title":"DUP10(v1, v2, ..., v9, v10) = v10, v1, v2, ..., v9, v10","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP10--description","title":"Description","text":"<p>Duplicate 10<sup>th</sup> stack item</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP10--inputs","title":"Inputs","text":"<ul> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>...</li> <li>v9: ignored value</li> <li>v10: value to duplicate</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP10--outputs","title":"Outputs","text":"<ul> <li>v10: duplicated value</li> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>...</li> <li>v9: ignored value</li> <li>v10: original value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP10--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP10--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#89</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP11","title":"<code>DUP11 = Opcode(138, pushed_stack_items=1, min_stack_height=11)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP11--dup11v1-v2-v10-v11-v11-v1-v2-v10-v11","title":"DUP11(v1, v2, ..., v10, v11) = v11, v1, v2, ..., v10, v11","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP11--description","title":"Description","text":"<p>Duplicate 11<sup>th</sup> stack item</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP11--inputs","title":"Inputs","text":"<ul> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>...</li> <li>v10: ignored value</li> <li>v11: value to duplicate</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP11--outputs","title":"Outputs","text":"<ul> <li>v11: duplicated value</li> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>...</li> <li>v10: ignored value</li> <li>v11: original value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP11--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP11--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#8A</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP12","title":"<code>DUP12 = Opcode(139, pushed_stack_items=1, min_stack_height=12)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP12--dup12v1-v2-v11-v12-v12-v1-v2-v11-v12","title":"DUP12(v1, v2, ..., v11, v12) = v12, v1, v2, ..., v11, v12","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP12--description","title":"Description","text":"<p>Duplicate 12<sup>th</sup> stack item</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP12--inputs","title":"Inputs","text":"<ul> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>...</li> <li>v11: ignored value</li> <li>v12: value to duplicate</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP12--outputs","title":"Outputs","text":"<ul> <li>v12: duplicated value</li> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>...</li> <li>v11: ignored value</li> <li>v12: original value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP12--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP12--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#8B</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP13","title":"<code>DUP13 = Opcode(140, pushed_stack_items=1, min_stack_height=13)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP13--dup13v1-v2-v12-v13-v13-v1-v2-v12-v13","title":"DUP13(v1, v2, ..., v12, v13) = v13, v1, v2, ..., v12, v13","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP13--description","title":"Description","text":"<p>Duplicate 13<sup>th</sup> stack item</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP13--inputs","title":"Inputs","text":"<ul> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>...</li> <li>v12: ignored value</li> <li>v13: value to duplicate</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP13--outputs","title":"Outputs","text":"<ul> <li>v13: duplicated value</li> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>...</li> <li>v12: ignored value</li> <li>v13: original value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP13--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP13--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#8C</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP14","title":"<code>DUP14 = Opcode(141, pushed_stack_items=1, min_stack_height=14)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP14--dup14v1-v2-v13-v14-v14-v1-v2-v13-v14","title":"DUP14(v1, v2, ..., v13, v14) = v14, v1, v2, ..., v13, v14","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP14--description","title":"Description","text":"<p>Duplicate 14<sup>th</sup> stack item</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP14--inputs","title":"Inputs","text":"<ul> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>...</li> <li>v13: ignored value</li> <li>v14: value to duplicate</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP14--outputs","title":"Outputs","text":"<ul> <li>v14: duplicated value</li> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>...</li> <li>v13: ignored value</li> <li>v14: original value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP14--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP14--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#8D</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP15","title":"<code>DUP15 = Opcode(142, pushed_stack_items=1, min_stack_height=15)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP15--dup15v1-v2-v14-v15-v15-v1-v2-v14-v15","title":"DUP15(v1, v2, ..., v14, v15) = v15, v1, v2, ..., v14, v15","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP15--description","title":"Description","text":"<p>Duplicate 15<sup>th</sup> stack item</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP15--inputs","title":"Inputs","text":"<ul> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>...</li> <li>v14: ignored value</li> <li>v15: value to duplicate</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP15--outputs","title":"Outputs","text":"<ul> <li>v15: duplicated value</li> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>...</li> <li>v14: ignored value</li> <li>v15: original value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP15--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP15--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#8E</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP16","title":"<code>DUP16 = Opcode(143, pushed_stack_items=1, min_stack_height=16)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP16--dup16v1-v2-v15-v16-v16-v1-v2-v15-v16","title":"DUP16(v1, v2, ..., v15, v16) = v16, v1, v2, ..., v15, v16","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP16--description","title":"Description","text":"<p>Duplicate 16<sup>th</sup> stack item</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP16--inputs","title":"Inputs","text":"<ul> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>...</li> <li>v15: ignored value</li> <li>v16: value to duplicate</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP16--outputs","title":"Outputs","text":"<ul> <li>v16: duplicated value</li> <li>v1: ignored value</li> <li>v2: ignored value</li> <li>...</li> <li>v15: ignored value</li> <li>v16: original value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP16--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUP16--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#8F</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP1","title":"<code>SWAP1 = Opcode(144, min_stack_height=2)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP1--swap1v1-v2-v2-v1","title":"SWAP1(v1, v2) = v2, v1","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP1--description","title":"Description","text":"<p>Exchange the top stack item with the second stack item.</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP1--inputs","title":"Inputs","text":"<ul> <li>v1: value to swap</li> <li>v2: value to swap</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP1--outputs","title":"Outputs","text":"<ul> <li>v1: swapped value</li> <li>v2: swapped value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP1--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP1--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#90</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP2","title":"<code>SWAP2 = Opcode(145, min_stack_height=3)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP2--swap2v1-v2-v3-v3-v2-v1","title":"SWAP2(v1, v2, v3) = v3, v2, v1","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP2--description","title":"Description","text":"<p>Exchange 1<sup>st</sup> and 3<sup>rd</sup> stack items</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP2--inputs","title":"Inputs","text":"<ul> <li>v1: value to swap</li> <li>v2: ignored value</li> <li>v3: value to swap</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP2--outputs","title":"Outputs","text":"<ul> <li>v3: swapped value</li> <li>v2: ignored value</li> <li>v1: swapped value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP2--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP2--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#91</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP3","title":"<code>SWAP3 = Opcode(146, min_stack_height=4)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP3--swap3v1-v2-v3-v4-v4-v2-v3-v1","title":"SWAP3(v1, v2, v3, v4) = v4, v2, v3, v1","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP3--description","title":"Description","text":"<p>Exchange 1<sup>st</sup> and 4<sup>th</sup> stack items</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP3--inputs","title":"Inputs","text":"<ul> <li>v1: value to swap</li> <li>v2: ignored value</li> <li>v3: ignored value</li> <li>v4: value to swap</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP3--outputs","title":"Outputs","text":"<ul> <li>v4: swapped value</li> <li>v2: ignored value</li> <li>v3: ignored value</li> <li>v1: swapped value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP3--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP3--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#92</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP4","title":"<code>SWAP4 = Opcode(147, min_stack_height=5)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP4--swap4v1-v2-v4-v5-v5-v2-v4-v1","title":"SWAP4(v1, v2, ..., v4, v5) = v5, v2, ..., v4, v1","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP4--description","title":"Description","text":"<p>Exchange 1<sup>st</sup> and 5<sup>th</sup> stack items</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP4--inputs","title":"Inputs","text":"<ul> <li>v1: value to swap</li> <li>v2: ignored value</li> <li>...</li> <li>v4: ignored value</li> <li>v5: value to swap</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP4--outputs","title":"Outputs","text":"<ul> <li>v5: swapped value</li> <li>v2: ignored value</li> <li>...</li> <li>v4: ignored value</li> <li>v1: swapped value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP4--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP4--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#93</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP5","title":"<code>SWAP5 = Opcode(148, min_stack_height=6)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP5--swap5v1-v2-v5-v6-v6-v2-v5-v1","title":"SWAP5(v1, v2, ..., v5, v6) = v6, v2, ..., v5, v1","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP5--description","title":"Description","text":"<p>Exchange 1<sup>st</sup> and 6<sup>th</sup> stack items</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP5--inputs","title":"Inputs","text":"<ul> <li>v1: value to swap</li> <li>v2: ignored value</li> <li>...</li> <li>v5: ignored value</li> <li>v6: value to swap</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP5--outputs","title":"Outputs","text":"<ul> <li>v6: swapped value</li> <li>v2: ignored value</li> <li>...</li> <li>v5: ignored value</li> <li>v1: swapped value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP5--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP5--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#94</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP6","title":"<code>SWAP6 = Opcode(149, min_stack_height=7)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP6--swap6v1-v2-v6-v7-v7-v2-v6-v1","title":"SWAP6(v1, v2, ..., v6, v7) = v7, v2, ..., v6, v1","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP6--description","title":"Description","text":"<p>Exchange 1<sup>st</sup> and 7<sup>th</sup> stack items</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP6--inputs","title":"Inputs","text":"<ul> <li>v1: value to swap</li> <li>v2: ignored value</li> <li>...</li> <li>v6: ignored value</li> <li>v7: value to swap</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP6--outputs","title":"Outputs","text":"<ul> <li>v7: swapped value</li> <li>v2: ignored value</li> <li>...</li> <li>v6: ignored value</li> <li>v1: swapped value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP6--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP6--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#95</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP7","title":"<code>SWAP7 = Opcode(150, min_stack_height=8)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP7--swap7v1-v2-v7-v8-v8-v2-v7-v1","title":"SWAP7(v1, v2, ..., v7, v8) = v8, v2, ..., v7, v1","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP7--description","title":"Description","text":"<p>Exchange 1<sup>st</sup> and 8<sup>th</sup> stack items</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP7--inputs","title":"Inputs","text":"<ul> <li>v1: value to swap</li> <li>v2: ignored value</li> <li>...</li> <li>v7: ignored value</li> <li>v8: value to swap</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP7--outputs","title":"Outputs","text":"<ul> <li>v8: swapped value</li> <li>v2: ignored value</li> <li>...</li> <li>v7: ignored value</li> <li>v1: swapped value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP7--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP7--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#96</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP8","title":"<code>SWAP8 = Opcode(151, min_stack_height=9)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP8--swap8v1-v2-v8-v9-v9-v2-v8-v1","title":"SWAP8(v1, v2, ..., v8, v9) = v9, v2, ..., v8, v1","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP8--description","title":"Description","text":"<p>Exchange 1<sup>st</sup> and 9<sup>th</sup> stack items</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP8--inputs","title":"Inputs","text":"<ul> <li>v1: value to swap</li> <li>v2: ignored value</li> <li>...</li> <li>v8: ignored value</li> <li>v9: value to swap</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP8--outputs","title":"Outputs","text":"<ul> <li>v9: swapped value</li> <li>v2: ignored value</li> <li>...</li> <li>v8: ignored value</li> <li>v1: swapped value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP8--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP8--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#97</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP9","title":"<code>SWAP9 = Opcode(152, min_stack_height=10)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP9--swap9v1-v2-v9-v10-v10-v2-v9-v1","title":"SWAP9(v1, v2, ..., v9, v10) = v10, v2, ..., v9, v1","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP9--description","title":"Description","text":"<p>Exchange 1<sup>st</sup> and 10<sup>th</sup> stack items</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP9--inputs","title":"Inputs","text":"<ul> <li>v1: value to swap</li> <li>v2: ignored value</li> <li>...</li> <li>v9: ignored value</li> <li>v10: value to swap</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP9--outputs","title":"Outputs","text":"<ul> <li>v10: swapped value</li> <li>v2: ignored value</li> <li>...</li> <li>v9: ignored value</li> <li>v1: swapped value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP9--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP9--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#98</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP10","title":"<code>SWAP10 = Opcode(153, min_stack_height=11)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP10--swap10v1-v2-v10-v11-v11-v2-v10-v1","title":"SWAP10(v1, v2, ..., v10, v11) = v11, v2, ..., v10, v1","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP10--description","title":"Description","text":"<p>Exchange 1<sup>st</sup> and 11<sup>th</sup> stack items</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP10--inputs","title":"Inputs","text":"<ul> <li>v1: value to swap</li> <li>v2: ignored value</li> <li>...</li> <li>v10: ignored value</li> <li>v11: value to swap</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP10--outputs","title":"Outputs","text":"<ul> <li>v11: swapped value</li> <li>v2: ignored value</li> <li>...</li> <li>v10: ignored value</li> <li>v1: swapped value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP10--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP10--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#99</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP11","title":"<code>SWAP11 = Opcode(154, min_stack_height=12)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP11--swap11v1-v2-v11-v12-v12-v2-v11-v1","title":"SWAP11(v1, v2, ..., v11, v12) = v12, v2, ..., v11, v1","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP11--description","title":"Description","text":"<p>Exchange 1<sup>st</sup> and 12<sup>th</sup> stack items</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP11--inputs","title":"Inputs","text":"<ul> <li>v1: value to swap</li> <li>v2: ignored value</li> <li>...</li> <li>v11: ignored value</li> <li>v12: value to swap</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP11--outputs","title":"Outputs","text":"<ul> <li>v12: swapped value</li> <li>v2: ignored value</li> <li>...</li> <li>v11: ignored value</li> <li>v1: swapped value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP11--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP11--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#9A</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP12","title":"<code>SWAP12 = Opcode(155, min_stack_height=13)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP12--swap12v1-v2-v12-v13-v13-v2-v12-v1","title":"SWAP12(v1, v2, ..., v12, v13) = v13, v2, ..., v12, v1","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP12--description","title":"Description","text":"<p>Exchange 1<sup>st</sup> and 13<sup>th</sup> stack items</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP12--inputs","title":"Inputs","text":"<ul> <li>v1: value to swap</li> <li>v2: ignored value</li> <li>...</li> <li>v12: ignored value</li> <li>v13: value to swap</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP12--outputs","title":"Outputs","text":"<ul> <li>v13: swapped value</li> <li>v2: ignored value</li> <li>...</li> <li>v12: ignored value</li> <li>v1: swapped value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP12--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP12--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#9B</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP13","title":"<code>SWAP13 = Opcode(156, min_stack_height=14)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP13--swap13v1-v2-v13-v14-v14-v2-v13-v1","title":"SWAP13(v1, v2, ..., v13, v14) = v14, v2, ..., v13, v1","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP13--description","title":"Description","text":"<p>Exchange 1<sup>st</sup> and 14<sup>th</sup> stack items</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP13--inputs","title":"Inputs","text":"<ul> <li>v1: value to swap</li> <li>v2: ignored value</li> <li>...</li> <li>v13: ignored value</li> <li>v14: value to swap</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP13--outputs","title":"Outputs","text":"<ul> <li>v14: swapped value</li> <li>v2: ignored value</li> <li>...</li> <li>v13: ignored value</li> <li>v1: swapped value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP13--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP13--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#9C</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP14","title":"<code>SWAP14 = Opcode(157, min_stack_height=15)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP14--swap14v1-v2-v14-v15-v15-v2-v14-v1","title":"SWAP14(v1, v2, ..., v14, v15) = v15, v2, ..., v14, v1","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP14--description","title":"Description","text":"<p>Exchange 1<sup>st</sup> and 15<sup>th</sup> stack items</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP14--inputs","title":"Inputs","text":"<ul> <li>v1: value to swap</li> <li>v2: ignored value</li> <li>...</li> <li>v14: ignored value</li> <li>v15: value to swap</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP14--outputs","title":"Outputs","text":"<ul> <li>v15: swapped value</li> <li>v2: ignored value</li> <li>...</li> <li>v14: ignored value</li> <li>v1: swapped value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP14--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP14--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#9D</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP15","title":"<code>SWAP15 = Opcode(158, min_stack_height=16)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP15--swap15v1-v2-v15-v16-v16-v2-v15-v1","title":"SWAP15(v1, v2, ..., v15, v16) = v16, v2, ..., v15, v1","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP15--description","title":"Description","text":"<p>Exchange 1<sup>st</sup> and 16<sup>th</sup> stack items</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP15--inputs","title":"Inputs","text":"<ul> <li>v1: value to swap</li> <li>v2: ignored value</li> <li>...</li> <li>v15: ignored value</li> <li>v16: value to swap</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP15--outputs","title":"Outputs","text":"<ul> <li>v16: swapped value</li> <li>v2: ignored value</li> <li>...</li> <li>v15: ignored value</li> <li>v1: swapped value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP15--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP15--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#9E</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP16","title":"<code>SWAP16 = Opcode(159, min_stack_height=17)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP16--swap16v1-v2-v16-v17-v17-v2-v16-v1","title":"SWAP16(v1, v2, ..., v16, v17) = v17, v2, ..., v16, v1","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP16--description","title":"Description","text":"<p>Exchange 1<sup>st</sup> and 17<sup>th</sup> stack items</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP16--inputs","title":"Inputs","text":"<ul> <li>v1: value to swap</li> <li>v2: ignored value</li> <li>...</li> <li>v16: ignored value</li> <li>v17: value to swap</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP16--outputs","title":"Outputs","text":"<ul> <li>v17: swapped value</li> <li>v2: ignored value</li> <li>...</li> <li>v16: ignored value</li> <li>v1: swapped value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP16--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAP16--gas","title":"Gas","text":"<p>3</p> <p>Source: evm.codes/#9F</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG0","title":"<code>LOG0 = Opcode(160, popped_stack_items=2, kwargs=['offset', 'size'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG0--log0offset-size","title":"LOG0(offset, size)","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG0--description","title":"Description","text":"<p>Append log record with no topics</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG0--inputs","title":"Inputs","text":"<ul> <li>offset: byte offset in the memory in bytes</li> <li>size: byte size to copy</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG0--outputs","title":"Outputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG0--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG0--gas","title":"Gas","text":"<ul> <li>static_gas = 375</li> <li>dynamic_gas = 375 * topic_count + 8 * size + memory_expansion_cost</li> </ul> <p>Source: evm.codes/#A0</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG1","title":"<code>LOG1 = Opcode(161, popped_stack_items=3, kwargs=['offset', 'size', 'topic_1'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG1--log1offset-size-topic_1","title":"LOG1(offset, size, topic_1)","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG1--description","title":"Description","text":"<p>Append log record with one topic</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG1--inputs","title":"Inputs","text":"<ul> <li>offset: byte offset in the memory in bytes</li> <li>size: byte size to copy</li> <li>topic_1: 32-byte value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG1--outputs","title":"Outputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG1--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG1--gas","title":"Gas","text":"<ul> <li>static_gas = 375</li> <li>dynamic_gas = 375 * topic_count + 8 * size + memory_expansion_cost</li> </ul> <p>Source: evm.codes/#A1</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG2","title":"<code>LOG2 = Opcode(162, popped_stack_items=4, kwargs=['offset', 'size', 'topic_1', 'topic_2'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG2--log2offset-size-topic_1-topic_2","title":"LOG2(offset, size, topic_1, topic_2)","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG2--description","title":"Description","text":"<p>Append log record with two topics</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG2--inputs","title":"Inputs","text":"<ul> <li>offset: byte offset in the memory in bytes</li> <li>size: byte size to copy</li> <li>topic_1: 32-byte value</li> <li>topic_2: 32-byte value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG2--outputs","title":"Outputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG2--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG2--gas","title":"Gas","text":"<ul> <li>static_gas = 375</li> <li>dynamic_gas = 375 * topic_count + 8 * size + memory_expansion_cost</li> </ul> <p>Source: evm.codes/#A2</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG3","title":"<code>LOG3 = Opcode(163, popped_stack_items=5, kwargs=['offset', 'size', 'topic_1', 'topic_2', 'topic_3'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG3--log3offset-size-topic_1-topic_2-topic_3","title":"LOG3(offset, size, topic_1, topic_2, topic_3)","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG3--description","title":"Description","text":"<p>Append log record with three topics</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG3--inputs","title":"Inputs","text":"<ul> <li>offset: byte offset in the memory in bytes</li> <li>size: byte size to copy</li> <li>topic_1: 32-byte value</li> <li>topic_2: 32-byte value</li> <li>topic_3: 32-byte value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG3--outputs","title":"Outputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG3--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG3--gas","title":"Gas","text":"<ul> <li>static_gas = 375</li> <li>dynamic_gas = 375 * topic_count + 8 * size + memory_expansion_cost</li> </ul> <p>Source: evm.codes/#A3</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG4","title":"<code>LOG4 = Opcode(164, popped_stack_items=6, kwargs=['offset', 'size', 'topic_1', 'topic_2', 'topic_3', 'topic_4'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG4--log4offset-size-topic_1-topic_2-topic_3-topic_4","title":"LOG4(offset, size, topic_1, topic_2, topic_3, topic_4)","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG4--description","title":"Description","text":"<p>Append log record with four topics</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG4--inputs","title":"Inputs","text":"<ul> <li>offset: byte offset in the memory in bytes</li> <li>size: byte size to copy</li> <li>topic_1: 32-byte value</li> <li>topic_2: 32-byte value</li> <li>topic_3: 32-byte value</li> <li>topic_4: 32-byte value</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG4--outputs","title":"Outputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG4--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.LOG4--gas","title":"Gas","text":"<ul> <li>static_gas = 375</li> <li>dynamic_gas = 375 * topic_count + 8 * size + memory_expansion_cost</li> </ul> <p>Source: evm.codes/#A4</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RJUMP","title":"<code>RJUMP = Opcode(224, data_portion_length=2)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>!!! Note: This opcode is under development</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RJUMP--rjump","title":"RJUMP()","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RJUMP--description","title":"Description","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RJUMP--inputs","title":"Inputs","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RJUMP--outputs","title":"Outputs","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RJUMP--fork","title":"Fork","text":"<p>EOF Fork</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RJUMP--gas","title":"Gas","text":"<p>Source: eips.ethereum.org/EIPS/eip-4200</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATALOAD","title":"<code>DATALOAD = Opcode(208, popped_stack_items=1, pushed_stack_items=1, kwargs=['offset'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>!!! Note: This opcode is under development</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATALOAD--dataloadoffset","title":"DATALOAD(offset)","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATALOAD--description","title":"Description","text":"<p>Reads 32 bytes of data at offset onto the stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATALOAD--inputs","title":"Inputs","text":"<ul> <li>offset: offset within the data section to start copying</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATALOAD--outputs","title":"Outputs","text":"<p>none</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATALOAD--fork","title":"Fork","text":"<p>EOF Fork</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATALOAD--gas","title":"Gas","text":"<p>4</p> <p>Source: eips.ethereum.org/EIPS/eip-7480</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATALOADN","title":"<code>DATALOADN = Opcode(209, pushed_stack_items=1, data_portion_length=2)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>!!! Note: This opcode is under development</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATALOADN--dataloadn","title":"DATALOADN()","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATALOADN--description","title":"Description","text":"<p>Reads 32 bytes of data at offset onto the stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATALOADN--immediates","title":"Immediates","text":"<p>2 bytes forming a UInt16, which is the offset into the data section.</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATALOADN--inputs","title":"Inputs","text":"<p>none</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATALOADN--outputs","title":"Outputs","text":"<p>none</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATALOADN--fork","title":"Fork","text":"<p>EOF Fork</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATALOADN--gas","title":"Gas","text":"<p>3</p> <p>Source: eips.ethereum.org/EIPS/eip-7480</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATASIZE","title":"<code>DATASIZE = Opcode(210, pushed_stack_items=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>!!! Note: This opcode is under development</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATASIZE--datasize","title":"DATASIZE()","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATASIZE--description","title":"Description","text":"<p>Returns the size of the data section</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATASIZE--inputs","title":"Inputs","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATASIZE--outputs","title":"Outputs","text":"<p>The size of the data section. If there is no data section, returns 0.</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATASIZE--fork","title":"Fork","text":"<p>EOF Fork</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATASIZE--gas","title":"Gas","text":"<p>2</p> <p>Source: eips.ethereum.org/EIPS/eip-7480</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATACOPY","title":"<code>DATACOPY = Opcode(211, popped_stack_items=3, kwargs=['dest_offset', 'offset', 'size'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>!!! Note: This opcode is under development</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATACOPY--datacopydest_offset-offset-size","title":"DATACOPY(dest_offset, offset, size)","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATACOPY--description","title":"Description","text":"<p>Copies data from the data section into call frame memory</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATACOPY--inputs","title":"Inputs","text":"<ul> <li>dest_offset: The offset within the memory section to start copying to</li> <li>offset: The offset within the data section to start copying from</li> <li>size: The number of bytes to copy</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATACOPY--outputs","title":"Outputs","text":"<p>none</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATACOPY--fork","title":"Fork","text":"<p>EOF Fork</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DATACOPY--gas","title":"Gas","text":"<ul> <li>minimum_word_size = (size + 31) / 32</li> <li>static_gas = 3</li> <li>dynamic_gas = 3 * minimum_word_size + memory_expansion_cost</li> </ul> <p>Source: eips.ethereum.org/EIPS/eip-7480</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RJUMPI","title":"<code>RJUMPI = Opcode(225, popped_stack_items=1, data_portion_length=2)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>!!! Note: This opcode is under development</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RJUMPI--rjumpi","title":"RJUMPI()","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RJUMPI--description","title":"Description","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RJUMPI--inputs","title":"Inputs","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RJUMPI--outputs","title":"Outputs","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RJUMPI--fork","title":"Fork","text":"<p>EOF Fork</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RJUMPI--gas","title":"Gas","text":"<p>Source: eips.ethereum.org/EIPS/eip-4200</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RJUMPV","title":"<code>RJUMPV = Opcode(226, popped_stack_items=1, data_portion_formatter=_rjumpv_encoder)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>!!! Note: This opcode is under development</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RJUMPV--rjumpv","title":"RJUMPV()","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RJUMPV--description","title":"Description","text":"<p>Relative jump with variable offset.</p> <p>When calling this opcode to generate bytecode, the first argument is used to format the data portion of the opcode, and it can be either of two types: - A bytes type, and in this instance the bytes are used verbatim as the data portion. - An integer iterable, list or tuple or any other iterable, where each element is a     jump offset.</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RJUMPV--inputs","title":"Inputs","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RJUMPV--outputs","title":"Outputs","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RJUMPV--fork","title":"Fork","text":"<p>EOF Fork</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RJUMPV--gas","title":"Gas","text":"<p>Source: eips.ethereum.org/EIPS/eip-4200</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLF","title":"<code>CALLF = Opcode(227, data_portion_length=2, unchecked_stack=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>!!! Note: This opcode is under development</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLF--callf","title":"CALLF()","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLF--description","title":"Description","text":"<ul> <li>deduct 5 gas</li> <li>read uint16 operand idx</li> <li>if 1024 &lt; len(stack) + types[idx].max_stack_height - types[idx].inputs, execution results in     an exceptional halt</li> <li>if 1024 &lt;= len(return_stack), execution results in an exceptional halt</li> <li>push new element to return_stack (current_code_idx, pc+3)</li> <li>update current_code_idx to idx and set pc to 0</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLF--inputs","title":"Inputs","text":"<p>Any: The inputs are not checked because we cannot know how many inputs the callee function/section requires</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLF--outputs","title":"Outputs","text":"<p>Any: The outputs are variable because we cannot know how many outputs the callee function/section produces</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLF--fork","title":"Fork","text":"<p>EOF Fork</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLF--gas","title":"Gas","text":"<p>5</p> <p>Source: ipsilon/eof/blob/main/spec/eof.md</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETF","title":"<code>RETF = Opcode(228, terminating=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>!!! Note: This opcode is under development</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETF--retf","title":"RETF()","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETF--description","title":"Description","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETF--inputs","title":"Inputs","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETF--outputs","title":"Outputs","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETF--fork","title":"Fork","text":"<p>EOF Fork</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETF--gas","title":"Gas","text":"<p>3</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMPF","title":"<code>JUMPF = Opcode(229, data_portion_length=2, terminating=True, unchecked_stack=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>!!! Note: This opcode is under development</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMPF--jumpf","title":"JUMPF()","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMPF--description","title":"Description","text":"<ul> <li>deduct 5 gas</li> <li>read uint16 operand idx</li> <li>if 1024 &lt; len(stack) + types[idx].max_stack_height - types[idx].inputs, execution results in     an exceptional halt</li> <li>set current_code_idx to idx</li> <li>set pc = 0</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMPF--inputs","title":"Inputs","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMPF--outputs","title":"Outputs","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMPF--fork","title":"Fork","text":"<p>EOF Fork</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.JUMPF--gas","title":"Gas","text":"<p>5</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUPN","title":"<code>DUPN = Opcode(230, pushed_stack_items=1, data_portion_length=1, stack_properties_modifier=_dupn_stack_properties_modifier)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>!!! Note: This opcode is under development</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUPN--dupn","title":"DUPN()","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUPN--description","title":"Description","text":"<ul> <li>deduct 3 gas</li> <li>read uint8 operand imm</li> <li>n = imm + 1</li> <li>n\u2018th (1-based) stack item is duplicated at the top of the stack</li> <li>Stack validation: stack_height &gt;= n</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUPN--inputs","title":"Inputs","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUPN--outputs","title":"Outputs","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUPN--fork","title":"Fork","text":"<p>EOF Fork</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DUPN--gas","title":"Gas","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAPN","title":"<code>SWAPN = Opcode(231, data_portion_length=1, stack_properties_modifier=_swapn_stack_properties_modifier)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>!!! Note: This opcode is under development</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAPN--swapn","title":"SWAPN()","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAPN--description","title":"Description","text":"<ul> <li>deduct 3 gas</li> <li>read uint8 operand imm</li> <li>n = imm + 1</li> <li>n + 1th stack item is swapped with the top stack item (1-based).</li> <li>Stack validation: stack_height &gt;= n + 1</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAPN--inputs","title":"Inputs","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAPN--outputs","title":"Outputs","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAPN--fork","title":"Fork","text":"<p>EOF Fork</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SWAPN--gas","title":"Gas","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXCHANGE","title":"<code>EXCHANGE = Opcode(232, data_portion_length=1, data_portion_formatter=_exchange_encoder, stack_properties_modifier=_exchange_stack_properties_modifier)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>!!! Note: This opcode is under development</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXCHANGE--exchangex-y","title":"EXCHANGE[x, y]","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXCHANGE--description","title":"Description","text":"<p>Exchanges two stack positions.  Two nybbles, n is high 4 bits + 1, then  m is 4 low bits + 1. Exchanges tne n+1'th item with the n + m + 1 item.</p> <p>Inputs x and y when the opcode is used as <code>EXCHANGE[x, y]</code>, are equal to: - x = n + 1 - y = n + m + 1 Which each equals to 1-based stack positions swapped.</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXCHANGE--inputs","title":"Inputs","text":"<p>n + m + 1, or ((imm &gt;&gt; 4) + (imm &amp;0x0F) + 3) from the raw immediate,</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXCHANGE--outputs","title":"Outputs","text":"<p>n + m + 1, or ((imm &gt;&gt; 4) + (imm &amp;0x0F) + 3) from the raw immediate,</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXCHANGE--fork","title":"Fork","text":"<p>EOF_FORK</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXCHANGE--gas","title":"Gas","text":"<p>3</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EOFCREATE","title":"<code>EOFCREATE = Opcode(236, popped_stack_items=4, pushed_stack_items=1, data_portion_length=1, kwargs=['value', 'salt', 'input_offset', 'input_size'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>!!! Note: This opcode is under development</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EOFCREATE--eofcreateinitcontainer_index-value-salt-input_offset-input_size","title":"EOFCREATE[initcontainer_index] (value, salt, input_offset, input_size)","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EOFCREATE--description","title":"Description","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EOFCREATE--inputs","title":"Inputs","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EOFCREATE--outputs","title":"Outputs","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EOFCREATE--fork","title":"Fork","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EOFCREATE--gas","title":"Gas","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNCODE","title":"<code>RETURNCODE = Opcode(238, popped_stack_items=2, data_portion_length=1, terminating=True, kwargs=['auxdata_offset', 'auxdata_size'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>!!! Note: This opcode is under development</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNCODE--returncode","title":"RETURNCODE()","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNCODE--description","title":"Description","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNCODE--inputs","title":"Inputs","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNCODE--outputs","title":"Outputs","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNCODE--fork","title":"Fork","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNCODE--gas","title":"Gas","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CREATE","title":"<code>CREATE = Opcode(240, popped_stack_items=3, pushed_stack_items=1, kwargs=['value', 'offset', 'size'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CREATE--createvalue-offset-size-address","title":"CREATE(value, offset, size) = address","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CREATE--description","title":"Description","text":"<p>Create a new contract with the given code</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CREATE--inputs","title":"Inputs","text":"<ul> <li>value: value in wei to send to the new account</li> <li>offset: byte offset in the memory in bytes, the initialization code for the new account</li> <li>size: byte size to copy (size of the initialization code)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CREATE--outputs","title":"Outputs","text":"<ul> <li>address: the address of the deployed contract, 0 if the deployment failed</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CREATE--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CREATE--gas","title":"Gas","text":"<pre><code>minimum_word_size = (size + 31) / 32\ninit_code_cost = 2 * minimum_word_size\ncode_deposit_cost = 200 * deployed_code_size\n\nstatic_gas = 32000\ndynamic_gas = init_code_cost + memory_expansion_cost + deployment_code_execution_cost\n    + code_deposit_cost\n</code></pre> <p>Source: evm.codes/#F0</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALL","title":"<code>CALL = Opcode(241, popped_stack_items=7, pushed_stack_items=1, kwargs=['gas', 'address', 'value', 'args_offset', 'args_size', 'ret_offset', 'ret_size'], kwargs_defaults={'gas': GAS})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALL--callgas-address-value-args_offset-args_size-ret_offset-ret_size-success","title":"CALL(gas, address, value, args_offset, args_size, ret_offset, ret_size) = success","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALL--description","title":"Description","text":"<p>Message-call into an account</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALL--inputs","title":"Inputs","text":"<ul> <li>gas: amount of gas to send to the sub context to execute. The gas that is not used by the sub     context is returned to this one</li> <li>address: the account which context to execute</li> <li>value: value in wei to send to the account</li> <li>args_offset: byte offset in the memory in bytes, the calldata of the sub context</li> <li>args_size: byte size to copy (size of the calldata)</li> <li>ret_offset: byte offset in the memory in bytes, where to store the return data of the sub     context</li> <li>ret_size: byte size to copy (size of the return data)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALL--outputs","title":"Outputs","text":"<ul> <li>success: return 0 if the sub context reverted, 1 otherwise</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALL--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALL--gas","title":"Gas","text":"<pre><code>static_gas = 0\ndynamic_gas = memory_expansion_cost + code_execution_cost + address_access_cost\n    + positive_value_cost + value_to_empty_account_cost\n</code></pre> <p>Source: evm.codes/#F1</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLCODE","title":"<code>CALLCODE = Opcode(242, popped_stack_items=7, pushed_stack_items=1, kwargs=['gas', 'address', 'value', 'args_offset', 'args_size', 'ret_offset', 'ret_size'], kwargs_defaults={'gas': GAS})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLCODE--callcodegas-address-value-args_offset-args_size-ret_offset-ret_size-success","title":"CALLCODE(gas, address, value, args_offset, args_size, ret_offset, ret_size) = success","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLCODE--description","title":"Description","text":"<p>Message-call into this account with an alternative account's code. Executes code starting at the address to which the call is made.</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLCODE--inputs","title":"Inputs","text":"<ul> <li>gas: amount of gas to send to the sub context to execute. The gas that is not used by the sub     context is returned to this one</li> <li>address: the account which code to execute</li> <li>value: value in wei to send to the account</li> <li>args_offset: byte offset in the memory in bytes, the calldata of the sub context</li> <li>args_size: byte size to copy (size of the calldata)</li> <li>ret_offset: byte offset in the memory in bytes, where to store the return data of the sub     context</li> <li>ret_size: byte size to copy (size of the return data)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLCODE--outputs","title":"Outputs","text":"<ul> <li>success: return 0 if the sub context reverted, 1 otherwise</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLCODE--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CALLCODE--gas","title":"Gas","text":"<pre><code>static_gas = 0\ndynamic_gas = memory_expansion_cost + code_execution_cost + address_access_cost\n    + positive_value_cost\n</code></pre> <p>Source: evm.codes/#F2</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURN","title":"<code>RETURN = Opcode(243, popped_stack_items=2, kwargs=['offset', 'size'], terminating=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURN--returnoffset-size","title":"RETURN(offset, size)","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURN--description","title":"Description","text":"<p>Halt execution returning output data</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURN--inputs","title":"Inputs","text":"<ul> <li>offset: byte offset in the memory in bytes, to copy what will be the return data of this     context</li> <li>size: byte size to copy (size of the return data)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURN--outputs","title":"Outputs","text":"<ul> <li>None</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURN--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURN--gas","title":"Gas","text":"<ul> <li>static_gas = 0</li> <li>dynamic_gas = memory_expansion_cost</li> </ul> <p>Source: evm.codes/#F3</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DELEGATECALL","title":"<code>DELEGATECALL = Opcode(244, popped_stack_items=6, pushed_stack_items=1, kwargs=['gas', 'address', 'args_offset', 'args_size', 'ret_offset', 'ret_size'], kwargs_defaults={'gas': GAS})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DELEGATECALL--delegatecallgas-address-args_offset-args_size-ret_offset-ret_size-success","title":"DELEGATECALL(gas, address, args_offset, args_size, ret_offset, ret_size) = success","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DELEGATECALL--description","title":"Description","text":"<p>Message-call into this account with an alternative account's code, but persisting the current values for sender and value</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DELEGATECALL--inputs","title":"Inputs","text":"<ul> <li>gas: amount of gas to send to the sub context to execute. The gas that is not used by the sub     context is returned to this one</li> <li>address: the account which code to execute</li> <li>args_offset: byte offset in the memory in bytes, the calldata of the sub context</li> <li>args_size: byte size to copy (size of the calldata)</li> <li>ret_offset: byte offset in the memory in bytes, where to store the return data of the sub     context</li> <li>ret_size: byte size to copy (size of the return data)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DELEGATECALL--outputs","title":"Outputs","text":"<ul> <li>success: return 0 if the sub context reverted, 1 otherwise</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DELEGATECALL--fork","title":"Fork","text":"<p>Byzantium</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.DELEGATECALL--gas","title":"Gas","text":"<ul> <li>static_gas = 0</li> <li>dynamic_gas = memory_expansion_cost + code_execution_cost + address_access_cost</li> </ul> <p>Source: evm.codes/#F4</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CREATE2","title":"<code>CREATE2 = Opcode(245, popped_stack_items=4, pushed_stack_items=1, kwargs=['value', 'offset', 'size', 'salt'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CREATE2--create2value-offset-size-salt-address","title":"CREATE2(value, offset, size, salt) = address","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CREATE2--description","title":"Description","text":"<p>Creates a new contract</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CREATE2--inputs","title":"Inputs","text":"<ul> <li>value: value in wei to send to the new account</li> <li>offset: byte offset in the memory in bytes, the initialization code of the new account</li> <li>size: byte size to copy (size of the initialization code)</li> <li>salt: 32-byte value used to create the new account at a deterministic address</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CREATE2--outputs","title":"Outputs","text":"<ul> <li>address: the address of the deployed contract, 0 if the deployment failed</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CREATE2--fork","title":"Fork","text":"<p>Constantinople</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.CREATE2--gas","title":"Gas","text":"<pre><code>minimum_word_size = (size + 31) / 32\ninit_code_cost = 2 * minimum_word_size\nhash_cost = 6 * minimum_word_size\ncode_deposit_cost = 200 * deployed_code_size\n\nstatic_gas = 32000\ndynamic_gas = init_code_cost + hash_cost + memory_expansion_cost\n    + deployment_code_execution_cost + code_deposit_cost\n</code></pre> <p>Source: evm.codes/#F5</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCALL","title":"<code>EXTCALL = Opcode(248, popped_stack_items=4, pushed_stack_items=1, kwargs=['address', 'args_offset', 'args_size', 'value'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCALL--extcalladdress-args_offset-args_size-value-address","title":"EXTCALL(address, args_offset, args_size, value) = address","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCALL--description","title":"Description","text":"<p>Message-call into an account</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCALL--inputs","title":"Inputs","text":"<ul> <li>address: the account which context to execute</li> <li>args_offset: byte offset in the memory in bytes, the calldata of the sub context</li> <li>args_size: byte size to copy (size of the calldata)</li> <li>value: value in wei to send to the account</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCALL--outputs","title":"Outputs","text":"<ul> <li>success:<ul> <li><code>0</code> if the call was successful.</li> <li><code>1</code> if the call has reverted (also can be pushed earlier in a light failure scenario).</li> <li><code>2</code> if the call has failed.</li> </ul> </li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCALL--fork","title":"Fork","text":"<p>Prague</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTCALL--gas","title":"Gas","text":"<pre><code>static_gas = 0\ndynamic_gas = memory_expansion_cost + code_execution_cost + address_access_cost\n    + positive_value_cost + value_to_empty_account_cost\n</code></pre> <p>Source: EIP-7069</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTDELEGATECALL","title":"<code>EXTDELEGATECALL = Opcode(249, popped_stack_items=3, pushed_stack_items=1, kwargs=['address', 'args_offset', 'args_size'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTDELEGATECALL--extdelegatecalladdress-args_offset-args_size-address","title":"EXTDELEGATECALL(address, args_offset, args_size) = address","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTDELEGATECALL--description","title":"Description","text":"<p>Message-call into this account with an alternative account's code, but persisting the current values for sender and value</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTDELEGATECALL--inputs","title":"Inputs","text":"<ul> <li>address: the account which context to execute</li> <li>args_offset: byte offset in the memory in bytes, the calldata of the sub context</li> <li>args_size: byte size to copy (size of the calldata)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTDELEGATECALL--outputs","title":"Outputs","text":"<ul> <li>success:<ul> <li><code>0</code> if the call was successful.</li> <li><code>1</code> if the call has reverted (also can be pushed earlier in a light failure scenario).</li> <li><code>2</code> if the call has failed.</li> </ul> </li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTDELEGATECALL--fork","title":"Fork","text":"<p>Prague</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTDELEGATECALL--gas","title":"Gas","text":"<ul> <li>static_gas = 0</li> <li>dynamic_gas = memory_expansion_cost + code_execution_cost + address_access_cost</li> </ul> <p>Source: EIP-7069</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.STATICCALL","title":"<code>STATICCALL = Opcode(250, popped_stack_items=6, pushed_stack_items=1, kwargs=['gas', 'address', 'args_offset', 'args_size', 'ret_offset', 'ret_size'], kwargs_defaults={'gas': GAS})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.STATICCALL--staticcallgas-address-args_offset-args_size-ret_offset-ret_size-success","title":"STATICCALL(gas, address, args_offset, args_size, ret_offset, ret_size) = success","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.STATICCALL--description","title":"Description","text":"<p>Static message-call into an account</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.STATICCALL--inputs","title":"Inputs","text":"<ul> <li>gas: amount of gas to send to the sub context to execute. The gas that is not used by the sub     context is returned to this one</li> <li>address: the account which context to execute</li> <li>args_offset: byte offset in the memory in bytes, the calldata of the sub context</li> <li>args_size: byte size to copy (size of the calldata)</li> <li>ret_offset: byte offset in the memory in bytes, where to store the return data of the sub     context</li> <li>ret_size: byte size to copy (size of the return data)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.STATICCALL--outputs","title":"Outputs","text":"<ul> <li>success: return 0 if the sub context reverted, 1 otherwise</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.STATICCALL--fork","title":"Fork","text":"<p>Byzantium</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.STATICCALL--gas","title":"Gas","text":"<ul> <li>static_gas = 0</li> <li>dynamic_gas = memory_expansion_cost + code_execution_cost + address_access_cost</li> </ul> <p>Source: evm.codes/#FA</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTSTATICCALL","title":"<code>EXTSTATICCALL = Opcode(251, popped_stack_items=3, pushed_stack_items=1, kwargs=['address', 'args_offset', 'args_size'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTSTATICCALL--extstaticcalladdress-args_offset-args_size-address","title":"EXTSTATICCALL(address, args_offset, args_size) = address","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTSTATICCALL--description","title":"Description","text":"<p>Static message-call into an account</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTSTATICCALL--inputs","title":"Inputs","text":"<ul> <li>address: the account which context to execute</li> <li>args_offset: byte offset in the memory in bytes, the calldata of the sub context</li> <li>args_size: byte size to copy (size of the calldata)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTSTATICCALL--outputs","title":"Outputs","text":"<ul> <li>success:<ul> <li><code>0</code> if the call was successful.</li> <li><code>1</code> if the call has reverted (also can be pushed earlier in a light failure scenario).</li> <li><code>2</code> if the call has failed.</li> </ul> </li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTSTATICCALL--fork","title":"Fork","text":"<p>Prague</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.EXTSTATICCALL--gas","title":"Gas","text":"<ul> <li>static_gas = 0</li> <li>dynamic_gas = memory_expansion_cost + code_execution_cost + address_access_cost</li> </ul> <p>Source: EIP-7069</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNDATALOAD","title":"<code>RETURNDATALOAD = Opcode(247, popped_stack_items=1, pushed_stack_items=1, kwargs=['offset'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNDATALOAD--returndataloadoffset","title":"RETURNDATALOAD(offset)","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNDATALOAD--description","title":"Description","text":"<p>Copy 32 bytes from returndata at offset onto the stack</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNDATALOAD--inputs","title":"Inputs","text":"<ul> <li>offset: byte offset in the return data from the last executed sub context to copy</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNDATALOAD--fork","title":"Fork","text":"<p>EOF</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.RETURNDATALOAD--gas","title":"Gas","text":"<p>3</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.REVERT","title":"<code>REVERT = Opcode(253, popped_stack_items=2, kwargs=['offset', 'size'], terminating=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.REVERT--revertoffset-size","title":"REVERT(offset, size)","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.REVERT--description","title":"Description","text":"<p>Halt execution reverting state changes but returning data and remaining gas</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.REVERT--inputs","title":"Inputs","text":"<ul> <li>offset: byte offset in the memory in bytes. The return data of the calling context</li> <li>size: byte size to copy (size of the return data)</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.REVERT--fork","title":"Fork","text":"<p>Byzantium</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.REVERT--gas","title":"Gas","text":"<p>static_gas = 0 dynamic_gas = memory_expansion_cost</p> <p>Source: evm.codes/#FD</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.INVALID","title":"<code>INVALID = Opcode(254, terminating=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.INVALID--invalid","title":"INVALID()","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.INVALID--description","title":"Description","text":"<p>Designated invalid instruction</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.INVALID--inputs","title":"Inputs","text":"<p>None</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.INVALID--outputs","title":"Outputs","text":"<p>None</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.INVALID--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.INVALID--gas","title":"Gas","text":"<p>All the remaining gas in this context is consumed</p> <p>Source: evm.codes/#FE</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SELFDESTRUCT","title":"<code>SELFDESTRUCT = Opcode(255, popped_stack_items=1, kwargs=['address'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SELFDESTRUCT--selfdestructaddress","title":"SELFDESTRUCT(address)","text":""},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SELFDESTRUCT--description","title":"Description","text":"<p>Halt execution and register the account for later deletion</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SELFDESTRUCT--inputs","title":"Inputs","text":"<ul> <li>address: account to send the current balance to</li> </ul>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SELFDESTRUCT--fork","title":"Fork","text":"<p>Frontier</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.Opcodes.SELFDESTRUCT--gas","title":"Gas","text":"<p>5000</p> <p>Source: evm.codes/#FF</p>"},{"location":"library/ethereum_test_vm/#ethereum_test_vm.UndefinedOpcodes","title":"<code>UndefinedOpcodes</code>","text":"<p>               Bases: <code>Opcode</code>, <code>Enum</code></p> <p>Enum containing all unknown opcodes (88 at the moment).</p> Source code in <code>src/ethereum_test_vm/opcode.py</code> <pre><code>class UndefinedOpcodes(Opcode, Enum):\n    \"\"\"Enum containing all unknown opcodes (88 at the moment).\"\"\"\n\n    OPCODE_0C = Opcode(0x0C)\n    OPCODE_0D = Opcode(0x0D)\n    OPCODE_0E = Opcode(0x0E)\n    OPCODE_0F = Opcode(0x0F)\n    OPCODE_1E = Opcode(0x1E)\n    OPCODE_1F = Opcode(0x1F)\n    OPCODE_21 = Opcode(0x21)\n    OPCODE_22 = Opcode(0x22)\n    OPCODE_23 = Opcode(0x23)\n    OPCODE_24 = Opcode(0x24)\n    OPCODE_25 = Opcode(0x25)\n    OPCODE_26 = Opcode(0x26)\n    OPCODE_27 = Opcode(0x27)\n    OPCODE_28 = Opcode(0x28)\n    OPCODE_29 = Opcode(0x29)\n    OPCODE_2A = Opcode(0x2A)\n    OPCODE_2B = Opcode(0x2B)\n    OPCODE_2C = Opcode(0x2C)\n    OPCODE_2D = Opcode(0x2D)\n    OPCODE_2E = Opcode(0x2E)\n    OPCODE_2F = Opcode(0x2F)\n    OPCODE_4B = Opcode(0x4B)\n    OPCODE_4C = Opcode(0x4C)\n    OPCODE_4D = Opcode(0x4D)\n    OPCODE_4E = Opcode(0x4E)\n    OPCODE_4F = Opcode(0x4F)\n    OPCODE_A5 = Opcode(0xA5)\n    OPCODE_A6 = Opcode(0xA6)\n    OPCODE_A7 = Opcode(0xA7)\n    OPCODE_A8 = Opcode(0xA8)\n    OPCODE_A9 = Opcode(0xA9)\n    OPCODE_AA = Opcode(0xAA)\n    OPCODE_AB = Opcode(0xAB)\n    OPCODE_AC = Opcode(0xAC)\n    OPCODE_AD = Opcode(0xAD)\n    OPCODE_AE = Opcode(0xAE)\n    OPCODE_AF = Opcode(0xAF)\n    OPCODE_B0 = Opcode(0xB0)\n    OPCODE_B1 = Opcode(0xB1)\n    OPCODE_B2 = Opcode(0xB2)\n    OPCODE_B3 = Opcode(0xB3)\n    OPCODE_B4 = Opcode(0xB4)\n    OPCODE_B5 = Opcode(0xB5)\n    OPCODE_B6 = Opcode(0xB6)\n    OPCODE_B7 = Opcode(0xB7)\n    OPCODE_B8 = Opcode(0xB8)\n    OPCODE_B9 = Opcode(0xB9)\n    OPCODE_BA = Opcode(0xBA)\n    OPCODE_BB = Opcode(0xBB)\n    OPCODE_BC = Opcode(0xBC)\n    OPCODE_BD = Opcode(0xBD)\n    OPCODE_BE = Opcode(0xBE)\n    OPCODE_BF = Opcode(0xBF)\n    OPCODE_C0 = Opcode(0xC0)\n    OPCODE_C1 = Opcode(0xC1)\n    OPCODE_C2 = Opcode(0xC2)\n    OPCODE_C3 = Opcode(0xC3)\n    OPCODE_C4 = Opcode(0xC4)\n    OPCODE_C5 = Opcode(0xC5)\n    OPCODE_C6 = Opcode(0xC6)\n    OPCODE_C7 = Opcode(0xC7)\n    OPCODE_C8 = Opcode(0xC8)\n    OPCODE_C9 = Opcode(0xC9)\n    OPCODE_CA = Opcode(0xCA)\n    OPCODE_CB = Opcode(0xCB)\n    OPCODE_CC = Opcode(0xCC)\n    OPCODE_CD = Opcode(0xCD)\n    OPCODE_CE = Opcode(0xCE)\n    OPCODE_CF = Opcode(0xCF)\n    OPCODE_D4 = Opcode(0xD4)\n    OPCODE_D5 = Opcode(0xD5)\n    OPCODE_D6 = Opcode(0xD6)\n    OPCODE_D7 = Opcode(0xD7)\n    OPCODE_D8 = Opcode(0xD8)\n    OPCODE_D9 = Opcode(0xD9)\n    OPCODE_DA = Opcode(0xDA)\n    OPCODE_DB = Opcode(0xDB)\n    OPCODE_DC = Opcode(0xDC)\n    OPCODE_DD = Opcode(0xDD)\n    OPCODE_DE = Opcode(0xDE)\n    OPCODE_DF = Opcode(0xDF)\n    OPCODE_E9 = Opcode(0xE9)\n    OPCODE_EA = Opcode(0xEA)\n    OPCODE_EB = Opcode(0xEB)\n    OPCODE_ED = Opcode(0xED)\n    OPCODE_EF = Opcode(0xEF)\n    OPCODE_F6 = Opcode(0xF6)\n    OPCODE_FC = Opcode(0xFC)\n</code></pre>"},{"location":"library/cli/","title":"EEST CLI Tools","text":"<ul> <li><code>eest</code> - A CLI tool that helps with routine tasks in ethereum/execution-spec-tests.</li> <li><code>evm_bytes</code> - Convert the given EVM bytes from a binary file or a hex string to EEST's python opcodes.</li> </ul>"},{"location":"library/cli/eest/","title":"The <code>eest</code> CLI","text":""},{"location":"library/cli/eest/#eest","title":"eest","text":"<p><code>eest</code> is a CLI tool that helps with routine tasks.</p> <p>Usage:</p> <pre><code>eest [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre> <p>Subcommands</p> <ul> <li>clean: Remove all generated files and directories.</li> <li>make: Generate project files.</li> </ul>"},{"location":"library/cli/eest/#eest-clean","title":"eest clean","text":"<p>Remove all generated files and directories from the repository. If <code>--all</code> is specified, the virtual environment and .tox directory will also be removed.</p> <p>Args:     all_files (bool): Remove the virtual environment and .tox directory as well.</p> <pre><code>dry_run (bool): Simulate the cleanup without removing files.\n\nverbose (bool): Show verbose output.\n</code></pre> <p>Note: The virtual environment and .tox directory are not removed by default.</p> <p>Example: Cleaning all generated files and directories and show the deleted items.</p> <pre><code>uv run eest clean --all -v\n</code></pre> <p>Output:</p> <pre><code>\ud83d\uddd1\ufe0f  Deleted: .tox\n\ud83d\uddd1\ufe0f  Deleted: .venv\n\ud83d\uddd1\ufe0f  Deleted: src/cli/et/__pycache__\n\ud83d\uddd1\ufe0f  Deleted: src/cli/et/commands/__pycache__\n\ud83d\uddd1\ufe0f  Deleted: src/cli/et/make/__pycache__\n\ud83d\uddd1\ufe0f  Deleted: src/cli/et/make/commands/__pycache__\n...\n\ud83e\uddf9 Cleanup complete!\n</code></pre> <p>Usage:</p> <pre><code>eest clean [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --all          Remove the virtual environment and .tox directory as well.\n  --dry-run      Simulate the cleanup without removing files.\n  -v, --verbose  Show verbose output.\n  --help         Show this message and exit.\n</code></pre>"},{"location":"library/cli/eest/#eest-make","title":"eest make","text":"<p>Generate project files.</p> <p>Usage:</p> <pre><code>eest make [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre> <p>Subcommands</p> <ul> <li>env: Generate the default environment file (env.yaml).</li> <li>test: Generate a new test file for an EIP.</li> </ul>"},{"location":"library/cli/eest/#eest-make-env","title":"eest make env","text":"<p>CLI command to generate the default environment file (env.yaml).</p> <p>If an <code>env.yaml</code> already exists, this command will NOT override it. In that case, it is recommended to manually make changes.</p> <p>Easter egg: Shows a random quote after creating the environment file.</p> <p>Example:     uv run eest make env</p> <p>Output:</p> <pre><code>\ud83c\udf89 Success! Environment file created at: &lt;path&gt;/env.yaml\n\n\ud83d\ude80 Well begun is half done. - Aristotle\n</code></pre> <p>Usage:</p> <pre><code>eest make env [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"library/cli/eest/#eest-make-test","title":"eest make test","text":"<p>Generate a new test file for an EIP.</p> <p>This function guides the user through a series of prompts to generate a test file for Ethereum execution specifications. The user is prompted to select the type of test, the fork to use, and to provide the EIP number and name. Based on the inputs, a test file is created in the appropriate directory with a rendered template.</p> <p>Example:     uv run eest make test</p> <p>Usage:</p> <pre><code>eest make test [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"library/cli/evm_bytes/","title":"The <code>evm_bytes</code> CLI","text":""},{"location":"library/cli/evm_bytes/#evm_bytes","title":"evm_bytes","text":"<p>Convert EVM bytecode to EEST's Python Opcodes or an assembly string.</p> <p>The input can be either a hex string or a binary file containing EVM bytes.</p> <p>Usage:</p> <pre><code>evm_bytes [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre> <p>Subcommands</p> <ul> <li>binary-file: Convert a binary file to Python Opcodes or assembly.</li> <li>hex-string: Convert a hex string to Python Opcodes or assembly.</li> </ul>"},{"location":"library/cli/evm_bytes/#evm_bytes-binary-file","title":"evm_bytes binary-file","text":"<p>Convert the BINARY_FILE containing EVM bytes to Python Opcodes or assembly.</p> <p>BINARY_FILE is a binary file containing EVM bytes, use <code>-</code> to read from stdin.</p> <p>Returns:     (str): The processed EVM opcodes in Python or assembly format.</p> <p>Example: Convert the Withdrawal Request contract to assembly     uv run evm_bytes binary-file ./src/ethereum_test_forks/forks/contracts/withdrawal_request.bin --assembly</p> <p>Output:     caller     push20 0xfffffffffffffffffffffffffffffffffffffffe     eq     push1 0x90     jumpi     ...</p> <p>Usage:</p> <pre><code>evm_bytes binary-file [OPTIONS] BINARY_FILE\n</code></pre> <p>Options:</p> <pre><code>  -a, --assembly  Output the code as assembly instead of Python Opcodes.\n  --help          Show this message and exit.\n</code></pre>"},{"location":"library/cli/evm_bytes/#evm_bytes-hex-string","title":"evm_bytes hex-string","text":"<p>Convert the HEX_STRING representing EVM bytes to EEST Python Opcodes.</p> <p>HEX_STRING is a string containing EVM bytecode.</p> <p>Returns:     (str): The processed EVM opcodes in Python or assembly format.</p> <p>Example 1: Convert a hex string to EEST Python <code>Opcodes</code>     uv run evm_bytes hex-string 604260005260206000F3</p> <p>Output 1:     Op.PUSH1[0x42] + Op.PUSH1[0x0] + Op.MSTORE + Op.PUSH1[0x20] + Op.PUSH1[0x0] + Op.RETURN</p> <p>Example 2: Convert a hex string to assembly     uv run evm_bytes hex-string --assembly 604260005260206000F3</p> <p>Output 2:     push1 0x42     push1 0x00     mstore     push1 0x20     push1 0x00     return</p> <p>Usage:</p> <pre><code>evm_bytes hex-string [OPTIONS] HEX_STRING\n</code></pre> <p>Options:</p> <pre><code>  -a, --assembly  Output the code as assembly instead of Python Opcodes.\n  --help          Show this message and exit.\n</code></pre>"},{"location":"library/pytest_plugins/","title":"Pytest Framework and Customizations","text":"<p>Package containing pytest plugins related to test filling.</p> <ul> <li>Filler Plugin.</li> <li>Forks Plugin.</li> <li>Spec Version Checker Plugin.</li> </ul>"},{"location":"library/pytest_plugins/filler/","title":"Filler Plugin","text":"<p>A pytest plugin that provides fixtures that fill tests and generate fixtures.</p> <p>Top-level pytest configuration file providing: - Command-line options, - Test-fixtures that can be used by all test cases, and that modifies pytest hooks in order to fill test specs for all tests and writes the generated fixtures to file.</p> <p>Pre-alloc specifically conditioned for test filling.</p>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.default_output_directory","title":"<code>default_output_directory()</code>","text":"<p>Directory (default) to store the generated test fixtures. Defined as a function to allow for easier testing.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>def default_output_directory() -&gt; str:\n    \"\"\"\n    Directory (default) to store the generated test fixtures. Defined as a\n    function to allow for easier testing.\n    \"\"\"\n    return \"./fixtures\"\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.default_html_report_file_path","title":"<code>default_html_report_file_path()</code>","text":"<p>File path (default) to store the generated HTML test report. Defined as a function to allow for easier testing.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>def default_html_report_file_path() -&gt; str:\n    \"\"\"\n    File path (default) to store the generated HTML test report. Defined as a\n    function to allow for easier testing.\n    \"\"\"\n    return \".meta/report_fill.html\"\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.strip_output_tarball_suffix","title":"<code>strip_output_tarball_suffix(output)</code>","text":"<p>Strip the '.tar.gz' suffix from the output path.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>def strip_output_tarball_suffix(output: Path) -&gt; Path:\n    \"\"\"Strip the '.tar.gz' suffix from the output path.\"\"\"\n    if str(output).endswith(\".tar.gz\"):\n        return output.with_suffix(\"\").with_suffix(\"\")\n    return output\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.is_output_stdout","title":"<code>is_output_stdout(output)</code>","text":"<p>Return True if the fixture output is configured to be stdout.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>def is_output_stdout(output: Path) -&gt; bool:\n    \"\"\"Return True if the fixture output is configured to be stdout.\"\"\"\n    return strip_output_tarball_suffix(output).name == \"stdout\"\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.pytest_addoption","title":"<code>pytest_addoption(parser)</code>","text":"<p>Add command-line options to pytest.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>def pytest_addoption(parser: pytest.Parser):\n    \"\"\"Add command-line options to pytest.\"\"\"\n    evm_group = parser.getgroup(\"evm\", \"Arguments defining evm executable behavior\")\n    evm_group.addoption(\n        \"--evm-bin\",\n        action=\"store\",\n        dest=\"evm_bin\",\n        type=Path,\n        default=\"ethereum-spec-evm-resolver\",\n        help=(\n            \"Path to an evm executable (or name of an executable in the PATH) that provides `t8n`.\"\n            \" Default: `ethereum-spec-evm-resolver`.\"\n        ),\n    )\n    evm_group.addoption(\n        \"--traces\",\n        action=\"store_true\",\n        dest=\"evm_collect_traces\",\n        default=None,\n        help=\"Collect traces of the execution information from the transition tool.\",\n    )\n    evm_group.addoption(\n        \"--verify-fixtures\",\n        action=\"store_true\",\n        dest=\"verify_fixtures\",\n        default=False,\n        help=(\n            \"Verify generated fixture JSON files using geth's evm blocktest command. \"\n            \"By default, the same evm binary as for the t8n tool is used. A different (geth) evm \"\n            \"binary may be specified via --verify-fixtures-bin, this must be specified if filling \"\n            \"with a non-geth t8n tool that does not support blocktest.\"\n        ),\n    )\n    evm_group.addoption(\n        \"--verify-fixtures-bin\",\n        action=\"store\",\n        dest=\"verify_fixtures_bin\",\n        type=Path,\n        default=None,\n        help=(\n            \"Path to an evm executable that provides the `blocktest` command. \"\n            \"Default: The first (geth) 'evm' entry in PATH.\"\n        ),\n    )\n\n    test_group = parser.getgroup(\"tests\", \"Arguments defining filler location and output\")\n    test_group.addoption(\n        \"--filler-path\",\n        action=\"store\",\n        dest=\"filler_path\",\n        default=\"./tests/\",\n        type=Path,\n        help=\"Path to filler directives\",\n    )\n    test_group.addoption(\n        \"--output\",\n        action=\"store\",\n        dest=\"output\",\n        type=Path,\n        default=Path(default_output_directory()),\n        help=(\n            \"Directory path to store the generated test fixtures. \"\n            \"If the specified path ends in '.tar.gz', then the specified tarball is additionally \"\n            \"created (the fixtures are still written to the specified path without the '.tar.gz' \"\n            f\"suffix). Can be deleted. Default: '{default_output_directory()}'.\"\n        ),\n    )\n    test_group.addoption(\n        \"--flat-output\",\n        action=\"store_true\",\n        dest=\"flat_output\",\n        default=False,\n        help=\"Output each test case in the directory without the folder structure.\",\n    )\n    test_group.addoption(\n        \"--single-fixture-per-file\",\n        action=\"store_true\",\n        dest=\"single_fixture_per_file\",\n        default=False,\n        help=(\n            \"Don't group fixtures in JSON files by test function; write each fixture to its own \"\n            \"file. This can be used to increase the granularity of --verify-fixtures.\"\n        ),\n    )\n    test_group.addoption(\n        \"--no-html\",\n        action=\"store_true\",\n        dest=\"disable_html\",\n        default=False,\n        help=(\n            \"Don't generate an HTML test report (in the output directory). \"\n            \"The --html flag can be used to specify a different path.\"\n        ),\n    )\n    test_group.addoption(\n        \"--build-name\",\n        action=\"store\",\n        dest=\"build_name\",\n        default=None,\n        type=str,\n        help=\"Specify a build name for the fixtures.ini file, e.g., 'stable'.\",\n    )\n    test_group.addoption(\n        \"--skip-index\",\n        action=\"store_false\",\n        dest=\"generate_index\",\n        default=True,\n        help=\"Skip generating an index file for all produced fixtures.\",\n    )\n\n    debug_group = parser.getgroup(\"debug\", \"Arguments defining debug behavior\")\n    debug_group.addoption(\n        \"--evm-dump-dir\",\n        \"--t8n-dump-dir\",\n        action=\"store\",\n        dest=\"base_dump_dir\",\n        default=AppConfig().DEFAULT_EVM_LOGS_DIR,\n        help=(\n            \"Path to dump the transition tool debug output. \"\n            f\"(Default: {AppConfig().DEFAULT_EVM_LOGS_DIR})\"\n        ),\n    )\n    debug_group.addoption(\n        \"--skip-evm-dump\",\n        \"--skip-t8n-dump\",\n        action=\"store_true\",\n        dest=\"skip_dump_dir\",\n        default=False,\n        help=(\"Skip dumping the the transition tool debug output.\"),\n    )\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.pytest_configure","title":"<code>pytest_configure(config)</code>","text":"<p>Pytest hook called after command line options have been parsed and before test collection begins.</p> <p>Couple of notes: 1. Register the plugin's custom markers and process command-line options.</p> <pre><code>Custom marker registration:\nhttps://docs.pytest.org/en/7.1.x/how-to/writing_plugins.html#registering-custom-markers\n</code></pre> <ol> <li><code>@pytest.hookimpl(tryfirst=True)</code> is applied to ensure that this hook is     called before the pytest-html plugin's pytest_configure to ensure that     it uses the modified <code>htmlpath</code> option.</li> </ol> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>@pytest.hookimpl(tryfirst=True)\ndef pytest_configure(config):\n    \"\"\"\n    Pytest hook called after command line options have been parsed and before\n    test collection begins.\n\n    Couple of notes:\n    1. Register the plugin's custom markers and process command-line options.\n\n        Custom marker registration:\n        https://docs.pytest.org/en/7.1.x/how-to/writing_plugins.html#registering-custom-markers\n\n    2. `@pytest.hookimpl(tryfirst=True)` is applied to ensure that this hook is\n        called before the pytest-html plugin's pytest_configure to ensure that\n        it uses the modified `htmlpath` option.\n    \"\"\"\n    if config.option.collectonly:\n        return\n    if not config.getoption(\"disable_html\") and config.getoption(\"htmlpath\") is None:\n        # generate an html report by default, unless explicitly disabled\n        config.option.htmlpath = (\n            strip_output_tarball_suffix(config.getoption(\"output\"))\n            / default_html_report_file_path()\n        )\n    # Instantiate the transition tool here to check that the binary path/trace option is valid.\n    # This ensures we only raise an error once, if appropriate, instead of for every test.\n    t8n = TransitionTool.from_binary_path(\n        binary_path=config.getoption(\"evm_bin\"), trace=config.getoption(\"evm_collect_traces\")\n    )\n    if (\n        isinstance(config.getoption(\"numprocesses\"), int)\n        and config.getoption(\"numprocesses\") &gt; 0\n        and \"Besu\" in str(t8n.detect_binary_pattern)\n    ):\n        pytest.exit(\n            \"The Besu t8n tool does not work well with the xdist plugin; use -n=0.\",\n            returncode=pytest.ExitCode.USAGE_ERROR,\n        )\n\n    if \"Tools\" not in config.stash[metadata_key]:\n        config.stash[metadata_key][\"Tools\"] = {\n            \"t8n\": t8n.version(),\n        }\n    else:\n        config.stash[metadata_key][\"Tools\"][\"t8n\"] = t8n.version()\n\n    args = [\"fill\"] + [str(arg) for arg in config.invocation_params.args]\n    for i in range(len(args)):\n        if \" \" in args[i]:\n            args[i] = f'\"{args[i]}\"'\n    command_line_args = \" \".join(args)\n    config.stash[metadata_key][\"Command-line args\"] = f\"&lt;code&gt;{command_line_args}&lt;/code&gt;\"\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.pytest_report_header","title":"<code>pytest_report_header(config)</code>","text":"<p>Add lines to pytest's console output header.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>@pytest.hookimpl(trylast=True)\ndef pytest_report_header(config: pytest.Config):\n    \"\"\"Add lines to pytest's console output header.\"\"\"\n    if config.option.collectonly:\n        return\n    t8n_version = config.stash[metadata_key][\"Tools\"][\"t8n\"]\n    return [(f\"{t8n_version}\")]\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.pytest_report_teststatus","title":"<code>pytest_report_teststatus(report, config)</code>","text":"<p>Modify test results in pytest's terminal output.</p> <p>We use this:</p> <ol> <li>To disable test session progress report if we're writing the JSON     fixtures to stdout to be read by a consume command on stdin. I.e.,     don't write this type of output to the console: <pre><code>...x...\n</code></pre></li> </ol> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>@pytest.hookimpl(tryfirst=True)\ndef pytest_report_teststatus(report, config: pytest.Config):\n    \"\"\"\n    Modify test results in pytest's terminal output.\n\n    We use this:\n\n    1. To disable test session progress report if we're writing the JSON\n        fixtures to stdout to be read by a consume command on stdin. I.e.,\n        don't write this type of output to the console:\n    ```text\n    ...x...\n    ```\n    \"\"\"\n    if is_output_stdout(config.getoption(\"output\")):\n        return report.outcome, \"\", report.outcome.upper()\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.pytest_terminal_summary","title":"<code>pytest_terminal_summary(terminalreporter, exitstatus, config)</code>","text":"<p>Modify pytest's terminal summary to emphasize that no tests were ran.</p> <p>Emphasize that fixtures have only been filled; they must now be executed to actually run the tests.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>@pytest.hookimpl(hookwrapper=True, trylast=True)\ndef pytest_terminal_summary(\n    terminalreporter: TerminalReporter, exitstatus: int, config: pytest.Config\n):\n    \"\"\"\n    Modify pytest's terminal summary to emphasize that no tests were ran.\n\n    Emphasize that fixtures have only been filled; they must now be executed to\n    actually run the tests.\n    \"\"\"\n    yield\n    if is_output_stdout(config.getoption(\"output\")):\n        return\n    stats = terminalreporter.stats\n    if \"passed\" in stats and stats[\"passed\"]:\n        # append / to indicate this is a directory\n        output_dir = str(strip_output_tarball_suffix(config.getoption(\"output\"))) + \"/\"\n        terminalreporter.write_sep(\n            \"=\",\n            (\n                f' No tests executed - the test fixtures in \"{output_dir}\" may now be executed '\n                \"against a client \"\n            ),\n            bold=True,\n            yellow=True,\n        )\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.pytest_metadata","title":"<code>pytest_metadata(metadata)</code>","text":"<p>Add or remove metadata to/from the pytest report.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>def pytest_metadata(metadata):\n    \"\"\"Add or remove metadata to/from the pytest report.\"\"\"\n    metadata.pop(\"JAVA_HOME\", None)\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.pytest_html_results_table_header","title":"<code>pytest_html_results_table_header(cells)</code>","text":"<p>Customize the table headers of the HTML report table.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>def pytest_html_results_table_header(cells):\n    \"\"\"Customize the table headers of the HTML report table.\"\"\"\n    cells.insert(3, '&lt;th class=\"sortable\" data-column-type=\"fixturePath\"&gt;JSON Fixture File&lt;/th&gt;')\n    cells.insert(4, '&lt;th class=\"sortable\" data-column-type=\"evmDumpDir\"&gt;EVM Dump Dir&lt;/th&gt;')\n    del cells[-1]  # Remove the \"Links\" column\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.pytest_html_results_table_row","title":"<code>pytest_html_results_table_row(report, cells)</code>","text":"<p>Customize the table rows of the HTML report table.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>def pytest_html_results_table_row(report, cells):\n    \"\"\"Customize the table rows of the HTML report table.\"\"\"\n    if hasattr(report, \"user_properties\"):\n        user_props = dict(report.user_properties)\n        if (\n            report.passed\n            and \"fixture_path_absolute\" in user_props\n            and \"fixture_path_relative\" in user_props\n        ):\n            fixture_path_absolute = user_props[\"fixture_path_absolute\"]\n            fixture_path_relative = user_props[\"fixture_path_relative\"]\n            fixture_path_link = (\n                f'&lt;a href=\"{fixture_path_absolute}\" target=\"_blank\"&gt;{fixture_path_relative}&lt;/a&gt;'\n            )\n            cells.insert(3, f\"&lt;td&gt;{fixture_path_link}&lt;/td&gt;\")\n        elif report.failed:\n            cells.insert(3, \"&lt;td&gt;Fixture unavailable&lt;/td&gt;\")\n        if \"evm_dump_dir\" in user_props:\n            if user_props[\"evm_dump_dir\"] is None:\n                cells.insert(\n                    4, \"&lt;td&gt;For t8n debug info use &lt;code&gt;--evm-dump-dir=path --traces&lt;/code&gt;&lt;/td&gt;\"\n                )\n            else:\n                evm_dump_dir = user_props.get(\"evm_dump_dir\")\n                if evm_dump_dir == \"N/A\":\n                    evm_dump_entry = \"N/A\"\n                else:\n                    evm_dump_entry = f'&lt;a href=\"{evm_dump_dir}\" target=\"_blank\"&gt;{evm_dump_dir}&lt;/a&gt;'\n                cells.insert(4, f\"&lt;td&gt;{evm_dump_entry}&lt;/td&gt;\")\n    del cells[-1]  # Remove the \"Links\" column\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.pytest_runtest_makereport","title":"<code>pytest_runtest_makereport(item, call)</code>","text":"<p>Make each test's fixture json path available to the test report via user_properties.</p> <p>This hook is called when each test is run and a report is being made.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>@pytest.hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item, call):\n    \"\"\"\n    Make each test's fixture json path available to the test report via\n    user_properties.\n\n    This hook is called when each test is run and a report is being made.\n    \"\"\"\n    outcome = yield\n    report = outcome.get_result()\n\n    if call.when == \"call\":\n        if hasattr(item.config, \"fixture_path_absolute\") and hasattr(\n            item.config, \"fixture_path_relative\"\n        ):\n            report.user_properties.append(\n                (\"fixture_path_absolute\", item.config.fixture_path_absolute)\n            )\n            report.user_properties.append(\n                (\"fixture_path_relative\", item.config.fixture_path_relative)\n            )\n        if hasattr(item.config, \"evm_dump_dir\") and hasattr(item.config, \"fixture_format\"):\n            if item.config.fixture_format in [\n                \"state_test\",\n                \"blockchain_test\",\n                \"blockchain_test_engine\",\n            ]:\n                report.user_properties.append((\"evm_dump_dir\", item.config.evm_dump_dir))\n            else:\n                report.user_properties.append((\"evm_dump_dir\", \"N/A\"))  # not yet for EOF\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.pytest_html_report_title","title":"<code>pytest_html_report_title(report)</code>","text":"<p>Set the HTML report title (pytest-html plugin).</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>def pytest_html_report_title(report):\n    \"\"\"Set the HTML report title (pytest-html plugin).\"\"\"\n    report.title = \"Fill Test Report\"\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.evm_bin","title":"<code>evm_bin(request)</code>","text":"<p>Return configured evm tool binary path used to run t8n.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>@pytest.fixture(autouse=True, scope=\"session\")\ndef evm_bin(request: pytest.FixtureRequest) -&gt; Path:\n    \"\"\"Return configured evm tool binary path used to run t8n.\"\"\"\n    return request.config.getoption(\"evm_bin\")\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.verify_fixtures_bin","title":"<code>verify_fixtures_bin(request)</code>","text":"<p>Return configured evm tool binary path used to run statetest or blocktest.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>@pytest.fixture(autouse=True, scope=\"session\")\ndef verify_fixtures_bin(request: pytest.FixtureRequest) -&gt; Path | None:\n    \"\"\"\n    Return configured evm tool binary path used to run statetest or\n    blocktest.\n    \"\"\"\n    return request.config.getoption(\"verify_fixtures_bin\")\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.t8n","title":"<code>t8n(request, evm_bin)</code>","text":"<p>Return configured transition tool.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>@pytest.fixture(autouse=True, scope=\"session\")\ndef t8n(request: pytest.FixtureRequest, evm_bin: Path) -&gt; Generator[TransitionTool, None, None]:\n    \"\"\"Return configured transition tool.\"\"\"\n    t8n = TransitionTool.from_binary_path(\n        binary_path=evm_bin, trace=request.config.getoption(\"evm_collect_traces\")\n    )\n    yield t8n\n    t8n.shutdown()\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.do_fixture_verification","title":"<code>do_fixture_verification(request, verify_fixtures_bin)</code>","text":"<p>Return True if evm statetest or evm blocktest should be ran on the generated fixture JSON files.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef do_fixture_verification(\n    request: pytest.FixtureRequest, verify_fixtures_bin: Path | None\n) -&gt; bool:\n    \"\"\"\n    Return True if evm statetest or evm blocktest should be ran on the\n    generated fixture JSON files.\n    \"\"\"\n    do_fixture_verification = False\n    if verify_fixtures_bin:\n        do_fixture_verification = True\n    if request.config.getoption(\"verify_fixtures\"):\n        do_fixture_verification = True\n    return do_fixture_verification\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.evm_fixture_verification","title":"<code>evm_fixture_verification(request, do_fixture_verification, evm_bin, verify_fixtures_bin)</code>","text":"<p>Return configured evm binary for executing statetest and blocktest commands used to verify generated JSON fixtures.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>@pytest.fixture(autouse=True, scope=\"session\")\ndef evm_fixture_verification(\n    request: pytest.FixtureRequest,\n    do_fixture_verification: bool,\n    evm_bin: Path,\n    verify_fixtures_bin: Path | None,\n) -&gt; Generator[FixtureConsumer | None, None, None]:\n    \"\"\"\n    Return configured evm binary for executing statetest and blocktest\n    commands used to verify generated JSON fixtures.\n    \"\"\"\n    if not do_fixture_verification:\n        yield None\n        return\n    reused_evm_bin = False\n    if not verify_fixtures_bin and evm_bin:\n        verify_fixtures_bin = evm_bin\n        reused_evm_bin = True\n    if not verify_fixtures_bin:\n        return\n    try:\n        evm_fixture_verification = FixtureConsumerTool.from_binary_path(\n            binary_path=Path(verify_fixtures_bin),\n            trace=request.config.getoption(\"evm_collect_traces\"),\n        )\n    except Exception:\n        if reused_evm_bin:\n            pytest.exit(\n                \"The binary specified in --evm-bin could not be recognized as a known \"\n                \"FixtureConsumerTool. Either remove --verify-fixtures or set \"\n                \"--verify-fixtures-bin to a known fixture consumer binary.\",\n                returncode=pytest.ExitCode.USAGE_ERROR,\n            )\n        else:\n            pytest.exit(\n                \"Specified binary in --verify-fixtures-bin could not be recognized as a known \"\n                \"FixtureConsumerTool. Please see `GethFixtureConsumer` for an example \"\n                \"of how a new fixture consumer can be defined.\",\n                returncode=pytest.ExitCode.USAGE_ERROR,\n            )\n    yield evm_fixture_verification\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.base_dump_dir","title":"<code>base_dump_dir(request)</code>","text":"<p>Path to base directory to dump the evm debug output.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef base_dump_dir(request: pytest.FixtureRequest) -&gt; Path | None:\n    \"\"\"Path to base directory to dump the evm debug output.\"\"\"\n    if request.config.getoption(\"skip_dump_dir\"):\n        return None\n    base_dump_dir_str = request.config.getoption(\"base_dump_dir\")\n    if base_dump_dir_str:\n        return Path(base_dump_dir_str)\n    return None\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.is_output_tarball","title":"<code>is_output_tarball(request)</code>","text":"<p>Return True if the output directory is a tarball.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef is_output_tarball(request: pytest.FixtureRequest) -&gt; bool:\n    \"\"\"Return True if the output directory is a tarball.\"\"\"\n    output: Path = request.config.getoption(\"output\")\n    if output.suffix == \".gz\" and output.with_suffix(\"\").suffix == \".tar\":\n        return True\n    return False\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.output_dir","title":"<code>output_dir(request, is_output_tarball)</code>","text":"<p>Return directory to store the generated test fixtures.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef output_dir(request: pytest.FixtureRequest, is_output_tarball: bool) -&gt; Path:\n    \"\"\"Return directory to store the generated test fixtures.\"\"\"\n    output = request.config.getoption(\"output\")\n    if is_output_tarball:\n        return strip_output_tarball_suffix(output)\n    return output\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.output_metadata_dir","title":"<code>output_metadata_dir(output_dir)</code>","text":"<p>Return metadata directory to store fixture meta files.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef output_metadata_dir(output_dir: Path) -&gt; Path:\n    \"\"\"Return metadata directory to store fixture meta files.\"\"\"\n    if is_output_stdout(output_dir):\n        return output_dir\n    return output_dir / \".meta\"\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.create_properties_file","title":"<code>create_properties_file(request, output_dir, output_metadata_dir)</code>","text":"<p>Create ini file with fixture build properties in the fixture output directory.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>@pytest.fixture(scope=\"session\", autouse=True)\ndef create_properties_file(\n    request: pytest.FixtureRequest, output_dir: Path, output_metadata_dir: Path\n) -&gt; None:\n    \"\"\"\n    Create ini file with fixture build properties in the fixture output\n    directory.\n    \"\"\"\n    if is_output_stdout(request.config.getoption(\"output\")):\n        return\n    if not output_dir.exists():\n        output_dir.mkdir(parents=True)\n    if not output_metadata_dir.exists():\n        output_metadata_dir.mkdir(parents=True)\n\n    fixture_properties = {\n        \"timestamp\": datetime.datetime.now().isoformat(),\n    }\n    if build_name := request.config.getoption(\"build_name\"):\n        fixture_properties[\"build\"] = build_name\n    if github_ref := os.getenv(\"GITHUB_REF\"):\n        fixture_properties[\"ref\"] = github_ref\n    if github_sha := os.getenv(\"GITHUB_SHA\"):\n        fixture_properties[\"commit\"] = github_sha\n    command_line_args = request.config.stash[metadata_key][\"Command-line args\"]\n    command_line_args = command_line_args.replace(\"&lt;code&gt;\", \"\").replace(\"&lt;/code&gt;\", \"\")\n    fixture_properties[\"command_line_args\"] = command_line_args\n\n    config = configparser.ConfigParser(interpolation=None)\n    config[\"fixtures\"] = fixture_properties\n    environment_properties = {}\n    for key, val in request.config.stash[metadata_key].items():\n        if key.lower() == \"command-line args\":\n            continue\n        if key.lower() in [\"ci\", \"python\", \"platform\"]:\n            environment_properties[key] = val\n        elif isinstance(val, dict):\n            config[key.lower()] = val\n        else:\n            warnings.warn(\n                f\"Fixtures ini file: Skipping metadata key {key} with value {val}.\", stacklevel=2\n            )\n    config[\"environment\"] = environment_properties\n\n    ini_filename = output_metadata_dir / \"fixtures.ini\"\n    with open(ini_filename, \"w\") as f:\n        f.write(\"; This file describes fixture build properties\\n\\n\")\n        config.write(f)\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.dump_dir_parameter_level","title":"<code>dump_dir_parameter_level(request, base_dump_dir, filler_path)</code>","text":"<p>Directory to dump evm transition tool debug output on a test parameter level.</p> <p>Example with --evm-dump-dir=/tmp/evm: -&gt; /tmp/evm/shanghai__eip3855_push0__test_push0__test_push0_key_sstore/fork_shanghai/</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>@pytest.fixture(scope=\"function\")\ndef dump_dir_parameter_level(\n    request: pytest.FixtureRequest, base_dump_dir: Path | None, filler_path: Path\n) -&gt; Path | None:\n    \"\"\"\n    Directory to dump evm transition tool debug output on a test parameter\n    level.\n\n    Example with --evm-dump-dir=/tmp/evm:\n    -&gt; /tmp/evm/shanghai__eip3855_push0__test_push0__test_push0_key_sstore/fork_shanghai/\n    \"\"\"\n    evm_dump_dir = node_to_test_info(request.node).get_dump_dir_path(\n        base_dump_dir,\n        filler_path,\n        level=\"test_parameter\",\n    )\n    # NOTE: Use str for compatibility with pytest-dist\n    if evm_dump_dir:\n        request.node.config.evm_dump_dir = str(evm_dump_dir)\n    else:\n        request.node.config.evm_dump_dir = None\n    return evm_dump_dir\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.get_fixture_collection_scope","title":"<code>get_fixture_collection_scope(fixture_name, config)</code>","text":"<p>Return the appropriate scope to write fixture JSON files.</p> <p>See: https://docs.pytest.org/en/stable/how-to/fixtures.html#dynamic-scope</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>def get_fixture_collection_scope(fixture_name, config):\n    \"\"\"\n    Return the appropriate scope to write fixture JSON files.\n\n    See: https://docs.pytest.org/en/stable/how-to/fixtures.html#dynamic-scope\n    \"\"\"\n    if is_output_stdout(config.getoption(\"output\")):\n        return \"session\"\n    if config.getoption(\"single_fixture_per_file\"):\n        return \"function\"\n    return \"module\"\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.fixture_collector","title":"<code>fixture_collector(request, do_fixture_verification, evm_fixture_verification, filler_path, base_dump_dir, output_dir)</code>","text":"<p>Return configured fixture collector instance used for all tests in one test module.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>@pytest.fixture(scope=get_fixture_collection_scope)\ndef fixture_collector(\n    request: pytest.FixtureRequest,\n    do_fixture_verification: bool,\n    evm_fixture_verification: FixtureConsumer,\n    filler_path: Path,\n    base_dump_dir: Path | None,\n    output_dir: Path,\n) -&gt; Generator[FixtureCollector, None, None]:\n    \"\"\"\n    Return configured fixture collector instance used for all tests\n    in one test module.\n    \"\"\"\n    fixture_collector = FixtureCollector(\n        output_dir=output_dir,\n        flat_output=request.config.getoption(\"flat_output\"),\n        single_fixture_per_file=request.config.getoption(\"single_fixture_per_file\"),\n        filler_path=filler_path,\n        base_dump_dir=base_dump_dir,\n    )\n    yield fixture_collector\n    fixture_collector.dump_fixtures()\n    if do_fixture_verification:\n        fixture_collector.verify_fixture_files(evm_fixture_verification)\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.filler_path","title":"<code>filler_path(request)</code>","text":"<p>Return directory containing the tests to execute.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>@pytest.fixture(autouse=True, scope=\"session\")\ndef filler_path(request: pytest.FixtureRequest) -&gt; Path:\n    \"\"\"Return directory containing the tests to execute.\"\"\"\n    return request.config.getoption(\"filler_path\")\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.node_to_test_info","title":"<code>node_to_test_info(node)</code>","text":"<p>Return test info of the current node item.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>def node_to_test_info(node: pytest.Item) -&gt; TestInfo:\n    \"\"\"Return test info of the current node item.\"\"\"\n    return TestInfo(\n        name=node.name,\n        id=node.nodeid,\n        original_name=node.originalname,  # type: ignore\n        path=Path(node.path),\n    )\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.fixture_source_url","title":"<code>fixture_source_url(request)</code>","text":"<p>Return URL to the fixture source.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>@pytest.fixture(scope=\"function\")\ndef fixture_source_url(request: pytest.FixtureRequest) -&gt; str:\n    \"\"\"Return URL to the fixture source.\"\"\"\n    function_line_number = request.function.__code__.co_firstlineno\n    module_relative_path = os.path.relpath(request.module.__file__)\n    hash_or_tag = get_current_commit_hash_or_tag()\n    github_url = generate_github_url(\n        module_relative_path, branch_or_commit_or_tag=hash_or_tag, line_number=function_line_number\n    )\n    return github_url\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.base_test_parametrizer","title":"<code>base_test_parametrizer(cls)</code>","text":"<p>Generate pytest.fixture for a given BaseTest subclass.</p> <p>Implementation detail: All spec fixtures must be scoped on test function level to avoid leakage between tests.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>def base_test_parametrizer(cls: Type[BaseTest]):\n    \"\"\"\n    Generate pytest.fixture for a given BaseTest subclass.\n\n    Implementation detail: All spec fixtures must be scoped on test function level to avoid\n    leakage between tests.\n    \"\"\"\n\n    @pytest.fixture(\n        scope=\"function\",\n        name=cls.pytest_parameter_name(),\n    )\n    def base_test_parametrizer_func(\n        request: pytest.FixtureRequest,\n        t8n: TransitionTool,\n        fork: Fork,\n        reference_spec: ReferenceSpec,\n        eips: List[int],\n        pre: Alloc,\n        output_dir: Path,\n        dump_dir_parameter_level: Path | None,\n        fixture_collector: FixtureCollector,\n        test_case_description: str,\n        fixture_source_url: str,\n    ):\n        \"\"\"\n        Fixture used to instantiate an auto-fillable BaseTest object from within\n        a test function.\n\n        Every test that defines a test filler must explicitly specify its parameter name\n        (see `pytest_parameter_name` in each implementation of BaseTest) in its function\n        arguments.\n\n        When parametrize, indirect must be used along with the fixture format as value.\n        \"\"\"\n        fixture_format = request.param\n        assert issubclass(fixture_format, BaseFixture)\n\n        class BaseTestWrapper(cls):  # type: ignore\n            def __init__(self, *args, **kwargs):\n                kwargs[\"t8n_dump_dir\"] = dump_dir_parameter_level\n                if \"pre\" not in kwargs:\n                    kwargs[\"pre\"] = pre\n                super(BaseTestWrapper, self).__init__(*args, **kwargs)\n                fixture = self.generate(\n                    request=request,\n                    t8n=t8n,\n                    fork=fork,\n                    fixture_format=fixture_format,\n                    eips=eips,\n                )\n                fixture.fill_info(\n                    t8n.version(),\n                    test_case_description,\n                    fixture_source_url=fixture_source_url,\n                    ref_spec=reference_spec,\n                    _info_metadata=t8n._info_metadata,\n                )\n\n                fixture_path = fixture_collector.add_fixture(\n                    node_to_test_info(request.node),\n                    fixture,\n                )\n\n                # NOTE: Use str for compatibility with pytest-dist\n                request.node.config.fixture_path_absolute = str(fixture_path.absolute())\n                request.node.config.fixture_path_relative = str(\n                    fixture_path.relative_to(output_dir)\n                )\n                request.node.config.fixture_format = fixture_format.format_name\n\n        return BaseTestWrapper\n\n    return base_test_parametrizer_func\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.pytest_generate_tests","title":"<code>pytest_generate_tests(metafunc)</code>","text":"<p>Pytest hook used to dynamically generate test cases for each fixture format a given test spec supports.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>def pytest_generate_tests(metafunc: pytest.Metafunc):\n    \"\"\"\n    Pytest hook used to dynamically generate test cases for each fixture format a given\n    test spec supports.\n    \"\"\"\n    for test_type in SPEC_TYPES:\n        if test_type.pytest_parameter_name() in metafunc.fixturenames:\n            metafunc.parametrize(\n                [test_type.pytest_parameter_name()],\n                [\n                    labeled_format_parameter_set(format_with_or_without_label)\n                    for format_with_or_without_label in test_type.supported_fixture_formats\n                ],\n                scope=\"function\",\n                indirect=True,\n            )\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.pytest_collection_modifyitems","title":"<code>pytest_collection_modifyitems(config, items)</code>","text":"<p>Remove pre-Paris tests parametrized to generate hive type fixtures; these can't be used in the Hive Pyspec Simulator.</p> <p>Replaces the test ID for state tests that use a transition fork with the base fork.</p> <p>These can't be handled in this plugins pytest_generate_tests() as the fork parametrization occurs in the forks plugin.</p> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>def pytest_collection_modifyitems(config: pytest.Config, items: List[pytest.Item]):\n    \"\"\"\n    Remove pre-Paris tests parametrized to generate hive type fixtures; these\n    can't be used in the Hive Pyspec Simulator.\n\n    Replaces the test ID for state tests that use a transition fork with the base fork.\n\n    These can't be handled in this plugins pytest_generate_tests() as the fork\n    parametrization occurs in the forks plugin.\n    \"\"\"\n    for item in items[:]:  # use a copy of the list, as we'll be modifying it\n        if isinstance(item, EIPSpecTestItem):\n            continue\n        params: Dict[str, Any] = item.callspec.params  # type: ignore\n        if \"fork\" not in params or params[\"fork\"] is None:\n            items.remove(item)\n            continue\n        fork: Fork = params[\"fork\"]\n        spec_type, fixture_format = get_spec_format_for_item(params)\n        assert issubclass(fixture_format, BaseFixture)\n        if not fixture_format.supports_fork(fork):\n            items.remove(item)\n            continue\n        markers = list(item.iter_markers())\n        if spec_type.discard_fixture_format_by_marks(fixture_format, fork, markers):\n            items.remove(item)\n            continue\n        for marker in markers:\n            if marker.name == \"fill\":\n                for mark in marker.args:\n                    item.add_marker(mark)\n        if \"yul\" in item.fixturenames:  # type: ignore\n            item.add_marker(pytest.mark.yul_test)\n\n        # Update test ID for state tests that use a transition fork\n        if fork in get_transition_forks():\n            has_state_test = any(marker.name == \"state_test\" for marker in markers)\n            has_valid_transition = any(\n                marker.name == \"valid_at_transition_to\" for marker in markers\n            )\n            if has_state_test and has_valid_transition:\n                base_fork = get_transition_fork_predecessor(fork)\n                item._nodeid = item._nodeid.replace(\n                    f\"fork_{fork.name()}\",\n                    f\"fork_{base_fork.name()}\",\n                )\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.filler.pytest_sessionfinish","title":"<code>pytest_sessionfinish(session, exitstatus)</code>","text":"<p>Perform session finish tasks.</p> <ul> <li>Remove any lock files that may have been created.</li> <li>Generate index file for all produced fixtures.</li> <li>Create tarball of the output directory if the output is a tarball.</li> </ul> Source code in <code>src/pytest_plugins/filler/filler.py</code> <pre><code>def pytest_sessionfinish(session: pytest.Session, exitstatus: int):\n    \"\"\"\n    Perform session finish tasks.\n\n    - Remove any lock files that may have been created.\n    - Generate index file for all produced fixtures.\n    - Create tarball of the output directory if the output is a tarball.\n    \"\"\"\n    if xdist.is_xdist_worker(session):\n        return\n\n    output: Path = session.config.getoption(\"output\")\n    # When using --collect-only it should not matter whether fixtures folder exists or not\n    if is_output_stdout(output) or session.config.option.collectonly:\n        return\n\n    output_dir = strip_output_tarball_suffix(output)\n    # Remove any lock files that may have been created.\n    for file in output_dir.rglob(\"*.lock\"):\n        file.unlink()\n\n    # Generate index file for all produced fixtures.\n    if session.config.getoption(\"generate_index\"):\n        generate_fixtures_index(\n            output_dir, quiet_mode=True, force_flag=False, disable_infer_format=False\n        )\n\n    # Create tarball of the output directory if the output is a tarball.\n    is_output_tarball = output.suffix == \".gz\" and output.with_suffix(\"\").suffix == \".tar\"\n    if is_output_tarball:\n        source_dir = output_dir\n        tarball_filename = output\n        with tarfile.open(tarball_filename, \"w:gz\") as tar:\n            for file in source_dir.rglob(\"*\"):\n                if file.suffix in {\".json\", \".ini\"}:\n                    arcname = Path(\"fixtures\") / file.relative_to(source_dir)\n                    tar.add(file, arcname=arcname)\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.pre_alloc.pytest_addoption","title":"<code>pytest_addoption(parser)</code>","text":"<p>Add command-line options to pytest.</p> Source code in <code>src/pytest_plugins/filler/pre_alloc.py</code> <pre><code>def pytest_addoption(parser: pytest.Parser):\n    \"\"\"Add command-line options to pytest.\"\"\"\n    pre_alloc_group = parser.getgroup(\n        \"pre_alloc\", \"Arguments defining pre-allocation behavior during test filling.\"\n    )\n\n    pre_alloc_group.addoption(\n        \"--strict-alloc\",\n        action=\"store_true\",\n        dest=\"strict_alloc\",\n        default=False,\n        help=(\"[DEBUG ONLY] Disallows deploying a contract in a predefined address.\"),\n    )\n    pre_alloc_group.addoption(\n        \"--ca-start\",\n        \"--contract-address-start\",\n        action=\"store\",\n        dest=\"test_contract_start_address\",\n        default=f\"{CONTRACT_START_ADDRESS_DEFAULT}\",\n        type=str,\n        help=\"The starting address from which tests will deploy contracts.\",\n    )\n    pre_alloc_group.addoption(\n        \"--ca-incr\",\n        \"--contract-address-increment\",\n        action=\"store\",\n        dest=\"test_contract_address_increments\",\n        default=f\"{CONTRACT_ADDRESS_INCREMENTS_DEFAULT}\",\n        type=str,\n        help=\"The address increment value to each deployed contract by a test.\",\n    )\n    pre_alloc_group.addoption(\n        \"--evm-code-type\",\n        action=\"store\",\n        dest=\"evm_code_type\",\n        default=None,\n        type=EVMCodeType,\n        choices=list(EVMCodeType),\n        help=\"Type of EVM code to deploy in each test by default.\",\n    )\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.pre_alloc.AllocMode","title":"<code>AllocMode</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Allocation mode for the state.</p> Source code in <code>src/pytest_plugins/filler/pre_alloc.py</code> <pre><code>class AllocMode(IntEnum):\n    \"\"\"Allocation mode for the state.\"\"\"\n\n    PERMISSIVE = 0\n    STRICT = 1\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.pre_alloc.Alloc","title":"<code>Alloc</code>","text":"<p>               Bases: <code>Alloc</code></p> <p>Allocation of accounts in the state, pre and post test execution.</p> Source code in <code>src/pytest_plugins/filler/pre_alloc.py</code> <pre><code>class Alloc(BaseAlloc):\n    \"\"\"Allocation of accounts in the state, pre and post test execution.\"\"\"\n\n    _alloc_mode: AllocMode = PrivateAttr()\n    _contract_address_iterator: Iterator[Address] = PrivateAttr()\n    _eoa_iterator: Iterator[EOA] = PrivateAttr()\n    _evm_code_type: EVMCodeType | None = PrivateAttr(None)\n\n    def __init__(\n        self,\n        *args,\n        alloc_mode: AllocMode,\n        contract_address_iterator: Iterator[Address],\n        eoa_iterator: Iterator[EOA],\n        evm_code_type: EVMCodeType | None = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize allocation with the given properties.\"\"\"\n        super().__init__(*args, **kwargs)\n        self._alloc_mode = alloc_mode\n        self._contract_address_iterator = contract_address_iterator\n        self._eoa_iterator = eoa_iterator\n        self._evm_code_type = evm_code_type\n\n    def __setitem__(self, address: Address | FixedSizeBytesConvertible, account: Account | None):\n        \"\"\"Set account associated with an address.\"\"\"\n        if self._alloc_mode == AllocMode.STRICT:\n            raise ValueError(\"Cannot set items in strict mode\")\n        super().__setitem__(address, account)\n\n    def code_pre_processor(\n        self, code: BytesConvertible, *, evm_code_type: EVMCodeType | None\n    ) -&gt; BytesConvertible:\n        \"\"\"Pre-processes the code before setting it.\"\"\"\n        if evm_code_type is None:\n            evm_code_type = self._evm_code_type\n        if evm_code_type == EVMCodeType.EOF_V1:\n            if not isinstance(code, Container):\n                if isinstance(code, Bytecode) and not code.terminating:\n                    return Container.Code(code + Opcodes.STOP)\n                return Container.Code(code)\n        return code\n\n    def deploy_contract(\n        self,\n        code: BytesConvertible,\n        *,\n        storage: Storage | StorageRootType | None = None,\n        balance: NumberConvertible = 0,\n        nonce: NumberConvertible = 1,\n        address: Address | None = None,\n        evm_code_type: EVMCodeType | None = None,\n        label: str | None = None,\n    ) -&gt; Address:\n        \"\"\"\n        Deploy a contract to the allocation.\n\n        Warning: `address` parameter is a temporary solution to allow tests to hard-code the\n        contract address. Do NOT use in new tests as it will be removed in the future!\n        \"\"\"\n        if storage is None:\n            storage = {}\n        if address is not None:\n            assert self._alloc_mode == AllocMode.PERMISSIVE, \"address parameter is not supported\"\n            assert address not in self, f\"address {address} already in allocation\"\n            contract_address = address\n        else:\n            contract_address = next(self._contract_address_iterator)\n\n        if self._alloc_mode == AllocMode.STRICT:\n            assert Number(nonce) &gt;= 1, \"impossible to deploy contract with nonce lower than one\"\n\n        super().__setitem__(\n            contract_address,\n            Account(\n                nonce=nonce,\n                balance=balance,\n                code=self.code_pre_processor(code, evm_code_type=evm_code_type),\n                storage=storage,\n            ),\n        )\n        if label is None:\n            # Try to deduce the label from the code\n            frame = inspect.currentframe()\n            if frame is not None:\n                caller_frame = frame.f_back\n                if caller_frame is not None:\n                    code_context = inspect.getframeinfo(caller_frame).code_context\n                    if code_context is not None:\n                        line = code_context[0].strip()\n                        if \"=\" in line:\n                            label = line.split(\"=\")[0].strip()\n\n        contract_address.label = label\n        return contract_address\n\n    def fund_eoa(\n        self,\n        amount: NumberConvertible | None = None,\n        label: str | None = None,\n        storage: Storage | None = None,\n        delegation: Address | Literal[\"Self\"] | None = None,\n        nonce: NumberConvertible | None = None,\n    ) -&gt; EOA:\n        \"\"\"\n        Add a previously unused EOA to the pre-alloc with the balance specified by `amount`.\n\n        If amount is 0, nothing will be added to the pre-alloc but a new and unique EOA will be\n        returned.\n        \"\"\"\n        eoa = next(self._eoa_iterator)\n        if amount is None:\n            amount = self._eoa_fund_amount_default\n        if (\n            Number(amount) &gt; 0\n            or storage is not None\n            or delegation is not None\n            or (nonce is not None and Number(nonce) &gt; 0)\n        ):\n            if storage is None and delegation is None:\n                nonce = Number(0 if nonce is None else nonce)\n                account = Account(\n                    nonce=nonce,\n                    balance=amount,\n                )\n                if nonce &gt; 0:\n                    eoa.nonce = nonce\n            else:\n                # Type-4 transaction is sent to the EOA to set the storage, so the nonce must be 1\n                if not isinstance(delegation, Address) and delegation == \"Self\":\n                    delegation = eoa\n                # If delegation is None but storage is not, realistically the nonce should be 2\n                # because the account must have delegated to set the storage and then again to\n                # reset the delegation (but can be overridden by the test for a non-realistic\n                # scenario)\n                real_nonce = 2 if delegation is None else 1\n                nonce = Number(real_nonce if nonce is None else nonce)\n                account = Account(\n                    nonce=nonce,\n                    balance=amount,\n                    storage=storage if storage is not None else {},\n                    code=DELEGATION_DESIGNATION + bytes(delegation)  # type: ignore\n                    if delegation is not None\n                    else b\"\",\n                )\n                eoa.nonce = nonce\n\n            super().__setitem__(eoa, account)\n        return eoa\n\n    def fund_address(self, address: Address, amount: NumberConvertible):\n        \"\"\"\n        Fund an address with a given amount.\n\n        If the address is already present in the pre-alloc the amount will be\n        added to its existing balance.\n        \"\"\"\n        if address in self:\n            account = self[address]\n            if account is not None:\n                current_balance = account.balance or 0\n                account.balance = ZeroPaddedHexNumber(current_balance + Number(amount))\n                return\n        super().__setitem__(address, Account(balance=amount))\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.pre_alloc.Alloc.__init__","title":"<code>__init__(*args, alloc_mode, contract_address_iterator, eoa_iterator, evm_code_type=None, **kwargs)</code>","text":"<p>Initialize allocation with the given properties.</p> Source code in <code>src/pytest_plugins/filler/pre_alloc.py</code> <pre><code>def __init__(\n    self,\n    *args,\n    alloc_mode: AllocMode,\n    contract_address_iterator: Iterator[Address],\n    eoa_iterator: Iterator[EOA],\n    evm_code_type: EVMCodeType | None = None,\n    **kwargs,\n):\n    \"\"\"Initialize allocation with the given properties.\"\"\"\n    super().__init__(*args, **kwargs)\n    self._alloc_mode = alloc_mode\n    self._contract_address_iterator = contract_address_iterator\n    self._eoa_iterator = eoa_iterator\n    self._evm_code_type = evm_code_type\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.pre_alloc.Alloc.__setitem__","title":"<code>__setitem__(address, account)</code>","text":"<p>Set account associated with an address.</p> Source code in <code>src/pytest_plugins/filler/pre_alloc.py</code> <pre><code>def __setitem__(self, address: Address | FixedSizeBytesConvertible, account: Account | None):\n    \"\"\"Set account associated with an address.\"\"\"\n    if self._alloc_mode == AllocMode.STRICT:\n        raise ValueError(\"Cannot set items in strict mode\")\n    super().__setitem__(address, account)\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.pre_alloc.Alloc.code_pre_processor","title":"<code>code_pre_processor(code, *, evm_code_type)</code>","text":"<p>Pre-processes the code before setting it.</p> Source code in <code>src/pytest_plugins/filler/pre_alloc.py</code> <pre><code>def code_pre_processor(\n    self, code: BytesConvertible, *, evm_code_type: EVMCodeType | None\n) -&gt; BytesConvertible:\n    \"\"\"Pre-processes the code before setting it.\"\"\"\n    if evm_code_type is None:\n        evm_code_type = self._evm_code_type\n    if evm_code_type == EVMCodeType.EOF_V1:\n        if not isinstance(code, Container):\n            if isinstance(code, Bytecode) and not code.terminating:\n                return Container.Code(code + Opcodes.STOP)\n            return Container.Code(code)\n    return code\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.pre_alloc.Alloc.deploy_contract","title":"<code>deploy_contract(code, *, storage=None, balance=0, nonce=1, address=None, evm_code_type=None, label=None)</code>","text":"<p>Deploy a contract to the allocation.</p> <p>Warning: <code>address</code> parameter is a temporary solution to allow tests to hard-code the contract address. Do NOT use in new tests as it will be removed in the future!</p> Source code in <code>src/pytest_plugins/filler/pre_alloc.py</code> <pre><code>def deploy_contract(\n    self,\n    code: BytesConvertible,\n    *,\n    storage: Storage | StorageRootType | None = None,\n    balance: NumberConvertible = 0,\n    nonce: NumberConvertible = 1,\n    address: Address | None = None,\n    evm_code_type: EVMCodeType | None = None,\n    label: str | None = None,\n) -&gt; Address:\n    \"\"\"\n    Deploy a contract to the allocation.\n\n    Warning: `address` parameter is a temporary solution to allow tests to hard-code the\n    contract address. Do NOT use in new tests as it will be removed in the future!\n    \"\"\"\n    if storage is None:\n        storage = {}\n    if address is not None:\n        assert self._alloc_mode == AllocMode.PERMISSIVE, \"address parameter is not supported\"\n        assert address not in self, f\"address {address} already in allocation\"\n        contract_address = address\n    else:\n        contract_address = next(self._contract_address_iterator)\n\n    if self._alloc_mode == AllocMode.STRICT:\n        assert Number(nonce) &gt;= 1, \"impossible to deploy contract with nonce lower than one\"\n\n    super().__setitem__(\n        contract_address,\n        Account(\n            nonce=nonce,\n            balance=balance,\n            code=self.code_pre_processor(code, evm_code_type=evm_code_type),\n            storage=storage,\n        ),\n    )\n    if label is None:\n        # Try to deduce the label from the code\n        frame = inspect.currentframe()\n        if frame is not None:\n            caller_frame = frame.f_back\n            if caller_frame is not None:\n                code_context = inspect.getframeinfo(caller_frame).code_context\n                if code_context is not None:\n                    line = code_context[0].strip()\n                    if \"=\" in line:\n                        label = line.split(\"=\")[0].strip()\n\n    contract_address.label = label\n    return contract_address\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.pre_alloc.Alloc.fund_eoa","title":"<code>fund_eoa(amount=None, label=None, storage=None, delegation=None, nonce=None)</code>","text":"<p>Add a previously unused EOA to the pre-alloc with the balance specified by <code>amount</code>.</p> <p>If amount is 0, nothing will be added to the pre-alloc but a new and unique EOA will be returned.</p> Source code in <code>src/pytest_plugins/filler/pre_alloc.py</code> <pre><code>def fund_eoa(\n    self,\n    amount: NumberConvertible | None = None,\n    label: str | None = None,\n    storage: Storage | None = None,\n    delegation: Address | Literal[\"Self\"] | None = None,\n    nonce: NumberConvertible | None = None,\n) -&gt; EOA:\n    \"\"\"\n    Add a previously unused EOA to the pre-alloc with the balance specified by `amount`.\n\n    If amount is 0, nothing will be added to the pre-alloc but a new and unique EOA will be\n    returned.\n    \"\"\"\n    eoa = next(self._eoa_iterator)\n    if amount is None:\n        amount = self._eoa_fund_amount_default\n    if (\n        Number(amount) &gt; 0\n        or storage is not None\n        or delegation is not None\n        or (nonce is not None and Number(nonce) &gt; 0)\n    ):\n        if storage is None and delegation is None:\n            nonce = Number(0 if nonce is None else nonce)\n            account = Account(\n                nonce=nonce,\n                balance=amount,\n            )\n            if nonce &gt; 0:\n                eoa.nonce = nonce\n        else:\n            # Type-4 transaction is sent to the EOA to set the storage, so the nonce must be 1\n            if not isinstance(delegation, Address) and delegation == \"Self\":\n                delegation = eoa\n            # If delegation is None but storage is not, realistically the nonce should be 2\n            # because the account must have delegated to set the storage and then again to\n            # reset the delegation (but can be overridden by the test for a non-realistic\n            # scenario)\n            real_nonce = 2 if delegation is None else 1\n            nonce = Number(real_nonce if nonce is None else nonce)\n            account = Account(\n                nonce=nonce,\n                balance=amount,\n                storage=storage if storage is not None else {},\n                code=DELEGATION_DESIGNATION + bytes(delegation)  # type: ignore\n                if delegation is not None\n                else b\"\",\n            )\n            eoa.nonce = nonce\n\n        super().__setitem__(eoa, account)\n    return eoa\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.pre_alloc.Alloc.fund_address","title":"<code>fund_address(address, amount)</code>","text":"<p>Fund an address with a given amount.</p> <p>If the address is already present in the pre-alloc the amount will be added to its existing balance.</p> Source code in <code>src/pytest_plugins/filler/pre_alloc.py</code> <pre><code>def fund_address(self, address: Address, amount: NumberConvertible):\n    \"\"\"\n    Fund an address with a given amount.\n\n    If the address is already present in the pre-alloc the amount will be\n    added to its existing balance.\n    \"\"\"\n    if address in self:\n        account = self[address]\n        if account is not None:\n            current_balance = account.balance or 0\n            account.balance = ZeroPaddedHexNumber(current_balance + Number(amount))\n            return\n    super().__setitem__(address, Account(balance=amount))\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.pre_alloc.alloc_mode","title":"<code>alloc_mode(request)</code>","text":"<p>Return allocation mode for the tests.</p> Source code in <code>src/pytest_plugins/filler/pre_alloc.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef alloc_mode(request: pytest.FixtureRequest) -&gt; AllocMode:\n    \"\"\"Return allocation mode for the tests.\"\"\"\n    if request.config.getoption(\"strict_alloc\"):\n        return AllocMode.STRICT\n    return AllocMode.PERMISSIVE\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.pre_alloc.contract_start_address","title":"<code>contract_start_address(request)</code>","text":"<p>Return starting address for contract deployment.</p> Source code in <code>src/pytest_plugins/filler/pre_alloc.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef contract_start_address(request: pytest.FixtureRequest) -&gt; int:\n    \"\"\"Return starting address for contract deployment.\"\"\"\n    return int(request.config.getoption(\"test_contract_start_address\"), 0)\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.pre_alloc.contract_address_increments","title":"<code>contract_address_increments(request)</code>","text":"<p>Return address increment for contract deployment.</p> Source code in <code>src/pytest_plugins/filler/pre_alloc.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef contract_address_increments(request: pytest.FixtureRequest) -&gt; int:\n    \"\"\"Return address increment for contract deployment.\"\"\"\n    return int(request.config.getoption(\"test_contract_address_increments\"), 0)\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.pre_alloc.contract_address_iterator","title":"<code>contract_address_iterator(contract_start_address, contract_address_increments)</code>","text":"<p>Return iterator over contract addresses.</p> Source code in <code>src/pytest_plugins/filler/pre_alloc.py</code> <pre><code>@pytest.fixture(scope=\"function\")\ndef contract_address_iterator(\n    contract_start_address: int,\n    contract_address_increments: int,\n) -&gt; Iterator[Address]:\n    \"\"\"Return iterator over contract addresses.\"\"\"\n    return iter(\n        Address(contract_start_address + (i * contract_address_increments)) for i in count()\n    )\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.pre_alloc.eoa_by_index","title":"<code>eoa_by_index(i)</code>  <code>cached</code>","text":"<p>Return EOA by index.</p> Source code in <code>src/pytest_plugins/filler/pre_alloc.py</code> <pre><code>@cache\ndef eoa_by_index(i: int) -&gt; EOA:\n    \"\"\"Return EOA by index.\"\"\"\n    return EOA(key=TestPrivateKey + i if i != 1 else TestPrivateKey2, nonce=0)\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.pre_alloc.eoa_iterator","title":"<code>eoa_iterator()</code>","text":"<p>Return iterator over EOAs copies.</p> Source code in <code>src/pytest_plugins/filler/pre_alloc.py</code> <pre><code>@pytest.fixture(scope=\"function\")\ndef eoa_iterator() -&gt; Iterator[EOA]:\n    \"\"\"Return iterator over EOAs copies.\"\"\"\n    return iter(eoa_by_index(i).copy() for i in count())\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.pre_alloc.evm_code_type","title":"<code>evm_code_type(request)</code>","text":"<p>Return default EVM code type for all tests (LEGACY).</p> Source code in <code>src/pytest_plugins/filler/pre_alloc.py</code> <pre><code>@pytest.fixture(autouse=True)\ndef evm_code_type(request: pytest.FixtureRequest) -&gt; EVMCodeType:\n    \"\"\"Return default EVM code type for all tests (LEGACY).\"\"\"\n    parameter_evm_code_type = request.config.getoption(\"evm_code_type\")\n    if parameter_evm_code_type is not None:\n        assert type(parameter_evm_code_type) is EVMCodeType, \"Invalid EVM code type\"\n        return parameter_evm_code_type\n    return EVMCodeType.LEGACY\n</code></pre>"},{"location":"library/pytest_plugins/filler/#pytest_plugins.filler.pre_alloc.pre","title":"<code>pre(alloc_mode, contract_address_iterator, eoa_iterator, evm_code_type)</code>","text":"<p>Return default pre allocation for all tests (Empty alloc).</p> Source code in <code>src/pytest_plugins/filler/pre_alloc.py</code> <pre><code>@pytest.fixture(scope=\"function\")\ndef pre(\n    alloc_mode: AllocMode,\n    contract_address_iterator: Iterator[Address],\n    eoa_iterator: Iterator[EOA],\n    evm_code_type: EVMCodeType,\n) -&gt; Alloc:\n    \"\"\"Return default pre allocation for all tests (Empty alloc).\"\"\"\n    return Alloc(\n        alloc_mode=alloc_mode,\n        contract_address_iterator=contract_address_iterator,\n        eoa_iterator=eoa_iterator,\n        evm_code_type=evm_code_type,\n    )\n</code></pre>"},{"location":"library/pytest_plugins/forks/","title":"Forks Plugin","text":"<p>A pytest plugin to configure the forks in the test session. It parametrizes tests based on the user-provided fork range the tests' specified validity markers.</p> <p>Pytest plugin to enable fork range configuration for the test session.</p>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.pytest_addoption","title":"<code>pytest_addoption(parser)</code>","text":"<p>Add command-line options to pytest.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>def pytest_addoption(parser):\n    \"\"\"Add command-line options to pytest.\"\"\"\n    fork_group = parser.getgroup(\"Forks\", \"Specify the fork range to generate fixtures for\")\n    fork_group.addoption(\n        \"--forks\",\n        action=\"store_true\",\n        dest=\"show_fork_help\",\n        default=False,\n        help=\"Display forks supported by the test framework and exit.\",\n    )\n    fork_group.addoption(\n        \"--fork\",\n        action=\"store\",\n        dest=\"single_fork\",\n        default=None,\n        help=\"Only fill tests for the specified fork.\",\n    )\n    fork_group.addoption(\n        \"--from\",\n        action=\"store\",\n        dest=\"forks_from\",\n        default=None,\n        help=\"Fill tests from and including the specified fork.\",\n    )\n    fork_group.addoption(\n        \"--until\",\n        action=\"store\",\n        dest=\"forks_until\",\n        default=None,\n        help=\"Fill tests until and including the specified fork.\",\n    )\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.ForkCovariantParameter","title":"<code>ForkCovariantParameter</code>  <code>dataclass</code>","text":"<p>Value list for a fork covariant parameter in a given fork.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>@dataclass(kw_only=True)\nclass ForkCovariantParameter:\n    \"\"\"Value list for a fork covariant parameter in a given fork.\"\"\"\n\n    names: List[str]\n    values: List[ParameterSet]\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.ForkParametrizer","title":"<code>ForkParametrizer</code>","text":"<p>A parametrizer for a test case that is parametrized by the fork.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>class ForkParametrizer:\n    \"\"\"A parametrizer for a test case that is parametrized by the fork.\"\"\"\n\n    fork: Fork\n    fork_covariant_parameters: List[ForkCovariantParameter] = field(default_factory=list)\n\n    def __init__(\n        self,\n        fork: Fork,\n        marks: List[pytest.MarkDecorator | pytest.Mark] | None = None,\n        fork_covariant_parameters: List[ForkCovariantParameter] | None = None,\n    ):\n        \"\"\"\n        Initialize a new fork parametrizer object for a given fork.\n\n        Args:\n            fork: The fork for which the test cases will be parametrized.\n            marks: A list of pytest marks to apply to all the test cases parametrized by the fork.\n            fork_covariant_parameters: A list of fork covariant parameters for the test case, for\n                unit testing purposes only.\n\n        \"\"\"\n        if marks is None:\n            marks = []\n        self.fork_covariant_parameters = [\n            ForkCovariantParameter(\n                names=[\"fork\"],\n                values=[\n                    pytest.param(\n                        fork,\n                        marks=marks,\n                    )\n                ],\n            )\n        ]\n        if fork_covariant_parameters is not None:\n            self.fork_covariant_parameters.extend(fork_covariant_parameters)\n        self.fork = fork\n\n    @property\n    def argnames(self) -&gt; List[str]:\n        \"\"\"Return the parameter names for the test case.\"\"\"\n        argnames = []\n        for p in self.fork_covariant_parameters:\n            argnames.extend(p.names)\n        return argnames\n\n    @property\n    def argvalues(self) -&gt; List[ParameterSet]:\n        \"\"\"Return the parameter values for the test case.\"\"\"\n        parameter_set_combinations = itertools.product(\n            # Add the values for each parameter, all of them are lists of at least one element.\n            *[p.values for p in self.fork_covariant_parameters],\n        )\n\n        parameter_set_list: List[ParameterSet] = []\n        for parameter_set_combination in parameter_set_combinations:\n            params: List[Any] = []\n            marks: List[pytest.Mark | pytest.MarkDecorator] = []\n            test_id: str | None = None\n            for p in parameter_set_combination:\n                assert isinstance(p, ParameterSet)\n                params.extend(p.values)\n                if p.marks:\n                    marks.extend(p.marks)\n                if p.id:\n                    if test_id is None:\n                        test_id = f\"fork_{self.fork.name()}-{p.id}\"\n                    else:\n                        test_id = f\"{test_id}-{p.id}\"\n            parameter_set_list.append(pytest.param(*params, marks=marks, id=test_id))\n\n        return parameter_set_list\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.ForkParametrizer.__init__","title":"<code>__init__(fork, marks=None, fork_covariant_parameters=None)</code>","text":"<p>Initialize a new fork parametrizer object for a given fork.</p> <p>Parameters:</p> Name Type Description Default <code>fork</code> <code>Fork</code> <p>The fork for which the test cases will be parametrized.</p> required <code>marks</code> <code>List[MarkDecorator | Mark] | None</code> <p>A list of pytest marks to apply to all the test cases parametrized by the fork.</p> <code>None</code> <code>fork_covariant_parameters</code> <code>List[ForkCovariantParameter] | None</code> <p>A list of fork covariant parameters for the test case, for unit testing purposes only.</p> <code>None</code> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>def __init__(\n    self,\n    fork: Fork,\n    marks: List[pytest.MarkDecorator | pytest.Mark] | None = None,\n    fork_covariant_parameters: List[ForkCovariantParameter] | None = None,\n):\n    \"\"\"\n    Initialize a new fork parametrizer object for a given fork.\n\n    Args:\n        fork: The fork for which the test cases will be parametrized.\n        marks: A list of pytest marks to apply to all the test cases parametrized by the fork.\n        fork_covariant_parameters: A list of fork covariant parameters for the test case, for\n            unit testing purposes only.\n\n    \"\"\"\n    if marks is None:\n        marks = []\n    self.fork_covariant_parameters = [\n        ForkCovariantParameter(\n            names=[\"fork\"],\n            values=[\n                pytest.param(\n                    fork,\n                    marks=marks,\n                )\n            ],\n        )\n    ]\n    if fork_covariant_parameters is not None:\n        self.fork_covariant_parameters.extend(fork_covariant_parameters)\n    self.fork = fork\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.ForkParametrizer.argnames","title":"<code>argnames: List[str]</code>  <code>property</code>","text":"<p>Return the parameter names for the test case.</p>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.ForkParametrizer.argvalues","title":"<code>argvalues: List[ParameterSet]</code>  <code>property</code>","text":"<p>Return the parameter values for the test case.</p>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.CovariantDescriptor","title":"<code>CovariantDescriptor</code>","text":"<p>A descriptor for a parameter that is covariant with the fork: the parametrized values change depending on the fork.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>class CovariantDescriptor:\n    \"\"\"\n    A descriptor for a parameter that is covariant with the fork:\n    the parametrized values change depending on the fork.\n    \"\"\"\n\n    argnames: List[str] = []\n    fn: Callable[[Fork], List[Any] | Iterable[Any]] | None = None\n\n    selector: FunctionType | None = None\n    marks: None | pytest.Mark | pytest.MarkDecorator | List[pytest.Mark | pytest.MarkDecorator] = (\n        None\n    )\n\n    def __init__(\n        self,\n        argnames: List[str] | str,\n        fn: Callable[[Fork], List[Any] | Iterable[Any]] | None = None,\n        *,\n        selector: FunctionType | None = None,\n        marks: None\n        | pytest.Mark\n        | pytest.MarkDecorator\n        | List[pytest.Mark | pytest.MarkDecorator] = None,\n    ):\n        \"\"\"\n        Initialize a new covariant descriptor.\n\n        Args:\n            argnames: The names of the parameters that are covariant with the fork.\n            fn: A function that takes the fork as the single parameter and returns the values for\n                the parameter for each fork.\n            selector: A function that filters the values for the parameter.\n            marks: A list of pytest marks to apply to the test cases parametrized by the parameter.\n\n        \"\"\"\n        self.argnames = (\n            [argname.strip() for argname in argnames.split(\",\")]\n            if isinstance(argnames, str)\n            else argnames\n        )\n        self.fn = fn\n        self.selector = selector\n        self.marks = marks\n\n    def process_value(\n        self,\n        parameters_values: Any | List[Any] | Tuple[Any] | ParameterSet,\n    ) -&gt; ParameterSet | None:\n        \"\"\"\n        Process a value for a covariant parameter.\n\n        The `selector` is applied to parameters_values in order to filter them.\n        \"\"\"\n        if isinstance(parameters_values, ParameterSet):\n            return parameters_values\n\n        if len(self.argnames) == 1:\n            # Wrap values that are meant for a single parameter in a list\n            parameters_values = [parameters_values]\n        marks = self.marks\n        if self.selector is None or self.selector(\n            *parameters_values[: self.selector.__code__.co_argcount]  # type: ignore\n        ):\n            if isinstance(marks, FunctionType):\n                marks = marks(*parameters_values[: marks.__code__.co_argcount])\n            assert not isinstance(marks, FunctionType), \"marks must be a list or None\"\n            if marks is None:\n                marks = []\n            elif not isinstance(marks, list):\n                marks = [marks]  # type: ignore\n\n            return pytest.param(*parameters_values, marks=marks)\n\n        return None\n\n    def process_values(self, values: Iterable[Any]) -&gt; List[ParameterSet]:\n        \"\"\"\n        Filter the values for the covariant parameter.\n\n        I.e. if the marker has an argument, the argument is interpreted as a lambda function\n        that filters the values.\n        \"\"\"\n        processed_values: List[ParameterSet] = []\n        for value in values:\n            processed_value = self.process_value(value)\n            if processed_value is not None:\n                processed_values.append(processed_value)\n        return processed_values\n\n    def add_values(self, fork_parametrizer: ForkParametrizer) -&gt; None:\n        \"\"\"Add the values for the covariant parameter to the parametrizer.\"\"\"\n        if self.fn is None:\n            return\n        fork = fork_parametrizer.fork\n        values = self.fn(fork)\n        values = self.process_values(values)\n        assert len(values) &gt; 0\n        fork_parametrizer.fork_covariant_parameters.append(\n            ForkCovariantParameter(names=self.argnames, values=values)\n        )\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.CovariantDescriptor.__init__","title":"<code>__init__(argnames, fn=None, *, selector=None, marks=None)</code>","text":"<p>Initialize a new covariant descriptor.</p> <p>Parameters:</p> Name Type Description Default <code>argnames</code> <code>List[str] | str</code> <p>The names of the parameters that are covariant with the fork.</p> required <code>fn</code> <code>Callable[[Fork], List[Any] | Iterable[Any]] | None</code> <p>A function that takes the fork as the single parameter and returns the values for the parameter for each fork.</p> <code>None</code> <code>selector</code> <code>FunctionType | None</code> <p>A function that filters the values for the parameter.</p> <code>None</code> <code>marks</code> <code>None | Mark | MarkDecorator | List[Mark | MarkDecorator]</code> <p>A list of pytest marks to apply to the test cases parametrized by the parameter.</p> <code>None</code> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>def __init__(\n    self,\n    argnames: List[str] | str,\n    fn: Callable[[Fork], List[Any] | Iterable[Any]] | None = None,\n    *,\n    selector: FunctionType | None = None,\n    marks: None\n    | pytest.Mark\n    | pytest.MarkDecorator\n    | List[pytest.Mark | pytest.MarkDecorator] = None,\n):\n    \"\"\"\n    Initialize a new covariant descriptor.\n\n    Args:\n        argnames: The names of the parameters that are covariant with the fork.\n        fn: A function that takes the fork as the single parameter and returns the values for\n            the parameter for each fork.\n        selector: A function that filters the values for the parameter.\n        marks: A list of pytest marks to apply to the test cases parametrized by the parameter.\n\n    \"\"\"\n    self.argnames = (\n        [argname.strip() for argname in argnames.split(\",\")]\n        if isinstance(argnames, str)\n        else argnames\n    )\n    self.fn = fn\n    self.selector = selector\n    self.marks = marks\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.CovariantDescriptor.process_value","title":"<code>process_value(parameters_values)</code>","text":"<p>Process a value for a covariant parameter.</p> <p>The <code>selector</code> is applied to parameters_values in order to filter them.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>def process_value(\n    self,\n    parameters_values: Any | List[Any] | Tuple[Any] | ParameterSet,\n) -&gt; ParameterSet | None:\n    \"\"\"\n    Process a value for a covariant parameter.\n\n    The `selector` is applied to parameters_values in order to filter them.\n    \"\"\"\n    if isinstance(parameters_values, ParameterSet):\n        return parameters_values\n\n    if len(self.argnames) == 1:\n        # Wrap values that are meant for a single parameter in a list\n        parameters_values = [parameters_values]\n    marks = self.marks\n    if self.selector is None or self.selector(\n        *parameters_values[: self.selector.__code__.co_argcount]  # type: ignore\n    ):\n        if isinstance(marks, FunctionType):\n            marks = marks(*parameters_values[: marks.__code__.co_argcount])\n        assert not isinstance(marks, FunctionType), \"marks must be a list or None\"\n        if marks is None:\n            marks = []\n        elif not isinstance(marks, list):\n            marks = [marks]  # type: ignore\n\n        return pytest.param(*parameters_values, marks=marks)\n\n    return None\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.CovariantDescriptor.process_values","title":"<code>process_values(values)</code>","text":"<p>Filter the values for the covariant parameter.</p> <p>I.e. if the marker has an argument, the argument is interpreted as a lambda function that filters the values.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>def process_values(self, values: Iterable[Any]) -&gt; List[ParameterSet]:\n    \"\"\"\n    Filter the values for the covariant parameter.\n\n    I.e. if the marker has an argument, the argument is interpreted as a lambda function\n    that filters the values.\n    \"\"\"\n    processed_values: List[ParameterSet] = []\n    for value in values:\n        processed_value = self.process_value(value)\n        if processed_value is not None:\n            processed_values.append(processed_value)\n    return processed_values\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.CovariantDescriptor.add_values","title":"<code>add_values(fork_parametrizer)</code>","text":"<p>Add the values for the covariant parameter to the parametrizer.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>def add_values(self, fork_parametrizer: ForkParametrizer) -&gt; None:\n    \"\"\"Add the values for the covariant parameter to the parametrizer.\"\"\"\n    if self.fn is None:\n        return\n    fork = fork_parametrizer.fork\n    values = self.fn(fork)\n    values = self.process_values(values)\n    assert len(values) &gt; 0\n    fork_parametrizer.fork_covariant_parameters.append(\n        ForkCovariantParameter(names=self.argnames, values=values)\n    )\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.CovariantDecorator","title":"<code>CovariantDecorator</code>","text":"<p>               Bases: <code>CovariantDescriptor</code></p> <p>A marker used to parametrize a function by a covariant parameter with the values returned by a fork method.</p> <p>The decorator must be subclassed with the appropriate class variables before initialization.</p> <p>Attributes:</p> Name Type Description <code>marker_name</code> <code>str</code> <p>Name of the marker.</p> <code>description</code> <code>str</code> <p>Description of the marker.</p> <code>fork_attribute_name</code> <code>str</code> <p>Name of the method to call on the fork to get the values.</p> <code>marker_parameter_names</code> <code>List[str]</code> <p>Names of the parameters to be parametrized in the test function.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>class CovariantDecorator(CovariantDescriptor):\n    \"\"\"\n    A marker used to parametrize a function by a covariant parameter with the values\n    returned by a fork method.\n\n    The decorator must be subclassed with the appropriate class variables before initialization.\n\n    Attributes:\n        marker_name: Name of the marker.\n        description: Description of the marker.\n        fork_attribute_name: Name of the method to call on the fork to get the values.\n        marker_parameter_names: Names of the parameters to be parametrized in the test function.\n\n    \"\"\"\n\n    marker_name: ClassVar[str]\n    description: ClassVar[str]\n    fork_attribute_name: ClassVar[str]\n    marker_parameter_names: ClassVar[List[str]]\n\n    def __init__(self, metafunc: Metafunc):\n        \"\"\"\n        Initialize the covariant decorator.\n\n        The decorator must already be subclassed with the appropriate class variables before\n        initialization.\n\n        Args:\n            metafunc: The metafunc object that pytest uses when generating tests.\n\n        \"\"\"\n        self.metafunc = metafunc\n\n        m = metafunc.definition.iter_markers(self.marker_name)\n        if m is None:\n            return\n        marker_list = list(m)\n        assert len(marker_list) &lt;= 1, f\"Multiple markers {self.marker_name} found\"\n        if len(marker_list) == 0:\n            return\n        marker = marker_list[0]\n\n        assert marker is not None\n        assert len(marker.args) == 0, \"Only keyword arguments are supported\"\n\n        kwargs = dict(marker.kwargs)\n\n        selector = kwargs.pop(\"selector\", lambda _: True)\n        assert isinstance(selector, FunctionType), \"selector must be a function\"\n\n        marks = kwargs.pop(\"marks\", None)\n\n        if len(kwargs) &gt; 0:\n            raise ValueError(f\"Unknown arguments to {self.marker_name}: {kwargs}\")\n\n        def fn(fork: Fork) -&gt; List[Any]:\n            return getattr(fork, self.fork_attribute_name)(block_number=0, timestamp=0)\n\n        super().__init__(\n            argnames=self.marker_parameter_names,\n            fn=fn,\n            selector=selector,\n            marks=marks,\n        )\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.CovariantDecorator.__init__","title":"<code>__init__(metafunc)</code>","text":"<p>Initialize the covariant decorator.</p> <p>The decorator must already be subclassed with the appropriate class variables before initialization.</p> <p>Parameters:</p> Name Type Description Default <code>metafunc</code> <code>Metafunc</code> <p>The metafunc object that pytest uses when generating tests.</p> required Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>def __init__(self, metafunc: Metafunc):\n    \"\"\"\n    Initialize the covariant decorator.\n\n    The decorator must already be subclassed with the appropriate class variables before\n    initialization.\n\n    Args:\n        metafunc: The metafunc object that pytest uses when generating tests.\n\n    \"\"\"\n    self.metafunc = metafunc\n\n    m = metafunc.definition.iter_markers(self.marker_name)\n    if m is None:\n        return\n    marker_list = list(m)\n    assert len(marker_list) &lt;= 1, f\"Multiple markers {self.marker_name} found\"\n    if len(marker_list) == 0:\n        return\n    marker = marker_list[0]\n\n    assert marker is not None\n    assert len(marker.args) == 0, \"Only keyword arguments are supported\"\n\n    kwargs = dict(marker.kwargs)\n\n    selector = kwargs.pop(\"selector\", lambda _: True)\n    assert isinstance(selector, FunctionType), \"selector must be a function\"\n\n    marks = kwargs.pop(\"marks\", None)\n\n    if len(kwargs) &gt; 0:\n        raise ValueError(f\"Unknown arguments to {self.marker_name}: {kwargs}\")\n\n    def fn(fork: Fork) -&gt; List[Any]:\n        return getattr(fork, self.fork_attribute_name)(block_number=0, timestamp=0)\n\n    super().__init__(\n        argnames=self.marker_parameter_names,\n        fn=fn,\n        selector=selector,\n        marks=marks,\n    )\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.covariant_decorator","title":"<code>covariant_decorator(*, marker_name, description, fork_attribute_name, argnames)</code>","text":"<p>Generate a new covariant decorator subclass.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>def covariant_decorator(\n    *,\n    marker_name: str,\n    description: str,\n    fork_attribute_name: str,\n    argnames: List[str],\n) -&gt; Type[CovariantDecorator]:\n    \"\"\"Generate a new covariant decorator subclass.\"\"\"\n    return type(\n        marker_name,\n        (CovariantDecorator,),\n        {\n            \"marker_name\": marker_name,\n            \"description\": description,\n            \"fork_attribute_name\": fork_attribute_name,\n            \"marker_parameter_names\": argnames,\n        },\n    )\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.pytest_configure","title":"<code>pytest_configure(config)</code>","text":"<p>Register the plugin's custom markers and process command-line options.</p> <p>Custom marker registration: https://docs.pytest.org/en/7.1.x/how-to/writing_plugins.html#registering-custom-markers</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>@pytest.hookimpl(tryfirst=True)\ndef pytest_configure(config: pytest.Config):\n    \"\"\"\n    Register the plugin's custom markers and process command-line options.\n\n    Custom marker registration:\n    https://docs.pytest.org/en/7.1.x/how-to/writing_plugins.html#registering-custom-markers\n    \"\"\"\n    config.addinivalue_line(\n        \"markers\",\n        (\n            \"valid_at_transition_to(fork, subsequent_forks: bool = False, \"\n            \"until: str | None = None): specifies a test case is only valid \"\n            \"at the specified fork transition boundaries\"\n        ),\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"valid_from(fork): specifies from which fork a test case is valid\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"valid_until(fork): specifies until which fork a test case is valid\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        (\n            \"parametrize_by_fork(names, values_fn): parametrize a test case by fork using the \"\n            \"specified names and values returned by the function values_fn(fork)\"\n        ),\n    )\n    for d in fork_covariant_decorators:\n        config.addinivalue_line(\"markers\", f\"{d.marker_name}: {d.description}\")\n\n    forks = {fork for fork in get_forks() if not fork.ignore()}\n    config.all_forks = forks  # type: ignore\n    config.all_forks_by_name = {fork.name(): fork for fork in forks}  # type: ignore\n    config.all_forks_with_transitions = {  # type: ignore\n        fork for fork in set(get_forks()) | get_transition_forks() if not fork.ignore()\n    }\n\n    available_forks_help = textwrap.dedent(\n        f\"\"\"\\\n        Available forks:\n        {\", \".join(fork.name() for fork in forks)}\n        \"\"\"\n    )\n    available_forks_help += textwrap.dedent(\n        f\"\"\"\\\n        Available transition forks:\n        {\", \".join([fork.name() for fork in get_transition_forks()])}\n        \"\"\"\n    )\n\n    def get_fork_option(config, option_name: str, parameter_name: str) -&gt; Set[Fork]:\n        \"\"\"Post-process get option to allow for external fork conditions.\"\"\"\n        config_str = config.getoption(option_name)\n        if not config_str:\n            return set()\n\n        forks_str = config_str.split(\",\")\n        forks_str = [s.strip() for s in config_str.split(\",\")]\n        # Alias for \"Merge\"\n        forks_str = [(\"Paris\" if s.lower() == \"merge\" else s) for s in forks_str]\n\n        resulting_forks = set()\n        for fork in config.all_forks_with_transitions:\n            if fork.name() in forks_str:\n                resulting_forks.add(fork)\n\n        if len(resulting_forks) != len(forks_str):\n            print(\n                f\"Error: Unsupported fork provided to {parameter_name}:\",\n                config_str,\n                \"\\n\",\n                file=sys.stderr,\n            )\n            print(available_forks_help, file=sys.stderr)\n            pytest.exit(\"Invalid command-line options.\", returncode=pytest.ExitCode.USAGE_ERROR)\n\n        return resulting_forks\n\n    single_fork = get_fork_option(config, \"single_fork\", \"--fork\")\n    forks_from = get_fork_option(config, \"forks_from\", \"--from\")\n    forks_until = get_fork_option(config, \"forks_until\", \"--until\")\n    show_fork_help = config.getoption(\"show_fork_help\")\n\n    dev_forks_help = textwrap.dedent(\n        \"To run tests for a fork under active development, it must be \"\n        \"specified explicitly via --until=FORK.\\n\"\n        \"Tests are only ran for deployed mainnet forks by default, i.e., \"\n        f\"until {get_deployed_forks()[-1].name()}.\\n\"\n    )\n    if show_fork_help:\n        print(available_forks_help)\n        print(dev_forks_help)\n        pytest.exit(\"After displaying help.\", returncode=0)\n\n    if single_fork and (forks_from or forks_until):\n        print(\n            \"Error: --fork cannot be used in combination with --from or --until\", file=sys.stderr\n        )\n        pytest.exit(\"Invalid command-line options.\", returncode=pytest.ExitCode.USAGE_ERROR)\n\n    if single_fork:\n        selected_fork_set = single_fork\n    else:\n        if not forks_from:\n            forks_from = get_forks_with_no_parents(forks)\n        if not forks_until:\n            forks_until = get_last_descendants(set(get_deployed_forks()), forks_from)\n        selected_fork_set = get_from_until_fork_set(forks, forks_from, forks_until)\n        for fork in list(selected_fork_set):\n            transition_fork_set = transition_fork_to(fork)\n            selected_fork_set |= transition_fork_set\n\n    config.selected_fork_set = selected_fork_set  # type: ignore\n\n    if not selected_fork_set:\n        print(\n            f\"Error: --from {','.join(fork.name() for fork in forks_from)} \"\n            f\"--until {','.join(fork.name() for fork in forks_until)} \"\n            \"creates an empty fork range.\",\n            file=sys.stderr,\n        )\n        pytest.exit(\n            \"Command-line options produce empty fork range.\",\n            returncode=pytest.ExitCode.USAGE_ERROR,\n        )\n\n    # with --collect-only, we don't have access to these config options\n    config.unsupported_forks: Set[Fork] = set()  # type: ignore\n    if config.option.collectonly:\n        return\n\n    evm_bin = config.getoption(\"evm_bin\", None)\n    if evm_bin is not None:\n        t8n = TransitionTool.from_binary_path(binary_path=evm_bin)\n        config.unsupported_forks = frozenset(  # type: ignore\n            fork for fork in selected_fork_set if not t8n.is_fork_supported(fork)\n        )\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.pytest_report_header","title":"<code>pytest_report_header(config, start_path)</code>","text":"<p>Pytest hook called to obtain the report header.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>@pytest.hookimpl(trylast=True)\ndef pytest_report_header(config, start_path):\n    \"\"\"Pytest hook called to obtain the report header.\"\"\"\n    bold = \"\\033[1m\"\n    warning = \"\\033[93m\"\n    reset = \"\\033[39;49m\"\n    header = [\n        (\n            bold\n            + \"Generating fixtures for: \"\n            + \", \".join([f.name() for f in sorted(config.selected_fork_set)])\n            + reset\n        ),\n    ]\n    if all(fork.is_deployed() for fork in config.selected_fork_set):\n        header += [\n            (\n                bold + warning + \"Only generating fixtures with stable/deployed forks: \"\n                \"Specify an upcoming fork via --until=fork to \"\n                \"add forks under development.\" + reset\n            )\n        ]\n    return header\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.fork","title":"<code>fork(request)</code>","text":"<p>Parametrize test cases by fork.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>@pytest.fixture(autouse=True)\ndef fork(request):\n    \"\"\"Parametrize test cases by fork.\"\"\"\n    pass\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.ValidityMarker","title":"<code>ValidityMarker</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class to represent any fork validity marker.</p> <p>Subclassing this class allows for the creation of new validity markers.</p> <p>Instantiation must be done per test function, and the <code>process</code> method must be called to process the fork arguments.</p> <p>When subclassing, the following optional parameters can be set: - marker_name: Name of the marker, if not set, the class name is converted to underscore. - mutually_exclusive: Whether the marker must be used in isolation.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>@dataclass(kw_only=True)\nclass ValidityMarker(ABC):\n    \"\"\"\n    Abstract class to represent any fork validity marker.\n\n    Subclassing this class allows for the creation of new validity markers.\n\n    Instantiation must be done per test function, and the `process` method must be called to\n    process the fork arguments.\n\n    When subclassing, the following optional parameters can be set:\n    - marker_name: Name of the marker, if not set, the class name is converted to underscore.\n    - mutually_exclusive: Whether the marker must be used in isolation.\n    \"\"\"\n\n    marker_name: ClassVar[str]\n    mutually_exclusive: ClassVar[bool]\n\n    test_name: str\n    all_forks: Set[Fork]\n    all_forks_by_name: Mapping[str, Fork]\n    mark: Mark\n\n    def __init_subclass__(\n        cls, *, marker_name: str | None = None, mutually_exclusive=False\n    ) -&gt; None:\n        \"\"\"Register the validity marker subclass.\"\"\"\n        super().__init_subclass__()\n        if marker_name is not None:\n            cls.marker_name = marker_name\n        else:\n            # Use the class name converted to underscore: https://stackoverflow.com/a/1176023\n            cls.marker_name = MARKER_NAME_REGEX.sub(\"_\", cls.__name__).lower()\n        cls.mutually_exclusive = mutually_exclusive\n        if cls in ALL_VALIDITY_MARKERS:\n            raise ValueError(f\"Duplicate validity marker class: {cls}\")\n        ALL_VALIDITY_MARKERS.append(cls)\n\n    def process_fork_arguments(self, *fork_args: str) -&gt; Set[Fork]:\n        \"\"\"Process the fork arguments.\"\"\"\n        fork_names: Set[str] = set()\n        for fork_arg in fork_args:\n            fork_names_list = fork_arg.strip().split(\",\")\n            expected_length_after_append = len(fork_names) + len(fork_names_list)\n            fork_names |= set(fork_names_list)\n            if len(fork_names) != expected_length_after_append:\n                pytest.fail(\n                    f\"'{self.test_name}': Duplicate argument specified in '{self.marker_name}'.\"\n                )\n        forks: Set[Fork] = set()\n        for fork_name in fork_names:\n            if fork_name not in self.all_forks_by_name:\n                pytest.fail(f\"'{self.test_name}': Invalid fork '{fork_name}' specified.\")\n            forks.add(self.all_forks_by_name[fork_name])\n        return forks\n\n    @classmethod\n    def get_validity_marker(cls, metafunc: Metafunc) -&gt; \"ValidityMarker | None\":\n        \"\"\"\n        Instantiate a validity marker for the test function.\n\n        If the test function does not contain the marker, return None.\n        \"\"\"\n        test_name = metafunc.function.__name__\n        validity_markers = list(metafunc.definition.iter_markers(cls.marker_name))\n        if not validity_markers:\n            return None\n\n        if len(validity_markers) &gt; 1:\n            pytest.fail(f\"'{test_name}': Too many '{cls.marker_name}' markers applied to test. \")\n        mark = validity_markers[0]\n        if len(mark.args) == 0:\n            pytest.fail(f\"'{test_name}': Missing fork argument with '{cls.marker_name}' marker. \")\n\n        all_forks_by_name: Mapping[str, Fork] = metafunc.config.all_forks_by_name  # type: ignore\n        all_forks: Set[Fork] = metafunc.config.all_forks  # type: ignore\n\n        return cls(\n            test_name=test_name,\n            all_forks_by_name=all_forks_by_name,\n            all_forks=all_forks,\n            mark=mark,\n        )\n\n    @staticmethod\n    def get_all_validity_markers(metafunc: Metafunc) -&gt; List[\"ValidityMarker\"]:\n        \"\"\"Get all the validity markers applied to the test function.\"\"\"\n        test_name = metafunc.function.__name__\n\n        validity_markers: List[ValidityMarker] = []\n        for validity_marker_class in ALL_VALIDITY_MARKERS:\n            if validity_marker := validity_marker_class.get_validity_marker(metafunc):\n                validity_markers.append(validity_marker)\n\n        if len(validity_markers) &gt; 1:\n            mutually_exclusive_markers = [\n                validity_marker\n                for validity_marker in validity_markers\n                if validity_marker.mutually_exclusive\n            ]\n            if mutually_exclusive_markers:\n                names = [\n                    f\"'{validity_marker.marker_name}'\" for validity_marker in validity_markers\n                ]\n                concatenated_names = \" and \".join([\", \".join(names[:-1])] + names[-1:])\n                pytest.fail(f\"'{test_name}': The markers {concatenated_names} can't be combined. \")\n\n        return validity_markers\n\n    def process(self) -&gt; Set[Fork]:\n        \"\"\"Process the fork arguments.\"\"\"\n        return self._process_with_marker_args(*self.mark.args, **self.mark.kwargs)\n\n    @abstractmethod\n    def _process_with_marker_args(self, *args, **kwargs) -&gt; Set[Fork]:\n        \"\"\"\n        Process the fork arguments as specified for the marker.\n\n        Method must be implemented by the subclass.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.ValidityMarker.__init_subclass__","title":"<code>__init_subclass__(*, marker_name=None, mutually_exclusive=False)</code>","text":"<p>Register the validity marker subclass.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>def __init_subclass__(\n    cls, *, marker_name: str | None = None, mutually_exclusive=False\n) -&gt; None:\n    \"\"\"Register the validity marker subclass.\"\"\"\n    super().__init_subclass__()\n    if marker_name is not None:\n        cls.marker_name = marker_name\n    else:\n        # Use the class name converted to underscore: https://stackoverflow.com/a/1176023\n        cls.marker_name = MARKER_NAME_REGEX.sub(\"_\", cls.__name__).lower()\n    cls.mutually_exclusive = mutually_exclusive\n    if cls in ALL_VALIDITY_MARKERS:\n        raise ValueError(f\"Duplicate validity marker class: {cls}\")\n    ALL_VALIDITY_MARKERS.append(cls)\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.ValidityMarker.process_fork_arguments","title":"<code>process_fork_arguments(*fork_args)</code>","text":"<p>Process the fork arguments.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>def process_fork_arguments(self, *fork_args: str) -&gt; Set[Fork]:\n    \"\"\"Process the fork arguments.\"\"\"\n    fork_names: Set[str] = set()\n    for fork_arg in fork_args:\n        fork_names_list = fork_arg.strip().split(\",\")\n        expected_length_after_append = len(fork_names) + len(fork_names_list)\n        fork_names |= set(fork_names_list)\n        if len(fork_names) != expected_length_after_append:\n            pytest.fail(\n                f\"'{self.test_name}': Duplicate argument specified in '{self.marker_name}'.\"\n            )\n    forks: Set[Fork] = set()\n    for fork_name in fork_names:\n        if fork_name not in self.all_forks_by_name:\n            pytest.fail(f\"'{self.test_name}': Invalid fork '{fork_name}' specified.\")\n        forks.add(self.all_forks_by_name[fork_name])\n    return forks\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.ValidityMarker.get_validity_marker","title":"<code>get_validity_marker(metafunc)</code>  <code>classmethod</code>","text":"<p>Instantiate a validity marker for the test function.</p> <p>If the test function does not contain the marker, return None.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>@classmethod\ndef get_validity_marker(cls, metafunc: Metafunc) -&gt; \"ValidityMarker | None\":\n    \"\"\"\n    Instantiate a validity marker for the test function.\n\n    If the test function does not contain the marker, return None.\n    \"\"\"\n    test_name = metafunc.function.__name__\n    validity_markers = list(metafunc.definition.iter_markers(cls.marker_name))\n    if not validity_markers:\n        return None\n\n    if len(validity_markers) &gt; 1:\n        pytest.fail(f\"'{test_name}': Too many '{cls.marker_name}' markers applied to test. \")\n    mark = validity_markers[0]\n    if len(mark.args) == 0:\n        pytest.fail(f\"'{test_name}': Missing fork argument with '{cls.marker_name}' marker. \")\n\n    all_forks_by_name: Mapping[str, Fork] = metafunc.config.all_forks_by_name  # type: ignore\n    all_forks: Set[Fork] = metafunc.config.all_forks  # type: ignore\n\n    return cls(\n        test_name=test_name,\n        all_forks_by_name=all_forks_by_name,\n        all_forks=all_forks,\n        mark=mark,\n    )\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.ValidityMarker.get_all_validity_markers","title":"<code>get_all_validity_markers(metafunc)</code>  <code>staticmethod</code>","text":"<p>Get all the validity markers applied to the test function.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>@staticmethod\ndef get_all_validity_markers(metafunc: Metafunc) -&gt; List[\"ValidityMarker\"]:\n    \"\"\"Get all the validity markers applied to the test function.\"\"\"\n    test_name = metafunc.function.__name__\n\n    validity_markers: List[ValidityMarker] = []\n    for validity_marker_class in ALL_VALIDITY_MARKERS:\n        if validity_marker := validity_marker_class.get_validity_marker(metafunc):\n            validity_markers.append(validity_marker)\n\n    if len(validity_markers) &gt; 1:\n        mutually_exclusive_markers = [\n            validity_marker\n            for validity_marker in validity_markers\n            if validity_marker.mutually_exclusive\n        ]\n        if mutually_exclusive_markers:\n            names = [\n                f\"'{validity_marker.marker_name}'\" for validity_marker in validity_markers\n            ]\n            concatenated_names = \" and \".join([\", \".join(names[:-1])] + names[-1:])\n            pytest.fail(f\"'{test_name}': The markers {concatenated_names} can't be combined. \")\n\n    return validity_markers\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.ValidityMarker.process","title":"<code>process()</code>","text":"<p>Process the fork arguments.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>def process(self) -&gt; Set[Fork]:\n    \"\"\"Process the fork arguments.\"\"\"\n    return self._process_with_marker_args(*self.mark.args, **self.mark.kwargs)\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.ValidFrom","title":"<code>ValidFrom</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ValidityMarker</code></p> <p>Marker used to specify the fork from which the test is valid. The test will not be filled for forks before the specified fork.</p> <pre><code>import pytest\n\nfrom ethereum_test_tools import Alloc, StateTestFiller\n\n@pytest.mark.valid_from(\"London\")\ndef test_something_only_valid_after_london(\n    state_test: StateTestFiller,\n    pre: Alloc\n):\n    pass\n</code></pre> <p>In this example, the test will only be filled for the London fork and after, e.g. London, Paris, Shanghai, Cancun, etc.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>class ValidFrom(ValidityMarker):\n    \"\"\"\n    Marker used to specify the fork from which the test is valid. The test will not be filled for\n    forks before the specified fork.\n\n    ```python\n    import pytest\n\n    from ethereum_test_tools import Alloc, StateTestFiller\n\n    @pytest.mark.valid_from(\"London\")\n    def test_something_only_valid_after_london(\n        state_test: StateTestFiller,\n        pre: Alloc\n    ):\n        pass\n    ```\n\n    In this example, the test will only be filled for the London fork and after, e.g. London,\n    Paris, Shanghai, Cancun, etc.\n    \"\"\"\n\n    def _process_with_marker_args(self, *fork_args) -&gt; Set[Fork]:\n        \"\"\"Process the fork arguments.\"\"\"\n        forks: Set[Fork] = self.process_fork_arguments(*fork_args)\n        resulting_set: Set[Fork] = set()\n        for fork in forks:\n            resulting_set |= {f for f in self.all_forks if f &gt;= fork}\n        return resulting_set\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.ValidUntil","title":"<code>ValidUntil</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ValidityMarker</code></p> <p>Marker to specify the fork until which the test is valid. The test will not be filled for forks after the specified fork.</p> <pre><code>import pytest\n\nfrom ethereum_test_tools import Alloc, StateTestFiller\n\n@pytest.mark.valid_until(\"London\")\ndef test_something_only_valid_until_london(\n    state_test: StateTestFiller,\n    pre: Alloc\n):\n    pass\n</code></pre> <p>In this example, the test will only be filled for the London fork and before, e.g. London, Berlin, Istanbul, etc.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>class ValidUntil(ValidityMarker):\n    \"\"\"\n    Marker to specify the fork until which the test is valid. The test will not be filled for\n    forks after the specified fork.\n\n    ```python\n    import pytest\n\n    from ethereum_test_tools import Alloc, StateTestFiller\n\n    @pytest.mark.valid_until(\"London\")\n    def test_something_only_valid_until_london(\n        state_test: StateTestFiller,\n        pre: Alloc\n    ):\n        pass\n    ```\n\n    In this example, the test will only be filled for the London fork and before, e.g. London,\n    Berlin, Istanbul, etc.\n    \"\"\"\n\n    def _process_with_marker_args(self, *fork_args) -&gt; Set[Fork]:\n        \"\"\"Process the fork arguments.\"\"\"\n        forks: Set[Fork] = self.process_fork_arguments(*fork_args)\n        resulting_set: Set[Fork] = set()\n        for fork in forks:\n            resulting_set |= {f for f in self.all_forks if f &lt;= fork}\n        return resulting_set\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.ValidAtTransitionTo","title":"<code>ValidAtTransitionTo</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ValidityMarker</code></p> <p>Marker to specify that a test is only meant to be filled at the transition to the specified fork.</p> <p>The test usually starts at the fork prior to the specified fork at genesis and at block 5 (for pre-merge forks) or at timestamp 15,000 (for post-merge forks) the fork transition occurs.</p> <pre><code>import pytest\n\nfrom ethereum_test_tools import Alloc, BlockchainTestFiller\n\n@pytest.mark.valid_at_transition_to(\"London\")\ndef test_something_that_happens_during_the_fork_transition_to_london(\n    blockchain_test: BlockchainTestFiller,\n    pre: Alloc\n):\n    pass\n</code></pre> <p>In this example, the test will only be filled for the fork that transitions to London at block number 5, <code>BerlinToLondonAt5</code>, and no other forks.</p> <p>To see or add a new transition fork, see the <code>ethereum_test_forks.forks.transition</code> module.</p> <p>Note that the test uses a <code>BlockchainTestFiller</code> fixture instead of a <code>StateTestFiller</code>, as the transition forks are used to test changes throughout the blockchain progression, and not just the state change of a single transaction.</p> <p>This marker also accepts the following keyword arguments:</p> <ul> <li><code>subsequent_transitions</code>: Force the test to also fill for subsequent fork transitions.</li> <li><code>until</code>: Implies <code>subsequent_transitions</code> and puts a limit on which transition fork will the     test filling will be limited to.</li> </ul> <p>For example: <pre><code>@pytest.mark.valid_at_transition_to(\"Cancun\", subsequent_transitions=True)\n</code></pre></p> <p>produces tests on <code>ShanghaiToCancunAtTime15k</code> and <code>CancunToPragueAtTime15k</code>, and any transition fork after that.</p> <p>And: <pre><code>@pytest.mark.valid_at_transition_to(\"Cancun\", subsequent_transitions=True, until=\"Prague\")\n</code></pre></p> <p>produces tests on <code>ShanghaiToCancunAtTime15k</code> and <code>CancunToPragueAtTime15k</code>, but no forks after Prague.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>class ValidAtTransitionTo(ValidityMarker, mutually_exclusive=True):\n    \"\"\"\n    Marker to specify that a test is only meant to be filled at the transition to the specified\n    fork.\n\n    The test usually starts at the fork prior to the specified fork at genesis and at block 5 (for\n    pre-merge forks) or at timestamp 15,000 (for post-merge forks) the fork transition occurs.\n\n    ```python\n    import pytest\n\n    from ethereum_test_tools import Alloc, BlockchainTestFiller\n\n    @pytest.mark.valid_at_transition_to(\"London\")\n    def test_something_that_happens_during_the_fork_transition_to_london(\n        blockchain_test: BlockchainTestFiller,\n        pre: Alloc\n    ):\n        pass\n    ```\n\n    In this example, the test will only be filled for the fork that transitions to London at block\n    number 5, `BerlinToLondonAt5`, and no other forks.\n\n    To see or add a new transition fork, see the `ethereum_test_forks.forks.transition` module.\n\n    Note that the test uses a `BlockchainTestFiller` fixture instead of a `StateTestFiller`,\n    as the transition forks are used to test changes throughout the blockchain progression, and\n    not just the state change of a single transaction.\n\n    This marker also accepts the following keyword arguments:\n\n    - `subsequent_transitions`: Force the test to also fill for subsequent fork transitions.\n    - `until`: Implies `subsequent_transitions` and puts a limit on which transition fork will the\n        test filling will be limited to.\n\n    For example:\n    ```python\n    @pytest.mark.valid_at_transition_to(\"Cancun\", subsequent_transitions=True)\n    ```\n\n    produces tests on `ShanghaiToCancunAtTime15k` and `CancunToPragueAtTime15k`, and any transition\n    fork after that.\n\n    And:\n    ```python\n    @pytest.mark.valid_at_transition_to(\"Cancun\", subsequent_transitions=True, until=\"Prague\")\n    ```\n\n    produces tests on `ShanghaiToCancunAtTime15k` and `CancunToPragueAtTime15k`, but no forks after\n    Prague.\n    \"\"\"\n\n    def _process_with_marker_args(\n        self, *fork_args, subsequent_forks: bool = False, until: str | None = None\n    ) -&gt; Set[Fork]:\n        \"\"\"Process the fork arguments.\"\"\"\n        forks: Set[Fork] = self.process_fork_arguments(*fork_args)\n        until_forks: Set[Fork] | None = (\n            None if until is None else self.process_fork_arguments(until)\n        )\n        if len(forks) == 0:\n            pytest.fail(\n                f\"'{self.test_name}': Missing fork argument with 'valid_at_transition_to' marker.\"\n            )\n\n        if len(forks) &gt; 1:\n            pytest.fail(\n                f\"'{self.test_name}': Too many forks specified to 'valid_at_transition_to' marker.\"\n            )\n\n        resulting_set: Set[Fork] = set()\n        for fork in forks:\n            resulting_set |= transition_fork_to(fork)\n            if subsequent_forks:\n                for transition_forks in (\n                    transition_fork_to(f) for f in self.all_forks if f &gt; fork\n                ):\n                    for transition_fork in transition_forks:\n                        if transition_fork and (\n                            until_forks is None\n                            or any(transition_fork &lt;= until_fork for until_fork in until_forks)\n                        ):\n                            resulting_set.add(transition_fork)\n        return resulting_set\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.pytest_generate_tests","title":"<code>pytest_generate_tests(metafunc)</code>","text":"<p>Pytest hook used to dynamically generate test cases.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>def pytest_generate_tests(metafunc: pytest.Metafunc):\n    \"\"\"Pytest hook used to dynamically generate test cases.\"\"\"\n    test_name = metafunc.function.__name__\n\n    validity_markers: List[ValidityMarker] = ValidityMarker.get_all_validity_markers(metafunc)\n\n    if not validity_markers:\n        # Limit to non-transition forks if no validity markers were applied\n        test_fork_set: Set[Fork] = metafunc.config.all_forks  # type: ignore\n    else:\n        # Start with all forks and transitions if any validity markers were applied\n        test_fork_set: Set[Fork] = metafunc.config.all_forks_with_transitions  # type: ignore\n        for validity_marker in validity_markers:\n            # Apply the validity markers to the test function if applicable\n            test_fork_set = test_fork_set &amp; validity_marker.process()\n\n    if not test_fork_set:\n        pytest.fail(\n            \"The test function's \"\n            f\"'{test_name}' fork validity markers generate \"\n            \"an empty fork range. Please check the arguments to its \"\n            f\"markers:  @pytest.mark.valid_from and \"\n            f\"@pytest.mark.valid_until.\"\n        )\n\n    intersection_set = test_fork_set &amp; metafunc.config.selected_fork_set  # type: ignore\n\n    if \"fork\" not in metafunc.fixturenames:\n        return\n\n    pytest_params: List[Any]\n    if not intersection_set:\n        if metafunc.config.getoption(\"verbose\") &gt;= 2:\n            pytest_params = [\n                pytest.param(\n                    None,\n                    marks=[\n                        pytest.mark.skip(\n                            reason=(\n                                f\"{test_name} is not valid for any any of forks specified on \"\n                                \"the command-line.\"\n                            )\n                        )\n                    ],\n                )\n            ]\n            metafunc.parametrize(\"fork\", pytest_params, scope=\"function\")\n    else:\n        unsupported_forks: Set[Fork] = metafunc.config.unsupported_forks  # type: ignore\n        pytest_params = [\n            (\n                ForkParametrizer(\n                    fork=fork,\n                    marks=[\n                        pytest.mark.skip(\n                            reason=(\n                                f\"Fork '{fork}' unsupported by \"\n                                f\"'{metafunc.config.getoption('evm_bin')}'.\"\n                            )\n                        )\n                    ],\n                )\n                if fork in sorted(unsupported_forks)\n                else ForkParametrizer(fork=fork)\n            )\n            for fork in sorted(intersection_set)\n        ]\n        add_fork_covariant_parameters(metafunc, pytest_params)\n        parametrize_fork(metafunc, pytest_params)\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.add_fork_covariant_parameters","title":"<code>add_fork_covariant_parameters(metafunc, fork_parametrizers)</code>","text":"<p>Iterate over the fork covariant descriptors and add their values to the test function.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>def add_fork_covariant_parameters(\n    metafunc: Metafunc, fork_parametrizers: List[ForkParametrizer]\n) -&gt; None:\n    \"\"\"Iterate over the fork covariant descriptors and add their values to the test function.\"\"\"\n    for covariant_descriptor in fork_covariant_decorators:\n        for fork_parametrizer in fork_parametrizers:\n            covariant_descriptor(metafunc=metafunc).add_values(fork_parametrizer=fork_parametrizer)\n\n    for marker in metafunc.definition.iter_markers():\n        if marker.name == \"parametrize_by_fork\":\n            descriptor = CovariantDescriptor(\n                *marker.args,\n                **marker.kwargs,\n            )\n            for fork_parametrizer in fork_parametrizers:\n                descriptor.add_values(fork_parametrizer=fork_parametrizer)\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.parameters_from_fork_parametrizer_list","title":"<code>parameters_from_fork_parametrizer_list(fork_parametrizers)</code>","text":"<p>Get the parameters from the fork parametrizers.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>def parameters_from_fork_parametrizer_list(\n    fork_parametrizers: List[ForkParametrizer],\n) -&gt; Tuple[List[str], List[ParameterSet]]:\n    \"\"\"Get the parameters from the fork parametrizers.\"\"\"\n    param_names: List[str] = []\n    param_values: List[ParameterSet] = []\n\n    for fork_parametrizer in fork_parametrizers:\n        if not param_names:\n            param_names = fork_parametrizer.argnames\n        else:\n            assert param_names == fork_parametrizer.argnames\n        param_values.extend(fork_parametrizer.argvalues)\n\n    # Remove duplicate parameters\n    param_1 = 0\n    while param_1 &lt; len(param_names):\n        param_2 = param_1 + 1\n        while param_2 &lt; len(param_names):\n            if param_names[param_1] == param_names[param_2]:\n                i = 0\n                while i &lt; len(param_values):\n                    if param_values[i].values[param_1] != param_values[i].values[param_2]:\n                        del param_values[i]\n                    else:\n                        param_values[i] = pytest.param(\n                            *param_values[i].values[:param_2],\n                            *param_values[i].values[(param_2 + 1) :],\n                            id=param_values[i].id,\n                            marks=param_values[i].marks,\n                        )\n                        i += 1\n\n                del param_names[param_2]\n            else:\n                param_2 += 1\n        param_1 += 1\n\n    return param_names, param_values\n</code></pre>"},{"location":"library/pytest_plugins/forks/#pytest_plugins.forks.forks.parametrize_fork","title":"<code>parametrize_fork(metafunc, fork_parametrizers)</code>","text":"<p>Add the fork parameters to the test function.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>def parametrize_fork(metafunc: Metafunc, fork_parametrizers: List[ForkParametrizer]) -&gt; None:\n    \"\"\"Add the fork parameters to the test function.\"\"\"\n    metafunc.parametrize(\n        *parameters_from_fork_parametrizer_list(fork_parametrizers), scope=\"function\"\n    )\n</code></pre>"},{"location":"library/pytest_plugins/spec_version_checker/","title":"Spec Version Checker Plugin","text":"<p>A pytest plugin that verifies the tested version of an EIP specification against the latest version from the ethereum/EIPs Github repository.</p> <p>A pytest plugin that checks that the spec version specified in test/filler modules matches that of ethereum/EIPs.</p>"},{"location":"library/pytest_plugins/spec_version_checker/#pytest_plugins.spec_version_checker.spec_version_checker.pytest_configure","title":"<code>pytest_configure(config)</code>","text":"<p>Register the plugin's custom markers and process command-line options.</p> <p>Custom marker registration: https://docs.pytest.org/en/7.1.x/how-to/writing_plugins.html#registering-custom-markers</p> Source code in <code>src/pytest_plugins/spec_version_checker/spec_version_checker.py</code> <pre><code>@pytest.hookimpl(tryfirst=True)\ndef pytest_configure(config):\n    \"\"\"\n    Register the plugin's custom markers and process command-line options.\n\n    Custom marker registration:\n    https://docs.pytest.org/en/7.1.x/how-to/writing_plugins.html#registering-custom-markers\n    \"\"\"\n    config.addinivalue_line(\n        \"markers\",\n        \"eip_version_check: a test that tests the reference spec defined in an EIP test module.\",\n    )\n</code></pre>"},{"location":"library/pytest_plugins/spec_version_checker/#pytest_plugins.spec_version_checker.spec_version_checker.get_ref_spec_from_module","title":"<code>get_ref_spec_from_module(module)</code>","text":"<p>Return the reference spec object defined in a module.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the module path contains \"eip\" and the module does not define a reference spec.</p> <p>Returns:</p> Name Type Description <code>spec_obj</code> <code>None | ReferenceSpec</code> <p>Return None if the module path does not contain \"eip\", i.e., the module is not required to define a reference spec, otherwise, return the ReferenceSpec object as defined by the module.</p> Source code in <code>src/pytest_plugins/spec_version_checker/spec_version_checker.py</code> <pre><code>def get_ref_spec_from_module(module: ModuleType) -&gt; None | ReferenceSpec:\n    \"\"\"\n    Return the reference spec object defined in a module.\n\n    Raises:\n        Exception: If the module path contains \"eip\" and the module\n            does not define a reference spec.\n\n    Returns:\n        spec_obj: Return None if the module path does not contain \"eip\",\n            i.e., the module is not required to define a reference spec,\n            otherwise, return the ReferenceSpec object as defined by the\n            module.\n\n    \"\"\"\n    if not is_test_for_an_eip(str(module.__file__)):\n        return None\n    module_dict = module.__dict__\n    parseable_ref_specs = [\n        ref_spec_type\n        for ref_spec_type in ReferenceSpecTypes\n        if ref_spec_type.parseable_from_module(module_dict)\n    ]\n    if len(parseable_ref_specs) &gt; 0:\n        module_dict = module.__dict__\n        try:\n            spec_obj = parseable_ref_specs[0].parse_from_module(module_dict)\n        except Exception as e:\n            raise Exception(f\"Error in spec_version_checker: {e} (this test is generated).\") from e\n    else:\n        raise Exception(\"Test doesn't define REFERENCE_SPEC_GIT_PATH and REFERENCE_SPEC_VERSION\")\n    return spec_obj\n</code></pre>"},{"location":"library/pytest_plugins/spec_version_checker/#pytest_plugins.spec_version_checker.spec_version_checker.reference_spec","title":"<code>reference_spec(request)</code>","text":"<p>Pytest fixture that returns the reference spec defined in a module.</p> <p>See <code>get_ref_spec_from_module</code>.</p> Source code in <code>src/pytest_plugins/spec_version_checker/spec_version_checker.py</code> <pre><code>@pytest.fixture(autouse=True, scope=\"module\")\ndef reference_spec(request) -&gt; None | ReferenceSpec:\n    \"\"\"\n    Pytest fixture that returns the reference spec defined in a module.\n\n    See `get_ref_spec_from_module`.\n    \"\"\"\n    return get_ref_spec_from_module(request.module)\n</code></pre>"},{"location":"library/pytest_plugins/spec_version_checker/#pytest_plugins.spec_version_checker.spec_version_checker.is_test_for_an_eip","title":"<code>is_test_for_an_eip(input_string)</code>","text":"<p>Return True if <code>input_string</code> contains an EIP number, i.e., eipNNNN.</p> Source code in <code>src/pytest_plugins/spec_version_checker/spec_version_checker.py</code> <pre><code>def is_test_for_an_eip(input_string: str) -&gt; bool:\n    \"\"\"Return True if `input_string` contains an EIP number, i.e., eipNNNN.\"\"\"\n    pattern = re.compile(r\".*eip\\d{1,4}\", re.IGNORECASE)\n    if pattern.match(input_string):\n        return True\n    return False\n</code></pre>"},{"location":"library/pytest_plugins/spec_version_checker/#pytest_plugins.spec_version_checker.spec_version_checker.test_eip_spec_version","title":"<code>test_eip_spec_version(module)</code>","text":"<p>Test that the ReferenceSpec object as defined in the test module is not outdated when compared to the remote hash from ethereum/EIPs.</p> Source code in <code>src/pytest_plugins/spec_version_checker/spec_version_checker.py</code> <pre><code>def test_eip_spec_version(module: ModuleType):\n    \"\"\"\n    Test that the ReferenceSpec object as defined in the test module\n    is not outdated when compared to the remote hash from\n    ethereum/EIPs.\n    \"\"\"\n    ref_spec = get_ref_spec_from_module(module)\n    assert ref_spec, \"No reference spec object defined\"\n\n    message = (\n        \"The version of the spec referenced in \"\n        f\"{module} does not match that from ethereum/EIPs, \"\n        f\"tests might be outdated: Spec: {ref_spec.name()}. \"\n        f\"Referenced version: {ref_spec.known_version()}. \"\n        f\"Latest version: {ref_spec.latest_version()}. The \"\n        f\"version was retrieved from {ref_spec.api_url()}.\"\n    )\n    try:\n        is_up_to_date = not ref_spec.is_outdated()\n    except Exception as e:\n        raise Exception(\n            f\"Error in spec_version_checker: {e} (this test is generated). \"\n            f\"Reference spec URL: {ref_spec.api_url()}.\"\n        ) from e\n\n    assert is_up_to_date, message\n</code></pre>"},{"location":"library/pytest_plugins/spec_version_checker/#pytest_plugins.spec_version_checker.spec_version_checker.EIPSpecTestItem","title":"<code>EIPSpecTestItem</code>","text":"<p>               Bases: <code>Item</code></p> <p>Custom pytest test item to test EIP spec versions.</p> Source code in <code>src/pytest_plugins/spec_version_checker/spec_version_checker.py</code> <pre><code>class EIPSpecTestItem(Item):\n    \"\"\"Custom pytest test item to test EIP spec versions.\"\"\"\n\n    def __init__(self, name, parent, module):\n        \"\"\"Initialize the test item.\"\"\"\n        super().__init__(name, parent)\n        self.module = module\n\n    @classmethod\n    def from_parent(cls, parent, module):\n        \"\"\"\n        Public constructor to define new tests.\n        https://docs.pytest.org/en/latest/reference/reference.html#pytest.nodes.Node.from_parent.\n        \"\"\"\n        return super().from_parent(parent=parent, name=\"test_eip_spec_version\", module=module)\n\n    def runtest(self):\n        \"\"\"Define the test to execute for this item.\"\"\"\n        test_eip_spec_version(self.module)\n\n    def reportinfo(self):\n        \"\"\"Get location information for this test item to use test reports.\"\"\"\n        return \"spec_version_checker\", 0, f\"{self.name}\"\n</code></pre>"},{"location":"library/pytest_plugins/spec_version_checker/#pytest_plugins.spec_version_checker.spec_version_checker.EIPSpecTestItem.__init__","title":"<code>__init__(name, parent, module)</code>","text":"<p>Initialize the test item.</p> Source code in <code>src/pytest_plugins/spec_version_checker/spec_version_checker.py</code> <pre><code>def __init__(self, name, parent, module):\n    \"\"\"Initialize the test item.\"\"\"\n    super().__init__(name, parent)\n    self.module = module\n</code></pre>"},{"location":"library/pytest_plugins/spec_version_checker/#pytest_plugins.spec_version_checker.spec_version_checker.EIPSpecTestItem.from_parent","title":"<code>from_parent(parent, module)</code>  <code>classmethod</code>","text":"<p>Public constructor to define new tests. https://docs.pytest.org/en/latest/reference/reference.html#pytest.nodes.Node.from_parent.</p> Source code in <code>src/pytest_plugins/spec_version_checker/spec_version_checker.py</code> <pre><code>@classmethod\ndef from_parent(cls, parent, module):\n    \"\"\"\n    Public constructor to define new tests.\n    https://docs.pytest.org/en/latest/reference/reference.html#pytest.nodes.Node.from_parent.\n    \"\"\"\n    return super().from_parent(parent=parent, name=\"test_eip_spec_version\", module=module)\n</code></pre>"},{"location":"library/pytest_plugins/spec_version_checker/#pytest_plugins.spec_version_checker.spec_version_checker.EIPSpecTestItem.runtest","title":"<code>runtest()</code>","text":"<p>Define the test to execute for this item.</p> Source code in <code>src/pytest_plugins/spec_version_checker/spec_version_checker.py</code> <pre><code>def runtest(self):\n    \"\"\"Define the test to execute for this item.\"\"\"\n    test_eip_spec_version(self.module)\n</code></pre>"},{"location":"library/pytest_plugins/spec_version_checker/#pytest_plugins.spec_version_checker.spec_version_checker.EIPSpecTestItem.reportinfo","title":"<code>reportinfo()</code>","text":"<p>Get location information for this test item to use test reports.</p> Source code in <code>src/pytest_plugins/spec_version_checker/spec_version_checker.py</code> <pre><code>def reportinfo(self):\n    \"\"\"Get location information for this test item to use test reports.\"\"\"\n    return \"spec_version_checker\", 0, f\"{self.name}\"\n</code></pre>"},{"location":"library/pytest_plugins/spec_version_checker/#pytest_plugins.spec_version_checker.spec_version_checker.pytest_collection_modifyitems","title":"<code>pytest_collection_modifyitems(session, config, items)</code>","text":"<p>Insert a new test EIPSpecTestItem for every test modules that contains 'eip' in its path.</p> Source code in <code>src/pytest_plugins/spec_version_checker/spec_version_checker.py</code> <pre><code>def pytest_collection_modifyitems(session, config, items):\n    \"\"\"\n    Insert a new test EIPSpecTestItem for every test modules that\n    contains 'eip' in its path.\n    \"\"\"\n    modules = {item.parent for item in items if isinstance(item.parent, Module)}\n    new_test_eip_spec_version_items = [\n        EIPSpecTestItem.from_parent(module, module.obj)\n        for module in modules\n        if is_test_for_an_eip(str(module.path))\n    ]\n    for item in new_test_eip_spec_version_items:\n        item.add_marker(\"eip_version_check\", append=True)\n    items.extend(new_test_eip_spec_version_items)\n</code></pre>"},{"location":"tests/","title":"Tests","text":"<p>Documentation for <code>tests@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests --fork Prague\n</code></pre> <p>Cross-client test cases organized by fork. Each directory underneath <code>tests/</code> contains test cases corresponding to the fork in which the functionality-under-test was introduced.</p>"},{"location":"tests/berlin/","title":"Berlin","text":"<p>Documentation for <code>tests/berlin@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/berlin --fork Prague\n</code></pre> <p>Test cases for EVM functionality introduced in Berlin.</p>"},{"location":"tests/berlin/eip2930_access_list/","title":"EIP-2930 Access List","text":"<p>Documentation for <code>tests/berlin/eip2930_access_list@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/berlin/eip2930_access_list --fork Prague\n</code></pre> Tests EIP-2930: Optional access lists <p>Test cases for EIP-2930: Optional access lists.</p>"},{"location":"tests/berlin/eip2930_access_list/test_acl/","title":"Test ACL","text":"<p>Documentation for <code>tests/berlin/eip2930_access_list/test_acl.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/berlin/eip2930_access_list/test_acl.py --fork Prague\n</code></pre> <p>Test ACL Transaction Source Code Examples.</p>"},{"location":"tests/berlin/eip2930_access_list/test_acl/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_access_list</code> state_test 1 Test type 1 transaction."},{"location":"tests/byzantium/","title":"Byzantium","text":"<p>Documentation for <code>tests/byzantium@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/byzantium --fork Prague\n</code></pre> <p>Test cases for EVM functionality introduced in Byzantium.</p>"},{"location":"tests/byzantium/eip198_modexp_precompile/","title":"EIP-198 Modexp Precompile","text":"<p>Documentation for <code>tests/byzantium/eip198_modexp_precompile@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/byzantium/eip198_modexp_precompile --fork Prague\n</code></pre> <p>Test for precompiles introduced in Byzantium.</p>"},{"location":"tests/byzantium/eip198_modexp_precompile/test_modexp/","title":"Test Modexp","text":"<p>Documentation for <code>tests/byzantium/eip198_modexp_precompile/test_modexp.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/byzantium/eip198_modexp_precompile/test_modexp.py --fork Prague\n</code></pre> Test EIP-198: MODEXP Precompile <p>Tests the MODEXP precompile, located at address 0x0000..0005. Test cases from the EIP are labelled with <code>EIP-198-caseX</code> in the test id.</p>"},{"location":"tests/byzantium/eip198_modexp_precompile/test_modexp/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_modexp</code> state_test 16 Test the MODEXP precompile."},{"location":"tests/cancun/","title":"Cancun","text":"<p>Documentation for <code>tests/cancun@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun --fork Prague\n</code></pre> <p>Test cases for EVM functionality introduced in Cancun.</p> <p>See EIP-7659: Hardfork Meta - Dencun for a list of EIPS included in Dencun (Deneb/Cancun).</p>"},{"location":"tests/cancun/eip1153_tstore/","title":"EIP-1153 TSTORE","text":"<p>Documentation for <code>tests/cancun/eip1153_tstore@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip1153_tstore --fork Prague\n</code></pre> <p>EIP-1153 Tests.</p>"},{"location":"tests/cancun/eip1153_tstore/spec/","title":"Spec","text":"<p>Documentation for <code>tests/cancun/eip1153_tstore/spec.py@af77f529</code>.</p> <p>Defines EIP-1153 specification constants and functions.</p>"},{"location":"tests/cancun/eip1153_tstore/spec/#tests.cancun.eip1153_tstore.spec.Spec","title":"<code>Spec</code>  <code>dataclass</code>","text":"<p>Parameters from the EIP-1153 specifications as defined at https://eips.ethereum.org/EIPS/eip-1153.</p> Source code in <code>tests/cancun/eip1153_tstore/spec.py</code> <pre><code>@dataclass(frozen=True)\nclass Spec:\n    \"\"\"\n    Parameters from the EIP-1153 specifications as defined at\n    https://eips.ethereum.org/EIPS/eip-1153.\n    \"\"\"\n\n    TLOAD_OPCODE_BYTE = 0x5C\n    TSTORE_OPCODE_BYTE = 0x5D\n    TLOAD_GAS_COST = 100\n    TSTORE_GAS_COST = 100\n</code></pre>"},{"location":"tests/cancun/eip1153_tstore/test_basic_tload/","title":"Test Basic TLOAD","text":"<p>Documentation for <code>tests/cancun/eip1153_tstore/test_basic_tload.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip1153_tstore/test_basic_tload.py --fork Prague\n</code></pre> <p>Ethereum Transient Storage EIP Tests https://eips.ethereum.org/EIPS/eip-1153.</p>"},{"location":"tests/cancun/eip1153_tstore/test_basic_tload/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_basic_tload_transaction_begin</code> state_test 1 Ported .json vectors. <code>test_basic_tload_works</code> state_test 1 Ported .json vectors. <code>test_basic_tload_other_after_tstore</code> state_test 1 Ported .json vectors. <code>test_basic_tload_gasprice</code> state_test 1 Ported .json vectors. <code>test_basic_tload_after_store</code> state_test 1 Ported .json vectors."},{"location":"tests/cancun/eip1153_tstore/test_tload_calls/","title":"Test TLOAD Calls","text":"<p>Documentation for <code>tests/cancun/eip1153_tstore/test_tload_calls.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip1153_tstore/test_tload_calls.py --fork Prague\n</code></pre> <p>Ethereum Transient Storage EIP Tests https://eips.ethereum.org/EIPS/eip-1153.</p>"},{"location":"tests/cancun/eip1153_tstore/test_tload_calls/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_tload_calls</code> state_test 3 Ported .json vectors."},{"location":"tests/cancun/eip1153_tstore/test_tload_reentrancy/","title":"Test TLOAD Reentrancy","text":"<p>Documentation for <code>tests/cancun/eip1153_tstore/test_tload_reentrancy.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip1153_tstore/test_tload_reentrancy.py --fork Prague\n</code></pre> <p>Ethereum Transient Storage EIP Tests https://eips.ethereum.org/EIPS/eip-1153.</p>"},{"location":"tests/cancun/eip1153_tstore/test_tload_reentrancy/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_tload_reentrancy</code> state_test 24 Ported .json vectors."},{"location":"tests/cancun/eip1153_tstore/test_tstorage/","title":"Test Tstorage","text":"<p>Documentation for <code>tests/cancun/eip1153_tstore/test_tstorage.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip1153_tstore/test_tstorage.py --fork Prague\n</code></pre> Tests EIP-1153: Transient Storage Opcodes <p>Test EIP-1153: Transient Storage Opcodes. Ports and extends some tests from ethereum/tests/src/EIPTestsFiller/StateTests/stEIP1153-transientStorage/.</p>"},{"location":"tests/cancun/eip1153_tstore/test_tstorage/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_transient_storage_unset_values</code> state_test 1 Test that tload returns zero for unset values. Loading an arbitrary value is <code>test_tload_after_tstore</code> state_test 1 Loading after storing returns the stored value: TSTORE(x, y), TLOAD(x) <code>test_tload_after_sstore</code> state_test 1 Loading after storing returns the stored value: TSTORE(x, y), TLOAD(x) <code>test_tload_after_tstore_is_zero</code> state_test 1 Test that tload returns zero after tstore is called with zero. <code>test_gas_usage</code> state_test 4 Test that tstore and tload consume the expected gas. <code>test_run_until_out_of_gas</code> state_test 3 Use TSTORE over and over to different keys until we run out of gas."},{"location":"tests/cancun/eip1153_tstore/test_tstorage_clear_after_tx/","title":"Test Tstorage Clear After Tx","text":"<p>Documentation for <code>tests/cancun/eip1153_tstore/test_tstorage_clear_after_tx.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip1153_tstore/test_tstorage_clear_after_tx.py --fork Prague\n</code></pre> <p>Ethereum Transient Storage EIP Tests https://eips.ethereum.org/EIPS/eip-1153.</p>"},{"location":"tests/cancun/eip1153_tstore/test_tstorage_clear_after_tx/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_tstore_clear_after_deployment_tx</code> blockchain_test 1 First creates a contract, which TSTOREs a value 1 in slot 1. <code>test_tstore_clear_after_tx</code> blockchain_test 1 First SSTOREs the TLOAD value of key 1 in slot 1. Then, it TSTOREs 1 in slot 1."},{"location":"tests/cancun/eip1153_tstore/test_tstorage_create_contexts/","title":"Test Tstorage CREATE Contexts","text":"<p>Documentation for <code>tests/cancun/eip1153_tstore/test_tstorage_create_contexts.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip1153_tstore/test_tstorage_create_contexts.py --fork Prague\n</code></pre> Tests for EIP-1153: Transient Storage <p>Test cases for <code>TSTORE</code> and <code>TLOAD</code> opcode calls in contract initcode.</p>"},{"location":"tests/cancun/eip1153_tstore/test_tstorage_create_contexts/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_contract_creation</code> state_test 10 Test transient storage in contract creation contexts."},{"location":"tests/cancun/eip1153_tstore/test_tstorage_execution_contexts/","title":"Test Tstorage Execution Contexts","text":"<p>Documentation for <code>tests/cancun/eip1153_tstore/test_tstorage_execution_contexts.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip1153_tstore/test_tstorage_execution_contexts.py --fork Prague\n</code></pre> Tests for EIP-1153: Transient Storage <p>Test cases for <code>TSTORE</code> and <code>TLOAD</code> opcode calls in different execution contexts.</p>"},{"location":"tests/cancun/eip1153_tstore/test_tstorage_execution_contexts/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_subcall</code> state_test 30 Test transient storage with a subcall using the following opcodes."},{"location":"tests/cancun/eip1153_tstore/test_tstorage_reentrancy_contexts/","title":"Test Tstorage Reentrancy Contexts","text":"<p>Documentation for <code>tests/cancun/eip1153_tstore/test_tstorage_reentrancy_contexts.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip1153_tstore/test_tstorage_reentrancy_contexts.py --fork Prague\n</code></pre> Tests for EIP-1153: Transient Storage <p>Test cases for <code>TSTORE</code> and <code>TLOAD</code> opcode calls in reentrancy contexts.</p>"},{"location":"tests/cancun/eip1153_tstore/test_tstorage_reentrancy_contexts/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_reentrant_call</code> state_test 10 Test transient storage in different reentrancy contexts."},{"location":"tests/cancun/eip1153_tstore/test_tstorage_selfdestruct/","title":"Test Tstorage SELFDESTRUCT","text":"<p>Documentation for <code>tests/cancun/eip1153_tstore/test_tstorage_selfdestruct.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip1153_tstore/test_tstorage_selfdestruct.py --fork Prague\n</code></pre> Tests for EIP-1153: Transient Storage <p>Test cases for <code>TSTORE</code> and <code>TLOAD</code> opcode calls in reentrancy after self-destruct, taking into account the changes in EIP-6780.</p>"},{"location":"tests/cancun/eip1153_tstore/test_tstorage_selfdestruct/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_reentrant_selfdestructing_call</code> state_test 6 Test transient storage in different reentrancy contexts after selfdestructing."},{"location":"tests/cancun/eip1153_tstore/test_tstore_reentrancy/","title":"Test TSTORE Reentrancy","text":"<p>Documentation for <code>tests/cancun/eip1153_tstore/test_tstore_reentrancy.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip1153_tstore/test_tstore_reentrancy.py --fork Prague\n</code></pre> <p>Ethereum Transient Storage EIP Tests https://eips.ethereum.org/EIPS/eip-1153.</p>"},{"location":"tests/cancun/eip1153_tstore/test_tstore_reentrancy/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_tstore_reentrancy</code> state_test 24 Ported .json vectors."},{"location":"tests/cancun/eip4788_beacon_root/","title":"EIP-4788 Beacon Root","text":"<p>Documentation for <code>tests/cancun/eip4788_beacon_root@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip4788_beacon_root --fork Prague\n</code></pre> <p>Cross-client EIP-4788 Tests.</p>"},{"location":"tests/cancun/eip4788_beacon_root/spec/","title":"Spec","text":"<p>Documentation for <code>tests/cancun/eip4788_beacon_root/spec.py@af77f529</code>.</p> <p>Defines EIP-4788 specification constants and functions.</p>"},{"location":"tests/cancun/eip4788_beacon_root/spec/#tests.cancun.eip4788_beacon_root.spec.Spec","title":"<code>Spec</code>  <code>dataclass</code>","text":"<p>Parameters from the EIP-4788 specifications as defined at https://eips.ethereum.org/EIPS/eip-4788#specification.</p> Source code in <code>tests/cancun/eip4788_beacon_root/spec.py</code> <pre><code>@dataclass(frozen=True)\nclass Spec:\n    \"\"\"\n    Parameters from the EIP-4788 specifications as defined at\n    https://eips.ethereum.org/EIPS/eip-4788#specification.\n    \"\"\"\n\n    BEACON_ROOTS_ADDRESS = 0x000F3DF6D732807EF1319FB7B8BB8522D0BEAC02\n    BEACON_ROOTS_CALL_GAS = 100_000\n    BEACON_ROOTS_DEPLOYER_ADDRESS = 0x0B799C86A49DEEB90402691F1041AA3AF2D3C875\n    HISTORY_BUFFER_LENGTH = 8_191\n    SYSTEM_ADDRESS = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE\n    FORK_TIMESTAMP = 15_000  # ShanghaiToCancun timestamp\n</code></pre>"},{"location":"tests/cancun/eip4788_beacon_root/spec/#tests.cancun.eip4788_beacon_root.spec.SpecHelpers","title":"<code>SpecHelpers</code>  <code>dataclass</code>","text":"<p>Helper functions closely related to the EIP-4788 specification.</p> Source code in <code>tests/cancun/eip4788_beacon_root/spec.py</code> <pre><code>@dataclass(frozen=True)\nclass SpecHelpers:\n    \"\"\"Helper functions closely related to the EIP-4788 specification.\"\"\"\n\n    def timestamp_index(self, timestamp: int) -&gt; int:\n        \"\"\"Derive the timestamp index into the timestamp ring buffer.\"\"\"\n        return timestamp % Spec.HISTORY_BUFFER_LENGTH\n\n    def root_index(self, timestamp: int) -&gt; int:\n        \"\"\"Derive the root index into the root ring buffer.\"\"\"\n        return self.timestamp_index(timestamp) + Spec.HISTORY_BUFFER_LENGTH\n\n    @staticmethod\n    def expected_storage(\n        *,\n        beacon_root: bytes,\n        valid_call: bool,\n        valid_input: bool,\n    ) -&gt; Storage:\n        \"\"\"\n        Derive expected storage for a given beacon root contract call\n        dependent on:\n        - success or failure of the call\n        - validity of the timestamp input used within the call.\n        \"\"\"\n        # By default assume the call is unsuccessful and all keys are zero\n        storage = Storage({k: 0 for k in range(4)})  # type: ignore\n        if valid_call and valid_input:\n            # beacon root contract call is successful\n            storage[0] = 1\n            storage[1] = beacon_root\n            storage[2] = 32\n            storage[3] = beacon_root\n\n        return storage\n</code></pre>"},{"location":"tests/cancun/eip4788_beacon_root/test_beacon_root_contract/","title":"Test Beacon Root Contract","text":"<p>Documentation for <code>tests/cancun/eip4788_beacon_root/test_beacon_root_contract.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip4788_beacon_root/test_beacon_root_contract.py --fork Prague\n</code></pre> Tests beacon block root for EIP-4788: Beacon block root in the EVM <p>Test the exposed beacon chain root in the EVM for EIP-4788: Beacon block root in the EVM.</p> Adding a new test <p>Add a function that is named <code>test_&lt;test_name&gt;</code> and takes at least the following arguments:</p> <ul> <li>state_test</li> <li>env</li> <li>pre</li> <li>tx</li> <li>post</li> <li>valid_call</li> </ul> <p>All other <code>pytest.fixtures</code> can be parametrized to generate new combinations and test cases.</p>"},{"location":"tests/cancun/eip4788_beacon_root/test_beacon_root_contract/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_beacon_root_contract_calls</code> blockchain_test 10 Tests the beacon root contract call using various call contexts:(\ud83d\udcd6\ud83d\udc1b?) <code>test_beacon_root_contract_timestamps</code> blockchain_test 24 Tests the beacon root contract call across for various valid and invalid timestamps. <code>test_calldata_lengths</code> blockchain_test 5 Tests the beacon root contract call using multiple invalid input lengths. <code>test_beacon_root_equal_to_timestamp</code> blockchain_test 8 Tests the beacon root contract call where the beacon root is equal to the timestamp. <code>test_tx_to_beacon_root_contract</code> blockchain_test 8 Tests the beacon root contract using a transaction with different types and data lengths. <code>test_invalid_beacon_root_calldata_value</code> blockchain_test 1 Tests the beacon root contract call using invalid input values:(\ud83d\udcd6\ud83d\udc1b?) <code>test_beacon_root_selfdestruct</code> blockchain_test 1 Tests that self destructing the beacon root address transfers actors balance correctly. <code>test_multi_block_beacon_root_timestamp_calls</code> blockchain_test 5 Tests multiple blocks where each block writes a timestamp to storage and contains one <code>test_beacon_root_transition</code> blockchain_test 0 Tests the fork transition to cancun and verifies that blocks with timestamp lower than the <code>test_no_beacon_root_contract_at_transition</code> blockchain_test 0 Tests the fork transition to cancun in the case where the beacon root pre-deploy was not <code>test_beacon_root_contract_deploy</code> blockchain_test 0 Tests the fork transition to cancun deploying the contract during Shanghai and verifying the"},{"location":"tests/cancun/eip4844_blobs/","title":"EIP-4844 Blobs","text":"<p>Documentation for <code>tests/cancun/eip4844_blobs@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip4844_blobs --fork Prague\n</code></pre> <p>Cross-client EIP-4844 Tests.</p>"},{"location":"tests/cancun/eip4844_blobs/point_evaluation_vectors/","title":"Readme","text":"<p>Markdown Content</p> <p>Below is the verbatim markdown content from <code>tests/cancun/eip4844_blobs/point_evaluation_vectors/README.md@af77f529</code>.</p>"},{"location":"tests/cancun/eip4844_blobs/point_evaluation_vectors/#kzg-point-evaluation-test-vectors","title":"KZG Point Evaluation Test Vectors","text":"<p>This directory contains test vectors for the KZG point evaluation algorithm that are loaded and used throughout different tests.</p> <p>Each file must contain a JSON list of objects, each with the following fields:</p> <ul> <li><code>name</code>: a string describing the test case</li> <li><code>input</code>: object containing <code>commitment</code>, <code>proof</code>, <code>z</code> and <code>y</code></li> <li><code>output</code>: expected output of the evaluation, true, false or null.</li> </ul>"},{"location":"tests/cancun/eip4844_blobs/point_evaluation_vectors/#generating-the-test-vectors-used-in-v106-and-on","title":"Generating The Test Vectors (used in v1.0.6 and on)","text":"<p>From execution-spec-tests release v1.0.6 and on, the point evaluation test vectors were generated using commit 63aa303c from the official-kzg consensus-specs branch.</p> <p>The test vectors were generated as following:</p> <ol> <li> <p>In the consensus-specs repo:</p> <pre><code>cd tests/generators/kzg_4844/\nrm -rf /tmp/kzg_4844_output\nmkdir /tmp/kzg_4844_output\npython -m main --output /tmp/kzg_4844_output\n</code></pre> </li> <li> <p>In the execution-spec-tests repo:</p> <pre><code>cd tests/cancun/4844_blobs/point_evaluation_vectors/\npip install -r requirements.txt\npython concat_kzg_vectors_to_json.py \\\n    --input /tmp/kzg_4844_output/general/deneb/kzg/verify_kzg_proof/kzg-mainnet/\n    --output go_kzg_4844_verify_kzg_proof.json\n</code></pre> </li> </ol>"},{"location":"tests/cancun/eip4844_blobs/point_evaluation_vectors/#previous-versions-of-the-test-vectors-used-up-to-v105","title":"Previous Versions of the Test Vectors (used up to v1.0.5)","text":"<p>The test vectors up and including execution-spec-tests release v1.0.5 were: - <code>go_kzg_4844_verify_kzg_proof.json</code>: test vectors from the go-kzg-4844 repository.</p>"},{"location":"tests/cancun/eip4844_blobs/spec/","title":"Spec","text":"<p>Documentation for <code>tests/cancun/eip4844_blobs/spec.py@af77f529</code>.</p> <p>Defines EIP-4844 specification constants and functions.</p>"},{"location":"tests/cancun/eip4844_blobs/spec/#tests.cancun.eip4844_blobs.spec.Spec","title":"<code>Spec</code>  <code>dataclass</code>","text":"<p>Parameters from the EIP-4844 specifications as defined at https://eips.ethereum.org/EIPS/eip-4844#parameters.</p> <p>If the parameter is not currently used within the tests, it is commented out.</p> Source code in <code>tests/cancun/eip4844_blobs/spec.py</code> <pre><code>@dataclass(frozen=True)\nclass Spec:\n    \"\"\"\n    Parameters from the EIP-4844 specifications as defined at\n    https://eips.ethereum.org/EIPS/eip-4844#parameters.\n\n    If the parameter is not currently used within the tests, it is commented\n    out.\n    \"\"\"\n\n    BLOB_TX_TYPE = 0x03\n    FIELD_ELEMENTS_PER_BLOB = 4096\n    BLS_MODULUS = 0x73EDA753299D7D483339D80809A1D80553BDA402FFFE5BFEFFFFFFFF00000001\n    BLOB_COMMITMENT_VERSION_KZG = 1\n    POINT_EVALUATION_PRECOMPILE_ADDRESS = 10\n    POINT_EVALUATION_PRECOMPILE_GAS = 50_000\n    # MAX_VERSIONED_HASHES_LIST_SIZE = 2**24\n    # MAX_CALLDATA_SIZE = 2**24\n    # MAX_ACCESS_LIST_SIZE = 2**24\n    # MAX_ACCESS_LIST_STORAGE_KEYS = 2**24\n    # MAX_TX_WRAP_COMMITMENTS = 2**12\n    # LIMIT_BLOBS_PER_TX = 2**12\n    HASH_OPCODE_BYTE = 0x49\n    HASH_GAS_COST = 3\n\n    @classmethod\n    def kzg_to_versioned_hash(\n        cls,\n        kzg_commitment: bytes | int,  # 48 bytes\n        blob_commitment_version_kzg: Optional[bytes | int] = None,\n    ) -&gt; bytes:\n        \"\"\"Calculate versioned hash for a given KZG commitment.\"\"\"\n        if blob_commitment_version_kzg is None:\n            blob_commitment_version_kzg = cls.BLOB_COMMITMENT_VERSION_KZG\n        if isinstance(kzg_commitment, int):\n            kzg_commitment = kzg_commitment.to_bytes(48, \"big\")\n        if isinstance(blob_commitment_version_kzg, int):\n            blob_commitment_version_kzg = blob_commitment_version_kzg.to_bytes(1, \"big\")\n        return blob_commitment_version_kzg + sha256(kzg_commitment).digest()[1:]\n\n    @classmethod\n    def get_total_blob_gas(cls, *, tx: Transaction, blob_gas_per_blob: int) -&gt; int:\n        \"\"\"Calculate the total blob gas for a transaction.\"\"\"\n        if tx.blob_versioned_hashes is None:\n            return 0\n        return blob_gas_per_blob * len(tx.blob_versioned_hashes)\n</code></pre>"},{"location":"tests/cancun/eip4844_blobs/spec/#tests.cancun.eip4844_blobs.spec.SpecHelpers","title":"<code>SpecHelpers</code>  <code>dataclass</code>","text":"<p>Define parameters and helper functions that are tightly coupled to the 4844 spec but not strictly part of it.</p> Source code in <code>tests/cancun/eip4844_blobs/spec.py</code> <pre><code>@dataclass(frozen=True)\nclass SpecHelpers:\n    \"\"\"\n    Define parameters and helper functions that are tightly coupled to the 4844\n    spec but not strictly part of it.\n    \"\"\"\n\n    BYTES_PER_FIELD_ELEMENT = 32\n\n    @classmethod\n    def get_min_excess_blob_gas_for_blob_gas_price(\n        cls,\n        *,\n        fork: Fork,\n        blob_gas_price: int,\n    ) -&gt; int:\n        \"\"\"\n        Get the minimum required excess blob gas value to get a given blob gas cost in a\n        block.\n        \"\"\"\n        current_excess_blob_gas = 0\n        current_blob_gas_price = 1\n        get_blob_gas_price = fork.blob_gas_price_calculator()\n        gas_per_blob = fork.blob_gas_per_blob()\n        while current_blob_gas_price &lt; blob_gas_price:\n            current_excess_blob_gas += gas_per_blob\n            current_blob_gas_price = get_blob_gas_price(excess_blob_gas=current_excess_blob_gas)\n        return current_excess_blob_gas\n\n    @classmethod\n    def get_min_excess_blobs_for_blob_gas_price(\n        cls,\n        *,\n        fork: Fork,\n        blob_gas_price: int,\n    ) -&gt; int:\n        \"\"\"Get the minimum required excess blobs to get a given blob gas cost in a block.\"\"\"\n        gas_per_blob = fork.blob_gas_per_blob()\n        return (\n            cls.get_min_excess_blob_gas_for_blob_gas_price(\n                fork=fork,\n                blob_gas_price=blob_gas_price,\n            )\n            // gas_per_blob\n        )\n\n    @classmethod\n    def get_blob_combinations(\n        cls,\n        blob_count: int,\n    ) -&gt; List[Tuple[int, ...]]:\n        \"\"\"Get all possible combinations of blobs that result in a given blob count.\"\"\"\n        combinations = [\n            seq\n            for i in range(\n                blob_count + 1, 0, -1\n            )  # We can have from 1 to at most MAX_BLOBS_PER_BLOCK blobs per block\n            for seq in itertools.combinations_with_replacement(\n                range(1, blob_count + 2), i\n            )  # We iterate through all possible combinations\n            if sum(seq) == blob_count  # And we only keep the ones that match the\n            # expected invalid blob count\n        ]\n\n        # We also add the reversed version of each combination, only if it's not\n        # already in the list. E.g. (4, 1) is added from (1, 4) but not\n        # (1, 1, 1, 1, 1) because its reversed version is identical.\n        combinations += [\n            tuple(reversed(x)) for x in combinations if tuple(reversed(x)) not in combinations\n        ]\n        return combinations\n\n    @classmethod\n    def all_valid_blob_combinations(cls, fork: Fork) -&gt; List[Tuple[int, ...]]:\n        \"\"\"\n        Return all valid blob tx combinations for a given block,\n        assuming the given MAX_BLOBS_PER_BLOCK.\n        \"\"\"\n        max_blobs_per_block = fork.max_blobs_per_block()\n        combinations: List[Tuple[int, ...]] = []\n        for i in range(1, max_blobs_per_block + 1):\n            combinations += cls.get_blob_combinations(i)\n        return combinations\n\n    @classmethod\n    def invalid_blob_combinations(cls, fork: Fork) -&gt; List[Tuple[int, ...]]:\n        \"\"\"\n        Return invalid blob tx combinations for a given block that use up to\n        MAX_BLOBS_PER_BLOCK+1 blobs.\n        \"\"\"\n        max_blobs_per_block = fork.max_blobs_per_block()\n        return cls.get_blob_combinations(max_blobs_per_block + 1)\n</code></pre>"},{"location":"tests/cancun/eip4844_blobs/test_blob_txs/","title":"Test Blob Txs","text":"<p>Documentation for <code>tests/cancun/eip4844_blobs/test_blob_txs.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip4844_blobs/test_blob_txs.py --fork Prague\n</code></pre> Tests blob type transactions for EIP-4844: Shard Blob Transactions <p>Test blob type transactions for EIP-4844: Shard Blob Transactions.</p> Adding a new test <p>Add a function that is named <code>test_&lt;test_name&gt;</code> and takes at least the following arguments:</p> <ul> <li>blockchain_test or state_test</li> <li>pre</li> <li>env</li> <li>block or txs</li> </ul> <p>All other <code>pytest.fixture</code> fixtures can be parametrized to generate new combinations and test cases.</p>"},{"location":"tests/cancun/eip4844_blobs/test_blob_txs/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_valid_blob_tx_combinations</code> blockchain_test 169 Test all valid blob combinations in a single block, assuming a given value of <code>test_invalid_tx_max_fee_per_blob_gas</code> blockchain_test 2 Reject blocks with invalid blob txs. <code>test_invalid_tx_max_fee_per_blob_gas_state</code> state_test 2 Reject an invalid blob transaction. <code>test_invalid_normal_gas</code> state_test 1 Reject an invalid blob transaction. <code>test_invalid_block_blob_count</code> blockchain_test 80 Test all invalid blob combinations in a single block, where the sum of all blobs in a block is <code>test_insufficient_balance_blob_tx</code> state_test 144 Reject blocks where user cannot afford the blob gas specified (but <code>test_sufficient_balance_blob_tx</code> state_test 288 Check that transaction is accepted when user can exactly afford the blob gas specified (and <code>test_sufficient_balance_blob_tx_pre_fund_tx</code> blockchain_test 288 Check that transaction is accepted when user can exactly afford the blob gas specified (and <code>test_blob_gas_subtraction_tx</code> state_test 128 Check that the blob gas fee for a transaction is subtracted from the sender balance before the <code>test_insufficient_balance_blob_tx_combinations</code> blockchain_test 169 Reject all valid blob transaction combinations in a block, but block is invalid. <code>test_invalid_tx_blob_count</code> state_test 2 Reject blocks that include blob transactions with invalid blob counts. <code>test_invalid_blob_hash_versioning_single_tx</code> state_test 4 Reject blob transactions with invalid blob hash version. <code>test_invalid_blob_hash_versioning_multiple_txs</code> blockchain_test 4 Reject blocks that include blob transactions with invalid blob hash <code>test_invalid_blob_tx_contract_creation</code> blockchain_test 1 Reject blocks that include blob transactions that have nil to value (contract creating). <code>test_blob_tx_attribute_opcodes</code> state_test 2 Test opcodes that read transaction attributes work properly for blob type transactions. <code>test_blob_tx_attribute_value_opcode</code> state_test 3 Test the VALUE opcode with different blob type transaction value amounts. <code>test_blob_tx_attribute_calldata_opcodes</code> state_test 9 Test calldata related opcodes to verify their behavior is not affected by blobs. <code>test_blob_tx_attribute_gasprice_opcode</code> state_test 4 Test GASPRICE opcode to sanity check that the blob gas fee does not affect its calculation. <code>test_blob_type_tx_pre_fork</code> state_test 0 Reject blocks with blob type transactions before Cancun fork."},{"location":"tests/cancun/eip4844_blobs/test_blob_txs_full/","title":"Test Blob Txs Full","text":"<p>Documentation for <code>tests/cancun/eip4844_blobs/test_blob_txs_full.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip4844_blobs/test_blob_txs_full.py --fork Prague\n</code></pre> Tests full blob type transactions for EIP-4844: Shard Blob Transactions <p>Test full blob type transactions for EIP-4844: Shard Blob Transactions.</p>"},{"location":"tests/cancun/eip4844_blobs/test_blob_txs_full/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_reject_valid_full_blob_in_block_rlp</code> blockchain_test 3 Test valid blob combinations where one or more txs in the block"},{"location":"tests/cancun/eip4844_blobs/test_blobhash_opcode/","title":"Test BLOBHASH Opcode","text":"<p>Documentation for <code>tests/cancun/eip4844_blobs/test_blobhash_opcode.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip4844_blobs/test_blobhash_opcode.py --fork Prague\n</code></pre> Tests <code>BLOBHASH</code> opcode in EIP-4844: Shard Blob Transactions <p>Test cases for the <code>BLOBHASH</code> opcode in EIP-4844: Shard Blob Transactions.</p> Adding a new test <p>Add a function that is named <code>test_&lt;test_name&gt;</code> and takes at least the following arguments:</p> <ul> <li>blockchain_test</li> <li>pre</li> <li>tx</li> <li>post</li> </ul> <p>Additional custom <code>pytest.fixture</code> fixtures can be added and parametrized for new test cases.</p> <p>There is no specific structure to follow within this test module.</p>"},{"location":"tests/cancun/eip4844_blobs/test_blobhash_opcode/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_blobhash_gas_cost</code> state_test 28 Tests <code>BLOBHASH</code> opcode gas cost using a variety of indexes. <code>test_blobhash_scenarios</code> blockchain_test 4 Tests that the <code>BLOBHASH</code> opcode returns the correct versioned hash for <code>test_blobhash_invalid_blob_index</code> blockchain_test 1 Tests that the <code>BLOBHASH</code> opcode returns a zeroed <code>bytes32</code> value for invalid <code>test_blobhash_multiple_txs_in_block</code> blockchain_test 1 Tests that the <code>BLOBHASH</code> opcode returns the appropriate values when there"},{"location":"tests/cancun/eip4844_blobs/test_blobhash_opcode_contexts/","title":"Test BLOBHASH Opcode Contexts","text":"<p>Documentation for <code>tests/cancun/eip4844_blobs/test_blobhash_opcode_contexts.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip4844_blobs/test_blobhash_opcode_contexts.py --fork Prague\n</code></pre> Tests <code>BLOBHASH</code> opcode in EIP-4844: Shard Blob Transactions <p>Test case for <code>BLOBHASH</code> opcode calls across different contexts in EIP-4844: Shard Blob Transactions.</p>"},{"location":"tests/cancun/eip4844_blobs/test_blobhash_opcode_contexts/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_blobhash_opcode_contexts</code> blockchain_test 11 Tests that the <code>BLOBHASH</code> opcode functions correctly when called in different contexts."},{"location":"tests/cancun/eip4844_blobs/test_excess_blob_gas/","title":"Test Excess Blob Gas","text":"<p>Documentation for <code>tests/cancun/eip4844_blobs/test_excess_blob_gas.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip4844_blobs/test_excess_blob_gas.py --fork Prague\n</code></pre> Tests <code>excessBlobGas</code> and <code>blobGasUsed</code> block fields for EIP-4844: Shard Blob Transactions <p>Test <code>excessBlobGas</code> and <code>blobGasUsed</code> block fields for EIP-4844: Shard Blob Transactions.</p> Adding a new test <p>Add a function that is named <code>test_&lt;test_name&gt;</code> and takes at least the following arguments:</p> <ul> <li>blockchain_test</li> <li>env</li> <li>pre</li> <li>blocks</li> <li>post</li> <li>correct_excess_blob_gas</li> </ul> <p>The following arguments need to be parametrized or the test will not be generated:</p> <ul> <li>new_blobs</li> </ul> <p>All other <code>pytest.fixture</code> fixtures can be parametrized to generate new combinations and test cases.</p>"},{"location":"tests/cancun/eip4844_blobs/test_excess_blob_gas/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_correct_excess_blob_gas_calculation</code> blockchain_test 70 Test calculation of the <code>excessBlobGas</code> increase/decrease across <code>test_correct_increasing_blob_gas_costs</code> blockchain_test 6 Test calculation of the <code>excessBlobGas</code> and blob gas tx costs at <code>test_correct_decreasing_blob_gas_costs</code> blockchain_test 6 Test calculation of the <code>excessBlobGas</code> and blob gas tx costs at <code>test_invalid_zero_excess_blob_gas_in_header</code> blockchain_test 20 Test rejection of blocks where the <code>excessBlobGas</code> in the header drops to <code>test_invalid_blob_gas_used_in_header</code> blockchain_test 100 Test rejection of blocks where the <code>blobGasUsed</code> in the header is invalid. <code>test_invalid_excess_blob_gas_above_target_change</code> blockchain_test 2 Test rejection of blocks where the <code>excessBlobGas</code>. <code>test_invalid_static_excess_blob_gas</code> blockchain_test 18 Test rejection of blocks where the <code>excessBlobGas</code> remains unchanged <code>test_invalid_excess_blob_gas_target_blobs_increase_from_zero</code> blockchain_test 56 Test rejection of blocks where the <code>excessBlobGas</code> increases from zero, <code>test_invalid_static_excess_blob_gas_from_zero_on_blobs_above_target</code> blockchain_test 3 Test rejection of blocks where the <code>excessBlobGas</code> does not increase from <code>test_invalid_excess_blob_gas_change</code> blockchain_test 120 Test rejection of blocks where the <code>excessBlobGas</code> changes to an invalid <code>test_invalid_negative_excess_blob_gas</code> blockchain_test 216 Test rejection of blocks where the <code>excessBlobGas</code> changes to the two's <code>test_invalid_non_multiple_excess_blob_gas</code> blockchain_test 4 Test rejection of blocks where the <code>excessBlobGas</code> changes to a value that"},{"location":"tests/cancun/eip4844_blobs/test_excess_blob_gas_fork_transition/","title":"Test Excess Blob Gas Fork Transition","text":"<p>Documentation for <code>tests/cancun/eip4844_blobs/test_excess_blob_gas_fork_transition.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip4844_blobs/test_excess_blob_gas_fork_transition.py --fork Prague\n</code></pre> Tests <code>excessBlobGas</code> and <code>blobGasUsed</code> block fields for EIP-4844: Shard Blob Transactions at fork transition. <p>Test <code>excessBlobGas</code> and <code>blobGasUsed</code> block fields for EIP-4844: Shard Blob Transactions at fork transition.</p>"},{"location":"tests/cancun/eip4844_blobs/test_excess_blob_gas_fork_transition/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_invalid_pre_fork_block_with_blob_fields</code> blockchain_test 0 Test block rejection when <code>excessBlobGas</code> and/or <code>blobGasUsed</code> fields are present on a pre-fork <code>test_invalid_post_fork_block_without_blob_fields</code> blockchain_test 0 Test block rejection when <code>excessBlobGas</code> and/or <code>blobGasUsed</code> fields are missing on a <code>test_fork_transition_excess_blob_gas_at_blob_genesis</code> blockchain_test 0 Test <code>excessBlobGas</code> calculation in the header when the fork is activated. <code>test_fork_transition_excess_blob_gas_post_blob_genesis</code> blockchain_test 0 Test <code>excessBlobGas</code> calculation in the header when the fork is activated."},{"location":"tests/cancun/eip4844_blobs/test_point_evaluation_precompile/","title":"Test Point Evaluation Precompile","text":"<p>Documentation for <code>tests/cancun/eip4844_blobs/test_point_evaluation_precompile.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip4844_blobs/test_point_evaluation_precompile.py --fork Prague\n</code></pre> Tests point evaluation precompile for EIP-4844: Shard Blob Transactions <p>Test point evaluation precompile for EIP-4844: Shard Blob Transactions.</p> Adding a new test <p>Add a function that is named <code>test_&lt;test_name&gt;</code> and takes at least the following arguments:</p> <ul> <li>blockchain_test | state_test</li> <li>pre</li> <li>tx</li> <li>post</li> </ul> <p>The following arguments need to be parametrized or the test will not be generated:</p> <ul> <li>versioned_hash</li> <li>kzg_commitment</li> <li>z</li> <li>y</li> <li>kzg_proof</li> <li>result</li> </ul> <p>These values correspond to a single call of the precompile, and <code>result</code> refers to whether the call should succeed or fail.</p> <p>All other <code>pytest.fixture</code> fixtures can be parametrized to generate new combinations and test cases.</p>"},{"location":"tests/cancun/eip4844_blobs/test_point_evaluation_precompile/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_valid_inputs</code> state_test 1 Test valid sanity precompile calls that are expected to succeed. <code>test_invalid_inputs</code> state_test 12 Test invalid precompile calls. <code>test_external_vectors</code> state_test 122 Test precompile calls using external test vectors compiled from different sources. <code>test_call_opcode_types</code> state_test 12 Test calling the Point Evaluation Precompile with different call types, gas <code>test_tx_entry_point</code> state_test 6 Test calling the Point Evaluation Precompile directly as <code>test_precompile_before_fork</code> state_test 0 Test calling the Point Evaluation Precompile before the appropriate fork. <code>test_precompile_during_fork</code> blockchain_test 0 Test calling the Point Evaluation Precompile during the appropriate fork."},{"location":"tests/cancun/eip4844_blobs/test_point_evaluation_precompile_gas/","title":"Test Point Evaluation Precompile Gas","text":"<p>Documentation for <code>tests/cancun/eip4844_blobs/test_point_evaluation_precompile_gas.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip4844_blobs/test_point_evaluation_precompile_gas.py --fork Prague\n</code></pre> Tests gas usage on point evaluation precompile for EIP-4844: Shard Blob Transactions <p>Test gas usage on point evaluation precompile for EIP-4844: Shard Blob Transactions.</p>"},{"location":"tests/cancun/eip4844_blobs/test_point_evaluation_precompile_gas/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_point_evaluation_precompile_gas_usage</code> state_test 24 Test point evaluation precompile gas usage under different call contexts and gas limits."},{"location":"tests/cancun/eip5656_mcopy/","title":"EIP-5656 MCOPY","text":"<p>Documentation for <code>tests/cancun/eip5656_mcopy@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip5656_mcopy --fork Prague\n</code></pre> <p>Cross-client EIP-5656 Tests.</p>"},{"location":"tests/cancun/eip5656_mcopy/test_mcopy/","title":"Test MCOPY","text":"<p>Documentation for <code>tests/cancun/eip5656_mcopy/test_mcopy.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip5656_mcopy/test_mcopy.py --fork Prague\n</code></pre> Tests EIP-5656: MCOPY - Memory copying instruction <p>Test copy operations of EIP-5656: MCOPY - Memory copying instruction.</p>"},{"location":"tests/cancun/eip5656_mcopy/test_mcopy/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_valid_mcopy_operations</code> state_test 21 Perform MCOPY operations using different offsets and lengths:(\ud83d\udcd6\ud83d\udc1b?) <code>test_mcopy_on_empty_memory</code> state_test 8 Perform MCOPY operations on an empty memory, using different offsets and lengths."},{"location":"tests/cancun/eip5656_mcopy/test_mcopy_contexts/","title":"Test MCOPY Contexts","text":"<p>Documentation for <code>tests/cancun/eip5656_mcopy/test_mcopy_contexts.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip5656_mcopy/test_mcopy_contexts.py --fork Prague\n</code></pre> Tests EIP-5656: MCOPY - Memory copying instruction <p>Test memory copy under different call contexts EIP-5656: MCOPY - Memory copying instruction.</p>"},{"location":"tests/cancun/eip5656_mcopy/test_mcopy_contexts/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_no_memory_corruption_on_upper_call_stack_levels</code> state_test 4 Perform a subcall with any of the following opcodes, which uses MCOPY during its execution, <code>test_no_memory_corruption_on_upper_create_stack_levels</code> state_test 2 Perform a subcall with any of the following opcodes, which uses MCOPY during its execution,"},{"location":"tests/cancun/eip5656_mcopy/test_mcopy_memory_expansion/","title":"Test MCOPY Memory Expansion","text":"<p>Documentation for <code>tests/cancun/eip5656_mcopy/test_mcopy_memory_expansion.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip5656_mcopy/test_mcopy_memory_expansion.py --fork Prague\n</code></pre> Tests EIP-5656: MCOPY - Memory copying instruction <p>Test copy operations of EIP-5656: MCOPY - Memory copying instruction that produce a memory expansion, and potentially an out-of-gas error.</p>"},{"location":"tests/cancun/eip5656_mcopy/test_mcopy_memory_expansion/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_mcopy_memory_expansion</code> state_test 40 Perform MCOPY operations that expand the memory, and verify the gas it costs to do so. <code>test_mcopy_huge_memory_expansion</code> state_test 18 Perform MCOPY operations that expand the memory by huge amounts, and verify that it correctly"},{"location":"tests/cancun/eip6780_selfdestruct/","title":"EIP-6780 SELFDESTRUCT","text":"<p>Documentation for <code>tests/cancun/eip6780_selfdestruct@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip6780_selfdestruct --fork Prague\n</code></pre> <p>Tests for EIP-6780: SELFDESTRUCT only in same transaction.</p>"},{"location":"tests/cancun/eip6780_selfdestruct/test_dynamic_create2_selfdestruct_collision/","title":"Test Dynamic CREATE2 SELFDESTRUCT Collision","text":"<p>Documentation for <code>tests/cancun/eip6780_selfdestruct/test_dynamic_create2_selfdestruct_collision.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip6780_selfdestruct/test_dynamic_create2_selfdestruct_collision.py --fork Prague\n</code></pre> <p>Suicide scenario requested test #381.</p>"},{"location":"tests/cancun/eip6780_selfdestruct/test_dynamic_create2_selfdestruct_collision/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_dynamic_create2_selfdestruct_collision</code> state_test 6 Dynamic Create2-&gt;Suicide-&gt;Create2 collision scenario. <code>test_dynamic_create2_selfdestruct_collision_two_different_transactions</code> blockchain_test 4 Dynamic Create2-&gt;Suicide-&gt;Create2 collision scenario. <code>test_dynamic_create2_selfdestruct_collision_multi_tx</code> blockchain_test 3 Dynamic Create2-&gt;Suicide-&gt;Create2 collision scenario over multiple transactions."},{"location":"tests/cancun/eip6780_selfdestruct/test_reentrancy_selfdestruct_revert/","title":"Test Reentrancy SELFDESTRUCT REVERT","text":"<p>Documentation for <code>tests/cancun/eip6780_selfdestruct/test_reentrancy_selfdestruct_revert.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip6780_selfdestruct/test_reentrancy_selfdestruct_revert.py --fork Prague\n</code></pre> <p>Suicide scenario requested test tests#1325.</p>"},{"location":"tests/cancun/eip6780_selfdestruct/test_reentrancy_selfdestruct_revert/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_reentrancy_selfdestruct_revert</code> state_test 9 Suicide reentrancy scenario."},{"location":"tests/cancun/eip6780_selfdestruct/test_selfdestruct/","title":"Test SELFDESTRUCT","text":"<p>Documentation for <code>tests/cancun/eip6780_selfdestruct/test_selfdestruct.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip6780_selfdestruct/test_selfdestruct.py --fork Prague\n</code></pre> Tests EIP-6780: SELFDESTRUCT only in same transaction <p>Tests for EIP-6780: SELFDESTRUCT only in same transaction.</p>"},{"location":"tests/cancun/eip6780_selfdestruct/test_selfdestruct/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_create_selfdestruct_same_tx</code> state_test 36 Use CREATE or CREATE2 to create a self-destructing contract, and call it in the same <code>test_self_destructing_initcode</code> state_test 8 Test that a contract can self-destruct in its initcode. <code>test_self_destructing_initcode_create_tx</code> state_test 4 Use a Create Transaction to execute a self-destructing initcode. <code>test_recreate_self_destructed_contract_different_txs</code> blockchain_test 4 Test that a contract can be recreated after it has self-destructed, over the lapse <code>test_selfdestruct_pre_existing</code> state_test 18 Test calling a previously created account that contains a selfdestruct, and verify its balance <code>test_selfdestruct_created_same_block_different_tx</code> blockchain_test 4 Test that if an account created in the same block that contains a selfdestruct is <code>test_calling_from_new_contract_to_pre_existing_contract</code> state_test 4 Test that if an account created in the current transaction delegate-call a previously created <code>test_calling_from_pre_existing_contract_to_new_contract</code> state_test 16 Test that if an account created in the current transaction contains a self-destruct and is <code>test_create_selfdestruct_same_tx_increased_nonce</code> state_test 8 Verify that a contract can self-destruct if it was created in the same transaction, even when"},{"location":"tests/cancun/eip6780_selfdestruct/test_selfdestruct_revert/","title":"Test SELFDESTRUCT REVERT","text":"<p>Documentation for <code>tests/cancun/eip6780_selfdestruct/test_selfdestruct_revert.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip6780_selfdestruct/test_selfdestruct_revert.py --fork Prague\n</code></pre> <p>tests for selfdestruct interaction with revert.</p>"},{"location":"tests/cancun/eip6780_selfdestruct/test_selfdestruct_revert/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_selfdestruct_created_in_same_tx_with_revert</code> state_test 3 Given:(\ud83d\udcd6\ud83d\udc1b?) <code>test_selfdestruct_not_created_in_same_tx_with_revert</code> state_test 3 Same test as selfdestruct_created_in_same_tx_with_revert except selfdestructable contract"},{"location":"tests/cancun/eip7516_blobgasfee/","title":"EIP-7516 Blobgasfee","text":"<p>Documentation for <code>tests/cancun/eip7516_blobgasfee@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip7516_blobgasfee --fork Prague\n</code></pre> <p>Tests for EIP-7516: BLOBBASEFEE opcode.</p>"},{"location":"tests/cancun/eip7516_blobgasfee/test_blobgasfee_opcode/","title":"Test Blobgasfee Opcode","text":"<p>Documentation for <code>tests/cancun/eip7516_blobgasfee/test_blobgasfee_opcode.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/cancun/eip7516_blobgasfee/test_blobgasfee_opcode.py --fork Prague\n</code></pre> Tests EIP-7516: BLOBBASEFEE opcode <p>Test BLOBGASFEE opcode EIP-7516: BLOBBASEFEE opcode.</p>"},{"location":"tests/cancun/eip7516_blobgasfee/test_blobgasfee_opcode/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_blobbasefee_stack_overflow</code> state_test 2 Tests that the BLOBBASEFEE opcode produces a stack overflow by using it repeatedly. <code>test_blobbasefee_out_of_gas</code> state_test 2 Tests that the BLOBBASEFEE opcode fails with insufficient gas. <code>test_blobbasefee_before_fork</code> state_test 0 Tests that the BLOBBASEFEE opcode results on exception when called before the fork. <code>test_blobbasefee_during_fork</code> blockchain_test 0 Tests that the BLOBBASEFEE opcode results on exception when called before the fork and"},{"location":"tests/constantinople/","title":"Constantinople","text":"<p>Documentation for <code>tests/constantinople@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/constantinople --fork Prague\n</code></pre> <p>Test cases for EVM functionality introduced in Constantinople.</p>"},{"location":"tests/constantinople/eip1014_create2/","title":"EIP-1014 CREATE2","text":"<p>Documentation for <code>tests/constantinople/eip1014_create2@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/constantinople/eip1014_create2 --fork Prague\n</code></pre> <p>abstract: Test EIP-1014: Skinny CREATE2.</p> <pre><code>Tests for  [EIP-1014: Skinny CREATE2](https://eips.ethereum.org/EIPS/eip-1014).\n</code></pre>"},{"location":"tests/constantinople/eip1014_create2/spec/","title":"Spec","text":"<p>Documentation for <code>tests/constantinople/eip1014_create2/spec.py@af77f529</code>.</p> <p>Defines EIP-1014 specification constants and functions.</p>"},{"location":"tests/constantinople/eip1014_create2/spec/#tests.constantinople.eip1014_create2.spec.Spec","title":"<code>Spec</code>  <code>dataclass</code>","text":"<p>Parameters from the EIP-1014 specifications as defined at https://eips.ethereum.org/EIPS/eip-1014.</p> Source code in <code>tests/constantinople/eip1014_create2/spec.py</code> <pre><code>@dataclass(frozen=True)\nclass Spec:\n    \"\"\"\n    Parameters from the EIP-1014 specifications as defined at\n    https://eips.ethereum.org/EIPS/eip-1014.\n    \"\"\"\n</code></pre>"},{"location":"tests/constantinople/eip1014_create2/test_create_returndata/","title":"Test CREATE Returndata","text":"<p>Documentation for <code>tests/constantinople/eip1014_create2/test_create_returndata.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/constantinople/eip1014_create2/test_create_returndata.py --fork Prague\n</code></pre> <p>Return data management around create2 Port call_outsize_then_create2_successful_then_returndatasizeFiller.json test Port call_then_create2_successful_then_returndatasizeFiller.json test.</p>"},{"location":"tests/constantinople/eip1014_create2/test_create_returndata/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_create2_return_data</code> state_test 24 Validate that create2 return data does not interfere with previously existing memory."},{"location":"tests/constantinople/eip1014_create2/test_recreate/","title":"Test Recreate","text":"<p>Documentation for <code>tests/constantinople/eip1014_create2/test_recreate.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/constantinople/eip1014_create2/test_recreate.py --fork Prague\n</code></pre> <p>Test Account Self-destruction and Re-creation.</p>"},{"location":"tests/constantinople/eip1014_create2/test_recreate/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_recreate</code> blockchain_test 0 Test that the storage is cleared when a contract is first destructed then re-created using"},{"location":"tests/frontier/","title":"Frontier","text":"<p>Documentation for <code>tests/frontier@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/frontier --fork Prague\n</code></pre> <p>Test cases for EVM functionality introduced in Frontier.</p>"},{"location":"tests/frontier/examples/","title":"Examples","text":"<p>Documentation for <code>tests/frontier/examples@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/frontier/examples --fork Prague\n</code></pre> <p>Test examples, patterns, templates to use in .py tests.</p>"},{"location":"tests/frontier/examples/test_block_intermediate_state/","title":"Test Block Intermediate State","text":"<p>Documentation for <code>tests/frontier/examples/test_block_intermediate_state.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/frontier/examples/test_block_intermediate_state.py --fork Prague\n</code></pre> <p>Test the SELFDESTRUCT opcode.</p>"},{"location":"tests/frontier/examples/test_block_intermediate_state/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_block_intermidiate_state</code> blockchain_test 0 Verify intermidiate block states."},{"location":"tests/frontier/opcodes/","title":"Opcodes","text":"<p>Documentation for <code>tests/frontier/opcodes@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/frontier/opcodes --fork Prague\n</code></pre> <p>Test for opcodes introduced in Frontier.</p>"},{"location":"tests/frontier/opcodes/test_all_opcodes/","title":"Test All Opcodes","text":"<p>Documentation for <code>tests/frontier/opcodes/test_all_opcodes.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/frontier/opcodes/test_all_opcodes.py --fork Prague\n</code></pre> <p>Call every possible opcode and test that the subcall is successful if the opcode is supported by the fork supports and fails otherwise.</p>"},{"location":"tests/frontier/opcodes/test_all_opcodes/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_all_opcodes</code> state_test 1 Test each possible opcode on the fork with a single contract that <code>test_cover_revert</code> state_test 1 Cover state revert from original tests for the coverage script."},{"location":"tests/frontier/opcodes/test_call_and_callcode_gas_calculation/","title":"Test CALL AND CALLCODE Gas Calculation","text":"<p>Documentation for <code>tests/frontier/opcodes/test_call_and_callcode_gas_calculation.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/frontier/opcodes/test_call_and_callcode_gas_calculation.py --fork Prague\n</code></pre> Tests the nested CALL/CALLCODE opcode gas consumption with a positive value transfer. <p>This test is designed to investigate an issue identified in EthereumJS, as reported in: ethereumjs/ethereumjs-monorepo#3194.</p> <p>The issue pertains to the incorrect gas calculation for CALL/CALLCODE operations with a positive value transfer, due to the pre-addition of the gas stipend (2300) to the currently available gas instead of adding it to the new call frame. This bug was specific to the case where insufficient gas was provided for the CALL/CALLCODE operation. Due to the pre-addition of the stipend to the currently available gas, the case for insufficient gas was not properly failing with an out-of-gas error.</p> <p>Test setup: Given two smart contract accounts, 0x0A (caller) and 0x0B (callee): 1) An arbitrary transaction calls into the contract 0x0A. 2) Contract 0x0A executes a CALL to contract 0x0B with a specific gas limit (X). 3) Contract 0x0B then attempts a CALL/CALLCODE to a non-existent contract 0x0C,    with a positive value transfer (activating the gas stipend). 4) If the gas X provided by contract 0x0A to 0x0B is sufficient, contract 0x0B    will push 0x01 onto the stack after returning to the call frame in 0x0A. Otherwise, it    should push 0x00, indicating the insufficiency of gas X (for the bug in EthereumJS, the    CALL/CALLCODE operation would return 0x01 due to the pre-addition of the gas stipend). 5) The resulting stack value is saved into contract 0x0A's storage, allowing us to    verify whether the provided gas was sufficient or insufficient.</p>"},{"location":"tests/frontier/opcodes/test_call_and_callcode_gas_calculation/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_value_transfer_gas_calculation</code> state_test 0 Tests the nested CALL/CALLCODE opcode gas consumption with a positive value transfer."},{"location":"tests/frontier/opcodes/test_calldatacopy/","title":"Test CALLDATACOPY","text":"<p>Documentation for <code>tests/frontier/opcodes/test_calldatacopy.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/frontier/opcodes/test_calldatacopy.py --fork Prague\n</code></pre> <p>test <code>CALLDATACOPY</code> opcode.</p>"},{"location":"tests/frontier/opcodes/test_calldatacopy/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_calldatacopy</code> state_test 8 Test <code>CALLDATACOPY</code> opcode."},{"location":"tests/frontier/opcodes/test_dup/","title":"Test Dup","text":"<p>Documentation for <code>tests/frontier/opcodes/test_dup.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/frontier/opcodes/test_dup.py --fork Prague\n</code></pre> Test DUP <p>Test the DUP opcodes.</p>"},{"location":"tests/frontier/opcodes/test_dup/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_dup</code> state_test 16 Test the DUP1-DUP16 opcodes."},{"location":"tests/frontier/opcodes/test_push/","title":"Test Push","text":"<p>Documentation for <code>tests/frontier/opcodes/test_push.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/frontier/opcodes/test_push.py --fork Prague\n</code></pre> <p>A State test for the set of <code>PUSH*</code> opcodes. Ported from: https://github.com/ethereum/tests/blob/4f65a0a7cbecf4442415c226c65e089acaaf6a8b/src/GeneralStateTestsFiller/VMTests/vmTests/pushFiller.yml.</p>"},{"location":"tests/frontier/opcodes/test_push/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_push</code> state_test 32 The set of <code>PUSH*</code> opcodes pushes data onto the stack. <code>test_stack_overflow</code> state_test 64 A test to ensure that the stack overflows when the stack limit of 1024 is exceeded."},{"location":"tests/frontier/opcodes/test_selfdestruct/","title":"Test SELFDESTRUCT","text":"<p>Documentation for <code>tests/frontier/opcodes/test_selfdestruct.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/frontier/opcodes/test_selfdestruct.py --fork Prague\n</code></pre> <p>Test the SELFDESTRUCT opcode.</p>"},{"location":"tests/frontier/opcodes/test_selfdestruct/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_double_kill</code> blockchain_test 0 Test that when two transactions attempt to destruct a contract,"},{"location":"tests/frontier/precompiles/","title":"Precompiles","text":"<p>Documentation for <code>tests/frontier/precompiles@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/frontier/precompiles --fork Prague\n</code></pre> <p>Test for precompiles that apply for all forks starting from Frontier.</p>"},{"location":"tests/frontier/precompiles/test_precompile_absence/","title":"Test Precompile Absence","text":"<p>Documentation for <code>tests/frontier/precompiles/test_precompile_absence.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/frontier/precompiles/test_precompile_absence.py --fork Prague\n</code></pre> <p>abstract: Test Calling Precompile Range (close to zero).</p>"},{"location":"tests/frontier/precompiles/test_precompile_absence/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_precompile_absence</code> state_test 3 Test that addresses close to zero are not precompiles unless active in the fork."},{"location":"tests/frontier/precompiles/test_precompiles/","title":"Test Precompiles","text":"<p>Documentation for <code>tests/frontier/precompiles/test_precompiles.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/frontier/precompiles/test_precompiles.py --fork Prague\n</code></pre> <p>Tests supported precompiled contracts.</p>"},{"location":"tests/frontier/precompiles/test_precompiles/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_precompiles</code> state_test 18 Tests the behavior of precompiled contracts in the Ethereum state test."},{"location":"tests/homestead/","title":"Homestead","text":"<p>Documentation for <code>tests/homestead@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/homestead --fork Prague\n</code></pre> <p>Test cases for EVM functionality introduced in Homestead.</p>"},{"location":"tests/homestead/coverage/","title":"Coverage","text":"<p>Documentation for <code>tests/homestead/coverage@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/homestead/coverage --fork Prague\n</code></pre> <p>Tests that fill coverage gaps when porting over from <code>ethereum/tests</code>.</p>"},{"location":"tests/homestead/coverage/test_coverage/","title":"Test Coverage","text":"<p>Documentation for <code>tests/homestead/coverage/test_coverage.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/homestead/coverage/test_coverage.py --fork Prague\n</code></pre> <p>Tests that address coverage gaps that result from updating <code>ethereum/tests</code> into EEST tests.</p>"},{"location":"tests/homestead/coverage/test_coverage/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_coverage</code> state_test 1 Cover gaps that result from transforming Yul code into"},{"location":"tests/homestead/yul/","title":"Yul","text":"<p>Documentation for <code>tests/homestead/yul@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/homestead/yul --fork Prague\n</code></pre> <p>Tests using Yul source for contracts.</p>"},{"location":"tests/homestead/yul/test_yul_example/","title":"Test Yul Example","text":"<p>Documentation for <code>tests/homestead/yul/test_yul_example.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/homestead/yul/test_yul_example.py --fork Prague\n</code></pre> <p>Test Yul Source Code Examples.</p>"},{"location":"tests/homestead/yul/test_yul_example/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_yul</code> state_test 1 Test YUL compiled bytecode."},{"location":"tests/istanbul/","title":"Istanbul","text":"<p>Documentation for <code>tests/istanbul@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/istanbul --fork Prague\n</code></pre> <p>Test cases for EVM functionality introduced in Istanbul.</p>"},{"location":"tests/istanbul/eip1344_chainid/","title":"EIP-1344 CHAINID","text":"<p>Documentation for <code>tests/istanbul/eip1344_chainid@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/istanbul/eip1344_chainid --fork Prague\n</code></pre> Tests EIP-1344: ChainID Opcode <p>Test cases for EIP-1344: ChainID Opcode.</p>"},{"location":"tests/istanbul/eip1344_chainid/test_chainid/","title":"Test CHAINID","text":"<p>Documentation for <code>tests/istanbul/eip1344_chainid/test_chainid.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/istanbul/eip1344_chainid/test_chainid.py --fork Prague\n</code></pre> Tests EIP-1344: CHAINID opcode <p>Test cases for EIP-1344: CHAINID opcode.</p>"},{"location":"tests/istanbul/eip1344_chainid/test_chainid/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_chainid</code> state_test 1 Test CHAINID opcode."},{"location":"tests/istanbul/eip152_blake2/","title":"EIP-152 Blake2","text":"<p>Documentation for <code>tests/istanbul/eip152_blake2@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/istanbul/eip152_blake2 --fork Prague\n</code></pre> Tests EIP-152: BLAKE2 compression precompile <p>Test cases for EIP-152: BLAKE2 compression precompile.</p>"},{"location":"tests/istanbul/eip152_blake2/test_blake2/","title":"Test Blake2","text":"<p>Documentation for <code>tests/istanbul/eip152_blake2/test_blake2.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/istanbul/eip152_blake2/test_blake2.py --fork Prague\n</code></pre> Tests EIP-152: BLAKE2b compression precompile <p>Test cases for EIP-152: BLAKE2b compression precompile.</p>"},{"location":"tests/istanbul/eip152_blake2/test_blake2/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_blake2b</code> state_test 28 Test BLAKE2b precompile."},{"location":"tests/osaka/","title":"Osaka","text":"<p>Documentation for <code>tests/osaka@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka --fork Osaka\n</code></pre> <p>Test cases for EVM functionality introduced in Osaka, EIP-7607: Hardfork Meta - Fusaka.</p>"},{"location":"tests/osaka/eip7692_eof_v1/","title":"EIP-7692 EOF V1","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1 --fork Osaka\n</code></pre> Test cases for EIP-7692: EVM Object Format (EOFv1) Meta <p>Test cases for the EIPs included in EIP-7692 EOFv1 Meta.</p> <ul> <li>EIP-663: SWAPN, DUPN and EXCHANGE instructions.</li> <li>EIP-3540: EOF - EVM Object Format v1.</li> <li>EIP-3670: EOF - Code Validation.</li> <li>EIP-4200: EOF - Static relative jumps.</li> <li>EIP-4750: EOF - Functions.</li> <li>EIP-5450: EOF - Stack Validation.</li> <li>EIP-6206: EOF - JUMPF and non-returning functions.</li> <li>EIP-7069: Revamped CALL instructions.</li> <li>EIP-7480: EOF - Data section access instructions.</li> <li>EIP-7620: EOF Contract Creation.</li> <li>EIP-7698: EOF - Creation transaction.</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/#tests.osaka.eip7692_eof_v1--devnet-specifications","title":"Devnet Specifications","text":"<ul> <li>ethpandaops/eof-devnet-0.</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/","title":"EOF Tracker","text":"<p>Markdown Content</p> <p>Below is the verbatim markdown content from <code>tests/osaka/eip7692_eof_v1/eof_tracker.md@af77f529</code>.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#eof-testing-coverage-tracker","title":"EOF Testing Coverage Tracker","text":"<ul> <li> Example Test Case 1</li> <li> Example Test Case 2 (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_eof_example.py</code>)</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#eip-3540-eof-evm-object-format-v1","title":"EIP-3540: EOF - EVM Object Format v1","text":""},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#validation","title":"Validation","text":"<ul> <li> Empty code is not a valid EOF (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k empty_container</code>)</li> <li> Valid container without data section (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k single_code_section_no_data_section</code>)</li> <li> Valid container with data section (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_valid_containers</code> <code>-k single_code_section_with_data_section</code>)</li> <li> Valid container with truncated data section (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k data_section_contents_incomplete</code>, <code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_migrated_valid_invalid.py::test_migrated_valid_invalid</code> <code>-k data_section_contents_incomplete</code>)</li> <li> Valid container with data section truncated to empty (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k no_data_section_contents</code>, <code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_migrated_valid_invalid.py::test_migrated_valid_invalid</code> <code>-k no_data_section_contents</code>)</li> <li> Valid containers with multiple code sections (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_valid_containers</code> <code>-k multiple_code_sections</code>)</li> <li> Valid containers with max number of code sections (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_max_code_sections</code>)</li> <li> Too many code sections (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k too_many_code_sections</code>)</li> <li> Truncated magic (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k incomplete_magic</code>)</li> <li> Valid container except magic (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_magic_validation</code>)</li> <li> Truncated before version  (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k no_version</code>)</li> <li> Valid container except version (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_version_validation</code>)</li> <li> Truncated before type section header (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k no_type_header</code>)</li> <li> Truncated before type section size (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k no_type_section_size</code>)</li> <li> Truncated type section size (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k incomplete_type_section_size</code>)</li> <li> No type section header (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_section_order.py::test_section_order</code> <code>-k test_position_CasePosition.HEADER-section_test_SectionTest.MISSING-section_kind_TYPE</code>)</li> <li> Truncated before code section header (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k no_code_header</code>)</li> <li> Truncated before code section number (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k code_section_count_missing</code>)</li> <li> Truncated code section number (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k code_section_count_incomplete</code>)</li> <li> Truncated before code section size (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k code_section_size_missing</code>)</li> <li> Truncated code section size (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k code_section_size_incomplete</code>)</li> <li> No code section header (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_section_order.py::test_section_order</code> <code>-k test_position_CasePosition.HEADER-section_test_SectionTest.MISSING-section_kind_CODE</code>)</li> <li> Zero code section number (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k zero_code_sections_header</code>)</li> <li> Zero code section size (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k empty_code_section</code>)</li> <li> Zero code section size with non-empty data section (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k empty_code_section_with_non_empty_data</code>)</li> <li> No container sections, truncated before data section header (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k truncated_header_data_section</code>)</li> <li> Container sections present, truncated before data section header (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k truncated_header_data_section_with_container_section</code>)</li> <li> Truncated before data section size (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k no_data_section_size</code>)</li> <li> Truncated data section size (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k data_section_size_incomplete</code>)</li> <li> Truncated before header terminator (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k terminator_incomplete</code>)</li> <li> Truncated before type section (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k truncated_before_type_section</code>)</li> <li> Type section truncated before outputs (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k truncated_type_section_before_outputs</code>)</li> <li> Type section truncated before max_stack_height (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k truncated_type_section_before_max_stack_height</code>)</li> <li> Type section truncated max_stack_height (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k truncated_type_section_truncated_max_stack_height</code>)</li> <li> Truncated before code sections (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k no_code_section_contents</code>)</li> <li> Truncated code section (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k incomplete_code_section_contents</code>)</li> <li> Data section empty, trailing bytes (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k no_data_section_contents</code>)</li> <li> Data section non-empty, trailing bytes (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k trailing_bytes_after_data_section</code>)</li> <li> Wrong order of sections (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_section_order.py</code>)</li> <li> No data section header (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_section_order.py::test_section_order</code> <code>-k test_position_CasePosition.HEADER-section_test_SectionTest.MISSING-section_kind_DATA</code>)</li> <li> Multiple data sections (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k multiple_data_sections</code>, <code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k multiple_code_and_data_sections</code>)</li> <li> Unknown section id (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k unknown_section_1</code>, <code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k unknown_section_2</code>)</li> <li> Type section size != 4 * code section number (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py</code><code>-k type_section_too</code>)</li> <li> Code section with max max_stack_height (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_valid_containers</code> <code>-k single_code_section_max_stack_size</code>)</li> <li> Code section with max_stack_height above limit (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_invalid_containers</code> <code>-k single_code_section_max_stack_size_too_large</code>)</li> <li> Valid code sections with inputs/outputs (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py</code><code>-k code_section_with_inputs_outputs</code>)</li> <li> Valid code section with max inputs (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py</code><code>-k code_section_input_maximum</code>)</li> <li> Valid code section with max outputs (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py</code><code>-k code_section_output_maximum</code>)</li> <li> Code sections with invalid number of inputs/outputs (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py</code><code>-k code_section_input_too_large</code>, <code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py</code><code>-k code_section_output_too_large</code>)</li> <li> First section with inputs/outputs (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py</code><code>-k invalid_first_code_section</code>)</li> <li> Multiple type section headers (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py</code><code>-k too_many_type_sections</code>)</li> <li> Multiple code section headers (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py</code><code>-k multiple_code_headers</code>)</li> <li> Multiple data section headers (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py</code><code>-k multiple_data_sections</code>)</li> <li> Container without type section (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_section_order.py::test_section_order</code> <code>-k 'SectionTest.MISSING-section_kind_TYPE'</code>)</li> <li> Container without code sections (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_section_order.py::test_section_order</code> <code>-k 'SectionTest.MISSING-section_kind_CODE'</code>)</li> <li> Container without data section (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_section_order.py::test_section_order</code> <code>-k 'SectionTest.MISSING-section_kind_DATA'</code>)</li> <li> Valid containers without data section and with subcontainers (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_valid_containers</code><code>[fork_Osaka-eof_test-single_subcontainer_without_data]</code>)</li> <li> Valid containers with data section and with subcontainers (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_valid_containers</code><code>[fork_CancunEIP7692-eof_test-single_subcontainer_with_data]</code>)</li> <li> Valid container with maximum number of subcontainers (<code>tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_subcontainer_validation.py::test_wide_container</code><code>[fork_CancunEIP7692-eof_test-256]</code>)</li> <li> Container with number of subcontainers above the limit (<code>tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_subcontainer_validation.py::test_wide_container</code><code>[fork_CancunEIP7692-eof_test-257]</code>)</li> <li> Subcontainer section header truncated before subcontainer number (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py</code><code>-k no_container_section_count</code>)</li> <li> Subcontainer section header truncated before subcontainer size (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py</code><code>-k incomplete_container_section_count</code>)</li> <li> Truncated subcontainer size (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py</code><code>-k no_container_section_size</code>, <code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py</code><code>-k incomplete_container_section_size</code>)</li> <li> Zero container section number (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py</code><code>-k zero_container_section_count</code>)</li> <li> Zero container section size (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py</code><code>-k zero_size_container_section</code>)</li> <li> Truncated container section body (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py</code><code>-k no_container_section_contents</code>)</li> <li> Multiple container section headers (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py</code><code>-k multiple_container_headers</code>)</li> <li> Invalid subcontainer (<code>tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_subcontainer_validation.py</code><code>-k invalid</code>)</li> <li> Invalid subcontainer on a deep nesting level (<code>tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_subcontainer_validation.py::test_deep_container</code>)</li> <li> Max number of inputs/outputs in a section (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_valid_containers</code><code>[fork_CancunEIP7692-eof_test-code_section_input_maximum]</code>, <code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py::test_valid_containers</code><code>[fork_CancunEIP7692-eof_test-code_section_output_maximum]</code>)</li> <li> Number of inputs/outputs in a section above the limit (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py</code><code>-k code_section_input_too_large</code>, <code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py</code><code>-k code_section_output_too_large</code>)</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#execution","title":"Execution","text":"<ul> <li> Execution of EOF contracts (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_execution.py::test_eof_execution</code>)</li> <li> Legacy executing EXTCODESIZE of EOF contract (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_extcode.py::test_legacy_calls_eof_sstore</code>)</li> <li> Legacy executing EXTCODEHASH of EOF contract (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_extcode.py::test_legacy_calls_eof_sstore</code>)</li> <li> Legacy executing EXTCODECOPY of EOF contract (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_extcode.py::test_legacy_calls_eof_sstore</code>)</li> <li> <code>*CALLs</code> from legacy contracts to EOF contracts (ethereum/tests: src/EIPTestsFiller/StateTests/stEOF/stEIP3540/EOF1_CallsFiller.yml)</li> <li> <code>EXT*CALLs</code> from EOF to legacy contracts (ethereum/tests: src/EIPTestsFiller/StateTests/stEOF/stEIP3540/EOF1_CallsFiller.yml)</li> <li> EXTDELEGATECALL from EOF to EOF contract (ethereum/tests: src/EIPTestsFiller/StateTests/stEOF/stEIP3540/EOF1_CallsFiller.yml)</li> <li> EXTDELEGATECALL from EOF to legacy contract failing (ethereum/tests: src/EIPTestsFiller/StateTests/stEOF/stEIP3540/EOF1_CallsFiller.yml)</li> <li> EXTDELEGATECALL from EOF to EOA failing</li> <li> EXTDELEGATECALL from EOF to empty account failing</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#eip-3670-eof-code-validation","title":"EIP-3670: EOF - Code Validation","text":""},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#validation_1","title":"Validation","text":"<ul> <li> Code section with invalid opcodes is rejected (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_all_opcodes_in_container.py::test_all_opcodes_in_container</code>)</li> <li> INVALID opcode is valid (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_all_opcodes_in_container.py::test_all_opcodes_in_container</code>)</li> <li> Truncated PUSH data (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_all_opcodes_in_container.py::test_truncated_data_portion_opcodes</code>)</li> <li> Opcodes deprecated in EOF are rejected (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_all_opcodes_in_container.py::test_all_opcodes_in_container</code>)</li> <li> Codes with each valid opcodes (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_all_opcodes_in_container.py::test_all_opcodes_in_container</code>)</li> <li> Undefined instruction after terminating instruction (<code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_all_opcodes_in_container.py::test_invalid_opcodes_after_stop</code>)</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#eip-4200-eof-static-relative-jumps","title":"EIP-4200: EOF - Static relative jumps","text":""},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#validation_2","title":"Validation","text":"<ul> <li> Valid RJUMP with various offsets (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjump.py::test_rjump_positive_negative</code>)</li> <li> Valid RJUMP with maximum offset (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjump.py::test_rjump_maxes</code>)</li> <li> Valid RJUMP with minimum offset (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjump.py::test_rjump_maxes</code>)</li> <li> Valid RJUMPI with various offsets (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_forwards</code>)</li> <li> Valid RJUMPI with maximum offset (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_max_forward</code>)</li> <li> Valid RJUMPI with minimum offset (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_max_backward</code>)</li> <li> Valid RJUMPV with various number of offsets and various offsets (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py::test_rjumpv_forwards</code>)</li> <li> Valid RJUMPV with table size 256 (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py::test_rjumpv_full_table</code>)</li> <li> Valid RJUMPV containing maximum offset (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py::test_rjumpv_max_forwards</code>)</li> <li> Valid RJUMPV containing minimum offset</li> <li> Truncated before RJUMP immediate (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjump.py::test_rjump_truncated_rjump</code>)</li> <li> Truncated RJUMP immediate (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjump.py::test_rjump_truncated_rjump_2</code>)</li> <li> RJUMP out of container bounds (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjump.py::test_rjump_after_container</code>)</li> <li> RJUMP out of section bounds (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjump.py::test_rjump_into_data</code>)</li> <li> RJUMP into immediate (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjump.py::test_rjump_into_push_1</code>)</li> <li> Truncated before RJUMPI immediate (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_truncated</code>)</li> <li> Truncated RJUMPI immediate (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_truncated_2</code>)</li> <li> RJUMPI out of container bounds (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_after_container</code>)</li> <li> RJUMPI out of section bounds (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_into_data</code>)</li> <li> RJUMPI into immediate (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_into_push_1</code>)</li> <li> Truncated before RJUMPV immediate (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py::test_rjumpv_truncated_empty</code>)</li> <li> Truncated RJUMPV immediate (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py::test_rjumpv_truncated</code>)</li> <li> RJUMPV out of container bounds (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py::test_rjumpv_after_container</code>)</li> <li> RJUMPV out of section bounds (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py::test_rjumpv_into_data</code>)</li> <li> RJUMPV into immediate (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py::test_rjumpv_into_push_1</code>)</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#execution_1","title":"Execution","text":"<ul> <li> RJUMP forwards (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjump.py::test_rjump_positive_negative</code>)</li> <li> RJUMP backwards (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjump.py::test_rjump_positive_negative</code>)</li> <li> RJUMP with 0 offset (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjump.py::test_rjump_zero</code>)</li> <li> RJUMPI forwards with condition true/false (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_condition_forwards</code>)</li> <li> RJUMPI backwards with condition true/false (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_condition_backwards</code>)</li> <li> RJUMPI with 0 offset with condition true/false (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_condition_zero</code>)</li> <li> RJUMPV with different case values (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py::test_rjumpv_condition</code>)</li> <li> RJUMPV with case value out of table bounds (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py::test_rjumpv_condition</code>)</li> <li> RJUMPV with max cases number (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py::test_rjumpv_condition</code>, <code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py</code><code>-k test_rjumpv_full_table</code>)</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#eip-4750-eof-functions","title":"EIP-4750: EOF - Functions","text":""},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#validation_3","title":"Validation","text":"<ul> <li> Valid CALLFs (<code>tests/osaka/eip7692_eof_v1/eip4750_functions/test_callf_execution.py::test_callf</code>)</li> <li> CALLFs to non-existing sections (<code>tests/osaka/eip7692_eof_v1/eip4750_functions/test_code_validation.py::test_invalid_code_section_index</code>)</li> <li> Truncated CALLF immediate (<code>tests/osaka/eip7692_eof_v1/eip4750_functions/test_code_validation.py::test_callf_truncated_immediate</code>)</li> <li> Unreachable code sections (<code>tests/osaka/eip7692_eof_v1/eip4750_functions/test_code_validation.py::test_unreachable_code_sections</code>)</li> <li> Sections reachable from other sections, but not reachable from section 0 (<code>tests/osaka/eip7692_eof_v1/eip4750_functions/test_code_validation.py::test_unreachable_code_sections</code>)</li> <li> Unreachable code section that calls itself with JUMPF (<code>tests/osaka/eip7692_eof_v1/eip4750_functions/test_code_validation.py::test_unreachable_code_sections</code>)</li> <li> Unreachable code section that calls itself with CALLF (<code>tests/osaka/eip7692_eof_v1/eip4750_functions/test_code_validation.py::test_unreachable_code_sections</code>)</li> <li> RETF with maximum number of outputs (ethereum/tests: src/EOFTestsFiller/EIP5450/validInvalidFiller.yml)</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#execution_2","title":"Execution","text":"<ul> <li> CALLF/RETF execution (ethereum/tests: src/EIPTestsFiller/StateTests/stEOF/stEIP4200/CALLF_RETF_ExecutionFiller.yml)</li> <li> Dispatch to CALLF to different functions based on calldata (ethereum/tests: src/EIPTestsFiller/StateTests/stEOF/stEIP4200/CALLF_RETF_ExecutionFiller.yml)</li> <li> Maximum number of code sections, calling each section with CALLF (ethereum/tests: src/EIPTestsFiller/StateTests/stEOF/stEIP4200/CALLF_RETF_ExecutionFiller.yml)</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#eip-5450-eof-stack-validation","title":"EIP-5450: EOF - Stack Validation","text":""},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#validation_4","title":"Validation","text":""},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#terminating-instructions","title":"Terminating instructions","text":"<ul> <li> Check all terminating opcodes (ethereum/tests: ./src/EOFTestsFiller/efExample/validInvalidFiller.yml src/EOFTestsFiller/EIP5450/validInvalidFiller.yml)</li> <li> Code section not terminating (executing beyond section end) (ethereum/tests: ./src/EOFTestsFiller/efExample/validInvalidFiller.yml src/EOFTestsFiller/EIP5450/validInvalidFiller.yml src/EOFTestsFiller/efStack/no_terminating_instruction_Copier.json)</li> <li> Code section ending with NOP (not terminating) (src/EOFTestsFiller/EIP5450/validInvalidFiller.yml)</li> <li> Check that unreachable code is invalid after all terminating instructions (ethereum/tests: src/EOFTestsFiller/EIP5450/validInvalidFiller.yml)</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#jumps","title":"Jumps","text":""},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#rjump","title":"RJUMP","text":"<ul> <li> Valid RJUMP backwards in a constant stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjump.py::test_rjump_valid_backward</code></li> <li> Invalid RJUMP backwards with mismatching stack in a constant stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjump.py::test_rjump_backward_invalid_max_stack_height</code></li> <li> Valid RJUMP backwards in a variable stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjump.py::test_rjump_valid_backward</code></li> <li> Invalid RJUMP backwards with mismatching stack in a variable stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjump.py::test_rjump_backward_invalid_max_stack_height</code></li> <li> Valid RJUMP forwards (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjump.py::test_rjump_valid_forward</code></li> <li> Valid RJUMP forwards from different stack (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjump.py::test_rjump_valid_forward</code></li> <li> Valid RJUMP forwards in variable stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjump.py::test_rjump_valid_forward</code></li> <li> Valid RJUMP forwards from different stack in variable stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjump.py::test_rjump_valid_forward</code></li> <li> Valid empty infinite loop with RJUMP (ethereum/tests: src/EOFTestsFiller/EIP5450/validInvalidFiller.yml)</li> <li> Valid balanced infinite loop (ethereum/tests: src/EOFTestsFiller/EIP5450/validInvalidFiller.yml)</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#rjumpi","title":"RJUMPI","text":"<ul> <li> Valid RJUMPI backwards in a constant stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_valid_backward</code></li> <li> Invalid RJUMPI backwards with mismatching stack in a constant stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_backward_invalid_max_stack_height</code></li> <li> Valid RJUMPI backwards in a variable stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_valid_backward</code></li> <li> Invalid RJUMPI backwards with mismatching stack in a variable stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_backward_invalid_max_stack_height</code></li> <li> RJUMPI forward with branches of equal stack height (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_valid_forward</code></li> <li> RJUMPI forward with branches of equal stack height in a variable stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_valid_forward</code></li> <li> RJUMPI forward with branches of different stack height (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_valid_forward</code></li> <li> RJUMPI forward with branches of different stack height in a variable stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_valid_forward</code></li> <li> Valid loop using RJUMPI (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_valid_forward</code></li> <li> Valid loop with a break using RJUMPI - equal stack after break and normal loop end (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_valid_forward</code></li> <li> Valid loop with a break using RJUMPI - equal stack after break and normal loop end, variable stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_valid_forward</code></li> <li> Valid loop with a break using RJUMPI - different stack after break and normal loop end (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_valid_forward</code></li> <li> Valid loop with a break using RJUMPI - different stack after break and normal loop end, variable stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_valid_forward</code></li> <li> If-then-else with equal stack height in branches (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_valid_forward</code></li> <li> If-then-else with equal stack height in branches, variable stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_valid_forward</code></li> <li> If-then-else with different stack height in branches (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_valid_forward</code></li> <li> If-then-else with different stack height in branches, variable stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py::test_rjumpi_valid_forward</code></li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#rjumpv","title":"RJUMPV","text":"<ul> <li> Valid RJUMPV backwards in a constant stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py::test_rjumpv_valid_backward</code></li> <li> Invalid RJUMPV backwards with mismatching stack in a constant stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py::test_rjumpv_backward_invalid_max_stack_height</code></li> <li> Valid RJUMPV backwards in a variable stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py::test_rjumpv_valid_backward</code></li> <li> Invalid RJUMPV backwards with mismatching stack in a variable stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py::test_rjumpv_backward_invalid_max_stack_height</code></li> <li> RJUMPV forward with branches of equal stack height (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py::test_rjumpv_valid_forward</code></li> <li> RJUMPV forward with branches of equal stack height in a variable stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py::test_rjumpv_valid_forward</code></li> <li> RJUMPV forward with branches of different stack height (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py::test_rjumpv_valid_forward</code></li> <li> RJUMPV forward with branches of different stack height  in a variable stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py::test_rjumpv_valid_forward</code></li> <li> Valid infinite loop using RJUMPV (ethereum/tests: src/EOFTestsFiller/EIP5450/validInvalidFiller.yml)</li> <li> Switch with equal stack height in branches (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py::test_rjumpv_valid_forward</code></li> <li> Switch with equal stack height in branches, variable stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py::test_rjumpv_valid_forward</code></li> <li> Switch with different stack height in branches (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py::test_rjumpv_valid_forward</code></li> <li> Switch with different stack height in branches, variable stack segment (<code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py::test_rjumpv_valid_forward</code></li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#combinations","title":"Combinations","text":"<ul> <li> RJUMP and RJUMPI with the same target and equal stack height (ethereum/tests: src/EOFTestsFiller/efStack/forwards_rjumpi_Copier.json)</li> <li> RJUMP and RJUMPI with the same target and equal stack height in a variable stack segment (ethereum/tests: src/EOFTestsFiller/efStack/forwards_rjumpi_variable_stack_Copier.json)</li> <li> RJUMP and RJUMPI with the same target and different stack height (ethereum/tests: src/EOFTestsFiller/efStack/forwards_rjumpi_Copier.json)</li> <li> RJUMP and RJUMPI with the same target and different stack height in a variable stack segment (ethereum/tests: src/EOFTestsFiller/efStack/forwards_rjumpi_variable_stack_Copier.json)</li> <li> RJUMP and RJUMPV with the same target and equal stack height (ethereum/tests: src/EOFTestsFiller/efStack/forwards_rjumpv_Copier.json)</li> <li> RJUMP and RJUMPV with the same target and equal stack height in a variable stack segment (ethereum/tests: src/EOFTestsFiller/efStack/forwards_rjumpv_variable_stack_Copier.json)</li> <li> RJUMP and RJUMPV with the same target and different stack height (ethereum/tests: src/EOFTestsFiller/efStack/forwards_rjumpv_Copier.json)</li> <li> RJUMP and RJUMPV with the same target and different stack height in a variable stack segment (ethereum/tests: src/EOFTestsFiller/efStack/forwards_rjumpv_variable_stack_Copier.json)</li> <li> <p> RJUMPI and RJUMPV with the same target</p> </li> <li> <p> RJUMP* to self (ethereum/tests: src/EOFTestsFiller/efStack/self_referencing_jumps_Copier.json)</p> </li> <li> RJUMP* to self in a variable stack segment (ethereum/tests: src/EOFTestsFiller/efStack/self_referencing_jumps_variable_stack_Copier.json)</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#stack-underflow","title":"Stack underflow","text":"<ul> <li> Stack underflows (ethereum/tests: ./src/EOFTestsFiller/efExample/validInvalidFiller.yml )</li> <li> Stack underflow with enough items available in caller stack - can't dig into caller frame (<code>tests/osaka/eip7692_eof_v1/eip4750_functions/test_code_validation.py::test_eof_validity</code>)</li> <li> Stack underflow in variable stack segment, only min underflow (ethereum/tests: src/EOFTestsFiller/efStack/underflow_variable_stack_Copier.json)</li> <li> Stack underflow in variable stack segment, both min and max underflow (ethereum/tests: src/EOFTestsFiller/efStack/underflow_variable_stack_Copier.json)</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#callf","title":"CALLF","text":"<ul> <li> Valid CALLFs to functions with inputs (ethereum/tests: src/EOFTestsFiller/efStack/callf_stack_validation_Copier.json)</li> <li> CALLF stack underflows (ethereum/tests: ./src/EOFTestsFiller/efExample/validInvalidFiller.yml src/EOFTestsFiller/EIP5450/validInvalidFiller.yml src/EOFTestsFiller/efStack/callf_stack_validation_Copier.json)</li> <li> CALLF stack underflow in variable stack segment, only min underflow (ethereum/tests: src/EOFTestsFiller/efStack/underflow_variable_stack_Copier.json)</li> <li> CALLF stack underflow in variable stack segment, both min and max underflow (ethereum/tests: src/EOFTestsFiller/efStack/underflow_variable_stack_Copier.json)</li> <li> Branching to CALLFs with the same number of outputs (ethereum/tests: src/EOFTestsFiller/EIP5450/validInvalidFiller.yml)</li> <li> Check that CALLF stack inputs/outputs equal to target section type definition</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#retf","title":"RETF","text":"<ul> <li> Valid RETF with correct number of items on stack (ethereum/tests: src/EOFTestsFiller/efStack/retf_stack_validation_Copier.json src/EOFTestsFiller/EIP5450/validInvalidFiller.yml)</li> <li> Invalid RETF with extra items on stack (ethereum/tests: src/EOFTestsFiller/efStack/retf_stack_validation_Copier.json ./src/EOFTestsFiller/efExample/validInvalidFiller.yml)</li> <li> RETF stack underflow (ethereum/tests: src/EOFTestsFiller/efStack/retf_stack_validation_Copier.json)</li> <li> RETF reached via different paths (ethereum/tests: src/EOFTestsFiller/efStack/retf_stack_validation_Copier.json)</li> <li> RETF in variable stack segment is not allowed (ethereum/tests: src/EOFTestsFiller/efStack/retf_variable_stack_Copier.json)</li> <li> Extra items on stack allowed for terminating instructions other than RETF (ethereum/tests: src/EOFTestsFiller/EIP5450/validInvalidFiller.yml)</li> <li> Invalid RETF in a non-returning function (<code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_nonreturning_validation.py::test_first_section_returning</code>)</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#jumpf","title":"JUMPF","text":"<ul> <li> Extra items on stack are allowed for JUMPF to non-returning function (ethereum/tests: src/EOFTestsFiller/efStack/jumpf_to_nonreturning_Copier.json src/EOFTestsFiller/efStack/jumpf_to_nonreturning_variable_stack_Copier.json)</li> <li> JUMPF stack underflows (ethereum/tests: src/EOFTestsFiller/efStack/jumpf_to_nonreturning_Copier.json src/EOFTestsFiller/efStack/jumpf_to_returning_Copier.json)</li> <li> JUMPF stack underflow in a variable stack segment - only min underflow (ethereum/tests: src/EOFTestsFiller/efStack/jumpf_to_nonreturning_variable_stack_Copier.json)</li> <li> JUMPF stack underflow in a variable stack segment - both min and max underflow (ethereum/tests: src/EOFTestsFiller/efStack/jumpf_to_nonreturning_variable_stack_Copier.json)</li> <li> JUMPF into function with the same number of outputs (ethereum/tests: src/EOFTestsFiller/efStack/jumpf_to_returning_Copier.json)</li> <li> JUMPF into function with fewer outputs than current one (ethereum/tests: src/EOFTestsFiller/efStack/jumpf_to_returning_Copier.json)</li> <li> Extra items on stack are allowed for JUMPF to returning function (ethereum/tests: src/EOFTestsFiller/efStack/jumpf_to_returning_Copier.json)</li> <li> JUMPF to returning in a variable stack segment is not allowed (ethereum/tests: src/EOFTestsFiller/efStack/jumpf_to_returning_variable_stack_Copier.json)</li> <li> Invalid JUMPF in a non-returning function (<code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_nonreturning_validation.py::test_retf_in_nonreturning</code>)</li> <li> Truncated JUMPF immediate</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#stack-overflow","title":"Stack overflow","text":""},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#callf_1","title":"CALLF","text":"<ul> <li> Max allowed stack height reached in CALLF-ed function (ethereum/tests: src/EOFTestsFiller/efStack/callf_stack_overflow_Copier.json)</li> <li> CALLF validation time stack overflow (ethereum/tests: src/EOFTestsFiller/efStack/callf_stack_overflow_Copier.json)</li> <li> Max allowed stack height reached in CALLF-ed function with inputs (ethereum/tests: src/EOFTestsFiller/efStack/callf_with_inputs_stack_overflow_Copier.json)</li> <li> CALLF validation time stack overflow in function with inputs (ethereum/tests: src/EOFTestsFiller/efStack/callf_with_inputs_stack_overflow_Copier.json)</li> <li> Max allowed stack height reached in CALLF-ed function. CALLF in variable stack segment. (ethereum/tests: src/EOFTestsFiller/efStack/callf_stack_overflow_variable_stack_Copier.json)</li> <li> CALLF validation time stack overflow in variable stack segment. (ethereum/tests: src/EOFTestsFiller/efStack/callf_stack_overflow_variable_stack_Copier.json)</li> <li> Max allowed stack height reached in CALLF-ed function with inputs. CALLF in variable stack segment. (ethereum/tests: src/EOFTestsFiller/efStack/callf_with_inputs_stack_overflow_variable_stack_Copier.json)</li> <li> CALLF validation time stack overflow in function with inputs in variable stack segment. (ethereum/tests: src/EOFTestsFiller/efStack/callf_with_inputs_stack_overflow_variable_stack_Copier.json)</li> <li> Function inputs are accessible and accounted for (no stack underflow if they are popped) (ethereum/tests: src/EOFTestsFiller/EIP5450/validInvalidFiller.yml)</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#jumpf_1","title":"JUMPF","text":"<ul> <li> Max allowed stack height reached in JUMPF-ed function (<code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_validation.py::test_jumpf_other_stack_overflow</code>)</li> <li> JUMPF validation time stack overflow (<code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_validation.py::test_jumpf_other_stack_overflow</code>)</li> <li> Max allowed stack height reached in JUMPF-ed function with inputs</li> <li> JUMPF validation time stack overflow in function with inputs (ethereum/tests: src/EOFTestsFiller/efStack/jumpf_with_inputs_stack_overflow_Copier.json)</li> <li> JUMPF validation time stack overflow in function with inputs, variable stack segment, only max overflow (ethereum/tests: src/EOFTestsFiller/efStack/jumpf_with_inputs_stack_overflow_variable_stack_Copier.json)</li> <li> JUMPF validation time stack overflow in function with inputs, variable stack segment, both max and min overflow (ethereum/tests: src/EOFTestsFiller/efStack/jumpf_with_inputs_stack_overflow_variable_stack_Copier.json)</li> <li> Max allowed stack height reached in JUMPF-ed function. JUMPF in variable stack segment. (ethereum/tests: src/EOFTestsFiller/efStack/jumpf_stack_overflow_variable_stack_Copier.json)</li> <li> JUMPF validation time stack overflow in variable stack segment - only max overflow. (ethereum/tests: src/EOFTestsFiller/efStack/jumpf_stack_overflow_variable_stack_Copier.json)</li> <li> JUMPF validation time stack overflow in variable stack segment - both min and max overflow. (ethereum/tests: src/EOFTestsFiller/efStack/jumpf_stack_overflow_variable_stack_Copier.json)</li> <li> Max allowed stack height reached in JUMPF-ed function with inputs. JUMPF in variable stack segment.</li> <li> JUMPF validation time stack overflow in function with inputs in variable stack segment.</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#swapndupnexchange","title":"SWAPN/DUPN/EXCHANGE","text":"<ul> <li> Valid DUPN with enough items on stack (ethereum/tests: src/EOFTestsFiller/efStack/dupn_stack_validation_Copier.json)</li> <li> DUPN stack underflow (ethereum/tests: src/EOFTestsFiller/efStack/dupn_stack_validation_Copier.json)</li> <li> Valid SWAPN with enough items on stack (ethereum/tests: src/EOFTestsFiller/efStack/swapn_stack_validation_Copier.json)</li> <li> SWAPN stack underflow (ethereum/tests: src/EOFTestsFiller/efStack/swapn_stack_validation_Copier.json)</li> <li> Valid EXCHANGE with enough items on stack (ethereum/tests: src/EOFTestsFiller/efStack/exchange_deep_stack_validation_Copier.json src/EOFTestsFiller/efStack/exchange_stack_validation_Copier.json)</li> <li> EXCHANGE stack underflow (ethereum/tests: src/EOFTestsFiller/efStack/exchange_stack_validation_Copier.json src/EOFTestsFiller/efStack/exchange_empty_stack_validation_Copier.json)</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#other","title":"Other","text":"<ul> <li> Wrong max_stack_height (ethereum/tests: ./src/EOFTestsFiller/efExample/validInvalidFiller.yml src/EOFTestsFiller/efValidation/max_stack_height_Copier.json)</li> <li> All opcodes correctly account for stack inputs/outputs (ethereum/tests: src/EOFTestsFiller/EIP5450/validInvalidFiller.yml)</li> <li> Code reachable only via backwards jump is invalid</li> <li> Maximally broad [0, 1023] stack range (ethereum/tests: src/EOFTestsFiller/efStack/stack_range_maximally_broad_Copier.json)</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#execution_3","title":"Execution","text":"<ul> <li> Max stack size (1024) in CALLF-ed function (<code>tests/osaka/eip7692_eof_v1/eip4750_functions/test_callf_execution.py::test_callf_operand_stack_size_max</code></li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#eip-6206-eof-jumpf-and-non-returning-functions","title":"EIP-6206: EOF - JUMPF and non-returning functions","text":""},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#validation_5","title":"Validation","text":"<ul> <li> Zero section returning (<code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_nonreturning_validation.py::test_first_section_returning</code>, ethereum/tests: ./src/EOFTestsFiller/efExample/validInvalidFiller.yml src/EOFTestsFiller/EIP4750/validInvalidFiller.yml)</li> <li> Zero section declared non-returning but ends with RETF (<code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_nonreturning_validation.py::test_retf_in_nonreturning</code>, ethereum/tests: src/EOFTestsFiller/EIP4750/validInvalidFiller.yml)</li> <li> CALLF into non-returning function (<code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_nonreturning_validation.py::test_callf_to_nonreturning</code>)</li> <li> Valid JUMPF into sections with equal number of outputs (<code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_execution.py::test_jumpf_to_retf</code>)</li> <li> Valid JUMPF into sections with different but compatible number of outputs (<code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_execution.py::test_jumpf_to_retf</code>)</li> <li> JUMPF into sections with incompatible outputs (<code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_stack.py::test_jumpf_incompatible_outputs</code>)</li> <li> Non-returning section without JUMPF (<code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_execution.py::test_jumpf_forward</code>)</li> <li> Non-returning section with JUMPF (<code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_nonreturning_validation.py::test_jumpf_in_nonreturning</code>)</li> <li> Returning section with RETF (<code>tests/osaka/eip7692_eof_v1/eip4750_functions/test_callf_execution.py::test_callf</code>)</li> <li> Returning section with JUMPF (<code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_validation.py::test_returning_jumpf</code>)</li> <li> Returning section with JUMPF to returning and RETF (<code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_execution.py::test_jumpf_to_retf</code>)</li> <li> Returning section with JUMPF to non-returning and RETF (<code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_validation.py::test_returning_jumpf</code>)</li> <li> Returning section without JUMPF nor RETF (<code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_nonreturning_validation.py::test_returning_section_not_returning</code>)</li> <li> Invalid non-returning flag (<code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_nonreturning_validation.py::test_returning_section_not_returning</code>)</li> <li> Circular JUMPF between two sections (<code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_execution.py::test_jumpf_infinite_loop</code>)</li> <li> JUMPF into non-existing section (<code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_validation.py::test_invalid_code_section_index</code>)</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#eip-7480-eof-data-section-access-instructions","title":"EIP-7480: EOF - Data section access instructions","text":""},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#validation_6","title":"Validation","text":"<ul> <li> Valid DATALOADN with various offsets (<code>tests/osaka/eip7692_eof_v1/eip7480_data_section/test_data_opcodes.py::test_dataloadn</code></li> <li> Truncated DATALOADN immediate (<code>tests/osaka/eip7692_eof_v1/eip7480_data_section/test_code_validation.py::test_dataloadn_truncated_immediate</code></li> <li> DATALOADN offset out of bounds (<code>tests/osaka/eip7692_eof_v1/eip7480_data_section/test_code_validation.py::test_invalid_containers_with_data_section</code></li> <li> DATALOADN accessing not full word (<code>tests/osaka/eip7692_eof_v1/eip7480_data_section/test_code_validation.py::test_invalid_containers_with_data_section</code></li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#eip-663-swapn-dupn-and-exchange-instructions","title":"EIP-663: SWAPN, DUPN and EXCHANGE instructions","text":""},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#validation_7","title":"Validation","text":"<ul> <li> A DUPN instruction causes stack overflow</li> <li> A DUPN instruction causes stack underflow</li> <li> A DUPN instruction causes max stack height mismatch</li> <li> A SWAPN instruction causes stack underflow</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#execution_4","title":"Execution","text":"<ul> <li> Positive tests for DUPN instructions (<code>./tests/osaka/eip7692_eof_v1/eip663_dupn_swapn_exchange/test_dupn.py::test_dupn_all_valid_immediates</code>)</li> <li> Positive tests for SWAPN instructions (<code>./tests/osaka/eip7692_eof_v1/eip663_dupn_swapn_exchange/test_swapn.py::test_swapn_all_valid_immediates</code>)</li> <li> Positive tests for EXCHANGE instruction (<code>./tests/osaka/eip7692_eof_v1/eip663_dupn_swapn_exchange/test_exchange.py::test_exchange_all_valid_immediates</code>)</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#eip-7069-revamped-call-instructions","title":"EIP-7069: Revamped CALL instructions","text":""},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#execution_5","title":"Execution","text":"<ul> <li> EXTDELEGATECALL from EOF to EOF (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py::test_eof_calls_eof_sstore</code>)</li> <li> EXTDELEGATECALL from EOF to legacy fails (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py::test_eof_calls_legacy_sstore</code>)</li> <li> EXTDELEGATECALL forwards static mode (evmone-tests: state_tests/state_transition/eof_calls/extdelegatecall_static.json)</li> <li> EXTCALL with value success (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py::test_eof_calls_with_value</code>)</li> <li> EXTCALL with value from EXTSTATICCALL (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py::test_eof_calls_static_flag_with_value</code>)</li> <li> EXTCALL with value, not enough balance (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py::test_eof_calls_with_value</code>)</li> <li> EXTCALL with value, check additional charge for value (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_gas.py::test_ext_calls_gas</code>)</li> <li> EXTCALL with gas not enough for callee to get 5000 gas (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py::test_eof_calls_min_callee_gas</code>)</li> <li> RETURNDATA* after EXTCALL (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_returndataload.py</code>)</li> <li> RETURNDATA* after EXTDELEGATECALL (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_returndataload.py</code>)</li> <li> RETURNDATA* after EXTSTATICCALL (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_returndataload.py</code>)</li> <li> RETURNDATA* after aborted EXT*CALL (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py::test_eof_calls_clear_return_buffer</code>)</li> <li> Failed EXTCALL clears returndata from previous EXTCALL (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py::test_eof_calls_clear_return_buffer</code>)</li> <li> EXTCALL not enough gas for input memory charge (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_gas.py::test_ext_calls_gas</code>)</li> <li> EXTDELEGATECALL not enough gas for input memory charge (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_gas.py::test_ext_calls_gas</code>)</li> <li> EXTSTATICCALL not enough gas for input memory charge (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_gas.py::test_ext_calls_gas</code>)</li> <li> EXTCALL exception due to target address overflow (bits set in high 12 bytes) (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_address_space_extension.py</code>)</li> <li> EXTDELEGATECALL exception due to target address overflow (bits set in high 12 bytes) (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_address_space_extension.py</code>)</li> <li> EXTSTATICCALL exception due to target address overflow (bits set in high 12 bytes) (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_address_space_extension.py</code>)</li> <li> EXTCALL not enough gas for warming up target address (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_gas.py::test_ext_calls_gas</code>)</li> <li> EXTDELEGATECALL not enough gas for warming up target address (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_gas.py::test_ext_calls_gas</code>)</li> <li> EXTSTATICCALL not enough gas for warming up target address (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_gas.py::test_ext_calls_gas</code>)</li> <li> EXTCALL not enough gas for account creation cost (transfer value to non-existing account) (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_gas.py::test_ext_calls_gas</code>)</li> <li> OOG after EXTCALL (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py::test_eof_calls_eof_then_fails</code>)</li> <li> OOG after EXTDELEGATECALL (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py::test_eof_calls_eof_then_fails</code>)</li> <li> OOG after EXTSTATICCALL (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py::test_eof_calls_eof_then_fails</code>)</li> <li> REVERT inside EXTCALL (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py::test_callee_fails</code>)</li> <li> REVERT inside EXTDELEGATECALL (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py::test_callee_fails</code>)</li> <li> REVERT inside EXTSTATICCALL (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py::test_callee_fails</code>)</li> <li> EXTCALL with input (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calldata.py</code>)</li> <li> EXTDELEGATECALL with input (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calldata.py</code>)</li> <li> EXTSTATICCALL with input (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calldata.py</code>)</li> <li> EXTCALL with just enough gas for MIN_RETAINED_GAS and MIN_CALLEE_GAS (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py::test_eof_calls_min_callee_gas</code>)</li> <li> EXTCALL with not enough gas for MIN_CALLEE_GAS (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py::test_eof_calls_min_callee_gas</code>)</li> <li> ADDRESS and CALLER inside EXTCALL (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py::test_callee_context</code>)</li> <li> ADDRESS and CALLER inside EXTDELEGATECALL (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py::test_callee_context</code>)</li> <li> ADDRESS and CALLER inside EXTSTATICCALL (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py::test_callee_context</code>)</li> <li> Refund inside EXTCALL is applied after the transaction (evmone-tests: state_tests/state_transition/eof_calls/extcall_gas_refund_propagation.json)</li> <li> Refund inside EXTDELEGATECALL is applied after the transaction (evmone-tests: state_tests/state_transition/eof_calls/extdelegatecall_gas_refund_propagation.json)</li> <li> EXTSTATICCALL from EOF to non-pure legacy contract failing (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py::test_eof_calls_legacy_sstore</code>)</li> <li> EXTSTATICCALL from EOF to pure EOF contract (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py::test_eof_calls_legacy_mstore</code>)</li> <li> EXTSTATICCALL from EOF to non-pure EOF contract failing (<code>./tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py::test_eof_calls_eof_sstore</code>)</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#eip-7620-eof-contract-creation","title":"EIP-7620: EOF Contract Creation","text":""},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#validation_8","title":"Validation","text":"<ul> <li> Valid EOFCREATEs referring to various container numbers (ethereum/tests: ./src/EOFTestsFiller/efValidation/EOF1_eofcreate_valid_Copier.json)</li> <li> Truncated before EOFCREATE immediate (<code>tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_eofcreate.py</code><code>-k test_eofcreate_invalid_truncated_immediate</code>)</li> <li> EOFCREATE is not a valid terminating instruction</li> <li> EOFCREATE immediate referring to non-existing container (<code>tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_eofcreate.py</code><code>-k test_eofcreate_invalid_index</code>)</li> <li> EOFCREATE immediate referring to container with truncated data (<code>tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_eofcreate.py</code><code>-k test_eofcreate_truncated_container</code>)</li> <li> Valid RETURNCODEs referring to various container numbers (<code>tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_returncode.py</code><code>-k test_returncode_valid_index</code>)</li> <li> Truncated before RETURNCODE immediate (<code>tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_returncode.py::test_returncode_invalid_truncated_immediate</code>)</li> <li> RETURNCODE immediate referring to non-existing container (<code>tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_returncode.py</code><code>-k test_returncode_invalid_index</code>)</li> <li> Unreachable code after RETURNCODE, check that RETURNCODE is terminating (<code>tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_returncode.py::test_returncode_terminating</code>)</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#execution_6","title":"Execution","text":"<ul> <li> CREATE with EOF initcode fails in Prague (evmone-tests: state_tests/state_transition/eof_create/create_with_eof_initcode.json)</li> <li> CREATE with EOF initcode fails in Cancun (evmone-tests: state_tests/state_transition/eof_create/create_with_eof_initcode_cancun.json)</li> <li> CREATE2 with EOF initcode fails in Prague (evmone-tests: state_tests/state_transition/eof_create/create2_with_eof_initcode.json)</li> <li> CREATE2 with EOF initcode fails in Cancun (evmone-tests: state_tests/state_transition/eof_create/create2_with_eof_initcode_cancun.json)</li> <li> CREATE with legacy initcode and EOF deploy code fails (evmone-tests: state_tests/state_transition/eof_create/create_deploying_eof.json)</li> <li> CREATE2 with legacy initcode and EOF deploy code fails (evmone-tests: state_tests/state_transition/eof_create/create2_deploying_eof.json)</li> <li> EOFCREATE success with empty aux data (evmone-tests: state_tests/state_transition/eof_create/eofcreate_empty_auxdata.json)</li> <li> EOFCREATE success with aux data length equal to declared in deploy container (evmone-tests: state_tests/state_transition/eof_create/eofcreate_auxdata_equal_to_declared.json)</li> <li> EOFCREATE success with aux data longer than size declared in deploy container (evmone-tests: state_tests/state_transition/eof_create/eofcreate_auxdata_longer_than_declared.json)</li> <li> EOFCREATE with aux data shorter than size declared in deploy container fails (evmone-tests: state_tests/state_transition/eof_create/eofcreate_auxdata_shorter_than_declared.json)</li> <li> EOFCREATE success deploying DATALOADN referring to aux data portion of deploy container data (evmone-tests: state_tests/state_transition/eof_create/eofcreate_dataloadn_referring_to_auxdata.json)</li> <li> EOFCREATE success with deploy container having aux data and subcontainer (evmone-tests: state_tests/state_transition/eof_create/eofcreate_with_auxdata_and_subcontainer.json)</li> <li> REVERT in initcontainer (evmone-tests: state_tests/state_transition/eof_create/eofcreate_revert_empty_returndata.json)</li> <li> REVERT with return data in initcontainer (evmone-tests: state_tests/state_transition/eof_create/eofcreate_revert_non_empty_returndata.json)</li> <li> Exceptional abort in initcontainer (evmone-tests: state_tests/state_transition/eof_create/eofcreate_initcontainer_aborts.json)</li> <li> EOFCREATE with deploy container of max size 0x6000 (evmone-tests: state_tests/state_transition/eof_create/eofcreate_deploy_container_max_size.json)</li> <li> EOFCREATE with deploy container size above limit (evmone-tests: state_tests/state_transition/eof_create/eofcreate_deploy_container_too_large.json)</li> <li> EOFCREATE with deploy container data size above 64K after appending aux data (evmone-tests: state_tests/state_transition/eof_create/eofcreate_appended_data_size_larger_than_64K.json)</li> <li> EOFCREATE with deploy container size above limit after appending aux data (evmone-tests: state_tests/state_transition/eof_create/eofcreate_deploy_container_with_aux_data_too_large.json)</li> <li> EOFCREATE success nested in EOFCREATE initcode (evmone-tests: state_tests/state_transition/eof_create/eofcreate_nested_eofcreate.json)</li> <li> EOFCREATE success nested in EOFCREATE initcode that reverts (evmone-tests: state_tests/state_transition/eof_create/eofcreate_nested_eofcreate_revert.json)</li> <li> EOFCREATE with value success</li> <li> EOFCREATE with value - not enough caller balance (evmone-tests: state_tests/state_transition/eof_create/eofcreate_caller_balance_too_low.json)</li> <li> EOFCREATE not enough gas for initcode (EIP-3860) charge (evmone-tests: state_tests/state_transition/eof_create/eofcreate_not_enough_gas_for_initcode_charge.json)</li> <li> EOFCREATE not enough gas for input memory expansion (evmone-tests: state_tests/state_transition/eof_create/eofcreate_not_enough_gas_for_mem_expansion.json)</li> <li> RETURNCODE not enough gas for aux data memory expansion (evmone-tests: state_tests/state_transition/eof_create/returncode_not_enough_gas_for_mem_expansion.json)</li> <li> Successful EOFCREATE clears returndata  (evmone-tests: state_tests/state_transition/eof_create/eofcreate_clears_returndata.json)</li> <li> Second EOFCREATE with the same container and salt fails (evmone-tests: state_tests/state_transition/eof_create/eofcreate_failure_after_eofcreate_success.json)</li> <li> Call created contract after EOFCREATE (evmone-tests: state_tests/state_transition/eof_create/eofcreate_call_created_contract.json)</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#eip-7698-eof-creation-transaction","title":"EIP-7698: EOF - Creation transaction","text":""},{"location":"tests/osaka/eip7692_eof_v1/eof_tracker/#execution_7","title":"Execution","text":"<ul> <li> Creation transaction success with empty deploy container data (evmone-tests: state_tests/state_transition/eof_create/creation_tx.json)</li> <li> Creation transaction success with data in deploy container without aux data (evmone-tests: state_tests/state_transition/eof_create/creation_tx_deploy_data.json)</li> <li> Creation transaction success with data in deploy container with aux data length equal to declared (evmone-tests: state_tests/state_transition/eof_create/creation_tx_static_auxdata_in_calldata.json)</li> <li> Creation transaction success with data in deploy container with aux data longer than declared (evmone-tests: state_tests/state_transition/eof_create/creation_tx_dynamic_auxdata_in_calldata.json)</li> <li> Creation transaction success deploying DATALOADN referring to aux data portion of deploy container data (evmone-tests: state_tests/state_transition/eof_create/creation_tx_dataloadn_referring_to_auxdata.json)</li> <li> Exceptional abort in creation transaction initcode (evmone-tests: state_tests/state_transition/eof_create/creation_tx_initcontainer_aborts.json)</li> <li> RETURN in creation transaction initcode fails (evmone-tests: state_tests/state_transition/eof_create/creation_tx_initcontainer_return.json)</li> <li> STOP in creation transaction initcode fails (evmone-tests: state_tests/state_transition/eof_create/creation_tx_initcontainer_stop.json)</li> <li> Creation transaction with initcode of max allowed size 0xc000 (evmone-tests: state_tests/state_transition/eof_create/creation_tx_initcontainer_max_size.json)</li> <li> Creation transaction with initcode size above limit (evmone-tests: state_tests/state_transition/eof_create/creation_tx_initcontainer_too_large.json)</li> <li> Creation transaction deploys container of max allowed size 0x6000 (evmone-tests: state_tests/state_transition/eof_create/creation_tx_deploy_container_max_size.json)</li> <li> Creation transaction deploying container of size above limit fails (evmone-tests: state_tests/state_transition/eof_create/creation_tx_deploy_container_too_large.json)</li> <li> EOFCREATE success nested in creation transaction initcode (evmone-tests: state_tests/state_transition/eof_create/creation_tx_nested_eofcreate.json)</li> <li> Creation transaction with invalid initcontainer (invalid header) (evmone-tests: state_tests/state_transition/eof_create/creation_tx_invalid_initcode_header.json)</li> <li> Creation transaction with invalid initcontainer (invalid EOF version) (evmone-tests: state_tests/state_transition/eof_create/creation_tx_invalid_eof_version.json)</li> <li> Creation transaction with invalid initcontainer (invalid max stack height) (evmone-tests: state_tests/state_transition/eof_create/creation_tx_invalid_initcode.json)</li> <li> Creation transaction fails if initcontainer has truncated data section (declared size &gt; present data size ) (evmone-tests: state_tests/state_transition/eof_create/creation_tx_truncated_data_initcode.json)</li> <li> Creation transaction with invalid deploy container (evmone-tests: state_tests/state_transition/eof_create/creation_tx_invalid_deploycode.json)</li> <li> Create transaction with legacy initcode and EOF deploy code fails (evmone-tests: state_tests/state_transition/eof_create/creation_tx_deploying_eof.json)</li> <li> EOF creation transaction fails before Prague (evmone-tests: state_tests/state_transition/eof_create/initcode_transaction_before_osaka.json)</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/","title":"EIP-3540 EOF V1","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip3540_eof_v1 --fork Osaka\n</code></pre> Test cases for EIP-3540: EOF - EVM Object Format v1 <p>EIP-3540 introduces a structured format for EVM bytecode, with separate sections for code and data. Opcodes introduced: None (defines a new bytecode structure but no new opcodes).</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/spec/","title":"Spec","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/spec.py@af77f529</code>.</p> <p>EOF V1 Constants used throughout all tests.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_all_opcodes_in_container/","title":"Test All Opcodes In Container","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_all_opcodes_in_container.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_all_opcodes_in_container.py --fork Osaka\n</code></pre> <p>EOF Container: check how every opcode behaves in the middle of the valid eof container code.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_all_opcodes_in_container/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_all_opcodes_in_container</code> eof_test 255 Test all opcodes inside valid container <code>test_invalid_opcodes_after_stop</code> eof_test 624 Test that an invalid opcode placed after STOP (terminating instruction) invalidates EOF. <code>test_all_invalid_terminating_opcodes</code> eof_test 142 Test all opcodes that are invalid as the last opcode in a container. <code>test_all_unreachable_terminating_opcodes_after_stop</code> eof_test 7 Test all terminating opcodes after stop. <code>test_all_unreachable_terminating_opcodes_before_stop</code> eof_test 6 Test all opcodes terminating opcodes before. <code>test_all_opcodes_stack_underflow</code> eof_test 96 Test stack underflow on all opcodes that require at least one item on the stack. <code>test_all_opcodes_stack_overflow</code> eof_test 140 Test stack overflow on all opcodes that push more items than they pop. <code>test_truncated_data_portion_opcodes</code> eof_test 152 Test that an instruction with data portion and truncated immediate bytes"},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_size/","title":"Test Container Size","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_size.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_size.py --fork Osaka\n</code></pre> <p>EOF validation tests for EIP-3540 container size.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_size/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_max_size</code> eof_test 4 Verify EOF container valid at maximum size, invalid above. <code>test_above_max_size_raw</code> eof_test 2 Verify EOF container invalid above maximum size, regardless of header contents. <code>test_section_after_end_of_container</code> eof_test 4 Verify EOF container is invalid if any of sections declares above container size."},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation/","title":"Test Container Validation","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation.py --fork Osaka\n</code></pre> <p>EOF validation tests for EIP-3540 container format.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_container_validation/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_valid_containers</code> eof_test 8 Test various types of valid containers. <code>test_invalid_containers</code> eof_test 122 Test invalid containers. <code>test_magic_validation</code> eof_test 34 Verify EOF container 2-byte magic. <code>test_version_validation</code> eof_test 5 Verify EOF container version. <code>test_single_code_section</code> eof_test 4 Verify EOF container single code section. <code>test_max_code_sections</code> eof_test 4 Verify EOF container maximum number of code sections."},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_eof_example/","title":"Test EOF Example","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_eof_example.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_eof_example.py --fork Osaka\n</code></pre> <p>EOF Classes example use.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_eof_example/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_eof_example</code> eof_test 1 Example of python EOF classes. <code>test_eof_example_custom_fields</code> eof_test 1 Example of python EOF container class tuning. <code>test_eof_example_parameters</code> eof_test 4 Example of EOF example parameters."},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_execution/","title":"Test Execution","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_execution.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_execution.py --fork Osaka\n</code></pre> <p>Execution of basic EOF containers.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_execution/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_eof_execution</code> state_test 2 Test simple contracts that are expected to succeed on call."},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_execution_function/","title":"Test Execution Function","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_execution_function.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_execution_function.py --fork Osaka\n</code></pre> <p>Execution of CALLF, RETF opcodes within EOF V1 containers tests.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_execution_function/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_eof_functions_contract_call_succeed</code> state_test 4 Test simple contracts that are simply expected to succeed on call. <code>test_eof_functions_contract_call_fail</code> state_test 4 Test simple contracts that are simply expected to fail on call. <code>test_eof_functions_contract_call_within_deep_nested</code> state_test 1 Test performing a call within a nested callf and verify correct behavior of"},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_extcode/","title":"Test Extcode","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_extcode.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_extcode.py --fork Osaka\n</code></pre> <p>test execution semantics changes.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_extcode/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_legacy_calls_eof_sstore</code> state_test 1 Test EXTCODE* opcodes calling EOF and legacy contracts."},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_migrated_valid_invalid/","title":"Test Migrated Valid INVALID","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_migrated_valid_invalid.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_migrated_valid_invalid.py --fork Osaka\n</code></pre> <p>EOF validation tests for EIP-3540 migrated from ethereum/tests/src/EOFTestsFiller/EIP3540/validInvalidFiller.yml.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_migrated_valid_invalid/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_migrated_valid_invalid</code> eof_test 40 Verify EOF container construction and exception."},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_opcodes_in_legacy/","title":"Test Opcodes In Legacy","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_opcodes_in_legacy.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_opcodes_in_legacy.py --fork Osaka\n</code></pre> <p>Tests all EOF-only opcodes in legacy contracts and expects failure.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_opcodes_in_legacy/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_opcodes_in_legacy</code> state_test 18 Test all EOF only opcodes in legacy contracts and expects failure. <code>test_opcodes_in_create_tx</code> state_test 18 Test all EOF only opcodes in create tx and expects failure. <code>test_opcodes_in_create_operation</code> state_test 36 Test opcodes in create operation. <code>test_opcodes_in_eof_calling_legacy</code> state_test 54 Test all opcodes in eof calling legacy and expects failure."},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_section_header_body_mismatch/","title":"Test Section Header Body Mismatch","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_section_header_body_mismatch.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_section_header_body_mismatch.py --fork Osaka\n</code></pre> <p>EOF Container construction test.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_section_header_body_mismatch/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_code_section_header_body_mismatch</code> eof_test 6 Inconsistent number of code sections (between types and code)."},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_section_order/","title":"Test Section Order","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_section_order.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_section_order.py --fork Osaka\n</code></pre> <p>Different variations of EOF sections displacement.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_section_order/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_section_order</code> eof_test 18 Test sections order and it appearance in body and header. <code>test_container_section_order</code> eof_test 12 Test containers section being out of order in the header and/or body."},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_section_size/","title":"Test Section Size","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_section_size.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_section_size.py --fork Osaka\n</code></pre> <p>EOF Container, test custom_size field for sections.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip3540_eof_v1/test_section_size/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_section_size</code> eof_test 24 Test custom_size is auto, more or less then the actual size of the section. <code>test_truncated_container_without_data</code> eof_test 4 Test takes a semi-valid container and removes some bytes from its tail. <code>test_truncated_container_with_data</code> eof_test 3 Test takes a valid container with data and removes some bytes from its tail."},{"location":"tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/","title":"EIP-4200 Relative Jumps","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip4200_relative_jumps --fork Osaka\n</code></pre> Test cases for EIP-4200: EOF - Static relative jumps <p>EIP-4200 replaces dynamic jump instructions with relative jump offsets for improved control flow predictability. Opcodes introduced: <code>RJUMP</code> (<code>0xE0</code>), <code>RJUMPI</code> (<code>0xE1</code>), <code>RJUMPV</code> (<code>0xE2</code>).</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjump/","title":"Test RJUMP","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjump.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjump.py --fork Osaka\n</code></pre> <p>EOF JUMPF tests covering stack and code validation rules.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjump/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_rjump_negative</code> eof_state_test 0 Test for a forward RJUMPI and backward RJUMP. <code>test_rjump_positive_negative</code> eof_state_test 0 EOF1V4200_0001 (Valid) EOF code containing RJUMP (Positive, Negative). <code>test_rjump_zero</code> eof_state_test 0 EOF1V4200_0002 (Valid) EOF code containing RJUMP (Zero). <code>test_rjump_maxes</code> eof_state_test 0 EOF1V4200_0003 EOF with RJUMP containing the max positive and negative offset (32767). <code>test_rjump_max_bytecode_size</code> eof_test 1 EOF1V4200_0003 EOF with RJUMP containing the maximum offset that does not exceed the maximum <code>test_rjump_truncated_rjump</code> eof_test 1 EOF1I4200_0001 (Invalid) EOF code containing truncated RJUMP. <code>test_rjump_truncated_rjump_2</code> eof_test 1 EOF1I4200_0002 (Invalid) EOF code containing truncated RJUMP. <code>test_rjump_into_header</code> eof_test 2 EOF1I4200_0003 (Invalid) EOF code containing RJUMP with target outside code bounds <code>test_rjump_before_header</code> eof_test 1 EOF1I4200_0004 (Invalid) EOF code containing RJUMP with target outside code bounds <code>test_rjump_into_data</code> eof_test 1 EOF1I4200_0005 (Invalid) EOF code containing RJUMP with target outside code bounds <code>test_rjump_outside_other_section_before</code> eof_test 1 EOF code containing RJUMP with target outside code bounds (prior code section). <code>test_rjump_outside_other_section_after</code> eof_test 1 EOF code containing RJUMP with target outside code bounds (Subsequent code section). <code>test_rjump_after_container</code> eof_test 1 EOF1I4200_0006 (Invalid) EOF code containing RJUMP with target outside code bounds <code>test_rjump_to_code_end</code> eof_test 1 EOF1I4200_0007 (Invalid) EOF code containing RJUMP with target outside code bounds <code>test_rjump_into_self_data_portion</code> eof_test 2 EOF1I4200_0008 (Invalid) EOF code containing RJUMP with target self RJUMP immediate. <code>test_rjump_into_self_remaining_code</code> eof_test 1 EOF1I4200_0008 (Invalid) EOF code containing RJUMP with target self RJUMP but remaining <code>test_rjump_into_self</code> eof_test 1 EOF code containing RJUMP with target self RJUMP. <code>test_rjump_into_self_pre_code</code> eof_test 1 EOF code containing RJUMP with target self RJUMP with non-zero stack before RJUMP. <code>test_rjump_valid_forward</code> eof_test 10 Validate a valid code section containing at least one forward RJUMP. <code>test_rjump_valid_backward</code> eof_test 5 Validate a valid code section containing at least one backward RJUMP. <code>test_rjump_into_stack_height_diff</code> eof_test 1 EOF code containing RJUMP with target instruction that causes stack height difference. <code>test_rjump_into_stack_height_diff_2</code> eof_test 1 EOF code containing RJUMP with target instruction that cause stack height difference. <code>test_rjump_backward_invalid_max_stack_height</code> eof_test 10 Validate a code section containing at least one backward RJUMP <code>test_rjump_into_stack_underflow</code> eof_test 1 EOF code containing RJUMP with target instruction that cause stack underflow. <code>test_rjump_into_rjump</code> eof_test 1 EOF1I4200_0009 (Invalid) EOF code containing RJUMP with target other RJUMP immediate. <code>test_rjump_into_rjumpi</code> eof_test 1 EOF1I4200_0010 (Invalid) EOF code containing RJUMP with target RJUMPI immediate. <code>test_rjump_into_push_1</code> eof_test 2 EOF1I4200_0011 (Invalid) EOF code containing RJUMP with target PUSH1 immediate. <code>test_rjump_into_push_n</code> eof_test 124 EOF1I4200_0011 (Invalid) EOF code containing RJUMP with target PUSH2+ immediate. <code>test_rjump_into_rjumpv</code> eof_test 4 EOF1I4200_0012 (Invalid) EOF code containing RJUMP with target RJUMPV immediate. <code>test_rjump_into_callf</code> eof_test 2 EOF1I4200_0013 (Invalid) EOF code containing RJUMP with target CALLF immediate. <code>test_rjump_into_dupn</code> eof_test 1 EOF code containing RJUMP with target DUPN immediate. <code>test_rjump_into_swapn</code> eof_test 1 EOF code containing RJUMP with target SWAPN immediate. <code>test_rjump_into_exchange</code> eof_test 1 EOF code containing RJUMP with target EXCHANGE immediate. <code>test_rjump_into_eofcreate</code> eof_test 1 EOF code containing RJUMP with target EOFCREATE immediate. <code>test_rjump_into_returncode</code> eof_test 1 EOF code containing RJUMP with target RETURNCODE immediate. <code>test_rjump_unreachable_code</code> eof_test 18 EOF code containing instructions skipped by RJUMP. <code>test_rjump_backwards_reference_only</code> eof_test 1 EOF code containing instructions only reachable by backwards RJUMP. <code>test_rjump_backwards_illegal_stack_height</code> eof_test 1 Invalid backward jump, found via fuzzing coverage. <code>test_rjump_backwards_infinite_loop</code> eof_test 1 Validate that a backwards RJUMP as terminal operation is valid."},{"location":"tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi/","title":"Test RJUMPI","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi.py --fork Osaka\n</code></pre> <p>EOF JUMPF tests covering stack and code validation rules.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpi/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_rjumpi_condition_forwards</code> state_test 2 Test RJUMPI contract switching based on external input (forwards). <code>test_rjumpi_condition_backwards</code> state_test 2 Test RJUMPI contract switching based on external input. <code>test_rjumpi_condition_zero</code> state_test 2 Test RJUMPI contract switching based on external input (condition zero). <code>test_rjumpi_forwards</code> eof_state_test 0 EOF1V4200_0004 (Valid) EOF code containing RJUMPI (Positive). <code>test_rjumpi_backwards</code> eof_state_test 0 EOF1V4200_0005 (Valid) EOF code containing RJUMPI (Negative). <code>test_rjumpi_zero</code> eof_state_test 0 EOF1V4200_0006 (Valid) EOF code containing RJUMPI (Zero). <code>test_rjumpi_max_forward</code> eof_state_test 0 EOF1V4200_0007 (Valid) EOF with RJUMPI containing the maximum offset (32767). <code>test_rjumpi_max_backward</code> eof_state_test 0 EOF with RJUMPI containing the maximum negative offset (-32768). <code>test_rjumpi_valid_forward</code> eof_test 26 Validate a valid code section containing at least one forward RJUMPI. <code>test_rjumpi_valid_backward</code> eof_test 10 Validate a valid code section containing at least one backward RJUMPI. <code>test_rjumpi_max_bytecode_size</code> eof_test 1 EOF1V4200_0003 EOF with RJUMPI containing the maximum offset that does not exceed the maximum <code>test_rjumpi_truncated</code> eof_test 1 EOF1I4200_0014 (Invalid) EOF code containing truncated RJUMPI. <code>test_rjumpi_truncated_2</code> eof_test 1 EOF1I4200_0015 (Invalid) EOF code containing truncated RJUMPI. <code>test_rjumpi_into_header</code> eof_test 2 EOF1I4200_0016 (Invalid) EOF code containing RJUMPI with target outside code bounds <code>test_rjumpi_jump_before_header</code> eof_test 1 EOF1I4200_0017 (Invalid) EOF code containing RJUMPI with target outside code bounds <code>test_rjumpi_into_data</code> eof_test 1 EOF1I4200_0018 (Invalid) EOF code containing RJUMPI with target outside code bounds <code>test_rjumpi_after_container</code> eof_test 1 EOF1I4200_0019 (Invalid) EOF code containing RJUMPI with target outside code bounds <code>test_rjumpi_to_code_end</code> eof_test 1 EOF1I4200_0020 (Invalid) EOF code containing RJUMPI with target outside code bounds <code>test_rjumpi_into_self_data_portion</code> eof_test 2 EOF1I4200_0021 (Invalid) EOF code containing RJUMPI with target same RJUMPI immediate <code>test_rjumpi_into_self</code> eof_test 1 EOF1I4200_0021 (Invalid) EOF code containing RJUMPI with target same RJUMPI immediate. <code>test_rjumpi_into_stack_height_diff</code> eof_test 1 EOF code containing RJUMPI with target instruction that causes stack height difference. <code>test_rjumpi_into_stack_underflow</code> eof_test 1 EOF code containing RJUMPI with target instruction that cause stack underflow. <code>test_rjumpi_skips_stack_underflow</code> eof_test 1 EOF code containing RJUMPI where the default path produces a stack underflow. <code>test_rjumpi_into_rjump</code> eof_test 1 EOF1I4200_0023 (Invalid) EOF code containing RJUMPI with target RJUMP immediate. <code>test_rjumpi_into_rjumpi</code> eof_test 1 EOF1I4200_0022 (Invalid) EOF code containing RJUMPI with target other RJUMPI immediate. <code>test_rjumpi_into_push_1</code> eof_test 2 EOF1I4200_0024 (Invalid) EOF code containing RJUMPI with target PUSH1 immediate. <code>test_rjumpi_into_push_n</code> eof_test 124 EOF1I4200_0024 (Invalid) EOF code containing RJUMPI with target PUSH2+ immediate. <code>test_rjumpi_into_rjumpv</code> eof_test 4 EOF1I4200_0025 (Invalid) EOF code containing RJUMPI with target RJUMPV immediate. <code>test_rjumpi_into_callf</code> eof_test 2 EOF1I4200_0026 (Invalid) EOF code containing RJUMPI with target CALLF immediate. <code>test_rjumpi_into_dupn</code> eof_test 1 EOF code containing RJUMPI with target DUPN immediate. <code>test_rjumpi_into_swapn</code> eof_test 1 EOF code containing RJUMPI with target SWAPN immediate. <code>test_rjumpi_into_exchange</code> eof_test 1 EOF code containing RJUMPI with target EXCHANGE immediate. <code>test_rjumpi_into_eofcreate</code> eof_test 1 EOF code containing RJUMPI with target EOFCREATE immediate. <code>test_rjumpi_into_returncode</code> eof_test 1 EOF code containing RJUMPI with target RETURNCODE immediate. <code>test_rjumpi_backwards_reference_only</code> eof_test 1 EOF code containing instructions only reachable by backwards RJUMPI. <code>test_rjumpi_stack_validation</code> eof_test 1 Check that you can get to the same opcode with two different stack heights <code>test_rjumpi_at_the_end</code> eof_test 1 Test invalid RJUMPI as the end of a code section. <code>test_tangled_rjumpi</code> eof_test 1 EOF code containing tangled RJUMPI paths. <code>test_rjumpi_backwards_onto_dup</code> eof_test 1 Backwards jumpi onto a dup. <code>test_rjumpi_backwards_min_stack_wrong</code> eof_test 1 Backwards rjumpi where min_stack does not match. <code>test_rjumpi_rjumpv_backwards_min_stack_wrong</code> eof_test 1 Backwards rjumpi rjumpv where min_stack does not match. <code>test_double_rjumpi_stack_underflow</code> eof_test 1 Two RJUMPIs, causing the min stack to underflow. <code>test_double_rjumpi_stack_height_mismatch</code> eof_test 1 Test stack height check of the backward RJUMP <code>test_double_rjumpi_invalid_max_stack_height</code> eof_test 1 Test max stack height of the final block <code>test_rjumpi_backward_invalid_max_stack_height</code> eof_test 10 Validate a code section containing at least one backward RJUMPI"},{"location":"tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv/","title":"Test RJUMPV","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv.py --fork Osaka\n</code></pre> <p>EOF JUMPF tests covering stack and code validation rules.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip4200_relative_jumps/test_rjumpv/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_rjumpv_condition</code> eof_state_test 0 Test RJUMPV contract switching based on external input. <code>test_rjumpv_forwards</code> eof_state_test 0 EOF1V4200_0008 (Valid) EOF with RJUMPV table size 1 (Positive). <code>test_rjumpv_backwards</code> eof_state_test 0 EOF1V4200_0009 (Valid) EOF with RJUMPV table size 1 (Negative). <code>test_rjumpv_backwards_onto_dup</code> eof_test 1 Backwards jumpv vector onto a dup. <code>test_rjumpv_backwards_large_table</code> eof_test 2 Backwards jump vector with a large table. <code>test_rjumpv_zero</code> eof_state_test 0 EOF1V4200_0010 (Valid) EOF with RJUMPV table size 1 (Zero). <code>test_rjumpv_size_3</code> eof_state_test 0 EOF1V4200_0011 (Valid) EOF with RJUMPV table size 3. <code>test_rjumpv_full_table</code> eof_state_test 0 EOF1V4200_0012/13/14/15 (Valid) EOF with RJUMPV table size 256 (target parameterized). <code>test_rjumpv_max_forwards</code> eof_state_test 0 EOF1V4200_0016 (Valid) EOF with RJUMPV containing the maximum offset (32767). <code>test_rjumpv_truncated_empty</code> eof_test 1 EOF1I4200_0027 (Invalid) EOF code containing RJUMPV with max_index 0 but no immediates. <code>test_rjumpv_truncated</code> eof_test 6 EOF1I4200_0028/29/30 (Invalid) EOF code containing truncated RJUMPV. <code>test_rjumpv_into_header</code> eof_test 3 EOF1I4200_0031 (Invalid) EOF code containing RJUMPV with target outside code bounds <code>test_rjumpv_before_container</code> eof_test 6 EOF1I4200_0032 (Invalid) EOF code containing RJUMPV with target outside code bounds <code>test_rjumpv_into_data</code> eof_test 3 EOF1I4200_0033 (Invalid) EOF code containing RJUMPV with target outside code bounds <code>test_rjumpv_after_container</code> eof_test 3 EOF1I4200_0034 (Invalid) EOF code containing RJUMPV with target outside code bounds <code>test_rjumpv_at_end</code> eof_test 3 EOF1I4200_0035 (Invalid) EOF code containing RJUMPV with target outside code bounds <code>test_rjumpv_into_self_data_portion</code> eof_test 6 EOF1I4200_0036 (Invalid) EOF code containing RJUMPV with target same RJUMPV immediate. <code>test_rjumpv_into_self</code> eof_test 3 EOF code containing RJUMPV with target same RJUMPV immediate. <code>test_rjumpv_into_stack_height_diff</code> eof_test 3 EOF code containing RJUMPV with target instruction that causes stack height difference. <code>test_rjumpv_into_stack_underflow</code> eof_test 3 EOF code containing RJUMPV with target instruction that cause stack underflow. <code>test_rjumpv_skips_stack_underflow</code> eof_test 2 EOF code containing RJUMPV where the default path produces a stack underflow. <code>test_rjumpv_into_rjump</code> eof_test 6 EOF1I4200_0037 (Invalid) EOF code containing RJUMPV with target RJUMP immediate. <code>test_rjumpv_into_rjumpi</code> eof_test 6 EOF1I4200_0038 (Invalid) EOF code containing RJUMPV with target RJUMPI immediate. <code>test_rjumpv_into_push_1</code> eof_test 6 EOF1I4200_0039 (Invalid) EOF code containing RJUMPV with target PUSH1 immediate. <code>test_rjumpv_into_push_n</code> eof_test 372 EOF1I4200_0039 (Invalid) EOF code containing RJUMPV with target PUSHN immediate. <code>test_rjumpv_into_rjumpv</code> eof_test 12 EOF1I4200_0040 (Invalid) EOF code containing RJUMPV with target other RJUMPV immediate. <code>test_rjumpv_into_callf</code> eof_test 6 EOF1I4200_0041 (Invalid) EOF code containing RJUMPV with target CALLF immediate. <code>test_rjumpv_into_dupn</code> eof_test 3 EOF code containing RJUMPV with target DUPN immediate. <code>test_rjumpv_into_swapn</code> eof_test 3 EOF code containing RJUMPV with target SWAPN immediate. <code>test_rjumpv_into_exchange</code> eof_test 3 EOF code containing RJUMPV with target EXCHANGE immediate. <code>test_rjumpv_into_eofcreate</code> eof_test 3 EOF code containing RJUMPV with target EOFCREATE immediate. <code>test_rjumpv_into_returncode</code> eof_test 3 EOF code containing RJUMPV with target RETURNCODE immediate. <code>test_rjumpv_backwards_reference_only</code> eof_test 1 EOF code containing instructions only reachable by backwards RJUMPV. <code>test_rjumpv_at_the_end</code> eof_test 1 https://github.com/ipsilon/eof/blob/main/spec/eof.md#stack-validation 4.i:(\ud83d\udcd6\ud83d\udc1b?) <code>test_rjumpv_backwards_min_stack_wrong</code> eof_test 1 Backwards rjumpv where min_stack does not match. <code>test_rjumpv_rjumpi_backwards_min_stack_wrong</code> eof_test 1 Backwards rjumpv rjumpi where min_stack does not match. <code>test_double_rjumpv</code> eof_test 1 Two RJUMPVs, causing the min stack to underflow. <code>test_rjumpv_valid_forward</code> eof_test 20 Validate a valid code section containing at least one forward RJUMPV. <code>test_rjumpv_valid_backward</code> eof_test 8 Validate a valid code section containing at least one backward RJUMPV. <code>test_rjumpv_backward_invalid_max_stack_height</code> eof_test 8 Validate a code section containing at least one backward RJUMPV"},{"location":"tests/osaka/eip7692_eof_v1/eip4750_functions/","title":"EIP-4750 Functions","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip4750_functions@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip4750_functions --fork Osaka\n</code></pre> Test cases for EIP-4750: EOF - Functions <p>EIP-4750 formalizes functions in the EVM object format, introducing callable units of code. Opcodes introduced: <code>CALLF</code> (<code>0xE3</code>), <code>RETF</code> (<code>0xE4</code>).</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip4750_functions/test_callf_execution/","title":"Test CALLF Execution","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip4750_functions/test_callf_execution.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip4750_functions/test_callf_execution.py --fork Osaka\n</code></pre> <p>EOF CALLF execution tests.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip4750_functions/test_callf_execution/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_callf_factorial</code> eof_state_test 0 Test factorial implementation with recursive CALLF instructions. <code>test_callf_fibonacci</code> eof_state_test 0 Test fibonacci sequence implementation with recursive CALLF instructions. <code>test_callf</code> eof_state_test 0 Test basic usage of CALLF and RETF instructions. <code>test_callf_operand_stack_size_max</code> eof_state_test 0 Test operand stack reaching 1024 items. <code>test_callf_operand_stack_overflow</code> eof_state_test 0 Test stack overflowing 1024 items in called function. <code>test_callf_sneaky_stack_overflow</code> state_test 2 CALLF where a normal execution would not overflow, but EIP-4750 CALLF rule #3 triggers. <code>test_callf_max_stack</code> state_test 3 CALLF where a normal execution would not overflow, but EIP-4750 CALLF rule #4 triggers. <code>test_callf_retf_memory_context</code> state_test 1 Verifies CALLF and RETF don't corrupt memory."},{"location":"tests/osaka/eip7692_eof_v1/eip4750_functions/test_code_validation/","title":"Test Code Validation","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip4750_functions/test_code_validation.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip4750_functions/test_code_validation.py --fork Osaka\n</code></pre> <p>Code validation of CALLF, RETF opcodes tests.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip4750_functions/test_code_validation/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_eof_validity</code> eof_test 12 Test EOF container validation for features around EIP-4750 / Functions / Code Sections. <code>test_callf_truncated_immediate</code> eof_test 3 Test cases for CALLF instructions with truncated immediate bytes. <code>test_invalid_code_section_index</code> eof_test 3 Test cases for CALLF instructions with invalid target code section index. <code>test_unreachable_code_sections</code> eof_test 19 Test cases for EOF unreachable code sections <code>test_callf_stack_height_limit_exceeded</code> eof_test 3 Test for invalid EOF code containing CALLF instruction exceeding the stack height limit. <code>test_callf_stack_overflow_by_outputs</code> eof_test 16 Test for invalid EOF code containing CALLF instruction exceeding the runtime stack height limit <code>test_callf_stack_overflow_by_height</code> eof_test 4 Test for invalid EOF code containing CALLF instruction exceeding the runtime stack height limit <code>test_returning_section_aborts</code> eof_test 1 Test EOF container validation where in the same code section we have returning"},{"location":"tests/osaka/eip7692_eof_v1/eip5450_stack/","title":"EIP-5450 Stack","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip5450_stack@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip5450_stack --fork Osaka\n</code></pre> Test cases for EIP-5450: EOF - Stack Validation <p>EIP-5450 defines stack validation requirements to ensure consistent behavior during execution. Opcodes introduced: None (specifies validation rules for stack usage).</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip5450_stack/test_code_validation/","title":"Test Code Validation","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip5450_stack/test_code_validation.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip5450_stack/test_code_validation.py --fork Osaka\n</code></pre> <p>Code validation of CALLF, JUMPF, RETF opcodes in conjunction with static relative jumps.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip5450_stack/test_code_validation/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_rjumps_callf_retf</code> eof_test 832 Test EOF container validaiton for EIP-4200 vs EIP-4750 interactions. <code>test_rjumps_jumpf_nonreturning</code> eof_test 104 Test EOF container validaiton for EIP-4200 vs EIP-6206 interactions on non-returning"},{"location":"tests/osaka/eip7692_eof_v1/eip6206_jumpf/","title":"EIP-6206 JUMPF","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip6206_jumpf@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip6206_jumpf --fork Osaka\n</code></pre> Test cases for EIP-6206: EOF - JUMPF and non-returning functions <p>EIP-6206 adds a conditional forward jump instruction and support for functions without return values. Opcodes introduced: <code>JUMPF</code> (<code>0xE5</code>).</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip6206_jumpf/spec/","title":"Spec","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/spec.py@af77f529</code>.</p> <p>EOF V1 Constants used throughout all tests.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_execution/","title":"Test JUMPF Execution","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_execution.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_execution.py --fork Osaka\n</code></pre> <p>EOF JUMPF tests covering simple cases.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_execution/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_jumpf_forward</code> eof_state_test 0 Test JUMPF jumping forward. <code>test_jumpf_to_retf</code> eof_state_test 0 Tests JUMPF to a returning section with RETF. <code>test_jumpf_to_self</code> eof_state_test 0 Tests JUMPF jumping to self. <code>test_jumpf_and_retf</code> eof_state_test 0 Tests JUMPF and RETF in the same section. <code>test_jumpf_too_large</code> eof_state_test 0 Tests JUMPF jumping to a section outside the max section range. <code>test_jumpf_way_too_large</code> eof_state_test 0 Tests JUMPF jumping to uint64.MAX. <code>test_jumpf_to_nonexistent_section</code> eof_state_test 0 Tests JUMPF jumping to valid section number but where the section does not exist. <code>test_callf_to_non_returning_section</code> eof_state_test 0 Tests CALLF into a non-returning section. <code>test_jumpf_stack_size_1024</code> eof_state_test 0 Test stack reaching 1024 items in target function of JUMPF. <code>test_jumpf_with_inputs_stack_size_1024</code> eof_state_test 0 Test stack reaching 1024 items in target function of JUMPF with inputs. <code>test_jumpf_stack_size_1024_at_push</code> eof_state_test 0 Test stack reaching 1024 items in JUMPF target function at PUSH0 instruction. <code>test_jumpf_stack_overflow</code> eof_state_test 0 Test rule #2 in execution semantics, where we make sure we have enough stack to guarantee <code>test_jumpf_with_inputs_stack_size_1024_at_push</code> eof_state_test 0 Test stack reaching 1024 items in JUMPF target function with inputs at PUSH0 instruction. <code>test_jumpf_with_inputs_stack_overflow</code> eof_state_test 0 Test stack overflowing 1024 items in JUMPF target function with inputs. <code>test_jumpf_infinite_loop</code> eof_state_test 0 Tests JUMPF causing an infinite loop. <code>test_jumpf_memory_context</code> state_test 1 Verifies JUMPF doesn't corrupt memory. <code>test_callf_jumpf_retf_memory_context</code> state_test 1 Verifies CALLF, JUMPF and RETF don't corrupt memory."},{"location":"tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_stack/","title":"Test JUMPF Stack","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_stack.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_stack.py --fork Osaka\n</code></pre> <p>EOF JUMPF tests covering stack validation rules.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_stack/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_jumpf_stack_non_returning_rules</code> eof_state_test 0 Tests for JUMPF validation stack rules.  Non-returning section cases. <code>test_jumpf_stack_returning_rules</code> eof_state_test 0 Tests for JUMPF validation stack rules.  Returning section cases. <code>test_jumpf_incompatible_outputs</code> eof_test 6 Tests JUMPF into a section with incorrect number of outputs. <code>test_jumpf_diff_max_stack_height</code> eof_test 6 Tests jumpf with a different max stack height. <code>test_jumpf_diff_min_stack_height</code> eof_test 6 Tests jumpf with a different min stack height."},{"location":"tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_target/","title":"Test JUMPF Target","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_target.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_target.py --fork Osaka\n</code></pre> <p>EOF JUMPF tests covering JUMPF target rules.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_target/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_jumpf_target_rules</code> eof_state_test 0 Validate the target section rules of JUMPF, and execute valid cases. <code>test_jumpf_multi_target_rules</code> eof_state_test 0 NOT IMPLEMENTED:(\ud83d\udcd6\ud83d\udc1b?)"},{"location":"tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_validation/","title":"Test JUMPF Validation","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_validation.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_validation.py --fork Osaka\n</code></pre> <p>EOF validation tests for JUMPF instruction.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_jumpf_validation/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_returning_jumpf</code> eof_test 3 Test cases for JUMPF instruction validation in a returning sections. <code>test_invalid_code_section_index</code> eof_test 3 Test cases for JUMPF instructions with invalid target code section index. <code>test_returning_section_aborts_jumpf</code> eof_test 1 Test EOF container validation where in the same code section we have returning <code>test_jumpf_self_stack_overflow</code> eof_test 3 Test JUMPF instruction jumping to itself causing validation time stack overflow. <code>test_jumpf_other_stack_overflow</code> eof_test 25 Test JUMPF instruction jumping to itself causing validation time stack overflow."},{"location":"tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_nonreturning_validation/","title":"Test Nonreturning Validation","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_nonreturning_validation.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_nonreturning_validation.py --fork Osaka\n</code></pre> <p>EOF validation tests for non-returning code sections.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip6206_jumpf/test_nonreturning_validation/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_first_section_returning</code> eof_test 6 Test EOF validation failing because the first section is not non-returning. <code>test_returning_section_not_returning</code> eof_test 10 Test EOF validation failing due to returning section with no RETF or JUMPF-to-returning. <code>test_returning_section_returncode</code> eof_test 2 Test EOF validation failing because a returning section has no RETF or JUMPF-to-returning - <code>test_retf_in_nonreturning</code> eof_test 6 Test EOF validation failing due to non-returning section with the RETF instruction. <code>test_jumpf_in_nonreturning</code> eof_test 6 Test EOF validation failing due to non-returning section with the JUMPF instruction. <code>test_callf_to_nonreturning</code> eof_test 5 Test EOF validation failing due to CALLF to non-returning section."},{"location":"tests/osaka/eip7692_eof_v1/eip663_dupn_swapn_exchange/","title":"EIP-663 DUPN SWAPN EXCHANGE","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip663_dupn_swapn_exchange@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip663_dupn_swapn_exchange --fork Osaka\n</code></pre> Test cases for EIP-663: SWAPN, DUPN and EXCHANGE instructions <p>EIP-663 defines new stack manipulation instructions that allow accessing the stack at higher depths. Opcodes introduced: <code>DUPN</code> (<code>0xE6</code>), <code>SWAPN</code> (<code>0xE7</code>), <code>EXCHANGEN</code> (<code>0xE8</code>).</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip663_dupn_swapn_exchange/test_dupn/","title":"Test DUPN","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip663_dupn_swapn_exchange/test_dupn.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip663_dupn_swapn_exchange/test_dupn.py --fork Osaka\n</code></pre> Tests EIP-663: SWAPN, DUPN and EXCHANGE instructions <p>Tests for the DUPN instruction.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip663_dupn_swapn_exchange/test_dupn/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_dupn_all_valid_immediates</code> eof_state_test 0 Test case for all valid DUPN immediates. <code>test_dupn_stack_underflow</code> eof_test 6 Test case out of bounds DUPN immediate. <code>test_dupn_stack_overflow</code> eof_test 4 Test case where DUPN produces an stack overflow."},{"location":"tests/osaka/eip7692_eof_v1/eip663_dupn_swapn_exchange/test_exchange/","title":"Test EXCHANGE","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip663_dupn_swapn_exchange/test_exchange.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip663_dupn_swapn_exchange/test_exchange.py --fork Osaka\n</code></pre> Tests EIP-663: SWAPN, DUPN and EXCHANGE instructions <p>Tests for the EXCHANGE instruction.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip663_dupn_swapn_exchange/test_exchange/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_exchange_all_valid_immediates</code> eof_state_test 0 Test case for all valid EXCHANGE immediates. <code>test_exchange_all_invalid_immediates</code> eof_test 6 Test case for all invalid EXCHANGE immediates."},{"location":"tests/osaka/eip7692_eof_v1/eip663_dupn_swapn_exchange/test_swapn/","title":"Test SWAPN","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip663_dupn_swapn_exchange/test_swapn.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip663_dupn_swapn_exchange/test_swapn.py --fork Osaka\n</code></pre> Tests EIP-663: SWAPN, DUPN and EXCHANGE instructions <p>Tests for the SWAPN instruction.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip663_dupn_swapn_exchange/test_swapn/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_swapn_all_valid_immediates</code> eof_state_test 0 Test case for all valid SWAPN immediates. <code>test_swapn_on_max_stack</code> eof_test 2 Test case out of bounds SWAPN (max stack). <code>test_swapn_stack_underflow</code> eof_test 4 Test case out of bounds SWAPN (underflow)."},{"location":"tests/osaka/eip7692_eof_v1/eip7069_extcall/","title":"EIP-7069 EXTCALL","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7069_extcall@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip7069_extcall --fork Osaka\n</code></pre> Test cases for EIP-7069: Revamped CALL instructions <p>EIP-7069 proposes modifications to <code>CALL</code> instructions to align with the structured EOF format. Opcodes introduced: <code>EXTCALL</code> (<code>0xF8</code>), <code>EXTDELEGATECALL</code> (<code>0xF9</code>), <code>EXTSTATICCALL</code> (<code>0xFB</code>), <code>RETURNDATALOAD</code> (<code>0xF7</code>).</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip7069_extcall/spec/","title":"Spec","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7069_extcall/spec.py@af77f529</code>.</p> <p>EOF V1 Constants used throughout all tests.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip7069_extcall/test_address_space_extension/","title":"Test ADDRESS Space Extension","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7069_extcall/test_address_space_extension.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip7069_extcall/test_address_space_extension.py --fork Osaka\n</code></pre> <p>Tests the \"Address Space Extension\" aspect of EXT*CALL.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip7069_extcall/test_address_space_extension/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_address_space_extension</code> state_test 224 Test contacts with possibly extended address and fail if address is too large."},{"location":"tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calldata/","title":"Test Calldata","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calldata.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calldata.py --fork Osaka\n</code></pre> Tests EIP-7069: Revamped CALL instructions <p>Tests for the RETURNDATALOAD instruction.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calldata/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_extcalls_inputdata</code> state_test 128 Tests call data into EXTCALL including multiple offset conditions. <code>test_extdelegatecall_inputdata</code> state_test 64 Tests call data into EXTDELEGATECALL including multiple offset conditions. <code>test_extstaticcall_inputdata</code> state_test 64 Tests call data into EXTSTATICCALL including multiple offset conditions. <code>test_calldata_remains_after_subcall</code> state_test 7 Tests call data remains after a call to another contract. <code>test_extcalls_input_offset</code> state_test 96 Tests call data into EXT*CALL including multiple offset conditions."},{"location":"tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls/","title":"Test Calls","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls.py --fork Osaka\n</code></pre> <p>test calls across EOF and Legacy.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip7069_extcall/test_calls/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_legacy_calls_eof_sstore</code> state_test 4 Test legacy contracts calling EOF contracts that use SSTORE. <code>test_legacy_calls_eof_mstore</code> state_test 4 Test legacy contracts calling EOF contracts that only return data. <code>test_eof_calls_eof_sstore</code> state_test 3 Test EOF contracts calling EOF contracts that use SSTORE. <code>test_eof_calls_eof_mstore</code> state_test 3 Test EOF contracts calling EOF contracts that return data. <code>test_eof_calls_precompile</code> state_test 9 Test EOF contracts calling precompiles. <code>test_eof_calls_legacy_sstore</code> state_test 3 Test EOF contracts calling Legacy contracts that use SSTORE. <code>test_eof_calls_legacy_mstore</code> state_test 3 Test EOF contracts calling Legacy contracts that return data. <code>test_callee_fails</code> state_test 21 Test EOF contracts calling contracts that fail for various reasons. <code>test_callee_context</code> state_test 24 Test EOF calls' callee context instructions. <code>test_eof_calls_eof_then_fails</code> state_test 4 Test EOF contracts calling EOF contracts and failing after the call. <code>test_eof_calls_clear_return_buffer</code> state_test 36 Test EOF contracts calling clears returndata buffer. <code>test_eof_calls_static_flag_with_value</code> state_test 2 Test EOF contracts calls handle static flag and sending value correctly. <code>test_eof_calls_min_callee_gas</code> state_test 16 Test EOF contracts calls do light failure when retained/callee gas is not enough. <code>test_eof_calls_with_value</code> state_test 16 Test EOF contracts calls handle value calls with and without enough balance. <code>test_eof_calls_msg_depth</code> state_test 3 Test EOF contracts calls handle msg depth limit correctly (1024)."},{"location":"tests/osaka/eip7692_eof_v1/eip7069_extcall/test_gas/","title":"Test Gas","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7069_extcall/test_gas.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip7069_extcall/test_gas.py --fork Osaka\n</code></pre> Tests EIP-7069: Revamped CALL instructions <p>Tests gas consumption.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip7069_extcall/test_gas/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_ext_calls_gas</code> state_test 32 Tests variations of EXT*CALL gas, both warm and cold, without and with mem expansions. <code>test_transfer_gas_is_cleared</code> state_test 6 Test that EXT*CALL call doesn't charge for value transfer, even if the outer call <code>test_late_account_create</code> state_test 3 Test EXTCALL to a non-existent account after another EXT*CALL has called it and not"},{"location":"tests/osaka/eip7692_eof_v1/eip7069_extcall/test_returndatacopy_memory_expansion/","title":"Test RETURNDATACOPY Memory Expansion","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7069_extcall/test_returndatacopy_memory_expansion.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip7069_extcall/test_returndatacopy_memory_expansion.py --fork Osaka\n</code></pre> <p>Memory expansion tests for RETURNDATACOPY executing in EOF code.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip7069_extcall/test_returndatacopy_memory_expansion/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_returndatacopy_memory_expansion</code> state_test 40 Perform RETURNDATACOPY operations that expand the memory, and verify the gas it costs. <code>test_returndatacopy_huge_memory_expansion</code> state_test 28 Perform RETURNDATACOPY operations that expand the memory by huge amounts, and verify that it"},{"location":"tests/osaka/eip7692_eof_v1/eip7069_extcall/test_returndataload/","title":"Test RETURNDATALOAD","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7069_extcall/test_returndataload.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip7069_extcall/test_returndataload.py --fork Osaka\n</code></pre> Tests EIP-7069: Revamped CALL instructions <p>Tests for the RETURNDATALOAD instruction.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip7069_extcall/test_returndataload/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_returndatacopy_handling</code> state_test 448 Tests ReturnDataLoad including multiple offset conditions and differing legacy vs. eof <code>test_returndataload_handling</code> state_test 48 Much simpler than returndatacopy, no memory or boosted call.  Returner is called <code>test_returndatacopy_oob</code> state_test 2 Extends the RETURNDATACOPY test for correct out-of-bounds behavior, by checking if the"},{"location":"tests/osaka/eip7692_eof_v1/eip7480_data_section/","title":"EIP-7480 Data Section","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7480_data_section@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip7480_data_section --fork Osaka\n</code></pre> Test cases for EIP-7480: EOF - Data section access instructions <p>EIP-7480 specifies instructions for accessing data stored in the dedicated data section of the EOF format. Opcodes introduced: <code>DATALOAD</code> (<code>0xD0</code>), <code>DATALOADN</code> (<code>0xD1</code>), <code>DATASIZE</code> (<code>0xD2</code>), <code>DATACOPY</code> (<code>0xD3</code>).</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip7480_data_section/spec/","title":"Spec","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7480_data_section/spec.py@af77f529</code>.</p> <p>EOF V1 Constants used throughout all tests.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip7480_data_section/test_code_validation/","title":"Test Code Validation","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7480_data_section/test_code_validation.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip7480_data_section/test_code_validation.py --fork Osaka\n</code></pre> <p>EOF V1 Code Validation tests.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip7480_data_section/test_code_validation/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_valid_containers_with_data_section</code> eof_test 7 Test EOF validation of valid containers with data sections. <code>test_invalid_containers_with_data_section</code> eof_test 10 Test EOF validation of invalid containers with data sections. <code>test_dataloadn_truncated_immediate</code> eof_test 3 Test cases for DATALOADN instructions with truncated immediate bytes."},{"location":"tests/osaka/eip7692_eof_v1/eip7480_data_section/test_data_opcodes/","title":"Test Data Opcodes","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7480_data_section/test_data_opcodes.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip7480_data_section/test_data_opcodes.py --fork Osaka\n</code></pre> <p>Execution of DATA* opcodes within EOF V1 containers tests.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip7480_data_section/test_data_opcodes/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_dataloadn</code> eof_state_test 0 Basic tests for DATALOADN execution. <code>test_data_section_succeed</code> state_test 18 Test simple contracts that simply expect data section to succeed."},{"location":"tests/osaka/eip7692_eof_v1/eip7480_data_section/test_datacopy_memory_expansion/","title":"Test DATACOPY Memory Expansion","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7480_data_section/test_datacopy_memory_expansion.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip7480_data_section/test_datacopy_memory_expansion.py --fork Osaka\n</code></pre> <p>Memory expansion tests for DATACOPY.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip7480_data_section/test_datacopy_memory_expansion/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_datacopy_memory_expansion</code> state_test 160 Perform DATACOPY operations that expand the memory, and verify the gas it costs to do so. <code>test_datacopy_huge_memory_expansion</code> state_test 112 Perform DATACOPY operations that expand the memory by huge amounts, and verify that it"},{"location":"tests/osaka/eip7692_eof_v1/eip7620_eof_create/","title":"EIP-7620 EOF CREATE","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7620_eof_create@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip7620_eof_create --fork Osaka\n</code></pre> Test cases for EIP-7620: EOF Contract Creation <p>EIP-7620 replaces <code>CREATE</code> and <code>CREATE2</code> with <code>EOFCREATE</code> for deploying contracts in the EOF format. Opcodes introduced: <code>EOFCREATE</code> (<code>0xEC</code>), <code>RETURNCODE</code> (<code>0xEE</code>).</p> <p>EOFCREATE, RETURNCODE, and container tests</p> <p>evmone tests not ported</p> <ul> <li>create_tx_with_eof_initcode - This calls it invalid, it is now the way to add EOF contacts to state</li> <li>eofcreate_extcall_returncode - per the new initcode mode tests you cannot have RETURNCODE     in a deployed contract</li> <li>eofcreate_dataloadn_referring_to_auxdata - covered by     tests.osaka.eip7480_data_section.test_data_opcodes.test_data_section_succeed</li> <li>eofcreate_initcontainer_return - RETURN is banned in initcode containers</li> <li>eofcreate_initcontainer_stop - STOP is banned in initcode containers</li> <li>All TXCREATE tests.</li> </ul>"},{"location":"tests/osaka/eip7692_eof_v1/eip7620_eof_create/spec/","title":"Spec","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7620_eof_create/spec.py@af77f529</code>.</p> <p>EOF V1 Constants used throughout all tests.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_eofcreate/","title":"Test EOFCREATE","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_eofcreate.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_eofcreate.py --fork Osaka\n</code></pre> <p>Test good and bad EOFCREATE cases.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_eofcreate/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_simple_eofcreate</code> state_test 1 Verifies a simple EOFCREATE case. <code>test_eofcreate_then_dataload</code> state_test 1 Verifies that a contract returned with auxdata does not overwrite the parent data. <code>test_eofcreate_then_call</code> state_test 1 Verifies a simple EOFCREATE case, and then calls the deployed contract. <code>test_auxdata_variations</code> state_test 6 Verifies that auxdata bytes are correctly handled in RETURNCODE. <code>test_calldata</code> state_test 1 Verifies CALLDATA passing through EOFCREATE. <code>test_eofcreate_in_initcode</code> state_test 1 Verifies an EOFCREATE occuring within initcode creates that contract. <code>test_eofcreate_in_initcode_reverts</code> state_test 1 Verifies an EOFCREATE occuring in an initcode is rolled back when the initcode reverts. <code>test_return_data_cleared</code> state_test 1 Verifies the return data is not re-used from a extcall but is cleared upon eofcreate. <code>test_address_collision</code> state_test 1 Tests address collision. <code>test_eofcreate_revert_eof_returndata</code> state_test 1 Verifies the return data is not being deployed, even if happens to be valid EOF. <code>test_eofcreate_invalid_index</code> eof_test 3 EOFCREATE referring non-existent container section index. <code>test_eofcreate_invalid_truncated_immediate</code> eof_test 1 EOFCREATE instruction with missing immediate byte. <code>test_eofcreate_truncated_container</code> eof_test 4 EOFCREATE instruction targeting a container with truncated data section. <code>test_eofcreate_context</code> state_test 6 Test EOFCREATE's initcode context instructions. <code>test_eofcreate_memory_context</code> state_test 1 Verifies an EOFCREATE frame enjoys a separate EVM memory from its caller frame."},{"location":"tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_eofcreate_failures/","title":"Test EOFCREATE Failures","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_eofcreate_failures.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_eofcreate_failures.py --fork Osaka\n</code></pre> <p>Test good and bad EOFCREATE cases.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_eofcreate_failures/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_initcode_revert</code> state_test 2 Verifies proper handling of REVERT in initcode. <code>test_initcode_aborts</code> state_test 1 Verifies correct handling of a halt in EOF initcode. <code>test_eofcreate_deploy_sizes</code> state_test 6 Verifies a mix of runtime contract sizes mixing success and multiple size failure modes. <code>test_eofcreate_deploy_sizes_tx</code> state_test 6 Verifies a mix of runtime contract sizes mixing success and multiple size failure modes <code>test_auxdata_size_failures</code> state_test 6 Exercises a number of auxdata size violations, and one maxcode success. <code>test_eofcreate_insufficient_stipend</code> state_test 2 Exercises an EOFCREATE that fails because the calling account does not have enough ether to <code>test_insufficient_initcode_gas</code> state_test 1 Excercises an EOFCREATE when there is not enough gas for the initcode charge. <code>test_insufficient_gas_memory_expansion</code> state_test 1 Exercises EOFCREATE when the memory for auxdata has not been expanded but is requested. <code>test_insufficient_returncode_auxdata_gas</code> state_test 1 Exercises a RETURNCODE when there is not enough gas for the initcode charge. <code>test_static_flag_eofcreate</code> state_test 8 Verifies correct handling of the static call flag with EOFCREATE. <code>test_eof_eofcreate_msg_depth</code> state_test 4 Test EOFCREATE handles msg depth limit correctly (1024). <code>test_reentrant_eofcreate</code> state_test 1 Verifies a reentrant EOFCREATE case, where EIP-161 prevents conflict via nonce bump."},{"location":"tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_gas/","title":"Test Gas","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_gas.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_gas.py --fork Osaka\n</code></pre> <p>Test good and bad EOFCREATE cases.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_gas/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_eofcreate_gas</code> state_test 144 Tests variations of EOFCREATE gas."},{"location":"tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_legacy_eof_creates/","title":"Test Legacy EOF Creates","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_legacy_eof_creates.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_legacy_eof_creates.py --fork Osaka\n</code></pre> <p>Test interactions between CREATE, CREATE2, and EOFCREATE.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_legacy_eof_creates/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_cross_version_creates_fail</code> state_test 4 Verifies that CREATE and CREATE2 cannot create EOF contracts. <code>test_legacy_initcode_eof_contract_fails</code> state_test 4 Verifies that legacy initcode cannot create EOF."},{"location":"tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_memory/","title":"Test Memory","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_memory.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_memory.py --fork Osaka\n</code></pre> <p>Test good and bad EOFCREATE cases.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_memory/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_eofcreate_memory</code> state_test 32 Tests auxdata sizes in EOFCREATE including multiple offset conditions."},{"location":"tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_returncode/","title":"Test RETURNCODE","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_returncode.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_returncode.py --fork Osaka\n</code></pre> <p>Tests for RETURNCODE instruction validation.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_returncode/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_returncode_valid_index_0</code> eof_test 1 Deploy container index 0. <code>test_returncode_valid_index_1</code> eof_test 1 Deploy container index 1. <code>test_returncode_valid_index_255</code> eof_test 1 Deploy container index 255. <code>test_returncode_invalid_truncated_immediate</code> eof_test 1 Truncated immediate. <code>test_returncode_invalid_index_0</code> eof_test 1 Referring to non-existent container section index 0. <code>test_returncode_invalid_index_1</code> eof_test 1 Referring to non-existent container section index 1. <code>test_returncode_invalid_index_255</code> eof_test 1 Referring to non-existent container section index 255. <code>test_returncode_terminating</code> eof_test 1 Unreachable code after RETURNCODE. <code>test_returncode_memory_expansion</code> state_test 32 Attempts an EOFCREATE with a possibly too-large auxdata.  Create either fails due to gas"},{"location":"tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_subcontainer_validation/","title":"Test Subcontainer Validation","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_subcontainer_validation.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_subcontainer_validation.py --fork Osaka\n</code></pre> <p>EOF Subcontainer tests covering simple cases.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip7620_eof_create/test_subcontainer_validation/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_simple_create_from_deployed</code> eof_state_test 0 Simple EOF creation from a deployed EOF container. <code>test_simple_create_from_creation</code> eof_state_test 0 Simple EOF creation from a create transaction container. <code>test_reverting_container</code> eof_state_test 0 Test revert containers. <code>test_orphan_container</code> eof_test 6 Test orphaned containers. <code>test_container_combos_valid</code> eof_state_test 0 Test valid subcontainer reference / opcode combos. <code>test_container_combos_invalid</code> eof_test 3 Test invalid subcontainer reference / opcode combos. <code>test_container_combos_deeply_nested_valid</code> eof_test 5 Test valid subcontainer reference / opcode combos on a deep container nesting level. <code>test_container_combos_deeply_nested_invalid</code> eof_test 3 Test invalid subcontainer reference / opcode combos on a deep container nesting level. <code>test_container_combos_non_first_code_sections_valid</code> eof_test 5 Test valid subcontainer reference / opcode combos in a non-first code section. <code>test_container_combos_non_first_code_sections_invalid</code> eof_test 3 Test invalid subcontainer reference / opcode combos in a non-first code section. <code>test_container_both_kinds_same_sub</code> eof_test 1 Test subcontainer conflicts (both EOFCREATE and RETURNCODE Reference). <code>test_container_ambiguous_kind</code> eof_test 6 Test ambiguous container kind:(\ud83d\udcd6\ud83d\udc1b?) <code>test_container_both_kinds_different_sub</code> eof_test 1 Test multiple kinds of subcontainer at the same level. <code>test_container_multiple_eofcreate_references</code> eof_test 1 Test multiple references to the same subcontainer from an EOFCREATE operation. <code>test_container_multiple_returncode_references</code> eof_test 1 Test multiple references to the same subcontainer from a RETURNCONTACT operation. <code>test_subcontainer_wrong_eof_version</code> eof_test 2 Test a subcontainer with the incorrect EOF version. <code>test_subcontainer_wrong_size</code> eof_test 4 Test a subcontainer with the incorrect size in the parent's header. <code>test_deep_container</code> eof_test 3 Test a very deeply nested container. <code>test_deep_container_initcode</code> eof_test 3 Test a very deeply nested initcontainer. <code>test_wide_container</code> eof_test 4 Test a container with the maximum number of sub-containers. <code>test_migrated_eofcreate</code> eof_test 9 Tests migrated from EOFTests/efValidation/EOF1_eofcreate_valid_.json. <code>test_dangling_initcode_subcontainer_bytes</code> eof_test 1 Initcode mode EOF Subcontainer test with subcontainer containing dangling bytes. <code>test_dangling_runtime_subcontainer_bytes</code> eof_test 1 Runtime mode EOF Subcontainer test with subcontainer containing dangling bytes."},{"location":"tests/osaka/eip7692_eof_v1/eip7698_eof_creation_tx/","title":"EIP-7698 EOF Creation Tx","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7698_eof_creation_tx@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip7698_eof_creation_tx --fork Osaka\n</code></pre> Test cases for EIP-7698: EOF - Creation transaction <p>EIP-7698 defines the transaction format for creating EOF-based contracts. Opcodes introduced: None (focuses on the transaction format).</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip7698_eof_creation_tx/test_eof_creation_tx/","title":"Test EOF Creation Tx","text":"<p>Documentation for <code>tests/osaka/eip7692_eof_v1/eip7698_eof_creation_tx/test_eof_creation_tx.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Osaka with:</p> <pre><code>fill -v tests/osaka/eip7692_eof_v1/eip7698_eof_creation_tx/test_eof_creation_tx.py --fork Osaka\n</code></pre> <p>Test execution of EOF creation txs.</p>"},{"location":"tests/osaka/eip7692_eof_v1/eip7698_eof_creation_tx/test_eof_creation_tx/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Osaka) Description <code>test_eof_creation_tx_context</code> state_test 6 Test EOF creation txs' initcode context instructions. <code>test_lecacy_cannot_create_eof</code> state_test 1 Test that a legacy contract creation initcode cannot deploy an EOF contract. <code>test_invalid_container_deployment</code> state_test 9 Verify nonce is not incremented when an invalid container deployment is attempted. <code>test_short_data_subcontainer</code> state_test 1 Deploy a subcontainer where the data is \"short\" and filled by deployment code."},{"location":"tests/paris/","title":"Paris","text":"<p>Documentation for <code>tests/paris@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/paris --fork Prague\n</code></pre> <p>Test cases for EVM functionality introduced in Paris (Merge).</p>"},{"location":"tests/paris/security/","title":"Security","text":"<p>Documentation for <code>tests/paris/security@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/paris/security --fork Prague\n</code></pre> <p>Ethereum execution client tests related to security issues.</p>"},{"location":"tests/paris/security/test_selfdestruct_balance_bug/","title":"Test SELFDESTRUCT BALANCE Bug","text":"<p>Documentation for <code>tests/paris/security/test_selfdestruct_balance_bug.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/paris/security/test_selfdestruct_balance_bug.py --fork Prague\n</code></pre> Tests the Consensus Flaw During Block Processing related to SELFDESTRUCT <p>Tests the consensus-vulnerability reported in go-ethereum/security/advisories/GHSA-xw37-57qp-9mm4.</p> <p>To reproduce the issue with this test case:</p> <ol> <li>Fill the test with the most recent geth evm version.</li> <li>Run the fixture output within a vulnerable geth version: v1.9.20 &gt; geth &gt;=     v1.9.4.</li> </ol>"},{"location":"tests/paris/security/test_selfdestruct_balance_bug/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_tx_selfdestruct_balance_bug</code> blockchain_test 1 Test that the vulnerability is not present by checking the balance of the"},{"location":"tests/prague/","title":"Prague","text":"<p>Documentation for <code>tests/prague@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague --fork Prague\n</code></pre> <p>Test cases for EVM functionality introduced in Prague, EIP-7600: Hardfork Meta - Pectra.</p> <p>Devnet Specifications:</p> <ul> <li>ethpandaops/pectra-devnet-5.</li> <li>ethpandaops/pectra-devnet-4.</li> <li>ethpandaops/pectra-devnet-3.</li> <li>ethpandaops/pectra-devnet-2.</li> <li>ethpandaops/pectra-devnet-1.</li> </ul>"},{"location":"tests/prague/eip2537_bls_12_381_precompiles/","title":"EIP-2537 BLS12 381 Precompiles","text":"<p>Documentation for <code>tests/prague/eip2537_bls_12_381_precompiles@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip2537_bls_12_381_precompiles --fork Prague\n</code></pre> Tests EIP-2537: Precompile for BLS12-381 curve operations <p>Tests for EIP-2537: Precompile for BLS12-381 curve operations.</p>"},{"location":"tests/prague/eip2537_bls_12_381_precompiles/spec/","title":"Spec","text":"<p>Documentation for <code>tests/prague/eip2537_bls_12_381_precompiles/spec.py@af77f529</code>.</p> <p>Defines EIP-2537 specification constants and functions.</p>"},{"location":"tests/prague/eip2537_bls_12_381_precompiles/spec/#tests.prague.eip2537_bls_12_381_precompiles.spec.Spec","title":"<code>Spec</code>  <code>dataclass</code>","text":"<p>Parameters from the EIP-2537 specifications as defined at https://eips.ethereum.org/EIPS/eip-2537.</p> Source code in <code>tests/prague/eip2537_bls_12_381_precompiles/spec.py</code> <pre><code>@dataclass(frozen=True)\nclass Spec:\n    \"\"\"\n    Parameters from the EIP-2537 specifications as defined at\n    https://eips.ethereum.org/EIPS/eip-2537.\n    \"\"\"\n\n    # Addresses\n    G1ADD = 0x0B\n    G1MSM = 0x0C\n    G2ADD = 0x0D\n    G2MSM = 0x0E\n    PAIRING = 0x0F\n    MAP_FP_TO_G1 = 0x10\n    MAP_FP2_TO_G2 = 0x11\n\n    # Gas constants\n    G1ADD_GAS = 375\n    G1MUL_GAS = 12_000\n    G2ADD_GAS = 600\n    G2MUL_GAS = 22_500\n    MAP_FP_TO_G1_GAS = 5_500\n    MAP_FP2_TO_G2_GAS = 23_800\n    PAIRING_BASE_GAS = 37_700\n    PAIRING_PER_PAIR_GAS = 32_600\n\n    # Other constants\n    B_COEFFICIENT = 0x04\n    X = -0xD201000000010000\n    Q = X**4 - X**2 + 1\n    P = (X - 1) ** 2 * Q // 3 + X\n    LEN_PER_PAIR = len(PointG1() + PointG2())\n    MSM_MULTIPLIER = 1_000\n    # fmt: off\n    G1MSM_DISCOUNT_TABLE = [\n        0,\n        1000, 949, 848, 797, 764, 750, 738, 728, 719, 712, 705, 698, 692, 687, 682, 677, 673, 669,\n        665, 661, 658, 654, 651, 648, 645, 642, 640, 637, 635, 632, 630, 627, 625, 623, 621, 619,\n        617, 615, 613, 611, 609, 608, 606, 604, 603, 601, 599, 598, 596, 595, 593, 592, 591, 589,\n        588, 586, 585, 584, 582, 581, 580, 579, 577, 576, 575, 574, 573, 572, 570, 569, 568, 567,\n        566, 565, 564, 563, 562, 561, 560, 559, 558, 557, 556, 555, 554, 553, 552, 551, 550, 549,\n        548, 547, 547, 546, 545, 544, 543, 542, 541, 540, 540, 539, 538, 537, 536, 536, 535, 534,\n        533, 532, 532, 531, 530, 529, 528, 528, 527, 526, 525, 525, 524, 523, 522, 522, 521, 520,\n        520, 519\n    ]\n    G2MSM_DISCOUNT_TABLE = [\n        0,\n        1000, 1000, 923, 884, 855, 832, 812, 796, 782, 770, 759, 749, 740, 732, 724, 717, 711, 704,\n        699, 693, 688, 683, 679, 674, 670, 666, 663, 659, 655, 652, 649, 646, 643, 640, 637, 634,\n        632, 629, 627, 624, 622, 620, 618, 615, 613, 611, 609, 607, 606, 604, 602, 600, 598, 597,\n        595, 593, 592, 590, 589, 587, 586, 584, 583, 582, 580, 579, 578, 576, 575, 574, 573, 571,\n        570, 569, 568, 567, 566, 565, 563, 562, 561, 560, 559, 558, 557, 556, 555, 554, 553, 552,\n        552, 551, 550, 549, 548, 547, 546, 545, 545, 544, 543, 542, 541, 541, 540, 539, 538, 537,\n        537, 536, 535, 535, 534, 533, 532, 532, 531, 530, 530, 529, 528, 528, 527, 526, 526, 525,\n        524, 524\n    ]\n    # fmt: on\n\n    # Test constants (from https://github.com/ethereum/bls12-381-tests/tree/eip-2537)\n    P1 = PointG1(  # random point in G1\n        0x112B98340EEE2777CC3C14163DEA3EC97977AC3DC5C70DA32E6E87578F44912E902CCEF9EFE28D4A78B8999DFBCA9426,\n        0x186B28D92356C4DFEC4B5201AD099DBDEDE3781F8998DDF929B4CD7756192185CA7B8F4EF7088F813270AC3D48868A21,\n    )\n    G1 = PointG1(\n        0x17F1D3A73197D7942695638C4FA9AC0FC3688C4F9774B905A14E3A3F171BAC586C55E83FF97A1AEFFB3AF00ADB22C6BB,\n        0x8B3F481E3AAA0F1A09E30ED741D8AE4FCF5E095D5D00AF600DB18CB2C04B3EDD03CC744A2888AE40CAA232946C5E7E1,\n    )\n    # point at infinity in G1\n    INF_G1 = PointG1(0, 0)\n    # random point in G2\n    P2 = PointG2(\n        (\n            0x103121A2CEAAE586D240843A398967325F8EB5A93E8FEA99B62B9F88D8556C80DD726A4B30E84A36EEABAF3592937F27,\n            0x86B990F3DA2AEAC0A36143B7D7C824428215140DB1BB859338764CB58458F081D92664F9053B50B3FBD2E4723121B68,\n        ),\n        (\n            0xF9E7BA9A86A8F7624AA2B42DCC8772E1AF4AE115685E60ABC2C9B90242167ACEF3D0BE4050BF935EED7C3B6FC7BA77E,\n            0xD22C3652D0DC6F0FC9316E14268477C2049EF772E852108D269D9C38DBA1D4802E8DAE479818184C08F9A569D878451,\n        ),\n    )\n    G2 = PointG2(\n        (\n            0x24AA2B2F08F0A91260805272DC51051C6E47AD4FA403B02B4510B647AE3D1770BAC0326A805BBEFD48056C8C121BDB8,\n            0x13E02B6052719F607DACD3A088274F65596BD0D09920B61AB5DA61BBDC7F5049334CF11213945D57E5AC7D055D042B7E,\n        ),\n        (\n            0xCE5D527727D6E118CC9CDC6DA2E351AADFD9BAA8CBDD3A76D429A695160D12C923AC9CC3BACA289E193548608B82801,\n            0x606C4A02EA734CC32ACD2B02BC28B99CB3E287E85A763AF267492AB572E99AB3F370D275CEC1DA1AAA9075FF05F79BE,\n        ),\n    )\n    # point at infinity in G2\n    INF_G2 = PointG2((0, 0), (0, 0))\n\n    # Other test constants\n    # point not in subgroup in curve Fp\n    P1_NOT_IN_SUBGROUP = PointG1(0, 2)\n    P1_NOT_IN_SUBGROUP_TIMES_2 = PointG1(0, P - 2)\n    # point not in subgroup in curve Fp2\n    P2_NOT_IN_SUBGROUP = PointG2(\n        (1, 1),\n        (\n            0x17FAA6201231304F270B858DAD9462089F2A5B83388E4B10773ABC1EEF6D193B9FCE4E8EA2D9D28E3C3A315AA7DE14CA,\n            0xCC12449BE6AC4E7F367E7242250427C4FB4C39325D3164AD397C1837A90F0EA1A534757DF374DD6569345EB41ED76E,\n        ),\n    )\n    P2_NOT_IN_SUBGROUP_TIMES_2 = PointG2(\n        (\n            0x919F97860ECC3E933E3477FCAC0E2E4FCC35A6E886E935C97511685232456263DEF6665F143CCCCB44C733333331553,\n            0x18B4376B50398178FA8D78ED2654B0FFD2A487BE4DBE6B69086E61B283F4E9D58389CCCB8EDC99995718A66666661555,\n        ),\n        (\n            0x26898F699C4B07A405AB4183A10B47F923D1C0FDA1018682DD2CCC88968C1B90D44534D6B9270CF57F8DC6D4891678A,\n            0x3270414330EAD5EC92219A03A24DFA059DBCBE610868BE1851CC13DAC447F60B40D41113FD007D3307B19ADD4B0F061,\n        ),\n    )\n\n    # Pairing precompile results\n    PAIRING_TRUE = int.to_bytes(1, length=32, byteorder=\"big\")\n    PAIRING_FALSE = int.to_bytes(0, length=32, byteorder=\"big\")\n\n    # Returned on precompile failure\n    INVALID = b\"\"\n</code></pre>"},{"location":"tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g1add/","title":"Test BLS12_G1ADD","text":"<p>Documentation for <code>tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g1add.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g1add.py --fork Prague\n</code></pre> Tests BLS12_G1ADD precompile of EIP-2537: Precompile for BLS12-381 curve operations <p>Tests BLS12_G1ADD precompile of EIP-2537: Precompile for BLS12-381 curve operations.</p>"},{"location":"tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g1add/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_valid</code> state_test 12 Test the BLS12_G1ADD precompile. <code>test_invalid</code> state_test 27 Negative tests for the BLS12_G1ADD precompile. <code>test_gas</code> state_test 2 Test the BLS12_G1ADD precompile gas requirements. <code>test_call_types</code> state_test 3 Test the BLS12_G1ADD precompile using different call types."},{"location":"tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g1msm/","title":"Test BLS12_G1MSM","text":"<p>Documentation for <code>tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g1msm.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g1msm.py --fork Prague\n</code></pre> Tests BLS12_G1MSM precompile of EIP-2537: Precompile for BLS12-381 curve operations <p>Tests BLS12_G1MSM precompile of EIP-2537: Precompile for BLS12-381 curve operations.</p>"},{"location":"tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g1msm/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_valid</code> state_test 165 Test valid calls to the BLS12_G1MSM precompile. <code>test_invalid</code> state_test 16 Test invalid calls to the BLS12_G1MSM precompile. <code>test_call_types</code> state_test 3 Test the BLS12_G1MSM precompile using different call types."},{"location":"tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g1mul/","title":"Test BLS12_G1MUL","text":"<p>Documentation for <code>tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g1mul.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g1mul.py --fork Prague\n</code></pre> Tests BLS12_G1MUL precompile of EIP-2537: Precompile for BLS12-381 curve operations <p>Tests BLS12_G1MUL precompile of EIP-2537: Precompile for BLS12-381 curve operations.</p>"},{"location":"tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g1mul/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_valid</code> state_test 19 Test the BLS12_G1MUL precompile. <code>test_invalid</code> state_test 22 Negative tests for the BLS12_G1MUL precompile. <code>test_gas</code> state_test 2 Test the BLS12_G1MUL precompile gas requirements. <code>test_call_types</code> state_test 3 Test the BLS12_G1MUL precompile using different call types."},{"location":"tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g2add/","title":"Test BLS12_G2ADD","text":"<p>Documentation for <code>tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g2add.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g2add.py --fork Prague\n</code></pre> Tests BLS12_G2ADD precompile of EIP-2537: Precompile for BLS12-381 curve operations <p>Tests BLS12_G2ADD precompile of EIP-2537: Precompile for BLS12-381 curve operations.</p>"},{"location":"tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g2add/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_valid</code> state_test 10 Test the BLS12_G2ADD precompile. <code>test_invalid</code> state_test 31 Negative tests for the BLS12_G2ADD precompile. <code>test_gas</code> state_test 2 Test the BLS12_G2ADD precompile gas requirements. <code>test_call_types</code> state_test 3 Test the BLS12_G2ADD precompile using different call types."},{"location":"tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g2msm/","title":"Test BLS12_G2MSM","text":"<p>Documentation for <code>tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g2msm.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g2msm.py --fork Prague\n</code></pre> Tests BLS12_G2MSM precompile of EIP-2537: Precompile for BLS12-381 curve operations <p>Tests BLS12_G2MSM precompile of EIP-2537: Precompile for BLS12-381 curve operations.</p>"},{"location":"tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g2msm/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_valid</code> state_test 166 Test the BLS12_G2MSM precompile. <code>test_invalid</code> state_test 18 Negative tests for the BLS12_G2MSM precompile. <code>test_call_types</code> state_test 3 Test the BLS12_G2MSM precompile using different call types."},{"location":"tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g2mul/","title":"Test BLS12_G2MUL","text":"<p>Documentation for <code>tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g2mul.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g2mul.py --fork Prague\n</code></pre> Tests BLS12_G2MUL precompile of EIP-2537: Precompile for BLS12-381 curve operations <p>Tests BLS12_G2MUL precompile of EIP-2537: Precompile for BLS12-381 curve operations.</p>"},{"location":"tests/prague/eip2537_bls_12_381_precompiles/test_bls12_g2mul/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_valid</code> state_test 20 Test the BLS12_G2MUL precompile. <code>test_invalid</code> state_test 25 Negative tests for the BLS12_G2MUL precompile. <code>test_gas</code> state_test 2 Test the BLS12_G2MUL precompile gas requirements. <code>test_call_types</code> state_test 3 Test the BLS12_G2MUL using different call types."},{"location":"tests/prague/eip2537_bls_12_381_precompiles/test_bls12_map_fp2_to_g2/","title":"Test BLS12_MAP_FP2_TO_G2","text":"<p>Documentation for <code>tests/prague/eip2537_bls_12_381_precompiles/test_bls12_map_fp2_to_g2.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip2537_bls_12_381_precompiles/test_bls12_map_fp2_to_g2.py --fork Prague\n</code></pre> Tests BLS12_MAP_FP2_TO_G2 precompile of EIP-2537: Precompile for BLS12-381 curve operations <p>Tests BLS12_MAP_FP2_TO_G2 precompile of EIP-2537: Precompile for BLS12-381 curve operations.</p>"},{"location":"tests/prague/eip2537_bls_12_381_precompiles/test_bls12_map_fp2_to_g2/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_valid</code> state_test 7 Test the BLS12_MAP_FP2_TO_G2 precompile. <code>test_invalid</code> state_test 14 Negative tests for the BLS12_MAP_FP_TO_G2 precompile. <code>test_gas</code> state_test 2 Test the BLS12_MAP_FP_TO_G2 precompile gas requirements. <code>test_call_types</code> state_test 3 Test the BLS12_MAP_FP_TO_G2 precompile using different call types."},{"location":"tests/prague/eip2537_bls_12_381_precompiles/test_bls12_map_fp_to_g1/","title":"Test BLS12_MAP_FP_TO_G1","text":"<p>Documentation for <code>tests/prague/eip2537_bls_12_381_precompiles/test_bls12_map_fp_to_g1.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip2537_bls_12_381_precompiles/test_bls12_map_fp_to_g1.py --fork Prague\n</code></pre> Tests BLS12_MAP_FP_TO_G1 precompile of EIP-2537: Precompile for BLS12-381 curve operations <p>Tests BLS12_MAP_FP_TO_G1 precompile of EIP-2537: Precompile for BLS12-381 curve operations.</p>"},{"location":"tests/prague/eip2537_bls_12_381_precompiles/test_bls12_map_fp_to_g1/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_valid</code> state_test 7 Test the BLS12_MAP_FP_TO_G1 precompile. <code>test_invalid</code> state_test 12 Negative tests for the BLS12_MAP_FP_TO_G1 precompile. <code>test_gas</code> state_test 2 Test the BLS12_MAP_FP_TO_G1 precompile gas requirements. <code>test_call_types</code> state_test 3 Test the BLS12_MAP_FP_TO_G1 precompile using different call types."},{"location":"tests/prague/eip2537_bls_12_381_precompiles/test_bls12_pairing/","title":"Test BLS12_PAIRING_CHECK","text":"<p>Documentation for <code>tests/prague/eip2537_bls_12_381_precompiles/test_bls12_pairing.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip2537_bls_12_381_precompiles/test_bls12_pairing.py --fork Prague\n</code></pre> Tests BLS12_PAIRING precompile of EIP-2537: Precompile for BLS12-381 curve operations <p>Tests BLS12_PAIRING precompile of EIP-2537: Precompile for BLS12-381 curve operations.</p>"},{"location":"tests/prague/eip2537_bls_12_381_precompiles/test_bls12_pairing/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_valid</code> state_test 17 Test the BLS12_PAIRING precompile. <code>test_multi_pair_invalid_inf</code> state_test 2 Multi pair invalid infinity cases for the BLS12_PAIRING precompile. <code>test_invalid</code> state_test 34 Negative tests for the BLS12_PAIRING precompile. <code>test_call_types</code> state_test 3 Test the BLS12_PAIRING precompile using different call types."},{"location":"tests/prague/eip2537_bls_12_381_precompiles/test_bls12_precompiles_before_fork/","title":"Test Bls12 Precompiles Before Fork","text":"<p>Documentation for <code>tests/prague/eip2537_bls_12_381_precompiles/test_bls12_precompiles_before_fork.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip2537_bls_12_381_precompiles/test_bls12_precompiles_before_fork.py --fork Prague\n</code></pre> Tests BLS12 precompiles of EIP-2537: Precompile for BLS12-381 curve operations <p>Tests BLS12 precompiles of EIP-2537: Precompile for BLS12-381 curve operations before the Prague hard fork is active.</p>"},{"location":"tests/prague/eip2537_bls_12_381_precompiles/test_bls12_precompiles_before_fork/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_precompile_before_fork</code> state_test 0 Test all BLS12 precompiles before the Prague hard fork is active."},{"location":"tests/prague/eip2537_bls_12_381_precompiles/test_bls12_variable_length_input_contracts/","title":"Test Bls12 Variable Length Input Contracts","text":"<p>Documentation for <code>tests/prague/eip2537_bls_12_381_precompiles/test_bls12_variable_length_input_contracts.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip2537_bls_12_381_precompiles/test_bls12_variable_length_input_contracts.py --fork Prague\n</code></pre> Tests minimum gas and input length for BLS12_G1MSM, BLS12_G2MSM, BLS12_PAIRING precompiles of EIP-2537: Precompile for BLS12-381 curve operations <p>Tests minimum gas and input length for BLS12_G1MSM, BLS12_G2MSM, BLS12_PAIRING precompiles of EIP-2537: Precompile for BLS12-381 curve operations.</p>"},{"location":"tests/prague/eip2537_bls_12_381_precompiles/test_bls12_variable_length_input_contracts/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_valid_gas_g1msm</code> state_test 2 Test the BLS12_G1MSM discount gas table in full, by expecting the call to succeed for <code>test_invalid_gas_g1msm</code> state_test 2 Test the BLS12_G1MSM discount gas table in full, by expecting the call to fail for <code>test_invalid_length_g1msm</code> state_test 3 Test the BLS12_G1MSM discount gas table in full, by expecting the call to fail for <code>test_valid_gas_g2msm</code> state_test 2 Test the BLS12_G2MSM discount gas table in full, by expecting the call to succeed for <code>test_invalid_gas_g2msm</code> state_test 2 Test the BLS12_G2MSM discount gas table in full, by expecting the call to fail for <code>test_invalid_length_g2msm</code> state_test 3 Test the BLS12_G2MSM discount gas table in full, by expecting the call to fail for <code>test_valid_gas_pairing</code> state_test 2 Test the BLS12_PAIRING precompile, by expecting the call to succeed for all possible input <code>test_invalid_gas_pairing</code> state_test 2 Test the BLS12_PAIRING precompile, by expecting the call to fail for all possible input <code>test_invalid_length_pairing</code> state_test 3 Test the BLS12_PAIRING precompile, by expecting the call to fail for all possible input"},{"location":"tests/prague/eip2537_bls_12_381_precompiles/vectors/test-vectors/","title":"test-vectors","text":"<p>Markdown Content</p> <p>Below is the verbatim markdown content from <code>tests/prague/eip2537_bls_12_381_precompiles/vectors/test-vectors.md@af77f529</code>.</p>"},{"location":"tests/prague/eip2537_bls_12_381_precompiles/vectors/test-vectors/#test-vectors-for-eip-2537-precompiles-for-bls12-381-curve-operations","title":"Test Vectors for EIP-2537 - Precompiles for BLS12-381 curve operations","text":"<p>The JSON test vector files in this directory originated from the assets attached to EIP-2537 as of EIPs#9217 (unmerged as of time of writing) which were generated using these BLS 12-381 tests.</p>"},{"location":"tests/prague/eip2935_historical_block_hashes_from_state/","title":"EIP-2935 Historical Block Hashes From State","text":"<p>Documentation for <code>tests/prague/eip2935_historical_block_hashes_from_state@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip2935_historical_block_hashes_from_state --fork Prague\n</code></pre> <p>Cross-client EIP-2935 Tests.</p>"},{"location":"tests/prague/eip2935_historical_block_hashes_from_state/spec/","title":"Spec","text":"<p>Documentation for <code>tests/prague/eip2935_historical_block_hashes_from_state/spec.py@af77f529</code>.</p> <p>Defines EIP-2935 specification constants and functions.</p>"},{"location":"tests/prague/eip2935_historical_block_hashes_from_state/spec/#tests.prague.eip2935_historical_block_hashes_from_state.spec.Spec","title":"<code>Spec</code>  <code>dataclass</code>","text":"<p>Parameters from the EIP-2935 specifications as defined at https://eips.ethereum.org/EIPS/eip-2935.</p> Source code in <code>tests/prague/eip2935_historical_block_hashes_from_state/spec.py</code> <pre><code>@dataclass(frozen=True)\nclass Spec:\n    \"\"\"\n    Parameters from the EIP-2935 specifications as defined at\n    https://eips.ethereum.org/EIPS/eip-2935.\n    \"\"\"\n\n    FORK_TIMESTAMP = 15_000\n    HISTORY_STORAGE_ADDRESS = 0x0000F90827F1C53A10CB7A02335B175320002935\n    HISTORY_SERVE_WINDOW = 8191\n    BLOCKHASH_OLD_WINDOW = 256\n</code></pre>"},{"location":"tests/prague/eip2935_historical_block_hashes_from_state/test_block_hashes/","title":"Test Block Hashes","text":"<p>Documentation for <code>tests/prague/eip2935_historical_block_hashes_from_state/test_block_hashes.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip2935_historical_block_hashes_from_state/test_block_hashes.py --fork Prague\n</code></pre> Tests EIP-2935: Serve historical block hashes from state <p>Test EIP-2935: Serve historical block hashes from state.</p>"},{"location":"tests/prague/eip2935_historical_block_hashes_from_state/test_block_hashes/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_block_hashes_history_at_transition</code> blockchain_test 0 Tests that block hashes are stored correctly at the system contract address after the fork <code>test_block_hashes_history</code> blockchain_test 5 Tests that block hashes are stored correctly at the system contract address after the fork <code>test_invalid_history_contract_calls</code> blockchain_test 4 Test calling the history contract with invalid block numbers, such as blocks from the future <code>test_invalid_history_contract_calls_input_size</code> blockchain_test 3 Test calling the history contract with invalid input sizes."},{"location":"tests/prague/eip2935_historical_block_hashes_from_state/test_contract_deployment/","title":"Test Contract Deployment","text":"<p>Documentation for <code>tests/prague/eip2935_historical_block_hashes_from_state/test_contract_deployment.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip2935_historical_block_hashes_from_state/test_contract_deployment.py --fork Prague\n</code></pre> Tests EIP-2935: Serve historical block hashes from state. <p>Test system contract deployment for EIP-2935: Serve historical block hashes from state.</p>"},{"location":"tests/prague/eip2935_historical_block_hashes_from_state/test_contract_deployment/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_system_contract_deployment</code> blockchain_test 0 Verify deployment of the block hashes system contract."},{"location":"tests/prague/eip6110_deposits/","title":"EIP-6110 Deposits","text":"<p>Documentation for <code>tests/prague/eip6110_deposits@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip6110_deposits --fork Prague\n</code></pre> <p>Cross-client EIP-6110 Tests.</p>"},{"location":"tests/prague/eip6110_deposits/spec/","title":"Spec","text":"<p>Documentation for <code>tests/prague/eip6110_deposits/spec.py@af77f529</code>.</p> <p>Defines EIP-6110 specification constants and functions.</p>"},{"location":"tests/prague/eip6110_deposits/spec/#tests.prague.eip6110_deposits.spec.Spec","title":"<code>Spec</code>  <code>dataclass</code>","text":"<p>Parameters from the EIP-6110 specifications as defined at https://eips.ethereum.org/EIPS/eip-6110.</p> Source code in <code>tests/prague/eip6110_deposits/spec.py</code> <pre><code>@dataclass(frozen=True)\nclass Spec:\n    \"\"\"\n    Parameters from the EIP-6110 specifications as defined at\n    https://eips.ethereum.org/EIPS/eip-6110.\n    \"\"\"\n\n    DEPOSIT_CONTRACT_ADDRESS = 0x00000000219AB540356CBB839CBE05303D7705FA\n</code></pre>"},{"location":"tests/prague/eip6110_deposits/test_deposits/","title":"Test Deposits","text":"<p>Documentation for <code>tests/prague/eip6110_deposits/test_deposits.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip6110_deposits/test_deposits.py --fork Prague\n</code></pre> Tests EIP-6110: Supply validator deposits on chain <p>Test EIP-6110: Supply validator deposits on chain.</p>"},{"location":"tests/prague/eip6110_deposits/test_deposits/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_deposit</code> blockchain_test 29 Test making a deposit to the beacon chain deposit contract. <code>test_deposit_negative</code> blockchain_test 9 Test producing a block with the incorrect deposits in the body of the block,"},{"location":"tests/prague/eip7002_el_triggerable_withdrawals/","title":"EIP-7002 El Triggerable Withdrawals","text":"<p>Documentation for <code>tests/prague/eip7002_el_triggerable_withdrawals@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip7002_el_triggerable_withdrawals --fork Prague\n</code></pre> <p>Cross-client EIP-7002 Tests.</p>"},{"location":"tests/prague/eip7002_el_triggerable_withdrawals/spec/","title":"Spec","text":"<p>Documentation for <code>tests/prague/eip7002_el_triggerable_withdrawals/spec.py@af77f529</code>.</p> <p>Common procedures to test EIP-7002: Execution layer triggerable withdrawals.</p>"},{"location":"tests/prague/eip7002_el_triggerable_withdrawals/spec/#tests.prague.eip7002_el_triggerable_withdrawals.spec.Spec","title":"<code>Spec</code>  <code>dataclass</code>","text":"<p>Parameters from the EIP-7002 specifications as defined at https://eips.ethereum.org/EIPS/eip-7002#configuration.</p> <p>If the parameter is not currently used within the tests, it is commented out.</p> Source code in <code>tests/prague/eip7002_el_triggerable_withdrawals/spec.py</code> <pre><code>@dataclass(frozen=True)\nclass Spec:\n    \"\"\"\n    Parameters from the EIP-7002 specifications as defined at\n    https://eips.ethereum.org/EIPS/eip-7002#configuration.\n\n    If the parameter is not currently used within the tests, it is commented\n    out.\n    \"\"\"\n\n    WITHDRAWAL_REQUEST_PREDEPLOY_ADDRESS = 0x00000961EF480EB55E80D19AD83579A64C007002\n    WITHDRAWAL_REQUEST_PREDEPLOY_SENDER = Address(0x8646861A7CF453DDD086874D622B0696DE5B9674)\n    SYSTEM_ADDRESS = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE\n\n    EXCESS_WITHDRAWAL_REQUESTS_STORAGE_SLOT = 0\n    WITHDRAWAL_REQUEST_COUNT_STORAGE_SLOT = 1\n    WITHDRAWAL_REQUEST_QUEUE_HEAD_STORAGE_SLOT = (\n        2  # Pointer to head of the withdrawal request message queue\n    )\n    WITHDRAWAL_REQUEST_QUEUE_TAIL_STORAGE_SLOT = (\n        3  # Pointer to the tail of the withdrawal request message queue\n    )\n    WITHDRAWAL_REQUEST_QUEUE_STORAGE_OFFSET = (\n        4  # The start memory slot of the in-state withdrawal request message queue\n    )\n    MAX_WITHDRAWAL_REQUESTS_PER_BLOCK = (\n        16  # Maximum number of withdrawal requests that can be de-queued into a block\n    )\n    TARGET_WITHDRAWAL_REQUESTS_PER_BLOCK = 2\n    MIN_WITHDRAWAL_REQUEST_FEE = 1\n    WITHDRAWAL_REQUEST_FEE_UPDATE_FRACTION = 17\n    EXCESS_RETURN_GAS_STIPEND = 2300\n\n    MAX_AMOUNT = 2**64 - 1\n\n    @staticmethod\n    def fake_exponential(factor: int, numerator: int, denominator: int) -&gt; int:\n        \"\"\"Calculate the withdrawal request fee.\"\"\"\n        i = 1\n        output = 0\n        numerator_accumulator = factor * denominator\n        while numerator_accumulator &gt; 0:\n            output += numerator_accumulator\n            numerator_accumulator = (numerator_accumulator * numerator) // (denominator * i)\n            i += 1\n        return output // denominator\n\n    @staticmethod\n    def get_fee(excess_withdrawal_requests: int) -&gt; int:\n        \"\"\"Calculate the fee for the excess withdrawal requests.\"\"\"\n        return Spec.fake_exponential(\n            Spec.MIN_WITHDRAWAL_REQUEST_FEE,\n            excess_withdrawal_requests,\n            Spec.WITHDRAWAL_REQUEST_FEE_UPDATE_FRACTION,\n        )\n\n    @staticmethod\n    def get_excess_withdrawal_requests(previous_excess: int, count: int) -&gt; int:\n        \"\"\"Calculate the new excess withdrawal requests.\"\"\"\n        if previous_excess + count &gt; Spec.TARGET_WITHDRAWAL_REQUESTS_PER_BLOCK:\n            return previous_excess + count - Spec.TARGET_WITHDRAWAL_REQUESTS_PER_BLOCK\n        return 0\n</code></pre>"},{"location":"tests/prague/eip7002_el_triggerable_withdrawals/test_contract_deployment/","title":"Test Contract Deployment","text":"<p>Documentation for <code>tests/prague/eip7002_el_triggerable_withdrawals/test_contract_deployment.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip7002_el_triggerable_withdrawals/test_contract_deployment.py --fork Prague\n</code></pre> Tests EIP-7002: Execution layer triggerable withdrawals. <p>Test system contract deployment for EIP-7002: Execution layer triggerable withdrawals.</p>"},{"location":"tests/prague/eip7002_el_triggerable_withdrawals/test_contract_deployment/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_system_contract_deployment</code> blockchain_test 0 Verify calling the withdrawals system contract after deployment."},{"location":"tests/prague/eip7002_el_triggerable_withdrawals/test_withdrawal_requests/","title":"Test Withdrawal Requests","text":"<p>Documentation for <code>tests/prague/eip7002_el_triggerable_withdrawals/test_withdrawal_requests.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip7002_el_triggerable_withdrawals/test_withdrawal_requests.py --fork Prague\n</code></pre> Tests EIP-7002: Execution layer triggerable withdrawals <p>Test execution layer triggered exits EIP-7002: Execution layer triggerable withdrawals.</p>"},{"location":"tests/prague/eip7002_el_triggerable_withdrawals/test_withdrawal_requests/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_withdrawal_requests</code> blockchain_test 22 Test making a withdrawal request to the beacon chain. <code>test_withdrawal_requests_negative</code> blockchain_test 7 Test blocks where the requests list and the actual withdrawal requests that happened in the"},{"location":"tests/prague/eip7002_el_triggerable_withdrawals/test_withdrawal_requests_during_fork/","title":"Test Withdrawal Requests During Fork","text":"<p>Documentation for <code>tests/prague/eip7002_el_triggerable_withdrawals/test_withdrawal_requests_during_fork.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip7002_el_triggerable_withdrawals/test_withdrawal_requests_during_fork.py --fork Prague\n</code></pre> Tests EIP-7002: Execution layer triggerable withdrawals <p>Test execution layer triggered exits EIP-7002: Execution layer triggerable withdrawals.</p>"},{"location":"tests/prague/eip7002_el_triggerable_withdrawals/test_withdrawal_requests_during_fork/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_withdrawal_requests_during_fork</code> blockchain_test 0 Test making a withdrawal request to the beacon chain at the time of the fork."},{"location":"tests/prague/eip7251_consolidations/","title":"EIP-7251 Consolidations","text":"<p>Documentation for <code>tests/prague/eip7251_consolidations@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip7251_consolidations --fork Prague\n</code></pre> <p>Cross-client EIP-7251 Tests.</p>"},{"location":"tests/prague/eip7251_consolidations/spec/","title":"Spec","text":"<p>Documentation for <code>tests/prague/eip7251_consolidations/spec.py@af77f529</code>.</p> <p>Defines EIP-7251 specification constants and functions.</p>"},{"location":"tests/prague/eip7251_consolidations/spec/#tests.prague.eip7251_consolidations.spec.Spec","title":"<code>Spec</code>  <code>dataclass</code>","text":"<p>Parameters from the EIP-7251 specifications as defined at https://eips.ethereum.org/EIPS/eip-7251#execution-layer.</p> Source code in <code>tests/prague/eip7251_consolidations/spec.py</code> <pre><code>@dataclass(frozen=True)\nclass Spec:\n    \"\"\"\n    Parameters from the EIP-7251 specifications as defined at\n    https://eips.ethereum.org/EIPS/eip-7251#execution-layer.\n    \"\"\"\n\n    CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS = 0x0000BBDDC7CE488642FB579F8B00F3A590007251\n    CONSOLIDATION_REQUEST_PREDEPLOY_SENDER = Address(0x13D1913D623E6A9D8811736359E50FD31FE54FCA)\n    SYSTEM_ADDRESS = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE\n\n    EXCESS_CONSOLIDATION_REQUESTS_STORAGE_SLOT = 0\n    CONSOLIDATION_REQUEST_COUNT_STORAGE_SLOT = 1\n    CONSOLIDATION_REQUEST_QUEUE_HEAD_STORAGE_SLOT = (\n        2  # Pointer to head of the consolidation request message queue\n    )\n    CONSOLIDATION_REQUEST_QUEUE_TAIL_STORAGE_SLOT = (\n        3  # Pointer to the tail of the consolidation request message queue\n    )\n    CONSOLIDATION_REQUEST_QUEUE_STORAGE_OFFSET = (\n        4  # The start memory slot of the in-state consolidation request message queue\n    )\n    MAX_CONSOLIDATION_REQUESTS_PER_BLOCK = (\n        2  # Maximum number of consolidation requests that can be de-queued into a block\n    )\n    TARGET_CONSOLIDATION_REQUESTS_PER_BLOCK = 1\n    MIN_CONSOLIDATION_REQUEST_FEE = 1\n    CONSOLIDATION_REQUEST_FEE_UPDATE_FRACTION = 17\n    EXCESS_INHIBITOR = 1181\n\n    @staticmethod\n    def fake_exponential(factor: int, numerator: int, denominator: int) -&gt; int:\n        \"\"\"Calculate the consolidation request fee.\"\"\"\n        i = 1\n        output = 0\n        numerator_accumulator = factor * denominator\n        while numerator_accumulator &gt; 0:\n            output += numerator_accumulator\n            numerator_accumulator = (numerator_accumulator * numerator) // (denominator * i)\n            i += 1\n        return output // denominator\n\n    @staticmethod\n    def get_fee(excess_consolidation_requests: int) -&gt; int:\n        \"\"\"Calculate the fee for the excess consolidation requests.\"\"\"\n        return Spec.fake_exponential(\n            Spec.MIN_CONSOLIDATION_REQUEST_FEE,\n            excess_consolidation_requests,\n            Spec.CONSOLIDATION_REQUEST_FEE_UPDATE_FRACTION,\n        )\n\n    @staticmethod\n    def get_excess_consolidation_requests(previous_excess: int, count: int) -&gt; int:\n        \"\"\"Calculate the new excess consolidation requests.\"\"\"\n        if previous_excess + count &gt; Spec.TARGET_CONSOLIDATION_REQUESTS_PER_BLOCK:\n            return previous_excess + count - Spec.TARGET_CONSOLIDATION_REQUESTS_PER_BLOCK\n        return 0\n</code></pre>"},{"location":"tests/prague/eip7251_consolidations/test_consolidations/","title":"Test Consolidations","text":"<p>Documentation for <code>tests/prague/eip7251_consolidations/test_consolidations.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip7251_consolidations/test_consolidations.py --fork Prague\n</code></pre> Tests EIP-7251: Increase the MAX_EFFECTIVE_BALANCE <p>Test execution layer triggered consolidations EIP-7251: Increase the MAX_EFFECTIVE_BALANCE.</p>"},{"location":"tests/prague/eip7251_consolidations/test_consolidations/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_consolidation_requests</code> blockchain_test 24 Test making a consolidation request to the beacon chain. <code>test_consolidation_requests_negative</code> blockchain_test 8 Test blocks where the requests list and the actual consolidation requests that happened in the"},{"location":"tests/prague/eip7251_consolidations/test_consolidations_during_fork/","title":"Test Consolidations During Fork","text":"<p>Documentation for <code>tests/prague/eip7251_consolidations/test_consolidations_during_fork.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip7251_consolidations/test_consolidations_during_fork.py --fork Prague\n</code></pre> Tests EIP-7251: Increase the MAX_EFFECTIVE_BALANCE <p>Test execution layer triggered consolidations EIP-7251: Increase the MAX_EFFECTIVE_BALANCE.</p>"},{"location":"tests/prague/eip7251_consolidations/test_consolidations_during_fork/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_consolidation_requests_during_fork</code> blockchain_test 0 Test making a consolidation request to the beacon chain at the time of the fork."},{"location":"tests/prague/eip7251_consolidations/test_contract_deployment/","title":"Test Contract Deployment","text":"<p>Documentation for <code>tests/prague/eip7251_consolidations/test_contract_deployment.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip7251_consolidations/test_contract_deployment.py --fork Prague\n</code></pre> Tests EIP-7251: Increase the MAX_EFFECTIVE_BALANCE. <p>Test system contract deployment for EIP-7251: Increase the MAX_EFFECTIVE_BALANCE.</p>"},{"location":"tests/prague/eip7251_consolidations/test_contract_deployment/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_system_contract_deployment</code> blockchain_test 0 Verify calling the consolidation system contract after deployment."},{"location":"tests/prague/eip7623_increase_calldata_cost/","title":"EIP-7623 Increase Calldata Cost","text":"<p>Documentation for <code>tests/prague/eip7623_increase_calldata_cost@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip7623_increase_calldata_cost --fork Prague\n</code></pre> Test EIP-7623: Increase calldata cost <p>Tests for  EIP-7623: Increase calldata cost.</p>"},{"location":"tests/prague/eip7623_increase_calldata_cost/spec/","title":"Spec","text":"<p>Documentation for <code>tests/prague/eip7623_increase_calldata_cost/spec.py@af77f529</code>.</p> <p>Defines EIP-7623 specification constants and functions.</p>"},{"location":"tests/prague/eip7623_increase_calldata_cost/spec/#tests.prague.eip7623_increase_calldata_cost.spec.Spec","title":"<code>Spec</code>  <code>dataclass</code>","text":"<p>Parameters from the EIP-7623 specifications as defined at https://eips.ethereum.org/EIPS/eip-7623.</p> Source code in <code>tests/prague/eip7623_increase_calldata_cost/spec.py</code> <pre><code>@dataclass(frozen=True)\nclass Spec:\n    \"\"\"\n    Parameters from the EIP-7623 specifications as defined at\n    https://eips.ethereum.org/EIPS/eip-7623.\n    \"\"\"\n\n    STANDARD_TOKEN_COST = 4\n    TOTAL_COST_FLOOR_PER_TOKEN = 10\n</code></pre>"},{"location":"tests/prague/eip7623_increase_calldata_cost/test_execution_gas/","title":"Test Execution Gas","text":"<p>Documentation for <code>tests/prague/eip7623_increase_calldata_cost/test_execution_gas.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip7623_increase_calldata_cost/test_execution_gas.py --fork Prague\n</code></pre> Test EIP-7623: Increase calldata cost <p>Test execution gas consumption after EIP-7623: Increase calldata cost.</p>"},{"location":"tests/prague/eip7623_increase_calldata_cost/test_execution_gas/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_full_gas_consumption</code> state_test 12 Test executing a transaction that fully consumes its execution gas allocation. <code>test_gas_consumption_below_data_floor</code> state_test 6 Test executing a transaction that almost consumes the floor data cost."},{"location":"tests/prague/eip7623_increase_calldata_cost/test_refunds/","title":"Test Refunds","text":"<p>Documentation for <code>tests/prague/eip7623_increase_calldata_cost/test_refunds.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip7623_increase_calldata_cost/test_refunds.py --fork Prague\n</code></pre> Test EIP-7623: Increase calldata cost <p>Test applied refunds for EIP-7623: Increase calldata cost.</p>"},{"location":"tests/prague/eip7623_increase_calldata_cost/test_refunds/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_gas_refunds_from_data_floor</code> state_test 9 Test gas refunds deducted from the execution gas cost and not the data floor."},{"location":"tests/prague/eip7623_increase_calldata_cost/test_transaction_validity/","title":"Test Transaction Validity","text":"<p>Documentation for <code>tests/prague/eip7623_increase_calldata_cost/test_transaction_validity.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip7623_increase_calldata_cost/test_transaction_validity.py --fork Prague\n</code></pre> Test EIP-7623: Increase calldata cost <p>Test transaction validity on EIP-7623: Increase calldata cost.</p>"},{"location":"tests/prague/eip7623_increase_calldata_cost/test_transaction_validity/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_transaction_validity_type_0</code> state_test 24 Test transaction validity for transactions without access lists and contract creation. <code>test_transaction_validity_type_1_type_2</code> state_test 168 Test transaction validity for transactions with access lists and contract creation. <code>test_transaction_validity_type_3</code> state_test 84 Test transaction validity for transactions with access lists, blobs, <code>test_transaction_validity_type_4</code> state_test 84 Test transaction validity for transactions with access lists, authorization lists, but no"},{"location":"tests/prague/eip7685_general_purpose_el_requests/","title":"EIP-7685 General Purpose El Requests","text":"<p>Documentation for <code>tests/prague/eip7685_general_purpose_el_requests@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip7685_general_purpose_el_requests --fork Prague\n</code></pre> <p>Cross-client EIP-7685 Tests.</p>"},{"location":"tests/prague/eip7685_general_purpose_el_requests/spec/","title":"Spec","text":"<p>Documentation for <code>tests/prague/eip7685_general_purpose_el_requests/spec.py@af77f529</code>.</p> <p>Common procedures to test EIP-7685: General purpose execution layer requests.</p>"},{"location":"tests/prague/eip7685_general_purpose_el_requests/test_deposits_withdrawals_consolidations/","title":"Test Deposits Withdrawals Consolidations","text":"<p>Documentation for <code>tests/prague/eip7685_general_purpose_el_requests/test_deposits_withdrawals_consolidations.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip7685_general_purpose_el_requests/test_deposits_withdrawals_consolidations.py --fork Prague\n</code></pre> Tests EIP-7685: General purpose execution layer requests <p>Cross testing for withdrawal and deposit request for EIP-7685: General purpose execution layer requests.</p>"},{"location":"tests/prague/eip7685_general_purpose_el_requests/test_deposits_withdrawals_consolidations/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_valid_deposit_withdrawal_consolidation_requests</code> blockchain_test 19 Test making a deposit to the beacon chain deposit contract and a withdrawal <code>test_valid_deposit_withdrawal_consolidation_request_from_same_tx</code> blockchain_test 6 Test making a deposit to the beacon chain deposit contract and a withdrawal in <code>test_invalid_deposit_withdrawal_consolidation_requests</code> blockchain_test 19 Negative testing for all request types in the same block."},{"location":"tests/prague/eip7702_set_code_tx/","title":"EIP-7702 Set Code Tx","text":"<p>Documentation for <code>tests/prague/eip7702_set_code_tx@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip7702_set_code_tx --fork Prague\n</code></pre> <p>Cross-client EIP-7702 Tests.</p>"},{"location":"tests/prague/eip7702_set_code_tx/spec/","title":"Spec","text":"<p>Documentation for <code>tests/prague/eip7702_set_code_tx/spec.py@af77f529</code>.</p> <p>Defines EIP-7702 specification constants and functions.</p>"},{"location":"tests/prague/eip7702_set_code_tx/spec/#tests.prague.eip7702_set_code_tx.spec.Spec","title":"<code>Spec</code>  <code>dataclass</code>","text":"<p>Parameters from the EIP-7702 specifications as defined at https://eips.ethereum.org/EIPS/eip-7702.</p> Source code in <code>tests/prague/eip7702_set_code_tx/spec.py</code> <pre><code>@dataclass(frozen=True)\nclass Spec:\n    \"\"\"\n    Parameters from the EIP-7702 specifications as defined at\n    https://eips.ethereum.org/EIPS/eip-7702.\n    \"\"\"\n\n    SET_CODE_TX_TYPE = 0x04\n    MAGIC = 0x05\n    PER_AUTH_BASE_COST = 12_500\n    PER_EMPTY_ACCOUNT_COST = 25_000\n    DELEGATION_DESIGNATION = Bytes(\"ef0100\")\n    RESET_DELEGATION_ADDRESS = Address(0)\n\n    MAX_AUTH_CHAIN_ID = 2**256 - 1\n    MAX_NONCE = 2**64 - 1\n\n    @staticmethod\n    def delegation_designation(address: Address) -&gt; Bytes:\n        \"\"\"Return delegation designation for the given address.\"\"\"\n        return Bytes(Spec.DELEGATION_DESIGNATION + bytes(address))\n</code></pre>"},{"location":"tests/prague/eip7702_set_code_tx/test_gas/","title":"Test Gas","text":"<p>Documentation for <code>tests/prague/eip7702_set_code_tx/test_gas.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip7702_set_code_tx/test_gas.py --fork Prague\n</code></pre> Tests related to gas of set-code transactions from EIP-7702: Set EOA account code for one transaction <p>Tests related to gas of set-code transactions from EIP-7702: Set EOA account code for one transaction.</p>"},{"location":"tests/prague/eip7702_set_code_tx/test_gas/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_gas_cost</code> state_test 30 Test gas at the execution start of a set-code transaction in multiple scenarios. <code>test_account_warming</code> state_test 54 Test warming of the authority and authorized accounts for set-code transactions. <code>test_intrinsic_gas_cost</code> state_test 60 Test sending a transaction with the exact intrinsic gas required and also insufficient <code>test_self_set_code_cost</code> state_test 2 Test set to code account access cost when it delegates to itself. <code>test_call_to_pre_authorized_oog</code> state_test 4 Test additional cost of delegation contract access in call instructions."},{"location":"tests/prague/eip7702_set_code_tx/test_invalid_tx/","title":"Test INVALID Tx","text":"<p>Documentation for <code>tests/prague/eip7702_set_code_tx/test_invalid_tx.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip7702_set_code_tx/test_invalid_tx.py --fork Prague\n</code></pre> Tests invalid set-code transactions from EIP-7702: Set EOA account code for one transaction <p>Tests invalid set-code transactions from EIP-7702: Set EOA account code for one transaction.</p>"},{"location":"tests/prague/eip7702_set_code_tx/test_invalid_tx/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_empty_authorization_list</code> transaction_test 1 Test sending a transaction with an empty authorization list. <code>test_invalid_auth_signature</code> transaction_test 8 Test sending a transaction where one of the signature elements is out of range. <code>test_invalid_tx_invalid_auth_chain_id</code> transaction_test 2 Test sending a transaction where the chain id field of an authorization overflows the <code>test_invalid_tx_invalid_nonce</code> transaction_test 8 Test sending a transaction where the nonce field of an authorization overflows the maximum"},{"location":"tests/prague/eip7702_set_code_tx/test_set_code_txs/","title":"Test Set Code Txs","text":"<p>Documentation for <code>tests/prague/eip7702_set_code_tx/test_set_code_txs.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip7702_set_code_tx/test_set_code_txs.py --fork Prague\n</code></pre> Tests use of set-code transactions from EIP-7702: Set EOA account code for one transaction <p>Tests use of set-code transactions from EIP-7702: Set EOA account code for one transaction.</p>"},{"location":"tests/prague/eip7702_set_code_tx/test_set_code_txs/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_self_sponsored_set_code</code> state_test 10 Test the executing a self-sponsored set-code transaction. <code>test_set_code_to_sstore</code> state_test 30 Test the executing a simple SSTORE in a set-code transaction. <code>test_set_code_to_non_empty_storage_non_zero_nonce</code> state_test 1 Test the setting the code to an account that has non-empty storage. <code>test_set_code_to_sstore_then_sload</code> blockchain_test 1 Test the executing a simple SSTORE then SLOAD in two separate set-code transactions. <code>test_set_code_to_tstore_reentry</code> state_test 8 Test the executing a simple TSTORE in a set-code transaction, which also performs a <code>test_set_code_to_tstore_available_at_correct_address</code> state_test 2 Test TLOADing from slot 2 and then SSTORE this in slot 1, then TSTORE 3 in slot 2. <code>test_set_code_to_self_destruct</code> state_test 4 Test the executing self-destruct opcode in a set-code transaction. <code>test_set_code_to_contract_creator</code> state_test 2 Test the executing a contract-creating opcode in a set-code transaction. <code>test_set_code_to_self_caller</code> state_test 8 Test the executing a self-call in a set-code transaction. <code>test_set_code_max_depth_call_stack</code> state_test 1 Test re-entry to delegated account until the max call stack depth is reached. <code>test_set_code_call_set_code</code> state_test 8 Test the calling a set-code account from another set-code account. <code>test_address_from_set_code</code> state_test 1 Test the address opcode in a set-code transaction. <code>test_tx_into_self_delegating_set_code</code> state_test 1 Test a transaction that has entry-point into a set-code account that delegates to itself. <code>test_tx_into_chain_delegating_set_code</code> state_test 1 Test a transaction that has entry-point into a set-code account that delegates to another <code>test_call_into_self_delegating_set_code</code> state_test 4 Test call into a set-code account that delegates to itself. <code>test_call_into_chain_delegating_set_code</code> state_test 4 Test call into a set-code account that delegates to another set-code account. <code>test_ext_code_on_set_code</code> state_test 8 Test different ext*code operations on a set-code address. <code>test_ext_code_on_self_set_code</code> state_test 2 Test different ext*code operations on self set-code address. <code>test_set_code_address_and_authority_warm_state</code> state_test 2 Test set to code address and authority warm status after a call to <code>test_set_code_address_and_authority_warm_state_call_types</code> state_test 8 Test set to code address and authority warm status after a call to <code>test_ext_code_on_self_delegating_set_code</code> state_test 2 Test different ext*code operations on a set-code address that delegates to itself. <code>test_ext_code_on_chain_delegating_set_code</code> state_test 1 Test different ext*code operations on a set-code address that references another delegated <code>test_self_code_on_set_code</code> state_test 2 Test codesize and codecopy operations on a set-code address. <code>test_set_code_to_account_deployed_in_same_tx</code> state_test 2 Test setting the code of an account to an address that is deployed in the same transaction, <code>test_set_code_to_self_destructing_account_deployed_in_same_tx</code> state_test 16 Test setting the code of an account to an account that contains the SELFDESTRUCT opcode and <code>test_set_code_multiple_first_valid_authorization_tuples_same_signer</code> state_test 1 Test setting the code of an account with multiple authorization tuples <code>test_set_code_multiple_valid_authorization_tuples_same_signer_increasing_nonce</code> state_test 1 Test setting the code of an account with multiple authorization tuples from the same signer <code>test_set_code_multiple_valid_authorization_tuples_same_signer_increasing_nonce_self_sponsored</code> state_test 1 Test setting the code of an account with multiple authorization tuples from the same signer <code>test_set_code_multiple_valid_authorization_tuples_first_invalid_same_signer</code> state_test 1 Test setting the code of an account with multiple authorization tuples from the same signer <code>test_set_code_all_invalid_authorization_tuples</code> state_test 1 Test setting the code of an account with multiple authorization tuples from the same signer <code>test_set_code_using_chain_specific_id</code> state_test 1 Test sending a transaction to set the code of an account using a chain-specific ID. <code>test_set_code_using_valid_synthetic_signatures</code> state_test 6 Test sending a transaction to set the code of an account using synthetic signatures. <code>test_valid_tx_invalid_auth_signature</code> state_test 21 Test sending a transaction to set the code of an account using synthetic signatures, <code>test_signature_s_out_of_range</code> state_test 1 Test sending a transaction with an authorization tuple where the signature s value is out of <code>test_valid_tx_invalid_chain_id</code> state_test 2 Test sending a transaction where the chain id field does not match <code>test_nonce_validity</code> state_test 4 Test sending a transaction where the nonce field of an authorization almost overflows the <code>test_nonce_overflow_after_first_authorization</code> state_test 1 Test sending a transaction with two authorization where the first one bumps the nonce <code>test_set_code_to_log</code> state_test 5 Test setting the code of an account to a contract that performs the log operation. <code>test_set_code_to_precompile</code> state_test 17 Test setting the code of an account to a pre-compile address. <code>test_set_code_to_system_contract</code> blockchain_test 5 Test setting the code of an account to a system contract. <code>test_eoa_tx_after_set_code</code> blockchain_test 4 Test sending a transaction from an EOA after code has been set to the account. <code>test_reset_code</code> blockchain_test 2 Test sending type-4 tx to reset the code of an account after code has been <code>test_contract_create</code> state_test 1 Test sending type-4 tx as a create transaction. <code>test_empty_authorization_list</code> state_test 1 Test sending an invalid transaction with empty authorization list. <code>test_delegation_clearing</code> state_test 4 Test clearing the delegation of an account under a variety of circumstances. <code>test_delegation_clearing_tx_to</code> state_test 4 Tests directly calling the account which delegation is being cleared. <code>test_delegation_clearing_and_set</code> state_test 2 Tests clearing and setting the delegation again in the same authorization list. <code>test_delegation_clearing_failing_tx</code> state_test 3 Test clearing the delegation of an account in a transaction that fails, OOGs or reverts. <code>test_deploying_delegation_designation_contract</code> state_test 1 Test attempting to deploy a contract that has the same format as a <code>test_creating_delegation_designation_contract</code> state_test 2 Tx -&gt; create -&gt; pointer bytecode <code>test_many_delegations</code> state_test 4 Perform as many delegations as possible in a single 120 million gas transaction. <code>test_invalid_transaction_after_authorization</code> blockchain_test 1 Test an invalid block due to a transaction reusing the same nonce as an authorization <code>test_authorization_reusing_nonce</code> blockchain_test 1 Test an authorization reusing the same nonce as a prior transaction included in the same <code>test_set_code_from_account_with_non_delegating_code</code> state_test 8 Test that a transaction is correctly rejected,"},{"location":"tests/prague/eip7702_set_code_tx/test_set_code_txs_2/","title":"Test Set Code Txs 2","text":"<p>Documentation for <code>tests/prague/eip7702_set_code_tx/test_set_code_txs_2.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/prague/eip7702_set_code_tx/test_set_code_txs_2.py --fork Prague\n</code></pre> <p>A state test for EIP-7702 SetCodeTX.</p>"},{"location":"tests/prague/eip7702_set_code_tx/test_set_code_txs_2/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_pointer_contract_pointer_loop</code> state_test 1 Tx -&gt; call -&gt; pointer A -&gt; contract A -&gt; pointer B -&gt; contract loop C. <code>test_pointer_to_pointer</code> state_test 1 Tx -&gt; call -&gt; pointer A -&gt; pointer B. <code>test_pointer_normal</code> blockchain_test 1 Tx -&gt; call -&gt; pointer A -&gt; contract <code>test_pointer_measurements</code> blockchain_test 1 Check extcode* operations on pointer before and after pointer is set <code>test_call_to_precompile_in_pointer_context</code> state_test 17 Tx -&gt; call -&gt; pointer A -&gt; precompile contract <code>test_pointer_to_precompile</code> state_test 17 Tx -&gt; call -&gt; pointer A -&gt; precompile contract. <code>test_gas_diff_pointer_vs_direct_call</code> blockchain_test 32 Check the gas difference when calling the contract directly vs as a pointer <code>test_pointer_call_followed_by_direct_call</code> state_test 1 If we first call by pointer then direct call, will the call/sload be hot <code>test_pointer_to_static</code> state_test 1 Tx -&gt; call -&gt; pointer A -&gt; static -&gt; static violation <code>test_static_to_pointer</code> state_test 1 Tx -&gt; staticcall -&gt; pointer A -&gt; static violation <code>test_pointer_to_eof</code> state_test 1 Tx -&gt; call -&gt; pointer A -&gt; EOF <code>test_pointer_to_static_reentry</code> state_test 1 Tx call -&gt; pointer A -&gt; static -&gt; code -&gt; pointer A -&gt; static violation <code>test_contract_storage_to_pointer_with_storage</code> state_test 3 Tx call -&gt; contract with storage -&gt; pointer A with storage -&gt; storage/tstorage modify <code>test_pointer_reentry</code> state_test 1 Check operations when reenter the pointer again <code>test_eoa_init_as_pointer</code> state_test 1 It was agreed before that senders don't have code <code>test_call_pointer_to_created_from_create_after_oog_call_again</code> state_test 3 Set pointer to account that we are about to create. <code>test_pointer_reverts</code> state_test 10 Pointer do operations then revert. <code>test_double_auth</code> state_test 9 Only the last auth works, but first auth still charges the gas. <code>test_pointer_resets_an_empty_code_account_with_storage</code> blockchain_test 1 So in Block1 we create a sender with empty code, but non empty storage using pointers"},{"location":"tests/shanghai/","title":"Shanghai","text":"<p>Documentation for <code>tests/shanghai@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/shanghai --fork Prague\n</code></pre> <p>Test cases for EVM functionality introduced in Shanghai.</p>"},{"location":"tests/shanghai/eip3651_warm_coinbase/","title":"EIP-3651 Warm COINBASE","text":"<p>Documentation for <code>tests/shanghai/eip3651_warm_coinbase@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/shanghai/eip3651_warm_coinbase --fork Prague\n</code></pre> Tests EIP-3651: Warm COINBASE <p>Tests for EIP-3651: Warm COINBASE.</p>"},{"location":"tests/shanghai/eip3651_warm_coinbase/spec/","title":"Spec","text":"<p>Documentation for <code>tests/shanghai/eip3651_warm_coinbase/spec.py@af77f529</code>.</p> <p>Defines EIP-3651 specification constants and functions.</p>"},{"location":"tests/shanghai/eip3651_warm_coinbase/test_warm_coinbase/","title":"Test Warm COINBASE","text":"<p>Documentation for <code>tests/shanghai/eip3651_warm_coinbase/test_warm_coinbase.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/shanghai/eip3651_warm_coinbase/test_warm_coinbase.py --fork Prague\n</code></pre> Tests EIP-3651: Warm COINBASE <p>Tests for EIP-3651: Warm COINBASE.</p> Tests ported from: <ul> <li>ethereum/tests/pull/1082.</li> </ul>"},{"location":"tests/shanghai/eip3651_warm_coinbase/test_warm_coinbase/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_warm_coinbase_call_out_of_gas</code> state_test 8 Test that the coinbase is warm by accessing the COINBASE with each <code>test_warm_coinbase_gas_usage</code> state_test 8 Test the gas usage of opcodes affected by assuming a warm coinbase."},{"location":"tests/shanghai/eip3855_push0/","title":"EIP-3855 PUSH0","text":"<p>Documentation for <code>tests/shanghai/eip3855_push0@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/shanghai/eip3855_push0 --fork Prague\n</code></pre> Tests EIP-3855: PUSH0 Instruction <p>Tests for EIP-3855: PUSH0 Instruction.</p>"},{"location":"tests/shanghai/eip3855_push0/spec/","title":"Spec","text":"<p>Documentation for <code>tests/shanghai/eip3855_push0/spec.py@af77f529</code>.</p> <p>Defines EIP-3855 specification constants and functions.</p>"},{"location":"tests/shanghai/eip3855_push0/test_push0/","title":"Test PUSH0","text":"<p>Documentation for <code>tests/shanghai/eip3855_push0/test_push0.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/shanghai/eip3855_push0/test_push0.py --fork Prague\n</code></pre> Tests EIP-3855: PUSH0 Instruction <p>Tests for EIP-3855: PUSH0 Instruction.</p> Tests ported from: <ul> <li>ethereum/tests/pull/1033.</li> </ul>"},{"location":"tests/shanghai/eip3855_push0/test_push0/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_push0_contracts</code> state_test 6 Tests PUSH0 within various deployed contracts. <code>test_push0_contract_during_call_contexts</code> state_test 4 Test PUSH0 during various call contexts."},{"location":"tests/shanghai/eip3860_initcode/","title":"EIP-3860 Initcode","text":"<p>Documentation for <code>tests/shanghai/eip3860_initcode@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/shanghai/eip3860_initcode --fork Prague\n</code></pre> Test EIP-3860: Limit and meter initcode <p>Tests for  EIP-3860: Limit and meter initcode.</p>"},{"location":"tests/shanghai/eip3860_initcode/spec/","title":"Spec","text":"<p>Documentation for <code>tests/shanghai/eip3860_initcode/spec.py@af77f529</code>.</p> <p>Defines EIP-3860 specification constants and functions.</p>"},{"location":"tests/shanghai/eip3860_initcode/spec/#tests.shanghai.eip3860_initcode.spec.Spec","title":"<code>Spec</code>  <code>dataclass</code>","text":"<p>Parameters from the EIP-3860 specifications as defined at https://eips.ethereum.org/EIPS/eip-3860#parameters.</p> Source code in <code>tests/shanghai/eip3860_initcode/spec.py</code> <pre><code>@dataclass(frozen=True)\nclass Spec:\n    \"\"\"\n    Parameters from the EIP-3860 specifications as defined at\n    https://eips.ethereum.org/EIPS/eip-3860#parameters.\n    \"\"\"\n\n    MAX_INITCODE_SIZE = 49152\n    INITCODE_WORD_COST = 2\n</code></pre>"},{"location":"tests/shanghai/eip3860_initcode/test_initcode/","title":"Test Initcode","text":"<p>Documentation for <code>tests/shanghai/eip3860_initcode/test_initcode.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/shanghai/eip3860_initcode/test_initcode.py --fork Prague\n</code></pre> Test EIP-3860: Limit and meter initcode <p>Tests for  EIP-3860: Limit and meter initcode.</p> Tests ported from: <ul> <li>ethereum/tests/pull/990</li> <li>ethereum/tests/pull/1012</li> </ul>"},{"location":"tests/shanghai/eip3860_initcode/test_initcode/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_contract_creating_tx</code> state_test 4 Tests creating a contract using a transaction with an initcode that is <code>test_gas_usage</code> state_test 30 Test transaction and contract creation behavior for different gas limits. <code>test_create_opcode_initcode</code> state_test 20 Test contract creation via the CREATE/CREATE2 opcodes that have an"},{"location":"tests/shanghai/eip3860_initcode/test_with_eof/","title":"Test With EOF","text":"<p>Documentation for <code>tests/shanghai/eip3860_initcode/test_with_eof.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/shanghai/eip3860_initcode/test_with_eof.py --fork Prague\n</code></pre> <p>Tests interaction between edge case size CREATE / CREATE2 and EOF, including EIP-3860 limits.</p>"},{"location":"tests/shanghai/eip3860_initcode/test_with_eof/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_legacy_create_edge_code_size</code> state_test 8 Verifies that legacy initcode/deploycode having 0 or max size continues to work in the fork"},{"location":"tests/shanghai/eip4895_withdrawals/","title":"EIP-4895 Withdrawals","text":"<p>Documentation for <code>tests/shanghai/eip4895_withdrawals@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/shanghai/eip4895_withdrawals --fork Prague\n</code></pre> Tests EIP-4895: Beacon chain withdrawals <p>Test cases for EIP-4895: Beacon chain push withdrawals as operations.</p>"},{"location":"tests/shanghai/eip4895_withdrawals/spec/","title":"Spec","text":"<p>Documentation for <code>tests/shanghai/eip4895_withdrawals/spec.py@af77f529</code>.</p> <p>Defines EIP-4895 specification constants and functions.</p>"},{"location":"tests/shanghai/eip4895_withdrawals/test_withdrawals/","title":"Test Withdrawals","text":"<p>Documentation for <code>tests/shanghai/eip4895_withdrawals/test_withdrawals.py@af77f529</code>.</p> <p>Generate fixtures for these test cases for Prague with:</p> <pre><code>fill -v tests/shanghai/eip4895_withdrawals/test_withdrawals.py --fork Prague\n</code></pre> Tests EIP-4895: Beacon chain withdrawals <p>Test cases for EIP-4895: Beacon chain push withdrawals as operations.</p>"},{"location":"tests/shanghai/eip4895_withdrawals/test_withdrawals/#test-functions-overview","title":"Test Functions Overview","text":"Name Type Cases (Prague) Description <code>test_use_value_in_tx</code> blockchain_test 2 Test sending withdrawal value in a transaction. <code>test_use_value_in_contract</code> blockchain_test 1 Test sending value from contract that has not received a withdrawal. <code>test_balance_within_block</code> blockchain_test 1 Test Withdrawal balance increase within the same block, <code>test_multiple_withdrawals_same_address</code> blockchain_test 2 Test Withdrawals can be done to the same address multiple times in <code>test_many_withdrawals</code> blockchain_test 1 Test Withdrawals with a count of N withdrawals in a single block where <code>test_self_destructing_account</code> blockchain_test 1 Test withdrawals can be done to self-destructed accounts. <code>test_newly_created_contract</code> blockchain_test 2 Test Withdrawing to a newly created contract. <code>test_no_evm_execution</code> blockchain_test 1 Test Withdrawals don't trigger EVM execution. <code>test_zero_amount</code> blockchain_test 4 Test withdrawals with zero amount for the following cases, all withdrawals <code>test_large_amount</code> blockchain_test 1 Test Withdrawals that have a large gwei amount, so that (gwei * 1e9) <code>test_withdrawing_to_precompiles</code> blockchain_test 34 Test withdrawing to all precompiles for a given fork."},{"location":"writing_tests/","title":"Writing Tests","text":"<p>The easiest way to get started is to use the interactive CLI:</p> <pre><code>uv run eest make test\n</code></pre> <p>and modify the generated test module to suit your needs.</p> <p>For help deciding which test format to select, see Types of Tests, in particular Deciding on a Test Type. Otherwise, some simple test case examples to get started with are:</p> <ul> <li>tests.berlin.eip2930_access_list.test_acl.test_access_list.</li> <li>tests.istanbul.eip1344_chainid.test_chainid.test_chainid.</li> </ul> <p>Please check that your code adheres to the repo's Coding Standards and read the other pages in this section for more background and an explanation of how to implement state transition and blockchain tests.</p>"},{"location":"writing_tests/adding_a_new_test/","title":"Adding a New Test","text":"<p>All test cases are located underneath the <code>tests</code> directory, which are then organized by fork. Each fork contains sub-directories containing test sub-categories.</p> <pre><code>\ud83d\udcc1 execution-test-specs/\n\u251c\u2500\u2574\ud83d\udcc1 tests/\n|   \u251c\u2500\u2500 \ud83d\udcc4 __init__.py\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 cancun/\n|   |    \u251c\u2500\u2500 \ud83d\udcc4 __init__.py\n\u2502   |    \u2514\u2500\u2500 \ud83d\udcc1 eip4844_blobs/\n|   |        \u251c\u2500\u2500 \ud83d\udcc4 __init__.py\n|   |        \u251c\u2500\u2500 \ud83d\udcc4 test_blobhash_opcode.py\n|   |        \u251c\u2500\u2500 \ud83d\udcc4 test_excess_blob_gas.py\n|   |        \u2514\u2500\u2500 \ud83d\udcc4 ...\n|   \u251c\u2500\u2500 \ud83d\udcc1 shanghai\n|   |    \u251c\u2500\u2500 \ud83d\udcc1 eip3651_warm_coinbase\n|   |    |   \u251c\u2500\u2500 \ud83d\udcc4 __init__.py\n|   |    |   \u2514\u2500\u2500 \ud83d\udcc4 test_warm_coinbase.py\n|   |    \u251c\u2500\u2500 \ud83d\udcc1 eip3855_push0\n|   |    |   \u251c\u2500\u2500 \ud83d\udcc4 __init__.py\n|   |    |   \u2514\u2500\u2500 \ud83d\udcc4 test_push0.py\n|   |    \u251c\u2500\u2500 \ud83d\udcc1...\n|   |    ...\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 ...\n</code></pre> <p>Each category/sub-directory may have multiple Python test modules (<code>*.py</code>) which in turn may contain many test functions. The test functions themselves are always parametrized by fork (by the framework).</p> <p>A new test can be added by either:</p> <ul> <li>Adding a new <code>test_</code> python function to an existing file in any of the existing category subdirectories within <code>tests</code>.</li> <li>Creating a new source file in an existing category, and populating it with the new test function(s).</li> <li>Creating an entirely new category by adding a subdirectory in <code>tests</code> with the appropriate source files and test functions.</li> </ul>"},{"location":"writing_tests/code_standards/","title":"Code Standards","text":"<p>The Python code in the tests subdirectory <code>./tests</code> must fulfill the following checks:</p> Command Explanation 1 <code>ruff check tests</code> Python lint, format and imports check. 2 <code>mypy tests</code> Objects that provide typehints pass type-checking via mypy. 3 <code>fill</code> All tests must execute correctly. 4 <code>mkdocs build --strict</code> Documentation generated without warnings. 5 <code>pyspelling</code> Markdown spell-check. 6 <code>markdownlint-cli2</code> Markdown lint check. <p>A correctly configured editor (see VS Code Setup) will ensure that most points are resolved automatically upon file save.</p> <p>Additionally, if you skip type hints, they won't be checked; we can help you add these in the PR.</p> <p>These checks must pass in order for the execution-spec-tests Github Actions to pass upon pushing to remote.</p> <p>Running the checks with tox</p> <p>All these checks can be executed locally in a single command, <code>tox</code>, see Verifying Changes.</p> <p>If you need help, get in touch!</p>"},{"location":"writing_tests/exception_tests/","title":"Exception Tests","text":"<p>Exception tests are a special type of test which verify that an invalid transaction or an invalid block are correctly rejected with the expected error.</p>"},{"location":"writing_tests/exception_tests/#creating-an-exception-test","title":"Creating an Exception Test","text":"<p>To test for an exception, the test can use either of the following types from <code>ethereum_test_exceptions</code> library:</p> <ol> <li> <p><code>TransactionException</code>: To be added to the <code>error</code> field of the <code>Transaction</code> object, and to the <code>exception</code> field of the <code>Block</code> object that includes the transaction; this exception type is used when a transaction is invalid, and therefore when included in a block, the block is expected to be invalid too. This is different from valid transactions where an exception during EVM execution is expected (e.g. a revert, or out-of-gas), which can be included in valid blocks.</p> <p>For an example, see <code>eip3860_initcode.test_initcode.test_contract_creating_tx</code> which raises <code>TransactionException.INITCODE_SIZE_EXCEEDED</code> in the case that the initcode size exceeds the maximum allowed size.</p> </li> <li> <p><code>BlockException</code>: To be added to the <code>exception</code> field of the <code>Block</code> object; this exception type is used when a block is expected to be invalid, but the exception is related to a block property, e.g. an invalid value of the block header.</p> <p>For an example, see <code>eip4844_blobs.test_excess_blob_gas.test_invalid_static_excess_blob_gas</code> which raises <code>BlockException.INCORRECT_EXCESS_BLOB_GAS</code> in the case that the <code>excessBlobGas</code> remains unchanged but the parent blobs included are not <code>TARGET_BLOBS_PER_BLOCK</code>.</p> </li> </ol> <p>Although exceptions can be combined with the <code>|</code> operator to indicate that a test vector can throw either one of multiple exceptions, ideally the tester should aim to use only one exception per test vector, and only use multiple exceptions on the rare instance when it is not possible to know which exception will be thrown because it depends on client implementation.</p>"},{"location":"writing_tests/exception_tests/#adding-a-new-exception","title":"Adding a new exception","text":"<p>If a test requires a new exception, because none of the existing ones is suitable for the test, a new exception can be added to either <code>TransactionException</code> or <code>BlockException</code> classes.</p> <p>The new exception should be added as a new enum value, and the docstring of the attribute should be a string that describes the exception.</p> <p>The name of the exception should be unique, and should not be used by any other exception.</p>"},{"location":"writing_tests/exception_tests/#test-runner-behavior-on-exception-tests","title":"Test runner behavior on exception tests","text":"<p>When an exception is added to a test vector, the test runner must check that the transaction or block is rejected with the expected exception.</p> <p>The test runner must map the exception key to the corresponding error string that is expected to be returned by the client.</p> <p>Exception mapping are particularly important in blockchain tests because the block can be invalid for multiple reasons, and the client returning a different error can mean that a verification in the client is faulty.</p>"},{"location":"writing_tests/reference_specification/","title":"Referencing an EIP Spec Version","text":"<p>An Ethereum Improvement Proposal (ethereum/EIPs) and its SHA digest can be directly referenced within a python test module in order to check whether the test implementation could be out-dated. The test framework automatically generates tests for every module that defines a spec version. If the spec is out-of-date because the SHA of the specified file in the remote repo changes, the corresponding <code>test_eip_spec_version()</code> test fails.</p> <p> <code>&lt;-snip-&gt;</code> </p> <p>The SHA value is the output from git's <code>hash-object</code> command, for example:</p> <pre><code>git clone git@github.com:ethereum/EIPs\ngit hash-object EIPS/EIPS/eip-3651.md\n# output: d94c694c6f12291bb6626669c3e8587eef3adff1\n</code></pre> <p>and can be retrieved from the remote repo via the Github API on the command-line as following:</p> <pre><code>sudo apt install jq\ncurl -s -H \"Accept: application/vnd.github.v3+json\" \\\nhttps://api.github.com/repos/ethereum/EIPs/contents/EIPS/eip-3651.md |\\\njq -r '.sha'\n# output: d94c694c6f12291bb6626669c3e8587eef3adff1\n</code></pre>"},{"location":"writing_tests/reference_specification/#how-to-add-a-spec-version-check","title":"How to Add a Spec Version Check","text":"<p>This check accomplished by adding the following two global variables anywhere in the Python source file:</p> Variable Name Explanation <code>REFERENCE_SPEC_GIT_PATH</code> The relative path of the EIP markdown file in the ethereum/EIPs repository, e.g. \"<code>EIPS/eip-1234.md</code>\" <code>REFERENCE_SPEC_VERSION</code> The SHA hash of the latest version of the file retrieved from the Github API:<code>https://api.github.com/repos/ethereum/EIPs/contents/EIPS/eip-&lt;EIP Number&gt;.md</code>"},{"location":"writing_tests/reference_specification/#example","title":"Example","text":"<p>Here is an example from ./tests/shanghai/eip3651_warm_coinbase/test_warm_coinbase.py:</p> <pre><code>REFERENCE_SPEC_GIT_PATH = \"EIPS/eip-3651.md\"\nREFERENCE_SPEC_VERSION = \"d94c694c6f12291bb6626669c3e8587eef3adff1\"\n</code></pre> <p>The SHA digest was retrieved from here.</p>"},{"location":"writing_tests/test_markers/","title":"Test Markers","text":"<p>Test markers are used to categorize tests and to run specific subsets of tests. They are defined in the test files using the <code>pytest.mark</code> decorator.</p> <p>The examples below use <code>StateTestFiller</code> tests, but the same markers can also be applied to <code>BlockchainTestFiller</code> tests.</p>"},{"location":"writing_tests/test_markers/#fork-markers","title":"Fork Markers","text":"<p>These markers are used to specify the forks for which a test is valid.</p>"},{"location":"writing_tests/test_markers/#pytestmarkvalid_fromfork_name","title":"<code>@pytest.mark.valid_from(\"FORK_NAME\")</code>","text":"<p>               Bases: <code>ValidityMarker</code></p> <p>Marker used to specify the fork from which the test is valid. The test will not be filled for forks before the specified fork.</p> <pre><code>import pytest\n\nfrom ethereum_test_tools import Alloc, StateTestFiller\n\n@pytest.mark.valid_from(\"London\")\ndef test_something_only_valid_after_london(\n    state_test: StateTestFiller,\n    pre: Alloc\n):\n    pass\n</code></pre> <p>In this example, the test will only be filled for the London fork and after, e.g. London, Paris, Shanghai, Cancun, etc.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>class ValidFrom(ValidityMarker):\n    \"\"\"\n    Marker used to specify the fork from which the test is valid. The test will not be filled for\n    forks before the specified fork.\n\n    ```python\n    import pytest\n\n    from ethereum_test_tools import Alloc, StateTestFiller\n\n    @pytest.mark.valid_from(\"London\")\n    def test_something_only_valid_after_london(\n        state_test: StateTestFiller,\n        pre: Alloc\n    ):\n        pass\n    ```\n\n    In this example, the test will only be filled for the London fork and after, e.g. London,\n    Paris, Shanghai, Cancun, etc.\n    \"\"\"\n\n    def _process_with_marker_args(self, *fork_args) -&gt; Set[Fork]:\n        \"\"\"Process the fork arguments.\"\"\"\n        forks: Set[Fork] = self.process_fork_arguments(*fork_args)\n        resulting_set: Set[Fork] = set()\n        for fork in forks:\n            resulting_set |= {f for f in self.all_forks if f &gt;= fork}\n        return resulting_set\n</code></pre>"},{"location":"writing_tests/test_markers/#pytestmarkvalid_untilfork_name","title":"<code>@pytest.mark.valid_until(\"FORK_NAME\")</code>","text":"<p>               Bases: <code>ValidityMarker</code></p> <p>Marker to specify the fork until which the test is valid. The test will not be filled for forks after the specified fork.</p> <pre><code>import pytest\n\nfrom ethereum_test_tools import Alloc, StateTestFiller\n\n@pytest.mark.valid_until(\"London\")\ndef test_something_only_valid_until_london(\n    state_test: StateTestFiller,\n    pre: Alloc\n):\n    pass\n</code></pre> <p>In this example, the test will only be filled for the London fork and before, e.g. London, Berlin, Istanbul, etc.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>class ValidUntil(ValidityMarker):\n    \"\"\"\n    Marker to specify the fork until which the test is valid. The test will not be filled for\n    forks after the specified fork.\n\n    ```python\n    import pytest\n\n    from ethereum_test_tools import Alloc, StateTestFiller\n\n    @pytest.mark.valid_until(\"London\")\n    def test_something_only_valid_until_london(\n        state_test: StateTestFiller,\n        pre: Alloc\n    ):\n        pass\n    ```\n\n    In this example, the test will only be filled for the London fork and before, e.g. London,\n    Berlin, Istanbul, etc.\n    \"\"\"\n\n    def _process_with_marker_args(self, *fork_args) -&gt; Set[Fork]:\n        \"\"\"Process the fork arguments.\"\"\"\n        forks: Set[Fork] = self.process_fork_arguments(*fork_args)\n        resulting_set: Set[Fork] = set()\n        for fork in forks:\n            resulting_set |= {f for f in self.all_forks if f &lt;= fork}\n        return resulting_set\n</code></pre>"},{"location":"writing_tests/test_markers/#pytestmarkvalid_at_transition_tofork_name","title":"<code>@pytest.mark.valid_at_transition_to(\"FORK_NAME\")</code>","text":"<p>               Bases: <code>ValidityMarker</code></p> <p>Marker to specify that a test is only meant to be filled at the transition to the specified fork.</p> <p>The test usually starts at the fork prior to the specified fork at genesis and at block 5 (for pre-merge forks) or at timestamp 15,000 (for post-merge forks) the fork transition occurs.</p> <pre><code>import pytest\n\nfrom ethereum_test_tools import Alloc, BlockchainTestFiller\n\n@pytest.mark.valid_at_transition_to(\"London\")\ndef test_something_that_happens_during_the_fork_transition_to_london(\n    blockchain_test: BlockchainTestFiller,\n    pre: Alloc\n):\n    pass\n</code></pre> <p>In this example, the test will only be filled for the fork that transitions to London at block number 5, <code>BerlinToLondonAt5</code>, and no other forks.</p> <p>To see or add a new transition fork, see the <code>ethereum_test_forks.forks.transition</code> module.</p> <p>Note that the test uses a <code>BlockchainTestFiller</code> fixture instead of a <code>StateTestFiller</code>, as the transition forks are used to test changes throughout the blockchain progression, and not just the state change of a single transaction.</p> <p>This marker also accepts the following keyword arguments:</p> <ul> <li><code>subsequent_transitions</code>: Force the test to also fill for subsequent fork transitions.</li> <li><code>until</code>: Implies <code>subsequent_transitions</code> and puts a limit on which transition fork will the     test filling will be limited to.</li> </ul> <p>For example: <pre><code>@pytest.mark.valid_at_transition_to(\"Cancun\", subsequent_transitions=True)\n</code></pre></p> <p>produces tests on <code>ShanghaiToCancunAtTime15k</code> and <code>CancunToPragueAtTime15k</code>, and any transition fork after that.</p> <p>And: <pre><code>@pytest.mark.valid_at_transition_to(\"Cancun\", subsequent_transitions=True, until=\"Prague\")\n</code></pre></p> <p>produces tests on <code>ShanghaiToCancunAtTime15k</code> and <code>CancunToPragueAtTime15k</code>, but no forks after Prague.</p> Source code in <code>src/pytest_plugins/forks/forks.py</code> <pre><code>class ValidAtTransitionTo(ValidityMarker, mutually_exclusive=True):\n    \"\"\"\n    Marker to specify that a test is only meant to be filled at the transition to the specified\n    fork.\n\n    The test usually starts at the fork prior to the specified fork at genesis and at block 5 (for\n    pre-merge forks) or at timestamp 15,000 (for post-merge forks) the fork transition occurs.\n\n    ```python\n    import pytest\n\n    from ethereum_test_tools import Alloc, BlockchainTestFiller\n\n    @pytest.mark.valid_at_transition_to(\"London\")\n    def test_something_that_happens_during_the_fork_transition_to_london(\n        blockchain_test: BlockchainTestFiller,\n        pre: Alloc\n    ):\n        pass\n    ```\n\n    In this example, the test will only be filled for the fork that transitions to London at block\n    number 5, `BerlinToLondonAt5`, and no other forks.\n\n    To see or add a new transition fork, see the `ethereum_test_forks.forks.transition` module.\n\n    Note that the test uses a `BlockchainTestFiller` fixture instead of a `StateTestFiller`,\n    as the transition forks are used to test changes throughout the blockchain progression, and\n    not just the state change of a single transaction.\n\n    This marker also accepts the following keyword arguments:\n\n    - `subsequent_transitions`: Force the test to also fill for subsequent fork transitions.\n    - `until`: Implies `subsequent_transitions` and puts a limit on which transition fork will the\n        test filling will be limited to.\n\n    For example:\n    ```python\n    @pytest.mark.valid_at_transition_to(\"Cancun\", subsequent_transitions=True)\n    ```\n\n    produces tests on `ShanghaiToCancunAtTime15k` and `CancunToPragueAtTime15k`, and any transition\n    fork after that.\n\n    And:\n    ```python\n    @pytest.mark.valid_at_transition_to(\"Cancun\", subsequent_transitions=True, until=\"Prague\")\n    ```\n\n    produces tests on `ShanghaiToCancunAtTime15k` and `CancunToPragueAtTime15k`, but no forks after\n    Prague.\n    \"\"\"\n\n    def _process_with_marker_args(\n        self, *fork_args, subsequent_forks: bool = False, until: str | None = None\n    ) -&gt; Set[Fork]:\n        \"\"\"Process the fork arguments.\"\"\"\n        forks: Set[Fork] = self.process_fork_arguments(*fork_args)\n        until_forks: Set[Fork] | None = (\n            None if until is None else self.process_fork_arguments(until)\n        )\n        if len(forks) == 0:\n            pytest.fail(\n                f\"'{self.test_name}': Missing fork argument with 'valid_at_transition_to' marker.\"\n            )\n\n        if len(forks) &gt; 1:\n            pytest.fail(\n                f\"'{self.test_name}': Too many forks specified to 'valid_at_transition_to' marker.\"\n            )\n\n        resulting_set: Set[Fork] = set()\n        for fork in forks:\n            resulting_set |= transition_fork_to(fork)\n            if subsequent_forks:\n                for transition_forks in (\n                    transition_fork_to(f) for f in self.all_forks if f &gt; fork\n                ):\n                    for transition_fork in transition_forks:\n                        if transition_fork and (\n                            until_forks is None\n                            or any(transition_fork &lt;= until_fork for until_fork in until_forks)\n                        ):\n                            resulting_set.add(transition_fork)\n        return resulting_set\n</code></pre>"},{"location":"writing_tests/test_markers/#fork-covariant-markers","title":"Fork Covariant Markers","text":"<p>These markers are used in conjunction with the fork validity markers to automatically parameterize tests with values that are valid for the fork being tested.</p>"},{"location":"writing_tests/test_markers/#pytestmarkwith_all_tx_types","title":"<code>@pytest.mark.with_all_tx_types</code>","text":"<p>This marker is used to automatically parameterize a test with all transaction types that are valid for the fork being tested.</p> <pre><code>import pytest\n\nfrom ethereum_test_tools import Alloc, StateTestFiller\n\n@pytest.mark.with_all_tx_types\n@pytest.mark.valid_from(\"Berlin\")\ndef test_something_with_all_tx_types(\n    state_test: StateTestFiller, \n    pre: Alloc,\n    tx_type: int\n):\n    pass\n</code></pre> <p>In this example, the test will be parameterized for parameter <code>tx_type</code> with values <code>[0, 1]</code> for fork Berlin, but with values <code>[0, 1, 2]</code> for fork London (because of EIP-1559).</p>"},{"location":"writing_tests/test_markers/#pytestmarkwith_all_contract_creating_tx_types","title":"<code>@pytest.mark.with_all_contract_creating_tx_types</code>","text":"<p>This marker is used to automatically parameterize a test with all contract creating transaction types that are valid for the fork being tested.</p> <p>This marker only differs from <code>pytest.mark.with_all_tx_types</code> in that it does not include transaction type 3 (Blob Transaction type) on fork Cancun and after.</p>"},{"location":"writing_tests/test_markers/#pytestmarkwith_all_precompiles","title":"<code>@pytest.mark.with_all_precompiles</code>","text":"<p>This marker is used to automatically parameterize a test with all precompiles that are valid for the fork being tested.</p> <pre><code>import pytest\n\nfrom ethereum_test_tools import Alloc, StateTestFiller\n\n@pytest.mark.with_all_precompiles\n@pytest.mark.valid_from(\"Shanghai\")\ndef test_something_with_all_precompiles(\n    state_test: StateTestFiller, \n    pre: Alloc,\n    precompile: int,\n):\n    pass\n</code></pre> <p>In this example, the test will be parameterized for parameter <code>precompile</code> with values <code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code> for fork Shanghai, but with values <code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code> for fork Cancun which introduced the point evaluation precompile defined in EIP-4844.</p>"},{"location":"writing_tests/test_markers/#pytestmarkwith_all_evm_code_types","title":"<code>@pytest.mark.with_all_evm_code_types</code>","text":"<p>This marker is used to automatically parameterize a test with all EVM code types that are valid for the fork being tested.</p> <pre><code>import pytest\n\nfrom ethereum_test_tools import Alloc, StateTestFiller\n\n@pytest.mark.with_all_evm_code_types\n@pytest.mark.valid_from(\"Frontier\")\ndef test_something_with_all_evm_code_types(\n    state_test: StateTestFiller,     \n    pre: Alloc,\n):\n    pass\n</code></pre> <p>In this example, the test will be parameterized for parameter <code>evm_code_type</code> only with value <code>[EVMCodeType.LEGACY]</code> starting on fork Frontier, and eventually it will be parametrized with with values <code>[EVMCodeType.LEGACY, EVMCodeType.EOF_V1]</code> on the EOF activation fork.</p> <p>In all calls to <code>pre.deploy_contract</code>, if the code parameter is <code>Bytecode</code> type, and <code>evm_code_type==EVMCodeType.EOF_V1</code>, the bytecode will be automatically wrapped in an EOF V1 container.</p> <p>Code wrapping might fail in the following circumstances:</p> <ul> <li>The code contains invalid EOF V1 opcodes.</li> <li>The code does not end with a valid EOF V1 terminating opcode (such as <code>Op.STOP</code> or <code>Op.REVERT</code> or <code>Op.RETURN</code>).</li> </ul> <p>In the case where the code wrapping fails, <code>evm_code_type</code> can be added as a parameter to the test and the bytecode can be dynamically modified to be compatible with the EOF V1 container.</p> <p>One thing to note is that <code>evm_code_type</code> is not necessary to be added as a parameter to the test because the <code>pre: Alloc</code> fixture automatically consumes this fixture, and therefore it only needs to be added to the test signature if the test's logic needs it.</p> <pre><code>import pytest\n\nfrom ethereum_test_tools import Alloc, StateTestFiller\nfrom ethereum_test_vm import EVMCodeType\nfrom ethereum_test_vm import Opcodes as Op\n\n@pytest.mark.with_all_evm_code_types\n@pytest.mark.valid_from(\"Frontier\")\ndef test_something_with_all_evm_code_types(\n    state_test: StateTestFiller,\n    pre: Alloc,\n    evm_code_type: EVMCodeType\n):\n    code = Op.SSTORE(1, 1)\n    if evm_code_type == EVMCodeType.EOF_V1:\n        # Modify the bytecode to be compatible with EOF V1 container\n        code += Op.STOP\n    pre.deploy_contract(code)\n    ...\n</code></pre>"},{"location":"writing_tests/test_markers/#pytestmarkwith_all_call_opcodes","title":"<code>@pytest.mark.with_all_call_opcodes</code>","text":"<p>This marker is used to automatically parameterize a test with all EVM call opcodes that are valid for the fork being tested.</p> <pre><code>import pytest\n\nfrom ethereum_test_tools import Alloc, StateTestFiller\nfrom ethereum_test_vm import Opcodes as Op\n\n@pytest.mark.with_all_call_opcodes\n@pytest.mark.valid_from(\"Frontier\")\ndef test_something_with_all_call_opcodes(\n    state_test: StateTestFiller,\n    pre: Alloc,\n    call_opcode: Op\n):\n    pass\n</code></pre> <p>In this example, the test will be parametrized for parameter <code>call_opcode</code> with values <code>[Op.CALL, Op.CALLCODE]</code> starting on fork Frontier, <code>[Op.CALL, Op.CALLCODE, Op.DELEGATECALL]</code> on fork Homestead, <code>[Op.CALL, Op.CALLCODE, Op.DELEGATECALL, Op.STATICCALL]</code> on fork Byzantium, and eventually it will be parametrized with with values <code>[Op.CALL, Op.CALLCODE, Op.DELEGATECALL, Op.STATICCALL, Op.EXTCALL, Op.EXTSTATICCALL, Op.EXTDELEGATECALL]</code> on the EOF activation fork.</p> <p>Parameter <code>evm_code_type</code> will also be parametrized with the correct EVM code type for the opcode under test.</p>"},{"location":"writing_tests/test_markers/#pytestmarkwith_all_create_opcodes","title":"<code>@pytest.mark.with_all_create_opcodes</code>","text":"<p>This marker is used to automatically parameterize a test with all EVM create opcodes that are valid for the fork being tested.</p> <pre><code>import pytest\n\nfrom ethereum_test_tools import Alloc, StateTestFiller\nfrom ethereum_test_vm import Opcodes as Op\n\n@pytest.mark.with_all_create_opcodes\n@pytest.mark.valid_from(\"Frontier\")\ndef test_something_with_all_create_opcodes(\n    state_test: StateTestFiller,\n    pre: Alloc,\n    create_opcode: Op\n):\n    pass\n</code></pre> <p>In this example, the test will be parametrized for parameter <code>create_opcode</code> with values <code>[Op.CREATE]</code> starting on fork Frontier, <code>[Op.CREATE, Op.CREATE2]</code> starting on fork Constantinople, and eventually it will be parametrized with with values <code>[Op.CREATE, Op.CREATE2, Op.EOFCREATE]</code> on the EOF activation fork.</p> <p>Parameter <code>evm_code_type</code> will also be parametrized with the correct EVM code type for the opcode under test.</p>"},{"location":"writing_tests/test_markers/#pytestmarkwith_all_system_contracts","title":"<code>@pytest.mark.with_all_system_contracts</code>","text":"<p>This marker is used to automatically parameterize a test with all system contracts that are valid for the fork being tested.</p> <pre><code>import pytest\n\nfrom ethereum_test_tools import Alloc, StateTestFiller\nfrom ethereum_test_base_types import Address\n\n@pytest.mark.with_all_system_contracts\n@pytest.mark.valid_from(\"Cancun\")\ndef test_something_with_all_system_contracts(\n    state_test: StateTestFiller,\n    pre: Alloc,\n    system_contract: Address,\n):\n    pass\n</code></pre> <p>In this example, the test will be parameterized for parameter <code>system_contract</code> with value <code>[0x000F3DF6D732807EF1319FB7B8BB8522D0BEAC02]</code> for fork Cancun.</p>"},{"location":"writing_tests/test_markers/#covariant-marker-keyword-arguments","title":"Covariant Marker Keyword Arguments","text":"<p>All fork covariant markers accept the following keyword arguments:</p>"},{"location":"writing_tests/test_markers/#selector","title":"<code>selector</code>","text":"<p>A lambda function that can be used to filter the fork covariant values that are valid for this specific test.</p> <pre><code>import pytest\n\nfrom ethereum_test_tools import Alloc, StateTestFiller\n\n@pytest.mark.with_all_tx_types(selector=lambda tx_type: tx_type != 2)\n@pytest.mark.valid_from(\"London\")\ndef test_something_with_all_tx_types(\n    state_test: StateTestFiller, \n    pre: Alloc,\n    tx_type: int\n):\n    pass\n</code></pre> <p>Ideally, the lambda function should be used to explicitly filter out values that are not compatible with the test (exclusive filter), rather than explicitly selecting values (inclusive filter), as the parametrized values might change with future forks.</p>"},{"location":"writing_tests/test_markers/#marks","title":"<code>marks</code>","text":"<p>A marker, list of markers, or a lambda function that can be used to add additional markers to the test.</p> <pre><code>import pytest\n\n@pytest.mark.with_all_tx_types(\n    marks=lambda tx_type: pytest.mark.skip(\"incompatible\") if tx_type == 1 else None,\n)\n@pytest.mark.valid_from(\"London\")\ndef test_something_with_all_tx_types_but_skip_type_1(state_test_only, tx_type):\n    assert tx_type != 1\n    ...\n</code></pre> <p>In this example, the test will be skipped if <code>tx_type</code> is equal to 1 by returning a <code>pytest.mark.skip</code> marker, and return <code>None</code> otherwise.</p>"},{"location":"writing_tests/test_markers/#pytestmarkparametrize_by_fork","title":"<code>@pytest.mark.parametrize_by_fork</code>","text":"<p>A test can be dynamically parametrized based on the fork using the <code>parametrize_by_fork</code> marker.</p> <p>This marker takes two positional arguments:</p> <ul> <li><code>argnames</code>: A list of parameter names that will be parametrized using the custom function.</li> <li><code>fn</code>: A function that takes the fork as parameter and returns a list of values that will be used to parametrize the test at that specific fork.</li> </ul> <p>And one keyword argument:</p> <ul> <li><code>marks</code> (optional): A marker, list of markers, or a lambda function that can be used to add additional markers to the generated tests.</li> </ul> <p>The marked test function will be parametrized by the values returned by the <code>fn</code> function for each fork.</p> <p>If the parameters that are being parametrized is only a single parameter, the return value of <code>fn</code> should be a list of values for that parameter.</p> <p>If the parameters that are being parametrized are multiple, the return value of <code>fn</code> should be a list of tuples/lists, where each tuple contains the values for each parameter.</p> <pre><code>import pytest\n\ndef covariant_function(fork):\n    return [[1, 2], [3, 4]] if fork.name() == \"Paris\" else [[4, 5], [5, 6], [6, 7]]\n\n@pytest.mark.parametrize_by_fork(\"test_parameter,test_parameter_2\", covariant_function)\n@pytest.mark.valid_from(\"Paris\")\n@pytest.mark.valid_until(\"Shanghai\")\ndef test_case(state_test_only, test_parameter, test_parameter_2):\n    pass\n</code></pre> <p>In this example, the test will be parametrized with the values <code>[1, 2]</code> and <code>[3, 4]</code> for the Paris fork, with values <code>1</code> and <code>3</code> being assigned to <code>test_parameter</code> and <code>2</code> and <code>4</code> being assigned to <code>test_parameter_2</code>. For the Shanghai fork, the test will be parametrized with the values <code>[4, 5]</code>, <code>[5, 6]</code>, and <code>[6, 7]</code>. Therefore, more test cases will be generated for the Shanghai fork.</p> <p>If the parameters that are being parametrized is only a single parameter, the return value of <code>fn</code> should be a list of values for that parameter.</p> <p>If the parameters that are being parametrized are multiple, the return value of <code>fn</code> should be a list of tuples/lists, where each tuple contains the values for each parameter.</p> <p>The function can also return a list of <code>pytest.param</code> objects, which allows for additional markers and test IDs to be added to the test.</p>"},{"location":"writing_tests/test_markers/#fillexecute-markers","title":"Fill/Execute Markers","text":"<p>These markers are used to apply different markers to a test depending on whether it is being filled or executed.</p>"},{"location":"writing_tests/test_markers/#pytestmarkfill","title":"<code>@pytest.mark.fill</code>","text":"<p>This marker is used to apply markers to a test when it is being filled.</p> <pre><code>import pytest\n\nfrom ethereum_test_tools import Alloc, StateTestFiller\n\n@pytest.mark.fill(pytest.mark.skip(reason=\"Only for execution\"))\ndef test_something(\n    state_test: StateTestFiller, \n    pre: Alloc\n):\n    pass\n</code></pre> <p>In this example, the test will be skipped when it is being filled.</p>"},{"location":"writing_tests/test_markers/#pytestmarkexecute","title":"<code>@pytest.mark.execute</code>","text":"<p>This marker is used to apply markers to a test when it is being executed.</p> <pre><code>import pytest\n\nfrom ethereum_test_tools import Alloc, StateTestFiller\n\n@pytest.mark.execute(pytest.mark.xfail(reason=\"Depends on block context\"))\ndef test_something(\n    state_test: StateTestFiller, \n    pre: Alloc\n):\n    pass\n</code></pre> <p>In this example, the test will be marked as expected to fail when it is being executed, which is particularly useful so that the test is still executed but does not fail the test run.</p>"},{"location":"writing_tests/test_markers/#other-markers","title":"Other Markers","text":""},{"location":"writing_tests/test_markers/#pytestmarkslow","title":"<code>@pytest.mark.slow</code>","text":"<p>This marker is used to mark tests that are slow to run. These tests are not run during <code>tox</code> checks, and are only run when a release is being prepared.</p>"},{"location":"writing_tests/test_markers/#pytestmarkpre_alloc_modify","title":"<code>@pytest.mark.pre_alloc_modify</code>","text":"<p>This marker is used to mark tests that modify the pre-alloc in a way that would be impractical to reproduce in a real-world scenario.</p> <p>Examples of this include:</p> <ul> <li>Modifying the pre-alloc to have a balance of 2^256 - 1.</li> <li>Address collisions that would require hash collisions.</li> </ul>"},{"location":"writing_tests/test_markers/#pytestmarkskip","title":"<code>@pytest.mark.skip()</code>","text":"<p>This marker can be used to skip a test.</p> <pre><code>import pytest\n\nfrom ethereum_test_tools import Alloc, StateTestFiller\n\n@pytest.mark.skip(reason=\"Not implemented\")\ndef test_something(state_test: StateTestFiller, pre: Alloc):\n    pass\n</code></pre>"},{"location":"writing_tests/test_markers/#pytestmarkxfail","title":"<code>@pytest.mark.xfail()</code>","text":"<p>This marker can be used to mark a test as expected to fail.</p> <pre><code>import pytest\n\nfrom ethereum_test_tools import Alloc, StateTestFiller\n\n@pytest.mark.xfail(reason=\"EVM binary doesn't support this opcode\")\ndef test_something(state_test: StateTestFiller, pre: Alloc):\n    pass\n</code></pre>"},{"location":"writing_tests/types_of_tests/","title":"Types of tests","text":"<p>There are currently three types of tests that can be produced by a test spec:</p> <ol> <li>State Tests</li> <li>Blockchain Tests</li> <li>Transaction Tests</li> </ol>"},{"location":"writing_tests/types_of_tests/#state-tests","title":"State Tests","text":""},{"location":"writing_tests/types_of_tests/#purpose","title":"Purpose","text":"<p>Tests the effects of individual transactions (ideally a single one) that span a single block in a controlled environment.</p>"},{"location":"writing_tests/types_of_tests/#use-cases","title":"Use cases","text":"<ul> <li>Test a single opcode behavior.</li> <li>Verify opcode gas costs.</li> <li>Test interactions between multiple smart contracts.</li> <li>Test creation of smart contracts.</li> </ul> <p>Info</p> <p>The fill function will automatically generate a <code>blockchain_test</code> fixture from <code>state_tests</code>, consisting of one block and one transaction.</p>"},{"location":"writing_tests/types_of_tests/#blockchain-tests","title":"Blockchain Tests","text":""},{"location":"writing_tests/types_of_tests/#purpose_1","title":"Purpose","text":"<p>Blockchain tests span multiple blocks which may or may not contain transactions and mainly focus on the block to block effects to the Ethereum state.</p>"},{"location":"writing_tests/types_of_tests/#use-cases_1","title":"Use cases","text":"<ul> <li>Verify system-level operations such as coinbase balance updates or withdrawals.</li> <li>Verify fork transitions.</li> <li>Verify blocks with invalid transactions/properties are rejected.</li> </ul>"},{"location":"writing_tests/types_of_tests/#fork-transition-tests","title":"Fork Transition Tests","text":"<p>There is a special type of blockchain test that is used to test a fork transition. It's not executed for all possible forks, rather it targets exactly the blocks at the point of transition from one evm implementation to the next. This type of test must be marked with the <code>valid_at_transition_to</code> marker, for example:</p> <pre><code>@pytest.mark.valid_at_transition_to(\"Cancun\")\ndef test_blob_type_tx_pre_fork(\n    blockchain_test: BlockchainTestFiller,\n    pre: Dict,\n    env: Environment,\n    blocks: List[Block],\n):\n    \"\"\"\n    Reject blocks with blobs before blobs fork\n    \"\"\"\n</code></pre>"},{"location":"writing_tests/types_of_tests/#transaction-tests","title":"Transaction Tests","text":""},{"location":"writing_tests/types_of_tests/#purpose_2","title":"Purpose","text":"<p>Test correct transaction rejection/acceptance of a serialized transaction (currently RLP only).</p>"},{"location":"writing_tests/types_of_tests/#use-cases_2","title":"Use cases","text":"<ul> <li>Verify that a badly formatted transaction is correctly rejected by the client.</li> <li>Verify that a transaction with an invalid value in one of its fields is correctly rejected by the client.</li> </ul> <p>Info</p> <p>Using the <code>execute</code> command, transaction tests can be sent to clients in a live network using the <code>eth_sendRawTransaction</code> endpoint.</p>"},{"location":"writing_tests/types_of_tests/#deciding-on-a-test-type","title":"Deciding on a test type","text":""},{"location":"writing_tests/types_of_tests/#prefer-state_test-for-single-transactions","title":"Prefer <code>state_test</code> for single transactions","text":"<p>Whenever possible, use <code>state_test</code> to examine individual transactions. This method is more straightforward and less prone to external influences that can occur during block building.</p> <p>This provides more targeted testing since it does not invoke the client's block-building machinery. This reduces the risk of encountering false positives, particularly in exception scenarios (e.g., see issue #343: \"Zero max_fee_per_blob_gas test is ineffective\").</p> <p>Moreover, the <code>fill</code> command automatically additionally generates a <code>blockchain_test</code> for every <code>state_test</code> by wrapping the <code>state_test</code>'s transaction in a block.</p>"},{"location":"writing_tests/verifying_changes/","title":"Verifying Changes","text":"<p>The <code>tox</code> tool is used by execution-spec-tests to perform various checks on the codebase such as linting, type checking and spell-checking. The <code>tox</code> command can be executed locally to ensure that Github CI checks pass upon pushing to the repository.</p> <p>Using automatic pre-commit checks</p> <p>Some <code>tox</code> environments can be ran as a git pre-commit hook, see Enabling Pre-Commit Checks.</p>"},{"location":"writing_tests/verifying_changes/#running-tox","title":"Running <code>tox</code>","text":""},{"location":"writing_tests/verifying_changes/#execution","title":"Execution","text":"<p>Run all <code>tox</code> environments in parallel with:</p> <pre><code>uvx --with=tox-uv tox run-parallel\n</code></pre> <p>or, with sequential test environment execution and verbose output as:</p> <pre><code>uvx --with=tox-uv tox\n</code></pre> <p>As some environments are rather slow, the next section describes how to run them individually.</p> <p>Tox Virtual Environment</p> <p>The checks performed by <code>tox</code> are sandboxed in their own virtual environments (which are created automatically in the <code>.tox/</code> subdirectory). These can be used to debug errors encountered during <code>tox</code> execution.</p>"},{"location":"writing_tests/verifying_changes/#listing-the-available-environments","title":"Listing the Available Environments","text":"<p>Get a list of all the available <code>tox</code> environments:</p> <pre><code>uvx --with=tox-uv tox -av\n</code></pre>"},{"location":"writing_tests/verifying_changes/#executing-tox-environments-individually","title":"Executing <code>tox</code> Environments Individually","text":"<p>A selection of preferred environments may be executed via the <code>-e</code> flag:</p> <pre><code>uvx --with=tox-uv tox -e lint,typecheck,spellcheck\n</code></pre>"},{"location":"writing_tests/verifying_changes/#environments-required-for-test-case-changes-tests","title":"Environments required for test case changes (<code>./tests/</code>)","text":"<pre><code>uvx --with=tox-uv tox -e lint,typecheck,spellcheck,tests-deployed\n</code></pre>"},{"location":"writing_tests/verifying_changes/#environments-required-for-test-framework-and-library-changes-src","title":"Environments required for test framework and library changes (<code>./src/</code>)","text":"<pre><code>uvx --with=tox-uv tox -e lint,typecheck,spellcheck,pytest\n</code></pre>"},{"location":"writing_tests/verifying_changes/#environment-required-for-documentation-changes-docs","title":"Environment required for documentation changes (<code>./docs/</code>)","text":"<pre><code>uvx --with=tox-uv tox -e spellcheck,markdownlint,mkdocs\n</code></pre>"},{"location":"writing_tests/verifying_changes/#additional-required-dependencies-for-spellcheck-and-markdownlint","title":"Additional Required Dependencies for <code>spellcheck</code> and <code>markdownlint</code>","text":"<p>The <code>spellcheck</code> and <code>markdownlint</code> environments require external (non-python) packages. To avoid disruption to external contributors, these environments run in a \"soft fail\" mode if these dependencies are not available.</p> <p>Additional, optional prerequisites:</p> <ol> <li> <p><code>pyspelling</code>:</p> <pre><code>sudo apt-get install aspell aspell-en\n</code></pre> </li> <li> <p><code>markdownlint-cli2</code>:</p> <pre><code>sudo apt install nodejs\nsudo npm install markdownlint-cli2 --global\n</code></pre> <p>Or use a specific node version using <code>nvm</code>, for example.</p> </li> </ol>"},{"location":"writing_tests/verifying_changes/#verifying-fixture-changes","title":"Verifying Fixture Changes","text":"<p>When writing a PR that modifies either the framework or test cases, it is important to verify that the changes do not cause any issues with the existing test cases.</p> <p>All filled fixtures contain a <code>hash</code> field in the <code>_info</code> object, which is the hash of the json string of the fixture. This hash can be used to verify that the fixture has not changed.</p> <p>The <code>hasher</code> command can be used to bulk-verify the hashes of all fixtures in a directory.</p> <p>It has the following options:</p> Flag Description <code>--files</code> / <code>-f</code> Prints a single combined hash per each JSON fixture file recursively contained in a directory. <code>--tests</code> / <code>-t</code> Prints the hash of every single test vector in every JSON fixture file recursively contained in a directory. <code>--root</code> / <code>-r</code> Prints a single combined hash for all JSON fixture files recursively contained in a directory. <p>For a quick comparison between two fixture directories, the <code>--root</code> option can be used and if the output matches, it means the fixtures in the directories are identical:</p> <pre><code>hasher --root fixtures/\nhasher --root fixtures_new/\n</code></pre> <p>If the output does not match, the <code>--files</code> option can be used to identify which files are different:</p> <pre><code>diff &lt;(hasher --files fixtures/) &lt;(hasher --files fixtures_new/)\n</code></pre> <p>And the <code>--tests</code> option can be used for an even more granular comparison:</p> <pre><code>diff &lt;(hasher --tests fixtures/) &lt;(hasher --tests fixtures_new/)\n</code></pre>"},{"location":"writing_tests/writing_a_new_test/","title":"Writing a New Test","text":""},{"location":"writing_tests/writing_a_new_test/#test-functions","title":"Test Functions","text":"<p>Every test case is defined as a Python function that implements a single <code>StateTest</code> or <code>BlockchainTest</code> using the <code>state_test</code> or <code>blockchain_test</code> objects made available by the framework (learn how to decide on a test type). Test cases, and the respective test modules, must fulfill the following requirements:</p> Requirement When Be decorated with validity markers If the test case is not valid for all forks Use one of <code>state_test</code> or <code>blockchain_test</code> in its function arguments Always Call the <code>state_test</code> or <code>blockchain_test</code> in its test body Always Add a reference version of the EIP spec under test Test path contains <code>eip</code>"},{"location":"writing_tests/writing_a_new_test/#specifying-which-forks-tests-are-valid-for","title":"Specifying which Forks Tests are Valid For","text":"<p>Test cases can (and it most cases should) be decorated with one or more \"validity markers\" that define which the forks the test is valid for. This is achieved by applying:</p> <ul> <li><code>pytest.mark.valid_from(FORK)</code> and/or <code>pytest.mark.valid_until(FORK)</code></li> </ul> <p>or</p> <ul> <li><code>pytest.mark.valid_at_transition_to(FORK)</code></li> </ul> <p>markers on either the test function, test class or test module level:</p> FunctionClassModule <pre><code>import pytest\n\n@pytest.mark.valid_from(\"Berlin\")\n@pytest.mark.valid_until(\"London\")\ndef test_access_list(state_test: StateTestFiller, fork: Fork):\n</code></pre> <pre><code>import pytest\n\n\n@pytest.mark.valid_from(\"Shanghai\")\nclass TestMultipleWithdrawalsSameAddress:\n</code></pre> <pre><code>import pytest\n\npytestmark = pytest.mark.valid_from(\"Shanghai\")\n</code></pre> <p>The <code>ethereum_test_forks</code> package defines the available forks and provides the following helpers that return all forks within the specified range:</p> <ul> <li>forks_from</li> <li>forks_from_until</li> </ul>"},{"location":"writing_tests/writing_a_new_test/#the-state_test-and-blockchain_test-test-function-arguments","title":"The <code>state_test</code> and <code>blockchain_test</code> Test Function Arguments","text":"<p>The test function's signature must contain exactly one of either a <code>state_test</code> or <code>blockchain_test</code> argument.</p> <p>For example, for state tests:</p> <pre><code>def test_access_list(state_test: StateTestFiller):\n</code></pre> <p>and for blockchain tests:</p> <pre><code>def test_contract_creating_tx(\n    blockchain_test: BlockchainTestFiller, fork: Fork, initcode: Initcode\n):\n</code></pre> <p>The <code>state_test</code> and <code>blockchain_test</code> objects are actually wrapper classes to the <code>StateTest</code>, respectively <code>BlockchainTest</code> objects, that once called actually instantiate a new instance of these objects and fill the test case using the <code>evm</code> tool according to the pre and post states and the transactions defined within the test.</p> <p>If a blockchain-type test should only generate a test fixture in the Engine format (<code>EngineFixture</code>), the <code>blockchain_test_engine</code> object can be specified. This object is a wrapper for the <code>BlockchainTestEngine</code> class.</p>"},{"location":"writing_tests/writing_a_new_test/#statetest-object","title":"<code>StateTest</code> Object","text":"<p>The <code>StateTest</code> object represents a single test vector, and contains the following attributes:</p> <ul> <li><code>env</code>: Environment object which describes the global state of the blockchain     before the test starts.</li> <li><code>pre</code>: Pre-State containing the information of all Ethereum accounts that exist     before any transaction is executed.</li> <li><code>post</code>: Post-State containing the information of all Ethereum accounts that are     created or modified after all transactions are executed.</li> <li><code>txs</code>: All transactions to be executed during test execution.</li> </ul>"},{"location":"writing_tests/writing_a_new_test/#blockchaintest-object","title":"<code>BlockchainTest</code> Object","text":"<p>The <code>BlockchainTest</code> object represents a single test vector that evaluates the Ethereum VM by attempting to append multiple blocks to the chain:</p> <ul> <li><code>pre</code>: Pre-State containing the information of all Ethereum accounts that exist     before any block is executed.</li> <li><code>post</code>: Post-State containing the information of all Ethereum accounts that are     created or modified after all blocks are executed.</li> <li><code>blocks</code>: All blocks to be appended to the blockchain during the test.</li> </ul>"},{"location":"writing_tests/writing_a_new_test/#blockchaintestengine-object","title":"<code>BlockchainTestEngine</code> Object","text":"<p>The <code>BlockchainTestEngine</code> object has the same properties as the <code>BlockchainTest</code> but it's used to only generate a blockchain test in the Engine format.</p>"},{"location":"writing_tests/writing_a_new_test/#prepost-state-of-the-test","title":"Pre/Post State of the Test","text":"<p>The <code>pre</code> and <code>post</code> states are elemental to setup and then verify the outcome of the state test.</p> <p>Both <code>pre</code> and <code>post</code> are mappings of account addresses to <code>account</code> structures (see more info).</p> <p>A single test vector can contain as many accounts in the <code>pre</code> and <code>post</code> states as required, and they can be also filled dynamically.</p> <p><code>storage</code> of an account is a key/value dictionary, and its values are integers within range of <code>[0, 2**256 - 1]</code>.</p> <p><code>txs</code> are the steps which transform the pre-state into the post-state and must perform specific actions within the accounts (smart contracts) that result in verifiable changes to the balance, nonce, and/or storage in each of them.</p> <p><code>post</code> is compared against the outcome of the client after the execution of each transaction, and any differences are considered a failure</p> <p>When designing a test, all the changes must be ideally saved into the contract's storage to be able to verify them in the post-state.</p>"},{"location":"writing_tests/writing_a_new_test/#test-transactions","title":"Test Transactions","text":"<p>Transactions can be crafted by sending them with specific <code>data</code> or to a specific account, which contains the code to be executed.</p> <p>Transactions can also create more accounts, by setting the <code>to</code> field to an empty string.</p> <p>Transactions can be designed to fail, and a verification must be made that the transaction fails with the specific error that matches what is expected by the test.</p> <p>They can also contain a <code>TransactionReceipt</code> object in field <code>expected_receipt</code> which allows checking for an exact <code>gas_used</code> value.</p>"},{"location":"writing_tests/writing_a_new_test/#writing-code-for-the-accounts-in-the-test","title":"Writing code for the accounts in the test","text":"<p>Account bytecode can be embedded in the test accounts by adding it to the <code>code</code> field of the <code>account</code> object, or the <code>data</code> field of the <code>tx</code> object if the bytecode is meant to be treated as init code or call data.</p> <p>The code can be in either of the following formats:</p> <ul> <li><code>bytes</code> object, representing the raw opcodes in binary format.</li> <li><code>str</code>, representing an hexadecimal format of the opcodes.</li> <li><code>Code</code> compilable object.</li> </ul> <p>Currently supported built-in compilable objects are:</p> <ul> <li><code>Yul</code> object containing Yul source code.</li> </ul> <p><code>Code</code> objects can be concatenated together by using the <code>+</code> operator.</p>"},{"location":"writing_tests/writing_a_new_test/#verifying-the-accounts-post-states","title":"Verifying the Accounts' Post States","text":"<p>The state of the accounts after all blocks/transactions have been executed is the way of verifying that the execution client actually behaves like the test expects.</p> <p>During their filling process, all tests automatically verify that the accounts specified in their <code>post</code> property actually match what was returned by the transition tool.</p> <p>Within the <code>post</code> dictionary object, an account address can be:</p> <ul> <li><code>None</code>: The account will not be checked for absence or existence in the   result returned by the transition tool.</li> <li><code>Account</code> object: The test expects that this account exists and also has   properties equal to the properties specified by the <code>Account</code> object.</li> <li><code>Account.NONEXISTENT</code>: The test expects that this account does not exist in   the result returned by the transition tool, and if the account exists,   it results in error.   E.g. when the transaction creating a contract is expected to fail and the   test wants to verify that the address where the contract was supposed to be   created is indeed empty.</li> </ul>"},{"location":"writing_tests/writing_a_new_test/#the-account-object","title":"The <code>Account</code> object","text":"<p>The <code>Account</code> object is used to specify the properties of an account to be verified in the post state.</p> <p>The python representation can be found in src/ethereum_test_types/types.py.</p> <p>It can verify the following properties of an account:</p> <ul> <li> <p><code>nonce</code>: the scalar value equal to a) the number of transactions sent by   an Externally Owned Account, b) the amount of contracts created by a contract.</p> </li> <li> <p><code>balance</code>: the amount of Wei (10<sup>-18</sup> Eth) the account has.  </p> </li> <li> <p><code>code</code>: Bytecode contained by the account. To verify that an account contains   no code, this property needs to be set to \"0x\" or \"\".</p> </li> </ul> <p>It is not recommended to verify Yul compiled code in the output account,   because the bytecode can change from version to version.</p> <ul> <li><code>storage</code>: Storage within the account represented as a <code>dict</code> object.   All storage keys that are expected to be set must be specified, and if a   key is skipped, it is implied that its expected value is zero.   Setting this property to <code>{}</code> (empty <code>dict</code>), means that all the keys in the   account must be unset (equal to zero).</li> </ul> <p>All account's properties are optional, and they can be skipped or set to <code>None</code>, which means that no check will be performed on that specific account property.</p>"},{"location":"writing_tests/writing_a_new_test/#verifying-correctness-of-the-new-test","title":"Verifying correctness of the new test","text":"<p>A well written test performs a single verification output at a time.</p> <p>A verification output can be a single storage slot, the balance of an account, or a newly created contract.</p> <p>It is not recommended to use balance changes to verify test correctness, as it can be easily affected by gas cost changes in future EIPs.</p> <p>The best way to verify a transaction/block execution outcome is to check its storage.</p> <p>A test can be written as a negative verification. E.g. a contract is not created, or a transaction fails to execute or runs out of gas.</p> <p>This kind of verification must be carefully crafted because it is possible to end up having a false positive result, which means that the test passed but the intended verification was never made.</p> <p>To avoid these scenarios, it is important to have a separate verification to check that test is effective. E.g. when a transaction is supposed to fail, it is necessary to check that the failure error is actually the one expected by the test.</p>"},{"location":"writing_tests/writing_a_new_test/#failing-or-invalid-transactions","title":"Failing or invalid transactions","text":"<p>Transactions included in a StateTest are expected to be intrinsically valid, i.e. the account sending the transaction must have enough funds to cover the gas costs, the max fee of the transaction must be equal or higher than the base fee of the block, etc.</p> <p>An intrinsically valid transaction can still revert during its execution.</p> <p>Blocks in a BlockchainTest can contain intrinsically invalid transactions but in this case the block is expected to be completely rejected, along with all transactions in it, including other valid transactions.</p>"},{"location":"writing_tests/writing_a_new_test/#parametrizing-tests","title":"Parametrizing tests","text":"<p>Tests can be parametrized by using the <code>@pytest.mark.parametrize</code> decorator.</p> <p>Example:</p> <pre><code>import pytest\n\n@pytest.mark.parametrize(\n    \"tx_value,expected_balance\",\n    [\n        pytest.param(0, 0, id=\"zero-value\"),\n        pytest.param(100, 100, id=\"non-zero-value\"),\n    ],\n)\ndef test_contract_creating_tx(\n    blockchain_test: BlockchainTestFiller, fork: Fork, tx_value: int, expected_balance: int\n):\n</code></pre> <p>This will run the test twice, once with <code>tx_value</code> set to <code>0</code> and <code>expected_balance</code> set to <code>0</code>, and once with <code>tx_value</code> set to <code>100</code> and <code>expected_balance</code> set to <code>100</code>.</p> <p>The <code>fork</code> fixture is automatically provided by the framework and contains the current fork under test, and does not need to be parametrized.</p> <p>Tests can also be automatically parametrized with appropriate fork covariant values using the <code>with_all_*</code> markers listed in the Test Markers page.</p>"},{"location":"writing_tests/writing_a_new_test/#the-extend_with_defaults-utility","title":"The <code>extend_with_defaults</code> Utility","text":"<p>Extend test cases with default parameter values.</p> <p>This utility function extends test case parameters by adding default values from the <code>defaults</code> dictionary to each case in the <code>cases</code> list. If a case already specifies a value for a parameter, its default is ignored.</p> <p>This function is particularly useful in scenarios where you want to define a common set of default values but allow individual test cases to override them as needed.</p> <p>The function returns a dictionary that can be directly unpacked and passed to the <code>@pytest.mark.parametrize</code> decorator.</p> <p>Parameters:</p> Name Type Description Default <code>defaults</code> <code>Dict[str, Any]</code> <p>A dictionary of default parameter names and their values. These values will be added to each case unless the case already defines a value for each parameter.</p> required <code>cases</code> <code>List[ParameterSet]</code> <p>A list of <code>pytest.param</code> objects representing different test cases. Its first argument must be a dictionary defining parameter names and values.</p> required <code>parametrize_kwargs</code> <code>Any</code> <p>Additional keyword arguments to be passed to <code>@pytest.mark.parametrize</code>. These arguments are not modified by this function and are passed through unchanged.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary with the following structure: <code>argnames</code>: A list of parameter names. <code>argvalues</code>: A list of test cases with modified parameter values. <code>parametrize_kwargs</code>: Additional keyword arguments passed through unchanged.</p> Example <pre><code>@pytest.mark.parametrize(**extend_with_defaults(\n    defaults=dict(\n        min_value=0,  # default minimum value is 0\n        max_value=100,  # default maximum value is 100\n        average=50,  # default average value is 50\n    ),\n    cases=[\n        pytest.param(\n            dict(),  # use default values\n            id='default_case',\n        ),\n        pytest.param(\n            dict(min_value=10),  # override with min_value=10\n            id='min_value_10',\n        ),\n        pytest.param(\n            dict(max_value=200),  # override with max_value=200\n            id='max_value_200',\n        ),\n        pytest.param(\n            dict(min_value=-10, max_value=50),  # override both min_value\n            # and max_value\n            id='min_-10_max_50',\n        ),\n        pytest.param(\n            dict(min_value=20, max_value=80, average=50),  # all defaults\n            # are overridden\n            id=\"min_20_max_80_avg_50\",\n        ),\n        pytest.param(\n            dict(min_value=100, max_value=0),  # invalid range\n            id='invalid_range',\n            marks=pytest.mark.xfail(reason='invalid range'),\n        )\n    ],\n))\ndef test_range(min_value, max_value, average):\n    assert min_value &lt;= max_value\n    assert min_value &lt;= average &lt;= max_value\n</code></pre> <p>The above test will execute with the following sets of parameters:</p> <pre><code>\"default_case\": {\"min_value\": 0, \"max_value\": 100, \"average\": 50}\n\"min_value_10\": {\"min_value\": 10, \"max_value\": 100, \"average\": 50}\n\"max_value_200\": {\"min_value\": 0, \"max_value\": 200, \"average\": 50}\n\"min_-10_max_50\": {\"min_value\": -10, \"max_value\": 50, \"average\": 50}\n\"min_20_max_80_avg_50\": {\"min_value\": 20, \"max_value\": 80, \"average\": 50}\n\"invalid_range\": {\"min_value\": 100, \"max_value\": 0, \"average\": 50}  # expected to fail\n</code></pre> Notes <ul> <li>Each case in <code>cases</code> must contain exactly one value, which is a dictionary   of parameter values.</li> <li>The function performs an in-place update of the <code>cases</code> list, so the   original <code>cases</code> list is modified.</li> </ul> Source code in <code>src/ethereum_test_tools/utility/pytest.py</code> <pre><code>def extend_with_defaults(\n    defaults: Dict[str, Any], cases: List[ParameterSet], **parametrize_kwargs: Any\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Extend test cases with default parameter values.\n\n    This utility function extends test case parameters by adding default values\n    from the `defaults` dictionary to each case in the `cases` list. If a case\n    already specifies a value for a parameter, its default is ignored.\n\n    This function is particularly useful in scenarios where you want to define\n    a common set of default values but allow individual test cases to override\n    them as needed.\n\n    The function returns a dictionary that can be directly unpacked and passed\n    to the `@pytest.mark.parametrize` decorator.\n\n    Args:\n        defaults (Dict[str, Any]): A dictionary of default parameter names and\n            their values. These values will be added to each case unless the case\n            already defines a value for each parameter.\n        cases (List[ParameterSet]): A list of `pytest.param` objects representing\n            different test cases. Its first argument must be a dictionary defining\n            parameter names and values.\n        parametrize_kwargs (Any): Additional keyword arguments to be passed to\n            `@pytest.mark.parametrize`. These arguments are not modified by this\n            function and are passed through unchanged.\n\n    Returns:\n        Dict[str, Any]: A dictionary with the following structure:\n            `argnames`: A list of parameter names.\n            `argvalues`: A list of test cases with modified parameter values.\n            `parametrize_kwargs`: Additional keyword arguments passed through unchanged.\n\n\n    Example:\n        ```python\n        @pytest.mark.parametrize(**extend_with_defaults(\n            defaults=dict(\n                min_value=0,  # default minimum value is 0\n                max_value=100,  # default maximum value is 100\n                average=50,  # default average value is 50\n            ),\n            cases=[\n                pytest.param(\n                    dict(),  # use default values\n                    id='default_case',\n                ),\n                pytest.param(\n                    dict(min_value=10),  # override with min_value=10\n                    id='min_value_10',\n                ),\n                pytest.param(\n                    dict(max_value=200),  # override with max_value=200\n                    id='max_value_200',\n                ),\n                pytest.param(\n                    dict(min_value=-10, max_value=50),  # override both min_value\n                    # and max_value\n                    id='min_-10_max_50',\n                ),\n                pytest.param(\n                    dict(min_value=20, max_value=80, average=50),  # all defaults\n                    # are overridden\n                    id=\"min_20_max_80_avg_50\",\n                ),\n                pytest.param(\n                    dict(min_value=100, max_value=0),  # invalid range\n                    id='invalid_range',\n                    marks=pytest.mark.xfail(reason='invalid range'),\n                )\n            ],\n        ))\n        def test_range(min_value, max_value, average):\n            assert min_value &lt;= max_value\n            assert min_value &lt;= average &lt;= max_value\n        ```\n\n    The above test will execute with the following sets of parameters:\n\n    ```python\n    \"default_case\": {\"min_value\": 0, \"max_value\": 100, \"average\": 50}\n    \"min_value_10\": {\"min_value\": 10, \"max_value\": 100, \"average\": 50}\n    \"max_value_200\": {\"min_value\": 0, \"max_value\": 200, \"average\": 50}\n    \"min_-10_max_50\": {\"min_value\": -10, \"max_value\": 50, \"average\": 50}\n    \"min_20_max_80_avg_50\": {\"min_value\": 20, \"max_value\": 80, \"average\": 50}\n    \"invalid_range\": {\"min_value\": 100, \"max_value\": 0, \"average\": 50}  # expected to fail\n    ```\n\n    Notes:\n        - Each case in `cases` must contain exactly one value, which is a dictionary\n          of parameter values.\n        - The function performs an in-place update of the `cases` list, so the\n          original `cases` list is modified.\n\n    \"\"\"\n    for i, case in enumerate(cases):\n        if not (len(case.values) == 1 and isinstance(case.values[0], dict)):\n            raise ValueError(\n                \"each case must contain exactly one value; a dict of parameter values\"\n            )\n        if set(case.values[0].keys()) - set(defaults.keys()):\n            raise UnknownParameterInCasesError()\n        # Overwrite values in defaults if the parameter is present in the test case values\n        merged_params = {**defaults, **case.values[0]}  # type: ignore\n        cases[i] = pytest.param(*merged_params.values(), id=case.id, marks=case.marks)\n\n    return {\"argnames\": list(defaults), \"argvalues\": cases, **parametrize_kwargs}\n</code></pre>"},{"location":"writing_tests/tutorials/blockchain/","title":"Blockchain Tests","text":"<p>This tutorial teaches you to create a blockchain execution specification test. These tests verify that a blockchain, starting from a defined pre-state, will process given blocks and arrive at a defined post-state.</p>"},{"location":"writing_tests/tutorials/blockchain/#pre-requisites","title":"Pre-requisites","text":"<p>Before proceeding with this tutorial, it is assumed that you have prior knowledge and experience with the following:</p> <ul> <li>Repository set-up, see installation.and run an execution specification test as outlined in the .</li> <li>Able to run <code>fill</code>, see Getting Started: Filling Tests.</li> <li>Understand how to read a blockchain test.</li> <li>Know the basics of Yul, which is an EVM assembly language.</li> <li>Familiarity with Python.</li> <li>Understand how to write an execution spec state transition test.</li> </ul>"},{"location":"writing_tests/tutorials/blockchain/#example-tests","title":"Example Tests","text":"<p>In this tutorial we will go over [test_block_number] in <code>test_block_example.py</code>(https://github.com/ethereum/execution-spec-tests/tree/main/tests/example/test_block_example.py#L19).</p> <p>It is assumed you have already gone through the state transition test tutorial. Only new concepts will be discussed.</p>"},{"location":"writing_tests/tutorials/blockchain/#smart-contract","title":"Smart Contract","text":"<p>A smart contract is defined that is called by each transaction in the test. It stores a pointer to storage at <code>storage[0]</code>. When it is called storage cell <code>0</code> gets the current block number, and the pointer is incremented to the next value.</p> <pre><code>contract_addr: Account(\n    balance=1000000000000000000000,\n    code=Yul(\n        \"\"\"\n        {\n            let next_slot := sload(0)\n            sstore(next_slot, number())\n            sstore(0, add(next_slot, 1))\n        }\n        \"\"\"\n    ),\n    storage={\n        0x00: 0x01,\n    },\n),\n</code></pre>"},{"location":"writing_tests/tutorials/blockchain/#transaction-generator","title":"Transaction Generator","text":"<p>The transactions used in this test are nearly identical. Their only difference is the <code>nonce</code> value which needs to be incremented.</p> <pre><code>def tx_generator():\n    nonce = 0  # Initial value\n    while True:\n        tx = Transaction(\n            ty=0x0,\n            chain_id=0x0,\n            nonce=nonce,\n            to=contractAddr,\n            gas_limit=500000,\n            gas_price=10,\n        )\n        nonce = nonce + 1\n        yield tx\n\ntx_generator = tx_generator()\n</code></pre> <p>This looks like an infinite loop but it isn't because this is a generator function. When generator encounters the <code>yield</code> keyword it returns the value and stops execution, keeping a copy of all the local variables, until it is called again. Hence infinite loops inside a generator are not a problem as long as they include <code>yield</code>. This code section is responsible for creating the <code>Transaction</code> object and incrementing the <code>nonce</code>.</p> <p>Every time the function <code>tx_generator()</code> is called, it returns a new generator with a <code>nonce</code> of zero. To increment the <code>nonce</code> we need to use the same generator. We assign this generator to <code>tx_generator</code>.</p>"},{"location":"writing_tests/tutorials/blockchain/#blocks","title":"Blocks","text":"<p>Each integer in the <code>tx_per_block</code> array is the number of transactions in a block. The genesis block is block 0 (no transactions). It follows that we have 2 transactions in block 1, 0 in block two, 4 in block 3, ..., and 50 in block 9.</p> <pre><code>tx_per_block = [2, 0, 4, 8, 0, 0, 20, 1, 50]\n</code></pre> <p>The code section that creates the blocks is a bit complex in this test. For some simpler definitions of Block creation you can browse tests within <code>test_withdrawals.py</code>.</p> <pre><code>blocks = map(\n    lambda len: Block(\n        txs=list(map(lambda x: next(tx_generator), range(len)))\n    ),\n    tx_per_block,\n)\n</code></pre> <p>We use <code>lambda</code> notation to specify short functions. In this case, the function doesn't actually care about its input, it just returns the next transaction from the generator.</p> <pre><code>lambda x: next(tx_generator)\n</code></pre> <p>Python uses <code>range(n)</code> to create a list of numbers from <code>0</code> to <code>n-1</code>. Among other things, it's a simple way to create a list of <code>n</code> values.</p> <pre><code>range(len)\n</code></pre> <p>The <code>map</code> function runs the function (the first parameter) on every element of the list (the second parameter). Putting together what we know, it means that it runs <code>next(tx_generator)</code> <code>len</code> times, giving us <code>len</code> transactions. We then use <code>list</code> to turn the transactions into a list that we can provide as the <code>txs</code> parameter to the <code>Block</code> constructor.</p> <pre><code>list(map(lambda x: next(tx_generator), range(len)))\n</code></pre> <p>The outer <code>lambda</code> function takes an integer, <code>len</code>, and creates a <code>Block</code> object with <code>len</code> transactions. This function is then run on every value of <code>tx_per_block</code> to generate the blocks.</p> <pre><code>blocks = map(\n    lambda len: Block(\n        txs=list of len transactions\n    ),\n    tx_per_block,\n)\n</code></pre> <p>For example, if we had <code>tx_per_block = [0,2,4]</code>, we'd get this result:</p> <pre><code>blocks = [\n    Blocks(txs=[]),\n    Blocks(txs=[next(tx_generator), next(tx_generator)]),\n    Blocks(txs=[next(tx_generator), next(tx_generator), next(tx_generator), next(tx_generator)])        \n]\n</code></pre>"},{"location":"writing_tests/tutorials/blockchain/#post-state","title":"Post State","text":"<p>Recall that storage slot 0 retains the value of the next slot that the block number is written into. It starts at one and is incremented after each transaction. Hence it's the total number of transactions plus 1.</p> <pre><code>storage = {0: sum(tx_per_block) + 1}\n</code></pre> <p>For every block and transaction within the block, we write the block number and increment the next slot number in storage slot 0. As Python lists are 0 indexed, we must increment the block number by 1.</p> <pre><code>next_slot = 1\nfor blocknum in range(len(tx_per_block)):\n    for _ in range(tx_per_block[blocknum]):\n        storage[next_slot] = blocknum + 1\n        next_slot = next_slot + 1\n</code></pre> <p>Now that the expected storage values are calculated, the post state can be defined and yielded within the <code>BlockchainTest</code>, synonymous to the state test example.</p> <pre><code>post = {contract_addr: Account(storage=storage)}\n\nyield BlockchainTest(\n    genesis_environment=env,\n    pre=pre,\n    blocks=blocks,\n    post=post,\n)\n</code></pre> <p>Note that because of the <code>yield</code> we could have multiple tests under the same name.</p>"},{"location":"writing_tests/tutorials/blockchain/#conclusion","title":"Conclusion","text":"<p>At this point you should be able to write blockchain tests.</p>"},{"location":"writing_tests/tutorials/state_transition/","title":"State Transition Tests","text":"<p>This tutorial teaches you to create a state transition execution specification test. These tests verify that a starting pre-state will reach a specified post-state after executing a single transaction.</p>"},{"location":"writing_tests/tutorials/state_transition/#pre-requisites","title":"Pre-requisites","text":"<p>Before proceeding with this tutorial, it is assumed that you have prior knowledge and experience with the following:</p> <ul> <li>Repository set-up, see installation.and run an execution specification test as outlined in the .</li> <li>Able to run <code>fill</code>, see Getting Started: Filling Tests.</li> <li>Understand how to read a static state transition test.</li> <li>Know the basics of Yul, which is an EVM assembly language.</li> <li>Familiarity with Python.</li> </ul>"},{"location":"writing_tests/tutorials/state_transition/#example-tests","title":"Example Tests","text":"<p>The most effective method of learning how to write tests is to study a couple of straightforward examples. In this tutorial we will go over the Yul state test.</p>"},{"location":"writing_tests/tutorials/state_transition/#yul-test","title":"Yul Test","text":"<p>You can find the source code for the Yul test in tests/homestead/yul/test_yul_example.py. It is the spec test equivalent of this static test.</p> <p>Lets examine each section.</p> <pre><code>\"\"\"\nTest Yul Source Code Examples\n\"\"\"\n</code></pre> <p>In Python, multi-line strings are denoted using <code>\"\"\"</code>. As a convention, a file's purpose is often described in the opening string of the file.</p> <pre><code>from ethereum_test_forks import Fork, Frontier, Homestead\nfrom ethereum_test_tools import (\n    Account,\n    Alloc,\n    Environment,\n    StateTestFiller,\n    Transaction,\n    YulCompiler,\n)\n</code></pre> <p>In this snippet the required constants, types and helper functions are imported from <code>ethereum_test_tools</code> and <code>ethereum_test_forks</code>. We will go over these as we come across them.</p> <pre><code>@pytest.mark.valid_from(\"Homestead\")\n</code></pre> <p>In Python this kind of definition is called a decorator. It modifies the action of the function after it. In this case, the decorator is a custom pytest fixture defined by the execution-specs-test framework that specifies that the test is valid for the Homestead fork and all forks after it. The framework will then fill this test case for all forks in the fork range specified by the command-line arguments.</p> <p>Filling the test</p> <p>To fill this test for all the specified forks, we can specify pytest's <code>-k</code> flag that filters test cases by keyword expression:</p> <pre><code>fill -k test_yul\n</code></pre> <p>and to fill it for a specific fork range, we can provide the <code>--from</code> and <code>--until</code> command-line arguments:</p> <pre><code>fill -k test_yul --from London --until Paris\n</code></pre> <pre><code>def test_yul(state_test: StateTestFiller, pre: Alloc, yul: YulCompiler, fork: Fork):\n    \"\"\"\n    Test YUL compiled bytecode.\n    \"\"\"\n</code></pre> <p>This is the format of a Python function. It starts with <code>def &lt;function name&gt;(&lt;parameters&gt;):</code>, and then has indented code for the function. The function definition ends when there is a line that is no longer indented. As with files, by convention functions start with a string that explains what the function does.</p> <p>The <code>state_test</code> function argument</p> <p>This test defines a state test and, as such, must include the <code>state_test</code> in its function arguments. This is a callable object (actually a wrapper class to the <code>StateTest</code>); we will see how it is called later.</p> <p>The <code>pre</code> function argument</p> <p>For all types of tests, it is highly encouraged that we define the <code>pre</code> allocation as a function argument, which will be populated with the pre-state requirements during the execution of the test function (see below).</p> <pre><code>    env = Environment()\n</code></pre> <p>This line specifies that <code>env</code> is an <code>Environment</code> object, and that we just use the default parameters. If necessary we can modify the environment to have different block gas limits, block numbers, etc. In most tests the defaults are good enough.</p> <p>For more information, see the static test documentation.</p>"},{"location":"writing_tests/tutorials/state_transition/#pre-state","title":"Pre State","text":"<p>For every test we need to define the pre-state requirements, so we are certain of what is on the \"blockchain\" before the transaction is executed. It can be used as a dictionary, which is the Python term for an associative array, but the appropriate way to populate it is by using the methods <code>fund_eoa</code>, <code>deploy_contract</code> or <code>fund_address</code> from the <code>Alloc</code> object.</p> <p>In this example we are using the <code>deploy_contract</code> method to deploy a contract to some address available in the pre-state.</p> <pre><code>    contract_address = pre.deploy_contract(\n        code=yul(\n            \"\"\"\n            {\n                function f(a, b) -&gt; c {\n                    c := add(a, b)\n                }\n\n                sstore(0, f(1, 2))\n                return(0, 32)\n            }\n            \"\"\"\n        ),\n        balance=0x0BA1A9CE0BA1A9CE,\n    )\n</code></pre> <p>Specifically we deploy a contract with yul code that adds two numbers and stores the result in storage.</p> <pre><code>            balance=0x0BA1A9CE0BA1A9CE,\n</code></pre> <p>This field is the balance: the amount of Wei that the account has. It usually doesn't matter what its value is in the case of state test contracts.</p> <pre><code>    contract_address = pre.deploy_contract(\n</code></pre> <p>As return value of the <code>deploy_contract</code> method we get the address where the contract was deployed and put it in the <code>contract_address</code> variable, which will later be used in the transaction.</p> <pre><code>        storage={\n            0x00: 0x00,\n        },\n</code></pre> <p>We could also specify a starting storage for the contract, which is done by adding a <code>storage</code> parameter to the <code>deploy_contract</code> method.</p> <pre><code>            code=yul(\n</code></pre> <p>Here we define the Yul code for the contract. It is defined as a multi-line string and starts and ends with curly braces (<code>{ &lt;yul&gt; }</code>).</p> <p>When running the test filler <code>fill</code>, the solidity compiler <code>solc</code> will automatically translate the Yul to EVM opcode at runtime.</p> <p>Note</p> <p>Currently Yul and direct EVM opcode are supported in execution spec tests.</p> <pre><code>                \"\"\"\n                {\n                    function f(a, b) -&gt; c {\n                        c := add(a, b)\n                    }\n                    sstore(0, f(1, 2))\n                    return(0, 32)\n                }\n                \"\"\"\n</code></pre> <p>Within this example test Yul code we have a function definition, and inside it we are using the Yul <code>add</code> instruction. When compiled with <code>solc</code> it translates the instruction directly to the <code>ADD</code> opcode. For further Yul instructions see here. Notice that function is utilized with the Yul <code>sstore</code> instruction, which stores the result of <code>add(1, 2)</code> to the storage address <code>0x00</code>.</p> <p>Generally for execution spec tests the <code>sstore</code> instruction acts as a high-level assertion method to check pre to post-state changes. The test filler achieves this by verifying that the correct value is held within post-state storage, hence we can validate that the Yul code has run successfully.</p> <pre><code>    sender = pre.fund_eoa(amount=0x0BA1A9CE0BA1A9CE)\n</code></pre> <p>In this line we specify that we require a single externally owned account (EOA) with a balance of <code>0x0BA1A9CE0BA1A9CE</code> Wei.</p> <p>The returned object, which includes a private key, an address, and a nonce, is stored in the <code>sender</code> variable and will later be used as the sender of the transaction.</p>"},{"location":"writing_tests/tutorials/state_transition/#transactions","title":"Transactions","text":"<pre><code>    tx = Transaction(\n        ty=0x0,\n        chain_id=0x01,\n        sender=sender,\n        to=contract_address,\n        gas_limit=500000,\n        gas_price=10,\n        protected=False if fork in [Frontier, Homestead] else True,\n    )\n</code></pre> <p>With the pre-state built, we can add a description for the <code>Transaction</code>.</p> <pre><code>            sender=sender,\n</code></pre> <p>We use the sender variable from the pre-state to specify the sender of the transaction, which already has the necessary information to sign the transaction, and also contains the correct <code>nonce</code> for the transaction.</p> <p>The <code>nonce</code> is a protection mechanism to prevent replay attacks, and the current rules of Ethereum require that the nonce of a transaction is equal to the number of transactions sent from the sender's address, starting from zero. This means that the first transaction sent from an address must have a nonce of zero, the second transaction must have a nonce of one, and so on.</p> <p>The <code>nonce</code> field of the <code>sender</code> variable is automatically incremented for us by the <code>Transaction</code> object when the transaction is signed, so if we were to create another transaction with the same sender, the nonce would be incremented by one yet another time.</p> <pre><code>            to=contract_address,\n</code></pre> <p>The <code>to</code> field specifies the address of the contract we want to call and, in this case, it is the address of the contract we deployed earlier.</p> <p>For more information, see the static test documentation</p>"},{"location":"writing_tests/tutorials/state_transition/#post-state","title":"Post State","text":"<pre><code>    post = {\n        contract_address: Account(\n            storage={\n                0x00: 0x03,\n            },\n        ),\n    }\n</code></pre> <p>This is the post-state which is equivalent to <code>expect</code> in static tests, but without the indexes. It is similar to the pre-state, except that we do not need to specify everything, only those accounts and fields we wish to test.</p> <p>In this case, we look at the storage of the contract we called and add to it what we expect to see. In this example storage cell <code>0x00</code> should be <code>0x03</code> as in the pre-state we essentially stored the result of the Yul instruction <code>add(1, 2)</code>.</p>"},{"location":"writing_tests/tutorials/state_transition/#state-test","title":"State Test","text":"<pre><code>    state_test(env=env, pre=pre, post=post, tx=tx)\n</code></pre> <p>This line calls the wrapper to the <code>StateTest</code> object that provides all the objects required (for example, the fork parameter) in order to fill the test, generate the test fixtures and write them to file (by default, <code>./fixtures/&lt;blockchain,state&gt;_tests/example/yul_example/test_yul.json</code>).</p>"},{"location":"writing_tests/tutorials/state_transition/#conclusion","title":"Conclusion","text":"<p>At this point you should be able to state transition tests within a single block.</p>"},{"location":"writing_tests/tutorials/state_transition_bad_opcode/","title":"Bad Opcode Test","text":"<p>The source code for this test is here. We will only go over the parts that are new.</p> <p>We use Python string templates, so we need to import that library.</p> <pre><code>from string import Template\n</code></pre> <p>In this test we need a couple of addresses, so we create them here. Python lets us specify <code>&lt;string&gt;*&lt;number&gt;</code> when we need a string repeated multiple times, which makes for more readable code than <code>0x00...000C0DE</code>.</p> <pre><code>    code_addr = \"0x\" + \"0\"*(40-4) + \"C0DE\"\n    goat_addr = \"0x\" + \"0\"*(40-4) + \"60A7\"\n</code></pre> <p>We create <code>env</code> and <code>tx</code> first because they are constant. This function will <code>yield</code> multiple tests, but always with the same <code>env</code> and <code>tx</code> values.</p> <pre><code>    env = Environment()\n\n    tx = Transaction(\n           .\n           .\n           .\n        )\n</code></pre> <p>Here we create two post states. We will use whichever one is appropriate to the test we create.</p> <pre><code>    post_valid = {\n       code_addr: Account(\n         storage={0x00: 1},\n       ),\n    }\n\n    post_invalid = {\n       code_addr: Account(\n         storage={0x00: 0},\n       ),\n    }\n</code></pre> <p>Here we define a function (<code>opc_valid</code>) inside another function. Python supports this, and it has two advantages:</p> <ul> <li>Avoid namespace pollution by restricting the function to where it is needed.</li> <li>Functions defined inside other functions can use the parameters and local variables of those functions.   In this case, we need to use <code>fork</code>.</li> </ul> <pre><code>    # Check if an Opcode is valid\n    def opc_valid(opc):\n        \"\"\"\n        Return whether opc will be evaluated as valid by the test or not.\n        Note that some opcodes are evaluated as invalid because of the way they act\n        \"\"\"\n</code></pre> <p>This is the syntax for Python comments, <code># &lt;rest of the line&gt;</code>.</p> <pre><code>        # PUSH0 is only valid Shanghai and later\n</code></pre> <p>Opcode 0x5F (<code>PUSH0</code>) is only valid starting with the Shanghai fork. We don't know what will be the fork names after Shanghai, so it is easiest to specify that prior to Shanghai it is invalid. We don't need to worry about forks prior to London because the decorator for this test says it is only valid from London.</p> <pre><code>        if fork in {\"london\", \"paris\"} and opc==0x5F:\n</code></pre> <p>Python has a set data structure. We use this structure when the order of the values are irrelevant, and we just want to be able to check if something is a member or not.</p> <p>Note that <code>if</code> statements are also followed by a colon (<code>:</code>) and the code inside them indented. That is the general Python syntax.</p> <pre><code>            return False\n</code></pre> <p>Boolean values in Python are either <code>True</code> or <code>False</code>.</p> <p>This test works by running an opcode and then does a <code>SSTORE</code>. Opcodes that terminate execution, such as <code>STOP</code> and <code>RETURN</code> also cause the <code>SSTORE</code> not to happen, so they must be treated as invalid. The same is true for <code>JUMP</code>.</p> <pre><code>        # Valid opcodes, but they are terminal, and so cause\n        # the SSTORE not to happen\n        if opc in {0x00, 0xF3, 0xFD, 0xFF}:\n            return False\n\n\n        # Jumps. If you jump to a random location, you skip the SSTORE\n        if opc in {0x56}:\n            return False\n</code></pre> <p>Next we return <code>True</code> for supported opcodes.</p> <pre><code>        # Opcodes that aren't part of a range\n        # 0x20 - SHA3\n        # 0xFA - STATICCALL\n        if opc in {0x20, 0xFA}:\n            return True\n</code></pre> <p>In Python, as in math, you can use <code>a &lt; b &lt; c</code> for <code>a &lt; b and b &lt; c</code>.</p> <pre><code>        # Arithmetic opcodes\n        if 0x01 &lt;= opc &lt;= 0x0b:\n            return True\n\n        .\n        .\n        .\n</code></pre> <p>The last part the function returns <code>False</code>. If we got here, then this is not a valid opcode.</p> <pre><code>        return False\n        # End of opc_valid\n</code></pre> <p>As this is the end of the function, the next code line is no longer indented (compared to the function definition code).</p> <p>This is a <code>for</code> loop. For loops iterate over a sequence, and the <code>range</code> function, in this case, gives us the range 0..255. As with functions and <code>if</code> statements, the <code>for</code> loop has a colon and includes the indented code.</p> <pre><code>    # For every possible opcode\n    for opc in range(256):\n</code></pre> <p>We have two post states. One, <code>post_valid</code>, has the value of <code>1</code> in storage location <code>0</code>. The other, <code>post_invalid</code> has the value of <code>0</code> in storage location <code>0</code>. But <code>SELFDESTRUCT</code> destroys the contract so there is no longer an account at that address. Neither is valid, so we just skip that test case.</p> <pre><code>        # We can't check SELFDESTRUCT using this technique\n        if opc in {0xFF}:\n           continue\n</code></pre> <p>We need the opcode in hexadecimal. The function <code>hex</code> gives us the hexadecimal number in hex. However, it also gives us a <code>0x</code> prefix, which we don't want, so we use a slice to remove the first two characters.</p> <pre><code>        opc_hex = hex(opc)[2:]\n</code></pre> <p>We need <code>opc_hex</code> to be two characters. If the length is only one, prepend a zero.</p> <pre><code>        if len(opc_hex) == 1:\n          opc_hex = \"0\" + opc_hex\n</code></pre> <p>This is a <code>Template</code> string. This means we'll be able to substitute template variables (<code>${&lt;var name&gt;}</code>) with values to produce the actual code.</p> <pre><code>        yul_code = Template(\"\"\"\n        {\n</code></pre> <p>We start with a call <code>0x00...0060A7</code> (a.k.a. <code>goat_addr</code>) so we'll have some return data. Otherwise, <code>RETURNDATACOPY</code> will fail and appear like it is not an opcode.</p> <pre><code>           pop(call(gas(), 0x60A7, 0, 0, 0, 0, 0))\n\n           // fails on opcodes with &gt;20 inputs\n           // (currently dup16, at 17 inputs, is the\n           // one that goes deepest)\n           //\n           // Follow with 32 NOPs (0x5B) to handle PUSH, which has an immediate\n           // operand\n</code></pre> <p>Opcodes can have two types of operands:</p> <ul> <li>Immediate operands, which are part of the bytecode.   For example, <code>6001</code> is <code>PUSH1</code> with the value <code>0x01</code>.</li> <li>Implied operands (a.k.a. stack operands), which come from the stack.</li> </ul> <p>This <code>verbatim</code> code provides both operand types. The code, <code>${opcode}${nop32}</code> is the opcode we are testing, followed by 32 copies of 0x5B. When <code>0x5B</code> is not used as an operand, it is <code>JUMPDEST</code> and does nothing.</p> <pre><code>           verbatim_20i_0o(hex\"${opcode}${nop32}\",\n</code></pre> <p>The opcode string is followed by the input parameters (in this case, twenty of them). These can be Yul expressions, but for the sake of simplicity here we just use constant values.</p> <pre><code>              0x00, 0x00, 0x00, 0xFF, 0xFF,\n              0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n              0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n              0xFF, 0xFF, 0xFF, 0xFF, 0xFF)\n</code></pre> <p>If the opcode terminates the smart contract execution (as invalid opcodes do), we don't get here. If we do get here, write to storage cell <code>0x00</code> to record that fact.</p> <p>Note the syntax <code>let &lt;var&gt; := &lt;value&gt;</code>. This is how you specify variables in Yul.</p> <pre><code>           // We only get here is the opcode is legit (and it doesn't terminate\n           // execution like STOP and RETURN)\n           let zero := 0\n           let one := 1\n           sstore(zero, one)\n        }\n</code></pre> <p>Replace <code>${opcode}</code> with the one byte hex code, and <code>${nop32}</code> with 32 copies of <code>5b</code> (for NOP).</p> <pre><code>        \"\"\").substitute(opcode=opc_hex, nop32=\"5B\"*32)\n        pre = {\n           TestAddress: Account(balance=0x0BA1A9CE0BA1A9CE),\n           codeAddr: Account(\n  balance=0,\n  nonce=1,\n  code=Yul(yul_code)\n           ),\n</code></pre> <p>This is the account for <code>0x00..0060A7</code>. It just returns data (all zeros).</p> <pre><code>           goat_addr: Account(\n                balance=0,\n                nonce=1,\n                code=Yul(\"{ return(0, 0x100) }\"),\n           )\n        }\n</code></pre> <p>Every time the <code>for</code> loop gets here, it <code>yields</code> a separate test. Over the entire for loop, it yields 255 different tests.</p> <pre><code>    yield StateTest(\n        env=env, \n        pre=pre, \n        tx=tx,\n        post=(post_valid if opc_valid(opc) else post_invalid),\n    )\n</code></pre> <p>The Python format for the ternary operation is a bit different from C-like languages. In C like languages the syntax is <code>&lt;condition&gt; ? &lt;yes value&gt; : &lt;no value&gt;</code>. In Python it is <code>&lt;yes value&gt; if &lt;condition&gt; else &lt;no value&gt;</code>.</p>"}]}