"""Common utilities for the Identity Precompile tests."""

from dataclasses import dataclass
from typing import Tuple

from ethereum_test_base_types.composite_types import Storage
from ethereum_test_tools import (
    Bytecode,
)
from ethereum_test_tools import Opcodes as Op


@dataclass(frozen=True)
class Constants:
    """Constants for the Identity Precompile."""

    IDENTITY_PRECOMPILE_ADDRESS = 0x04


class CallArgs:
    """Defines inputs to CALL for the Identity precompile."""

    def __init__(
        self,
        gas=0x1F4,
        value=0x0,
        args_offset=0x0,
        args_size=0x20,
        ret_offset=0x0,
        ret_size=0x20,
    ):
        """Create a new instance with the provided values."""
        self.gas = gas
        self.value = value
        self.args_offset = args_offset
        self.args_size = args_size
        self.ret_offset = ret_offset
        self.ret_size = ret_size


def generate_identity_call_bytecode(
    storage: Storage,
    call_type: Op,
    memory_values: Tuple[int, ...],
    call_args: CallArgs,
    call_succeeds: bool,
) -> Bytecode:
    """
    Generate bytecode for calling the identity precompile with given memory values.

    Args:
        storage (Storage): The storage object to use for storing values.
        call_type (Op): The type of call opcode (CALL or CALLCODE).
        memory_values (Tuple[int, ...]): Values to store in memory before the call.
        call_args (CallArgs): Arguments for the CALL opcode.
        call_succeeds (bool): Whether the call should succeed or not.

    Returns:
        Bytecode: The generated bytecode for the identity precompile call.

    """
    code = Bytecode()

    # Store provided values in memory
    mstore_count = len(memory_values) if memory_values else 0
    mstore_offset = 0
    mstore_value = 0
    if mstore_count:
        for i, value in enumerate(memory_values):
            mstore_value = value
            code += Op.MSTORE(mstore_offset, mstore_value)
            if mstore_count > i + 1:
                mstore_offset += 0x20

    # Call the identity precompile, then check that the last value in memory has not changed
    code += (
        Op.SSTORE(
            storage.store_next(call_succeeds),
            call_type(
                gas=call_args.gas,
                address=Constants.IDENTITY_PRECOMPILE_ADDRESS,
                value=call_args.value,
                args_offset=call_args.args_offset,
                args_size=call_args.args_size,
                ret_offset=call_args.ret_offset,
                ret_size=call_args.ret_size,
            ),
        )
        + Op.SSTORE(storage.store_next(mstore_value), Op.MLOAD(mstore_offset))
        + Op.STOP
    )

    return code
