"""
A State test for the set of `SWAP*` opcodes.
Ported from: https://github.com/ethereum/tests/
blob/develop/src/GeneralStateTestsFiller/VMTests/vmTests/swapFiller.yml.
"""

import pytest

from ethereum_test_forks import Fork, Frontier, Homestead
from ethereum_test_tools import (
    Account,
    Alloc,
    Bytecode,
    Environment,
    StateTestFiller,
    Transaction,
)
from ethereum_test_tools import Opcodes as Op


def sstore(storage, key, value, debug_hint=None):
    
    """
    Helper function to update storage with a debug hint.
    """
    storage[key] = value
    if debug_hint:
        print(f"Debug: {debug_hint} - Updated key {key} with value {value}")
    return storage


@pytest.mark.parametrize(
    "swap_opcode",
    [getattr(Op, f"SWAP{i}") for i in range(1, 17)],
    ids=lambda op: str(op),
)
@pytest.mark.valid_from("Frontier")
def test_swap(
    state_test: StateTestFiller,
    fork: Fork,
    pre: Alloc,
    swap_opcode: Op
):
    """
    The set of `SWAP*` opcodes swaps the top of the stack with a specific
    element.

    In this test, we ensure that the set of `SWAP*` opcodes correctly swaps
    the top element with the nth element and stores the result in storage.
    """
    env = Environment()

    # Calculate which position we're swapping with (1-based index)
    swap_pos = swap_opcode.int() - 0x90 + 1

    # Generate stack values
    stack_values = list(range(swap_pos + 1))

    # Push the stack values onto the stack (in reverse order).
    contract_code = Bytecode()
    for value in reversed(stack_values):
        contract_code += Op.PUSH1(value)

    # Perform the SWAP operation.
    contract_code += swap_opcode

    # Store the top of the stack in storage slot 0.
    contract_code += Op.PUSH1(0) + Op.SSTORE

    # Deploy the contract with the generated bytecode.
    contract = pre.deploy_contract(contract_code)

    # Create a transaction to execute the contract.
    tx = Transaction(
        sender=pre.fund_eoa(),
        to=contract,
        gas_limit=500_000,
        protected=False if fork in [Frontier, Homestead] else True,
    )

    # After SWAP, the top value will be the one at swap_pos
    expected_value = swap_pos

    # Define the expected post-state.
    post = {}
    storage = {}
    sstore(storage, 0, expected_value, f"SWAP{swap_pos} result")
    post[contract] = Account(storage=storage)

    # Run the state test.
    state_test(env=env, pre=pre, post=post, tx=tx)


@pytest.mark.parametrize(
    "swap_opcode",
    [getattr(Op, f"SWAP{i}") for i in range(1, 17)],
    ids=lambda op: str(op),
)
@pytest.mark.parametrize("stack_height", range(1022, 1024))
@pytest.mark.valid_from("Frontier")
def test_stack_underflow(
    state_test: StateTestFiller,
    fork: Fork,
    pre: Alloc,
    swap_opcode: Op,
    stack_height: int
):
    """
    A test to ensure that the stack underflow when there are not enough
    elements for the `SWAP*` opcode to operate.
    """
    env = Environment()

    # Calculate which position we're swapping with (1-based index)
    swap_pos = swap_opcode.int() - 0x90 + 1

    # Push values onto the stack
    contract_code = Bytecode()
    for i in range(stack_height):
        contract_code += Op.PUSH1(i % 256)

    # Attempt to perform the SWAP operation
    contract_code += swap_opcode

    # Store the top of the stack in storage slot 0
    contract_code += Op.PUSH1(0) + Op.SSTORE

    # Deploy the contract with the generated bytecode.
    contract = pre.deploy_contract(contract_code)

    # Create a transaction to execute the contract.
    tx = Transaction(
        sender=pre.fund_eoa(),
        to=contract,
        gas_limit=500_000,
        protected=False if fork in [Frontier, Homestead] else True,
    )

    # Define the expected post-state.
    post = {}
    storage = {}
    MAX_STACK = 1024

    if stack_height >= (swap_pos + 1) and (MAX_STACK - stack_height) >= 1:
        # If the operation succeeds, the value at swap_pos will be at the top
        swapped_value = (stack_height - swap_pos - 1) % 256
        sstore(storage,
               0,
               swapped_value,
               f"SWAP{swap_pos} result (stack_height={stack_height})")
    else:
        # Operation should fail with no storage update
        sstore(storage, 0, 0, "SWAP failed due to stack underflow")

    post[contract] = Account(storage=storage)

    # Run the state test.
    state_test(env=env, pre=pre, post=post, tx=tx)
