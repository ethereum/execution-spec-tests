"""
A State test for the set of `SWAP*` opcodes.
Ported from: https://github.com/ethereum/tests/
blob/develop/src/GeneralStateTestsFiller/VMTests/vmTests/swapFiller.yml.
"""

import pytest  # noqa: I001

from ethereum_test_forks import Fork, Frontier, Homestead
from ethereum_test_tools import Account, Alloc, Bytecode, Environment
from ethereum_test_tools import Opcodes as Op
from ethereum_test_tools import StateTestFiller, Storage, Transaction


@pytest.mark.ported_from(
    [
        "https://github.com/ethereum/tests/blob/v13.3/src/GeneralStateTestsFiller/VMTests/vmTests/swapFiller.yml"
    ],
    pr=["https://github.com/ethereum/execution-spec-tests/pull/1163"],
    coverage_missed_reason=(
        "Test isolation (1 contract per execution) reduces evmone state "
        "comparisons vs old dispatcher pattern (16 contracts per execution)"
    ),
)
@pytest.mark.parametrize(
    "swap_opcode",
    [getattr(Op, f"SWAP{i}") for i in range(1, 17)],
    ids=lambda op: str(op),
)
@pytest.mark.valid_from("Frontier")
def test_swap(state_test: StateTestFiller, fork: Fork, pre: Alloc, swap_opcode: Op):
    """
    The set of `SWAP*` opcodes swaps the top of the stack with a specific
    element.

    In this test, we ensure that the set of `SWAP*` opcodes correctly swaps
    the top element with the nth element and stores the result in storage.
    """
    env = Environment()

    # Calculate which position we're swapping with (1-based index)
    swap_pos = swap_opcode.int() - 0x90 + 1

    # Generate stack values
    stack_values = list(range(swap_pos + 16))

    # Push the stack values onto the stack (in reverse order).
    contract_code = Bytecode()
    for value in reversed(stack_values):
        contract_code += Op.PUSH1(value)

    # Perform the SWAP operation.
    contract_code += swap_opcode

    # Store multiple values to storage.
    for slot in range(16):
        contract_code += Op.PUSH1(slot) + Op.SSTORE

    # Deploy the contract with the generated bytecode.
    contract_address = pre.deploy_contract(contract_code)

    # Create a transaction to execute the contract.
    tx = Transaction(
        sender=pre.fund_eoa(),
        to=contract_address,
        gas_limit=500_000,
        protected=False if fork in [Frontier, Homestead] else True,
    )

    # Calculate expected storage values after SWAP and storage operations
    # Initial stack (after pushes, before swap): [0, 1, 2, ..., swap_pos+15]
    # (top is index 0)
    # After SWAP at position swap_pos: top and position swap_pos are swapped
    # Then we do: PUSH1(slot) SSTORE 16 times, which pops values from stack

    # Build the stack state after SWAP
    stack_after_swap = stack_values.copy()
    stack_after_swap[0], stack_after_swap[swap_pos] = (
        stack_after_swap[swap_pos],
        stack_after_swap[0],
    )

    # Store the first 16 values from the post-swap stack
    storage = Storage()
    for value in stack_after_swap[:16]:
        storage.store_next(value)

    post = {contract_address: Account(storage=storage)}

    # Run the state test.
    state_test(env=env, pre=pre, post=post, tx=tx)


@pytest.mark.parametrize(
    "swap_opcode",
    [getattr(Op, f"SWAP{i}") for i in range(1, 17)],
    ids=lambda op: str(op),
)
@pytest.mark.valid_from("Frontier")
def test_stack_underflow(
    state_test: StateTestFiller,
    fork: Fork,
    pre: Alloc,
    swap_opcode: Op,
):
    """
    A test to ensure that the stack underflow when there are not enough
    elements for the `SWAP*` opcode to operate.

    For each SWAPn operation, we push exactly (n-1) elements to cause an
    underflow when trying to swap with the nth element.
    """
    env = Environment()

    # Calculate which position we're swapping with (1-based index)
    swap_pos = swap_opcode.int() - 0x90 + 1

    # Push exactly (n-1) elements for SWAPn to cause underflow
    contract_code = Bytecode()
    for i in range(swap_pos - 1):
        contract_code += Op.PUSH1(i % 256)

    # Attempt to perform the SWAP operation
    contract_code += swap_opcode

    # Store the top of the stack in storage slot 0
    contract_code += Op.PUSH1(0) + Op.SSTORE

    # Deploy the contract with the generated bytecode.
    contract = pre.deploy_contract(contract_code)

    # Create a transaction to execute the contract.
    tx = Transaction(
        sender=pre.fund_eoa(),
        to=contract,
        gas_limit=500_000,
        protected=False if fork in [Frontier, Homestead] else True,
    )

    # Define the expected post-state.
    post = {}
    storage = Storage()
    storage.store_next(0, f"SWAP{swap_pos} failed due to stack underflow")
    post[contract] = Account(storage=storage)

    # Run the state test.
    state_test(env=env, pre=pre, post=post, tx=tx)
