"""
A State test for the set of `SWAP*` opcodes.
Ported from: https://github.com/ethereum/tests/blob/develop/src/GeneralStateTestsFiller/VMTests/vmTests/swapFiller.yml.
"""

import pytest

from ethereum_test_forks import Fork, Frontier, Homestead
from ethereum_test_tools import Account, Alloc, Environment
from ethereum_test_tools import Opcodes as Op
from ethereum_test_tools import StateTestFiller, Storage, Transaction, Bytecode


@pytest.mark.parametrize(
    "swap_opcode",
    [getattr(Op, f"SWAP{i}") for i in range(1, 17)],  # Dynamically parametrize SWAP opcodes (SWAP1 to SWAP16)
    ids=lambda op: str(op),
)
@pytest.mark.valid_from("Frontier")
def test_swap(state_test: StateTestFiller, fork: Fork, pre: Alloc, swap_opcode: Op):
    """
    The set of `SWAP*` opcodes swaps the top of the stack with a specific element.

    In this test, we ensure that the set of `SWAP*` opcodes correctly swaps
    the top element with the nth element and stores the result in storage.
    """
    env = Environment()

    # Calculate which position we're swapping with (1-based index)
    swap_pos = swap_opcode.int() - 0x90 + 1

    # Generate stack values
    # We'll use position numbers as values to make it clear what's being swapped
    # For SWAP1: [1, 0]
    # For SWAP2: [2, 1, 0]
    # etc.
    stack_values = list(range(swap_pos + 1))

    # Push the stack values onto the stack (in reverse order).
    contract_code = Bytecode()
    for value in reversed(stack_values):
        contract_code += Op.PUSH1(value)

    # Perform the SWAP operation.
    contract_code += swap_opcode

    # Store the top of the stack in storage slot 0.
    contract_code += Op.PUSH1(0) + Op.SSTORE

    # Deploy the contract with the generated bytecode.
    contract = pre.deploy_contract(contract_code)

    # Create a transaction to execute the contract.
    tx = Transaction(
        sender=pre.fund_eoa(),
        to=contract,
        gas_limit=500_000,
        protected=False if fork in [Frontier, Homestead] else True,
    )

    # After SWAP, the top value will be the one at swap_pos
    expected_value = swap_pos

    # Define the expected post-state.
    post = {}
    post[contract] = Account(storage={0: expected_value})

    # Run the state test.
    state_test(env=env, pre=pre, post=post, tx=tx)


@pytest.mark.parametrize(
    "swap_opcode",
    [getattr(Op, f"SWAP{i}") for i in range(1, 17)],
    ids=lambda op: str(op),
)
@pytest.mark.parametrize("stack_height", range(1022, 1024))  # Test stack underflow conditions
@pytest.mark.valid_from("Frontier")
def test_stack_underflow(
    state_test: StateTestFiller, fork: Fork, pre: Alloc, swap_opcode: Op, stack_height: int
):
    """
    A test to ensure that the stack underflow when there are not enough elements
    for the `SWAP*` opcode to operate.
    """
    env = Environment()

    # Calculate which position we're swapping with (1-based index)
    swap_pos = swap_opcode.int() - 0x90 + 1

    # Push values onto the stack
    contract_code = Bytecode()
    # Push stack_height number of values, using the position as the value
    for i in range(stack_height):
        contract_code += Op.PUSH1(i % 256)  # Use modulo to keep values in byte range

    # Attempt to perform the SWAP operation
    contract_code += swap_opcode

    # Store the top of the stack in storage slot 0
    contract_code += Op.PUSH1(0) + Op.SSTORE

    # Deploy the contract with the generated bytecode.
    contract = pre.deploy_contract(contract_code)

    # Create a transaction to execute the contract.
    tx = Transaction(
        sender=pre.fund_eoa(),
        to=contract,
        gas_limit=500_000,
        protected=False if fork in [Frontier, Homestead] else True,
    )

    # Define the expected post-state.
    post = {}
    
    # The SWAP operation requires swap_pos + 1 items on the stack
    # Plus one more space for the SSTORE operation
    MAX_STACK = 1024
    
    if stack_height >= (swap_pos + 1) and (MAX_STACK - stack_height) >= 1:
        # If the operation succeeds, the value at swap_pos will be at the top
        swapped_value = (stack_height - swap_pos - 1) % 256
        post[contract] = Account(storage={0: swapped_value})
    else:
        # Operation should fail with no storage update
        post[contract] = Account(storage={})

    # Run the state test.
    state_test(env=env, pre=pre, post=post, tx=tx)