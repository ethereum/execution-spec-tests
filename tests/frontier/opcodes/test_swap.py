"""
A State test for the set of `SWAP*` opcodes.
Ported from: https://github.com/ethereum/tests/
blob/develop/src/GeneralStateTestsFiller/VMTests/vmTests/swapFiller.yml.
"""

import pytest

from ethereum_test_forks import Fork, Frontier, Homestead
from ethereum_test_tools import (
    Account,
    Alloc,
    Bytecode,
    Environment,
    StateTestFiller,
    Transaction,
)
from ethereum_test_tools import Opcodes as Op


class Storage:
    def __init__(self):
        self._data = {}  # Internal storage for key-value pairs

    def store_next(
        self, key: int, value: int, debug_hint: str | None = None
    ) -> dict:
        """
        Store a value at the specified key in the storage.

        Args:
            key: The key where the value will be stored.
            value: The value to store.
            debug_hint: Optional debug hint to print when updating the storage.

        Returns:
            The updated storage.
        """
        self._data[key] = value  # Update the storage at the specified key

        if debug_hint:
            print(
                f"Debug: {debug_hint} - Updated key {key} with value {value}"
            )

        return self._data  # Return the updated storage

    def __getitem__(self, key):
        """Allow accessing stored values using `storage[key]` syntax."""
        return self._data[key]

    def __setitem__(self, key, value):
        """Allow updating stored values using `storage[key] = value` syntax."""
        self._data[key] = value


@pytest.mark.parametrize(
    "swap_opcode",
    [getattr(Op, f"SWAP{i}") for i in range(1, 17)],
    ids=lambda op: str(op),
)
@pytest.mark.valid_from("Frontier")
def test_swap(
    state_test: StateTestFiller,
    fork: Fork,
    pre: Alloc,
    swap_opcode: Op
):
    """
    The set of `SWAP*` opcodes swaps the top of the stack with a specific
    element.

    In this test, we ensure that the set of `SWAP*` opcodes correctly swaps
    the top element with the nth element and stores the result in storage.
    """
    env = Environment()

    # Calculate which position we're swapping with (1-based index)
    swap_pos = swap_opcode.int() - 0x90 + 1

    # Generate stack values
    stack_values = list(range(swap_pos + 1))

    # Push the stack values onto the stack (in reverse order).
    contract_code = Bytecode()
    for value in reversed(stack_values):
        contract_code += Op.PUSH1(value)

    # Perform the SWAP operation.
    contract_code += swap_opcode

    # Store the top of the stack in storage slot 0.
    contract_code += Op.PUSH1(0) + Op.SSTORE

    # Deploy the contract with the generated bytecode.
    contract = pre.deploy_contract(contract_code)

    # Create a transaction to execute the contract.
    tx = Transaction(
        sender=pre.fund_eoa(),
        to=contract,
        gas_limit=500_000,
        protected=False if fork in [Frontier, Homestead] else True,
    )

    # After SWAP, the top value will be the one at swap_pos
    expected_value = swap_pos

    # Define the expected post-state.
    post = {}
    storage = Storage()
    storage.store_next(0, expected_value, f"SWAP{swap_pos} result")
    post[contract] = Account(storage=storage._data)

    # Run the state test.
    state_test(env=env, pre=pre, post=post, tx=tx)


@pytest.mark.parametrize(
    "swap_opcode",
    [getattr(Op, f"SWAP{i}") for i in range(1, 17)],
    ids=lambda op: str(op),
)
@pytest.mark.parametrize("stack_height", range(1022, 1024))
@pytest.mark.valid_from("Frontier")
def test_stack_underflow(
    state_test: StateTestFiller,
    fork: Fork,
    pre: Alloc,
    swap_opcode: Op,
    stack_height: int
):
    """
    A test to ensure that the stack underflow when there are not enough
    elements for the `SWAP*` opcode to operate.
    """
    env = Environment()

    # Calculate which position we're swapping with (1-based index)
    swap_pos = swap_opcode.int() - 0x90 + 1

    # Push values onto the stack
    contract_code = Bytecode()
    for i in range(stack_height):
        contract_code += Op.PUSH1(i % 256)

    # Attempt to perform the SWAP operation
    contract_code += swap_opcode

    # Store the top of the stack in storage slot 0
    contract_code += Op.PUSH1(0) + Op.SSTORE

    # Deploy the contract with the generated bytecode.
    contract = pre.deploy_contract(contract_code)

    # Create a transaction to execute the contract.
    tx = Transaction(
        sender=pre.fund_eoa(),
        to=contract,
        gas_limit=500_000,
        protected=False if fork in [Frontier, Homestead] else True,
    )

    # Define the expected post-state.
    post = {}
    storage = Storage()
    MAX_STACK = 1024

    if stack_height >= (swap_pos + 1) and (MAX_STACK - stack_height) >= 1:
        # If the operation succeeds, the value at swap_pos will be at the top
        swapped_value = (stack_height - swap_pos - 1) % 256
        storage.store_next(
            0,
            swapped_value,
            f"SWAP{swap_pos} result (stack_height={stack_height})")
    else:
        # Operation should fail with no storage update
        storage.store_next(0, 0, "SWAP failed due to stack underflow")

    post[contract] = Account(storage=storage._data)

    # Run the state test.
    state_test(env=env, pre=pre, post=post, tx=tx)
